#!/usr/bin/perl
#___________________________________________________________________________________
# Title     : Bio::Bioinf (for Bio Perlogical) or bio_lib.pl
# Usage     : require "Bioinf.pl"; ##<-- This is very slow, so you'd better
#             use Bio::Bioinf; <- When you have Bioinf.pm module installed under Bio
#              or
#             use Bioinf;
#
#             or, copy the subroutines in your prog. or make a smaller lib files
#               which are classified according to functions(like, Bio_Seq.pl
#               for sequence handling, Bio_Array.pl for various array
#               subroutines..), or make your own module out of this, do whatever
#               you want....
#
# Function  : 1) This is a comprehensive perl subroutine library developed
#                 under Bioperl project and others.
#                 URL: http://cyrah.med.harvard.edu/Proj/Comp/Perl/Sub_DB/
#
#             2) The design of this module is for simple layer biological
#                 module than multilevel object oriented module.
#
#             3) This also serves as the depository database for various
#                 perl subroutines or algorithms developed in
#                 Bioinformatics and Genome projects.
#
#             4) You can copy any of the sub routines in this file, modify, use
#                 in yours...
#                 PLEASE MODIFY AS FREELY AS YOU WANT !! All has the
#                 same PERL copyright
#
#             5) All the subroutines are tested in small files
#                 If you want to have such single example program
#                 to see how they really work, pls contact me( A Biomatic )
#                 For example, a file called  'handle_arguments.pl' exists to
#                 test the subroutine 'handle_arguments'. Usually you can find them
#                 in  http://cyrah.med.harvard.edu/Proj/Bio/Bioperl/Bioinf.html
#
# Example   : require "Bioinf.pl"; BUT, I recommand you take subroutines out and
#             use it directly or modify in your programs.
#             use Bioinf;
#
# Warning   : For the enhancement of Biology, Biomatics, and Science.
#             This is a development companion.
#             Class is for classification of my subroutines. If it is Bio, it can
#             be useful for biological sequence data handling. If it's Utility,
#             it can also be used for general purpose file handling stuff.
#             File, Array, Hash,... are my classification items.
# Keywords  : Biology, perl library, sequence handling lib
# Options   : nothing (used as subroutine library or as Bioinf.pm module)
#
# Author    : J. Park, Andreas Heger, Jason Johnson, Sarah Teichmann, Alex Bateman,
#               Astrid Reinhardt, and anybody contributed AND YOU!!
#               jong@biosophy.org
# Category  : Bioinf Bioperl
# Version   : 3    (Dec/31/1999)
#------------------------------------------------------------------


print "\n ################################################################\n";
print   " #                                                              #\n";
print   " # Using Bioperl subroutine Module for Bioinformatics & Biology #\n";
print   " #                                                              #\n";
print   " ################################################################\n";


## The following box is used as the header for any subroutines developed to
##  give information on the subroutines. It is used by Jong as a template.


#______________________________________________________________________________
# Title     :
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------


## Following variables in 'my' are very commonly used ones. I have
## put those to be copied into any new subroutines to be developed
## This is because, in Perl, every variable is global unless you mark them
## to be inside the subroutines. Many BUGs are coming from not localizing vars.
## This array variables are used  as a defalt insertion for the subroutine
## 'handle_arguments'. If you add this box in any sub, 'handle_arguments'
## subroutine will be called and any arguments passed to the subroutine will
## be classified to file, dir, string, hash(as reference), array(as reference),
## pure number, or option(with -) prefix. etc. For more detail look at
## handle_argument's header.


sub IGNORE_THIS{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
}


#________________________________________________________________________
# Title     : handle_arguments
# Usage     : Just put the whole box delimited by the two '###..' lines below
#             to inside of your subroutines. It will call 'handle_arguments'
#             subroutine and parse all the given input arguments.
#             To use, claim the arguments, just use the variable in the box.
#             For example, if you had passed 2 file names for files existing
#             in your PWD(or if the string looks like this: xxxx.ext),
#             you can claim them by $file[0], $file[1] in
#             your subroutine.
# Function  : Sorts input arguments going into subroutines and returns default
#             arrays of references for various types (file, dir, hash, array,,,,)
#             If you give (\@out, @file), it will put @out into @array as a ref
#             and also the contents of @out will be dereferenced and put to
#             raw_string regardless what is in it).
#
# Example   : 'handle_arguments(\@array, $string, \%hash, 8, 'any_string')
# Warning   :
# Keywords  : handling arguments, parsing arguments,
# Options   :
# Returns   : Following GLOBAL variables
#
#             $num_opt,    @num_opt     @file          @dir
#             $char_opt,   @char_opt    %vars          @array,
#             @hash        @string,     @raw_string    @range,
#
#             $num_opt has 10,20
#             @num_opt has (10, 20)
#             @file has  xxxx.ext
#             @dir has  dir  or /my/dir
#             $char_opt has 'A,B'
#             @char_opt has (A, B)
#             @array has  (\@ar1, \@ar2)
#             @hash has (\%hash1, \%hash2)
#             @string  ('sdfasf', 'dfsf')
#             @raw_string (file.ext, dir_name, 'strings',,)
#             @range has values like  10-20
#             %vars deals with x=2, y=3 stuff.
#
# Argument  : any type, any amount
# Version   : 5.0
#--------------------------------------------------------------------
sub handle_arguments{
    my($c, $d, $e, $f, $i, $j, $k, $l, $s, $t, $x, $y, $z, $char_opt, $dir, @hash,
        $file, $in_dir, $num_opt, @char_opt, @dir, @file, @string, @file_dir, @k,
        @num_opt, @raw_string, @array, %vars, @range, @temp, $temp,
        @char_options, %duplicate);

    &set_debug_option;
    if(@_<1){ print chr(7),"\n This is handle_arguments. No args Passed, Error?\n"}
    elsif( (@_ ==1)&& (ref($_[0]) eq 'ARRAY') ){ # when there is only 1 argument
      push(@array, $_[0]);
      push(@k, $_[0]);
    }elsif( (@_==1)&&( !ref($_[0]) ) ){
      if(-f $_[0]){ push(@file, $_[0]);   push(@string, $_[0]) }
      elsif(-d $_[0]){ push(@dir, $_[0]); push(@string, $_[0]) }
      elsif($_[0]=~/^\d+$/){ push(@num_opt, $_[0]); $num_opt.=$_[0] }
      elsif($_[0]=~/^\w+$/){ push(@string, $_[0]); }
    }elsif(@_ >=1){ @k = @_ }

    #####______Start of  general argument handling______######
    for($k=0; $k < @k ;$k++){
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Check if the input was REFERENCE
      #________________________________________________
      if( !ref($k[$k]) ){
          if($k[$k]=~ /^[\-]?([a-zA-Z]\d*) {0,5}$/){  push(@char_opt, $1); $char_opt .= "$1\,";
          }elsif($k[$k]=~ /^\-([a-zA-Z]+)$/){          ## When multiple option is given,
                          @char_options = split(/\,|/, $1);  push(@char_opt, @char_options);
                          $char_opt .= join("\,", @char_options); ## '-' should be used. eg. '-HEGI'
          }elsif($k[$k]=~ /^(\w+)\=(\S*\s*)$/){  $vars{$1}=$2;  $vars .= "$1\,";
          }elsif($k[$k]=~ /^(\-?\d+)$/){ push(@num_opt, $1);  $num_opt .= "$1\,";
          }elsif($k[$k]=~ /^\d+\.?\d*\-\d+\.?\d*$/){  push(@range,  $k[$k] );
          }elsif(-f $k[$k]){                          push(@file,   $k[$k] );
          }elsif(-d $k[$k]){                          push(@dir,    $k[$k] ); }
          if(    $k[$k]=~ /\/[\w\d\.\-]+\/.+?\/$/){   push(@dir,    $k[$k] );
          }elsif($k[$k]=~ /\/.+?\/\w+\.\w+$/){        push(@file,    $k[$k] );
          }elsif($k[$k]=~ /^\/[\w\d\.\-]+[\/]*$/){    push(@dir,    $k[$k] );
          }elsif($k[$k]=~ /^[\/\w\d\-\.]+\.\w+$/){    push(@file,   $k[$k] );
          }elsif($k[$k]=~ /\S\/[\/\w\d\-\.]+\.\w+$/){ push(@file,   $k[$k] );
          }elsif($k[$k]=~/^\w+[\/\\\w\d\.\-]+$/){     push(@string, $k[$k] );
                      # string does not have space, but includes '\', '/', '.'
          }else{                                      push(@raw_string, $k[$k] ); }
      }elsif( ref($k[$k]) ){
          if( ref($k[$k]) eq "SCALAR"){
              if(${$k[$k]} =~ /^[\-]?([a-zA-Z]\d*) {0,5}$/){ push(@char_opt, $1); $char_opt  .= "$1\,";
              }elsif(${$k[$k]}=~ /^\-([a-zA-Z]+)$/){ push(@char_opt, @char_options);
                              $char_opt  .= join("\,", @char_options);  ## as an option string.
              }elsif(${$k[$k]}=~ /^(\w+)\=(\S*\s*)$/){  $vars{$1}=$2;  $vars .= "$1\,";
              }elsif(${$k[$k]}=~ /^(\-?\d+)$/){ $num_opt .= "$1\,";  push(@num_opt, $1);
              }elsif(${$k[$k]}=~ /^\d+\.?\d*\-\d+\.?\d*$/){    push(@range,  $k[$k] );
              }elsif(-f ${$k[$k]}){                            push(@file,   ${$k[$k]} );
              }elsif(-d ${$k[$k]}){                            push(@dir,    ${$k[$k]} );
              }elsif(${$k[$k]}=~ /\/[\/\w\d\.\-]+[\/].+[\/]$/){ push(@dir,    ${$k[$k]} );
              }elsif(${$k[$k]}=~ /\/\S*\.\w+\s*$/){   push(@file,    ${$k[$k]} );
              }elsif(${$k[$k]}=~/^\/[\/\w\d\.\-]+[\/]*$/){     push(@dir,    ${$k[$k]} );
              }elsif($k[$k]=~ /\/[\w\d\.\-]+\/.+?\/\w+\.\w+$/){   push(@file,    $k[$k] );
              }elsif(${$k[$k]}=~ /^[\/\w\d\-\.]+\.\w+$/){      push(@file,   ${$k[$k]} );
              }elsif(${$k[$k]}=~/^\w+[\w\d\.\-]+$/){           push(@string, ${$k[$k]} );
              }else{                                           push(@raw_string, ${$k[$k]}) }
          }elsif(ref($k[$k]) eq "ARRAY"){
              my @temp_arr = @{$k[$k]}; push(@array, $k[$k]);
              for ($i=0; $i<@temp_arr; $i++){
                 if(-f $temp_arr[$i]){                            push(@file, $temp_arr[$i]); next;
                 }elsif($temp_arr[$i]=~/^\d+\.?\d*\-\d+\.?\d*$/){ push(@range,$temp_arr[$i] ); next;
                 }elsif(-d $temp_arr[$i]){                        push(@dir , $temp_arr[$i]);  next;
                 }
                 if($temp_arr[$i]=~ /\/[\/\w\d\.\-]+[\/].+\/$/){ push(@dir,    ${$k[$k]} );
                 }elsif($temp_arr[$i]=~ /\/[\w\d\.\-]+\/.+?\/\w+\.\w+$/){   push(@file,    $k[$k] );
                 }elsif($temp_arr[$i]=~/^\/[\/\w\d\.\-]+[\/]*$/){ push(@dir, $temp_arr[$i] );
                 }elsif($temp_arr[$i]=~/^[\/\w\d\-\.]+\.\w+$/){   push(@file,$temp_arr[$i] );
                                                                  push(@string,$temp_arr[$i] );
                 }elsif($temp_arr[$i]=~/^\w+[\w\d\.\-]+$/){       push(@string,$temp_arr[$i]);
                 }else{                                           push(@raw_string, $temp_arr[$i]);
              }
          }
      }elsif(ref($k[$k]) eq "HASH"){
          push(@hash,   $k[$k] ); }
      }
    }
    @raw_string=(@raw_string, @string);
    @file = grep { ! $duplicate{$_}++ } @file;
    return(\@hash, \@array, \@string, \@dir, \@file, \@num_opt,
            \@char_opt, \$num_opt, \$char_opt, \@raw_string, \%vars, \@range );
}



#________________________________________________________________________
# Title     : set_debug_option
# Usage     : &set_debug_option;
# Function  : If you put '#' or  '##' at the prompt of any program which uses
#             this sub you will get verbose printouts for the program if the program
#             has a lot of comments.
# Example   : set_debug_option #    <-- at prompt.
# Warning   :
# Keywords  :
# Options   : #   for 1st level of verbose printouts
#             ##  for even more verbose printouts
# $debug  becomes 1 by '#'  or '_'
# $debug2 becomes 1 by '##'  or '__'
#
# Returns   :  $debug
# Argument  :
# Category  :
# Version   : 1.8
#--------------------------------------------------------------------
sub set_debug_option{
    my($j, $i, $level);
    unless( defined($debug) ){
        for($j=0; $j < @ARGV; $j ++){
            if( $ARGV[$j] =~/^(_+)$|^(#+)$/){ # in bash, '#' is a special var, so use '_'
                 print __LINE__," >>>>>>> Debug option is set by $1 <<<<<<<<<\n";
                 $debug=1;
                                  print chr(7);
                 print __LINE__," \$debug  is set to ", $debug, "\n";
                 splice(@ARGV,$j,1); $j-- ;
                 $level = length($1)+1;
                 for($i=0; $i < $level; $i++){
                      ${"debug$i"}=1;
                      print __LINE__," \$debug${i} is set to ", ${"debug$i"}, "\n";
                 }
            }
        }
    }
}

#______________________________________________________________________________
# Title     : set_options_for_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub set_options_for_DALI {
        local ($fsspfile)=@_;
print "<FORM METHOD=GET ACTION=$qz3>\n<INPUT TYPE=hidden NAME=filename VALUE=$fsspfile>\n<H2>Family alignments</H2>\n";
print "Maximum pairwise identity:\n",$query->popup_menu(-name=>'idecut',-default=>'80 %',-values=>['100 %','90 %','80 %','70 %','60 %','50
%','40 %','30 %']);
print "<H2>3D
superimpositions</H2>\nStereo:\n",$query->popup_menu(-name=>'stereo',-default=>'mono',-values=>['mono','left-right','right-left']);
print "<HR><INPUT TYPE=submit Value='Use these settings'><INPUT TYPE=Reset Value=Reset><HR></FORM>\n";
print "<H2>Viewers</H2><A HREF=http://www.umass.edu/microbio/rasmol/>RasMol2.6</A><BR>\n";

EOS
}


#______________________________________________________________________________
# Title     : align_intermediate_alignments
# Usage     : @aligned_alignments=@{&align_intermediate_alignments($hash[$i], $hash[$i+1])};
#             %hash1=%{$aligned_alignments[0]};
#             %hash2=%{$aligned_alignments[1]};
#             $common_interm_seq_name=${$aligned_alignments[2]};
#             $non_common_seq_entry1=${$aligned_alignments[3]};
#             $non_common_seq_entry2=${$aligned_alignments[4]};
# Function  :
# Example   :
# Keywords  : align_multiple_alignments
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.3
#------------------------------------------------------------------------------
sub align_intermediate_alignments{
		my ($i, %hash1, %hash2, $pair1_name1_orig, $seq1_name_orig, @seq_names,
				$INT_seq2_name_orig, $seq2_name_orig, @aligned_alignments, %temp2,
				$common_INT_seq_name, $non_common_seq_entry1, $non_common_seq_entry2,
				%lookup_table1, %lookup_table2, $inter_temp_name, @splited1_interm,
				@splited1_seq, @splited2_interm, @splited2_seq,
				$gap_char);
		$gap_char='-';

		%hash1=%{$_[0]};
		%hash2=%{$_[1]};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# GEtting the Common seq (INTERMs)
		#_____________________________________________________________
		@names1= keys %hash1;
		@names2= keys %hash2;
		%lookup_table1=($names1[0]=>$names1[1], $names1[1]=> $names1[0]);
		%lookup_table2=($names2[0]=>$names2[1], $names2[1]=> $names2[0]);

		@seq_names=(@names1, @names2);
		($INT_seq1_name_orig, $INT_seq2_name_orig, $seq1_name_orig, $seq2_name_orig)=@{&find_common_seq_names(\@seq_names)};


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Following is necessary to know which keys belong to which hash
		#___________________________________________________________________
		if($lookup_table1{$INT_seq1_name_orig} and $lookup_table1{$seq1_name_orig}){
		    # Default situation. No change in key and value in hash1, hash2
		}elsif($lookup_table2{$INT_seq1_name_orig} and $lookup_table2{$seq1_name_orig}){
				%temp=%hash1; %hash1=%hash2; %hash2=%temp; ## total reverse case
				#$temp=$INT_seq2_name_orig; $INT_seq2_name_orig=$INT_seq1_name_orig; $INT_seq1_name_orig=$temp;
				#$temp=$seq1_name_orig; $seq1_name_orig=$seq2_name_orig; $seq2_name_orig=$temp;
		}elsif($lookup_table1{$INT_seq1_name_orig} and $lookup_table2{$seq1_name_orig}){
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# When Query seqs are swapped.
				#___________________________________________________________________________
				print "\n      > seq1_name_orig seq2_name_orig  were swapped\n";
				%hash1=($INT_seq1_name_orig, $hash1{$INT_seq1_name_orig},
								$seq2_name_orig, $hash1{$seq2_name_orig});
				%hash2=($INT_seq2_name_orig, $hash2{$INT_seq2_name_orig},
								$seq1_name_orig, $hash2{$seq1_name_orig});
				$temp=$seq1_name_orig; $seq1_name_orig=$seq2_name_orig; $seq2_name_orig=$temp;
		}elsif($lookup_table2{$INT_seq1_name_orig} and $lookup_table2{$seq2_name_orig}){
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# When Interm seqs are swapped.
				#___________________________________________________________________________
				print "\n      > INT_seq1_name_orig INT_seq2_name_orig  were swapped\n";
				%hash1=($INT_seq1_name_orig, $hash1{$INT_seq2_name_orig},
								$seq1_name_orig,     $hash1{$seq1_name_orig});
				%hash2=($INT_seq2_name_orig, $hash2{$INT_seq1_name_orig},
								$seq2_name_orig,     $hash2{$seq2_name_orig});
		}else{
				print "\n========================================================\n";
				&show_hash(\%hash1);
				&show_hash(\%hash2);
		    print "\nError ??  \n$INT_seq1_name_orig => $seq1_name_orig\n$INT_seq2_name_orig => $seq2_name_orig\n\n\a";
				#sleep(1);
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Check if it is an MSF like alignment (saves time)
		#________________________________________________________________________________
		if( $INT_seq1_name_orig eq $INT_seq2_name_orig
				and ($hash1{$seq1_name_orig}=~/\./ or $hash1{$INT_seq1_name_orig}=~/\./)){
					$MSF_input=1;
					return([\%hash1, \%hash2, \$INT_seq1_name_orig, \$seq1_name_orig, \$seq2_name_orig]);
		}


		#print "\n22222222--------------------------------------\n";
		#&show_hash(\%hash1);
		#&show_hash(\%hash2);
		#print "\n So far I have hash1 and hash2";


		if($INT_seq1_name_orig=~/(\S+)_(\d+)\-(\d+)/){
		    $INT_seq1_name=$1;
				@INT_seq1_range=($2, $3);
				$INT_seq1_leng=$INT_seq1_range[1]-$INT_seq1_range[0];
		}else{ $INT_seq1_leng=length($hash1{$INT_seq1_name_orig}); }
		if($INT_seq2_name_orig=~/(\S+)_(\d+)\-(\d+)$/){
		    $INT_seq2_name=$1;
				@INT_seq2_range=($2, $3);
				$INT_seq2_leng=$INT_seq2_range[1]-$INT_seq2_range[0];
		}else{ $INT_seq2_leng=length($hash2{$INT_seq2_name_orig}); }


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (1) sequ1  ----------
		#     inter  ---------- . . . . .
		#     inter                      ------------
		#     sequ2                      ------------
		#____________________________________________________________
		if($INT_seq2_range[0] >= $INT_seq1_range[1]){
				if($seq1_name_orig    =~/(\S+)_(\d+)\-(\d+)/){ $seq1_name=$1;     @seq1_range    =($2, $3);
						$seq1_leng    =length($hash1{$seq1_name_orig});}
				if($seq2_name_orig    =~/(\S+)_(\d+)\-(\d+)/){ $seq2_name=$1;     @seq2_range    =($2, $3);
						$seq2_leng    =length($hash2{$seq2_name_orig});}
				$INT_seq1_leng=length($hash1{$INT_seq1_name_orig});
				$INT_seq2_leng=length($hash2{$INT_seq2_name_orig});

				$leng_between_matched_segments=$INT_seq2_range[0]-$INT_seq1_range[1];
				$hash1{$seq1_name_orig}=$hash1{$seq1_name_orig}."$gap_char"x($leng_between_matched_segments+$INT_seq2_leng);
				#print "\n(1) 1. $seq1_name_orig\t$hash1{$seq1_name_orig}\n";
				$hash1{$INT_seq1_name_orig}=$hash1{$INT_seq1_name_orig}."$gap_char"x$leng_between_matched_segments.$hash2{$INT_seq2_name_orig};
				$hash1{$INT_seq1_name}     =$hash1{$INT_seq1_name_orig};
				#print "\n(1) 2. $INT_seq1_name\t$hash1{$INT_seq1_name}\n";
				$hash2{$seq2_name_orig}    ="$gap_char"x($INT_seq1_leng+$leng_between_matched_segments).$hash2{$seq2_name_orig};
				$hash2{$INT_seq2_name_orig}="$gap_char"x($INT_seq1_leng+$leng_between_matched_segments).$hash2{$INT_seq2_name_orig};
				#print "\n(1) 3. $seq2_name_orig\t$hash2{$seq2_name_orig}\n $INT_seq1_leng $leng_between_matched_segments \n";
				$hash2{$INT_seq2_name}=$hash1{$INT_seq1_name};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (2) sequ1  -------------------
		#     inter  -------------------
		#     inter            ----------------------
		#     sequ2            ----------------------
		#____________________________________________________________
		}else{ # when there is a overlap
				if($seq1_name_orig    =~/(\S+)_(\d+)\-(\d+)/){ $seq1_name=$1;
				    @seq1_range    =($2, $3);
						$seq1_leng    =$3-$2;
				}else{ $seq1_leng=length($hash1{$seq1_name_orig}); }
				if($seq2_name_orig    =~/(\S+)_(\d+)\-(\d+)/){ $seq2_name=$1;
				    @seq2_range    =($2, $3);
						$seq2_leng    =$3-$2;
				}else{ $seq2_leng=length($hash2{$seq2_name_orig}); }

				$overlap_between_matched_segments=$INT_seq1_range[1]-$INT_seq2_range[0];

				#$hash1{$seq1_name_orig}=$hash1{$seq1_name_orig}."$gap_char"x($seq2_leng - $overlap_between_matched_segments);
				#print "\n \$seq2_leng : $seq2_leng $overlap_between_matched_segments\n";

				#$hash1{$INT_seq1_name_orig}=$hash1{$INT_seq1_name_orig}."$gap_char"x($seq2_leng - $overlap_between_matched_segments);
				#print "\n(2) 1. $seq1_name_orig  $hash1{$seq1_name_orig} $seq2_leng $overlap_between_matched_segments $INT_seq1_range[1]-$INT_seq2_range[0]\n";

				#$hash1{$INT_seq1_name}=substr($hash1{$INT_seq1_name_orig}, 0, $INT_seq1_leng-$overlap_between_matched_segments).$hash2{$INT_seq2_name_orig};
				#print "\n(2) 2. $INT_seq1_name       $hash1{$INT_seq1_name}\n";
				#print "(2) 2.$INT_seq1_name_orig  $hash1{$INT_seq1_name_orig}\n";

				$len=$INT_seq2_range[0]-$INT_seq1_range[0];
				$leading_gap_seq="$gap_char"x$len;

				$hash2{$seq2_name_orig}=$leading_gap_seq.$hash2{$seq2_name_orig};
				$hash2{$INT_seq2_name_orig}="$gap_char"x($INT_seq2_range[0]-$INT_seq1_range[0]).$hash2{$INT_seq2_name_orig};
				#print "\n(2) 3. $seq2_name_orig  $hash2{$seq2_name_orig}\n";
				$hash2{$INT_seq2_name}=$hash1{$INT_seq1_name};

				@splited1_interm=split(//, $hash1{$INT_seq1_name_orig} );
				@splited1_seq   =split(//, $hash1{$seq1_name_orig} );
				@splited2_interm=split(//, $hash2{$INT_seq2_name_orig} );
				@splited2_seq   =split(//, $hash2{$seq2_name_orig} );

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  Core algorithm. Splits seq. If gap char is found in One interm seq, it puts gaps in the other seq and interm
				#_______________________________________________________________________________________________________________________
				for($i=$len; $i< (@splited1_interm+@splited2_interm); $i++){
						if($splited1_interm[$i] ne $splited2_interm[$i]){
								if($splited1_interm[$i] =~/[\-\.]/ and $splited2_interm[$i]=~/\w/){
										splice(@splited2_interm, $i, 0, $gap_char);
										splice(@splited2_seq,    $i, 0, $gap_char);
								}elsif($splited2_interm[$i] =~/[\-\.]/ and $splited1_interm[$i]=~/\w/){
										splice(@splited1_interm, $i, 0, $gap_char);
										splice(@splited1_seq,    $i, 0, $gap_char);
								}elsif( !$splited1_interm[$i] and $splited2_interm[$i]=~/\S/){
										$splited1_interm[$i]=$splited2_interm[$i];
										$splited1_seq[$i]=$gap_char;
								}elsif( !$splited2_interm[$i] and $splited1_interm[$i]=~/\S/){
										$splited2_interm[$i]=$splited1_interm[$i];
								    $splited2_seq[$i]=$gap_char;
								}
						}
				}

				$hash1{$INT_seq1_name_orig}=join('', @splited1_interm);
				$hash1{$seq1_name_orig}    =join('', @splited1_seq);
				$hash2{$INT_seq2_name_orig}=join('', @splited2_interm);
				$hash2{$seq2_name_orig}    =join('', @splited2_seq);

				$hash1{$INT_seq1_name}=$hash2{$INT_seq2_name}=$hash1{$INT_seq1_name_orig};
				#print "\n\n===========44444444444-------------------------------------\n";
				#&show_hash(\%hash1);
				#&show_hash(\%hash2);
				#print "\n So far I have hash1 and hash2";

		}
		$common_INT_seq_name  =$INT_seq1_name; # <--- This never has ranges in the names
		$non_common_seq_entry1=$seq1_name_orig;
		$non_common_seq_entry2=$seq2_name_orig;

		return([\%hash1, \%hash2, \$common_INT_seq_name, \$non_common_seq_entry1, \$non_common_seq_entry2]);
}





#__________________________________________________________________________
# Title     : sort_by_E_values
# Usage     : @out=@{&sort_by_E_values(\@input_line_array)};
# Function  : it sorts by the 2nd column(E-value, in mspa file), small comes top
# Example   :
# Keywords  : sort_by_2nd_column, sort_by_second_column, sort_by_e_values,
#             sort_by_evalues,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Authors   : jong@ebi.ac.uk
# Version   : 1.0
#----------------------------------------------------------------------------
sub sort_by_E_values{
    my (@in);
    if(ref $_[0] eq 'ARRAY'){
               @in = @{$_[0]};
    }else{
               @in = @_;
    }
    @in= map {$_->[0]} sort { $a->[1] <=> $b->[1] } map {/^ {0,3}\S+\s+(\S+)/ && [$_, $1] } @in;
    return(\@in);
}

#__________________________________________________________________________
# Title     : sort_sequence_ranges
# Usage     : @out=@{&sort_sequence_ranges(\@input_line_array)};
# Function  :
# Example   : 10-20, 38-40, 1-9, 20-34
#             => 1-9, 10-20, 20-34, 38-40
# Keywords  : sort_ranges sort_seq_ranges sort_by_sequence_ranges
#             sort_ranges_by_start_point
# Options   :
# Returns   :
# Argument  :
# Category  :
# Authors   : jong@ebi.ac.uk
# Version   : 1.1
#----------------------------------------------------------------------------
sub sort_sequence_ranges{
    my (@in);
    if(ref $_[0] eq 'ARRAY'){
        @in = @{$_[0]};
    }else{
        @in = @_;
    }
    @in= map {$_->[0]} sort { $a->[1] <=> $b->[1] } map {/(\d+)\-\d+/ && [$_, $1] } @in;
    return(\@in);
}



#__________________________________________________________________________
# Title     : sort_hash_value_by_column
# Usage     : @out=@{&sort_by_column(\%input_line_hash, <column num>)};
# Function  : it sorts values of hash by the given column , small comes top. Unless number is
#             is given, it sorts by the first column.
#             It returnns ARRAY of the keys of the input HASH!!!
#
#             It can handle gzipped file. It called gunzip to open and sort.
#
# Example   : Above will sort the file xxxx.mspa by its 3rd column(numerically)
#               small numbers will come to the top.
# Keywords  : sort_by_2nd_column, sort_by_second_column, sort_by_e_values,
#             sort_by_evalues, sort_hash_by_column, sort_value_by_column,
# Options   :
#      s  for sorting stringwise
#      d  for sorting by digit
#      n  for sorting by digit(numerically)
#   $sort_numerically_RV=r by r
#
#   numerically  an alias of n
#
# Category  :
# Version   : 1.2
#----------------------------------------------------------------------------
sub sort_hash_value_by_column{
    my (%in, $i, $col, $sort_numerically, $sort_numerically_RV,
        $sort_non_numerically, @keys);
    $sort_numerically=1;
    if(@_ < 2  ){ print "\n# FATAL: sort_by_column needs 2 arguments\n"; die }
    for (@_){
            if(ref $_ eq 'HASH'){ %in =%{$_}; }
            elsif( ref $_ eq 'SCALAR'){ $col=${$_}; }
            elsif(/^\d+$/){ $col=$_ }
            elsif(/^\s*r\s*$/i){ $sort_numerically=1; $sort_numerically_RV='r'; $sort_non_numerically=0; }
            elsif(/^\s*[nd]\s*$/i){ $sort_numerically=1; $sort_non_numerically=0; }
            elsif(/^\s*n[umerically]*\s*$/i){ $sort_numerically=1; $sort_non_numerically=0; }
            elsif(/^\s*s\s*$/i){ $sort_non_numerically=1; $sort_numerically=0; }
    }
    $col--;

    @keys= keys %in;
    if($sort_numerically ){
         if($sort_numerically_RV){
             @keys= map {$_->[0]} sort { $b->[1] <=> $a->[1] } map { [$_, ($in{$_}=~/(\S+)/g)[$col] ] } @keys;
         }else{
             @keys= map {$_->[0]} sort { $a->[1] <=> $b->[1] } map { [$_, ($in{$_}=~/(\S+)/g)[$col] ] } @keys;
         }
    }else{ # here let's do the sring sort
             @keys= map {$_->[0]} sort { $a->[1] cmp $b->[1] } map { [$_, ($in{$_}=~/(\S+)/g)[$col] ] } @keys;
    }
    return(\@keys);
}


#__________________________________________________________________________
# Title     : sort_by_column
# Usage     : @out=@{&sort_by_column(\@input_line_array, <column num>)};
# Function  : it sorts by the given column , small comes top. Unless number is
#             is given, it sorts by the first column.
#
#             It can handle gzipped file. It called gunzip to open and sort.
#
# Example   : sort_by_column.pl 3 xxxx.mspa
#               Above will sort the file xxxx.mspa by its 3rd column(numerically)
#               small numbers will come to the top.
# Keywords  : sort_by_2nd_column, sort_by_second_column, sort_by_e_values,
#             sort_by_evalues, sort_columns
# Options   :
#   $sort_numerically=n by n -n ## s is NOT numerically, n is numerically
#   $sort_by_string=s by s -s
#   $column_to_use= by c=
#   $Columns_to_use= by C=
#   $write_output_file=w by w
#   $NO_write_on_SCREEN=q by q
#   $bigger_num_first=b by b
#   $reverse_order=r by r
#
# Version   : 2.2
#----------------------------------------------------------------------------
sub sort_by_column{
	 my (@in, @M, $col, $sort_numerically, $sort_non_numerically,$temp,
         $COL, $sort_by_string, @COL, $NO_write_on_SCREEN, $reverse_order);
	 unless(@_ > 1  ){ print "\n# FATAL: sort_by_column needs 2 arguments\n"; exit }
	 $sort_numerically='n';
	 for (@_){
         if(ref $_ eq 'ARRAY'){ @in =@{$_}; }
         elsif( ref $_ eq 'SCALAR'){ $col=${$_}; }
         elsif(/c=(\d+)/){ $COL[0]=$1; $col=$1; }
         if(/^\d+$/){    $COL[0]=$_; $col=1; }
         elsif(/C=(\d+.*)/){
              $temp=$1;
              if($temp=~/\w\W\w/){
                  @COL= map { $_ - 1;  } split(/\W/, $temp);
              }elsif($temp=~/^\d+$/){
                  push(@COL, $temp); $col=$temp;
              }
              for $col(@COL){ if($col<0){ $col=0 } };
         }
         elsif(/^\s*b[igger_num_first]*\s*$/i){ $bigger_num_first=1; $sort_non_numerically=0; }
         elsif(/^\s*[nd]\s*$/i){ $sort_numerically=1; $sort_non_numerically=0; }
         elsif(/^\s*r\s*$/i){ $reverse_order='r'; $bigger_num_first='b' }
         elsif(/^\s*s\s*$/i){ $sort_non_numerically=$sort_by_string='s'; $sort_numerically=0; }
         elsif(/^\s*Q\s*$/i){ $NO_write_on_SCREEN='Q'; }
	 }
     $col--;
	 if($sort_numerically ){ ## if the first and last elements are digits?
         if($bigger_num_first){
              if($in[0]=~/\d+\.\d+\./ and $in[$#in]=~/\d+\.\d+\./){ ## when the column number contains things like:  10.10.2.1
                  print "\n# (i) sort_by_column: The column $col contains $in[0], sorting reasonably\n" unless $NO_write_on_SCREEN;
                  @in= map {$_->[0]} sort { $b->[1] <=> $a->[1]   ## this is good for SCOP classification
                                 or $b->[2] <=> $a->[2]    or $b->[3] <=> $a->[3]
                                 or $b->[4] <=> $a->[4]    or $b->[5] <=> $a->[5]
                                 or $b->[6] <=> $a->[6]    or $b->[7] <=> $a->[7]
                                 or $b->[8] <=> $a->[8]    or $b->[9] <=> $a->[9]
                                 or $b->[10] <=> $a->[10]  or $b->[11] <=> $a->[11]
                                  }
                                  map { [$_->[0], ($_->[1])=~/(\d+)/g] }
                                  map { [$_,  ($_=~/(\S+)/g)[$col] ] } @in;
              }else{
                  @in= map {$_->[0]} sort { $b->[1] <=> $a->[1]   or $b->[2] <=> $a->[2]
                                  or $b->[3] <=> $a->[3]   or $b->[4] <=> $a->[4]
                                  or $b->[5] <=> $a->[5]   or $b->[6] <=> $a->[6]
                                  or $b->[7] <=> $a->[7]   or $b->[8] <=> $a->[8]
                                  or $b->[9] <=> $a->[9]   or $b->[10] <=> $a->[10]
                                  or $b->[11] <=> $a->[11] or $b->[12] <=> $a->[12]
                                  or $b->[13] <=> $a->[13] or $b->[14] <=> $a->[14]
                                  }
                                  map { [$_, ($_=~/(\S+)/g)[$col] ] } @in;
              }
		 }else{
					 if($in[0]=~/\d+\.\d+\./ and $in[$#in]=~/\d+\.\d+\./){ ## when the column number contains things like:  10.10.2.1
							 print "\n# (i) sort_by_column: The column $col contains $in[0], sorting reasonably\n" unless $NO_write_on_SCREEN;
							 @in= map {$_->[0]} sort { $a->[1] <=> $b->[1]   ## this is good for SCOP classification
                                             or $a->[2] <=> $b->[2]    or $a->[3] <=> $b->[3]
                                             or $a->[4] <=> $b->[4]    or $a->[5] <=> $b->[5]
                                             or $a->[6] <=> $b->[6]    or $a->[7] <=> $b->[7]
                                             or $a->[8] <=> $b->[8]    or $a->[9] <=> $b->[9]
                                             or $a->[10] <=> $b->[10]  or $a->[11] <=> $b->[11]
                                              }
                                              map { [$_->[0], ($_->[1])=~/(\d+)/g] }
                                              map { [$_,  ($_=~/(\S+)/g)[$col] ] } @in;
					 }else{
							 @in= map {$_->[0]} sort { $a->[1] <=> $b->[1]   or $a->[2] <=> $b->[2]
                                             or $a->[3] <=> $b->[3]   or $a->[4] <=> $b->[4]
                                             or $a->[5] <=> $b->[5]   or $a->[6] <=> $b->[6]
                                             or $a->[7] <=> $b->[7]   or $a->[8] <=> $b->[8]
                                             or $a->[9] <=> $b->[9]   or $a->[10] <=> $b->[10]
                                             or $a->[11] <=> $b->[11] or $a->[12] <=> $b->[12]
                                             or $a->[11] <=> $b->[13] or $a->[12] <=> $b->[14]
                                             }
                                             map { [$_, ($_=~/(\S+)/g)[$col] ] } @in;
					 }
			 }
	 }elsif($sort_by_string){ # here let's do the sring sort
			 @in= map {$_->[0]} sort {     $a->[1] cmp $b->[1]   or $a->[2] cmp $b->[2]
                                        or $a->[3] cmp $b->[3]   or $a->[4] cmp $b->[4]
                                        or $a->[5] cmp $b->[5]   or $a->[6] cmp $b->[6]
                                        or $a->[7] cmp $b->[7]   or $a->[8] cmp $b->[8]
                                        or $a->[9] cmp $b->[9]   or $a->[10] cmp $b->[10]
                                        or $a->[11] cmp $b->[11] or $a->[12] cmp $b->[12]
                                        or $a->[11] <=> $b->[13] or $a->[12] <=> $b->[14]
                                        }
                                        map { [$_, ($_=~/(\S+)/g)[$col] ] } @in;
	 }
	 return(\@in);
}



#__________________________________________________________________________
# Title     : sort_by_scop_classification
# Usage     : @out=@{&sort_by_scop_classification(\@input_line_array, <classification column no>)};
# Function  : it sorts by the given column , small comes top. Unless number is
#             is given, it sorts by the first column.
#
#             It can handle gzipped file. It called gunzip to open and sort.
#
# Example   : sort_by_scop_classification.pl 3 xxxx.mpfa
#               Above will sort the file xxxx.mpfa by its 3rd column(numerically)
#               small numbers will come to the top.
#  sorts things like:
#     >dsfsf 1.2.3.1.4
#     >dsfsa 1.2.10.1.5
#
# Keywords  : sort_by_2nd_column, sort_by_second_column, sort_by_e_values,
#             sort_by_evalues,
# Options   :
#      s  for sorting stringwise
#      d  for sorting by digit
#      n  for sorting by digit(numerically)
# Version   : 1.1
#----------------------------------------------------------------------------
sub sort_by_scop_classification{
	 my (@in, @M, $col, $sort_numerically, $sort_non_numerically, $sort_by_string);
	 unless(@_ > 1  ){ print "\n# FATAL: sort_by_scop_classification needs 2 arguments\n"; die }
	 $sort_numerically='n'; # for SCOP it is n
	 for (@_){
			if(ref $_ eq 'ARRAY'){ @in =@{$_}; }
			elsif( ref $_ eq 'SCALAR'){ $col=${$_}; }
			elsif(/^\d+$/){ $col=$_ }
			elsif(/^\s*[nd]\s*$/i){ $sort_numerically=1; $sort_non_numerically=0; }
			elsif(/^\s*s\s*$/i){ $sort_non_numerically=$sort_by_string='s'; $sort_numerically=0; }
	 }
	 $col--;
	 if($sort_numerically ){ ## if the first and last elements are digits?
			@in= map {$_->[0]} sort{ $a->[1] <=> $b->[1]   ## this is good for SCOP classification
														 or $a->[2] <=> $b->[2]
														 or $a->[3] <=> $b->[3]
														 or $a->[4] <=> $b->[4]
														 or $a->[5] <=> $b->[5]
														 or $a->[6] <=> $b->[6]
														 or $a->[7] <=> $b->[7]
														 or $a->[8] <=> $b->[8]
														 or $a->[9] <=> $b->[9]
														 or $a->[10] <=> $b->[10]
														 or $a->[11] <=> $b->[11]
														 }
														 map { [$_->[0], ($_->[1])=~/(\d+)/g] }
														 map { [$_,  ($_=~/(\S+)/g)[$col] ] } @in;
	 }elsif($sort_by_string){ # here let's do the sring sort
			 @in= map {$_->[0]} sort { $a->[1] cmp $b->[1] } map { [$_, ($_=~/(\d+)/g)[$col] ] } @in;
	 }
	 return(\@in);
}



#__________________________________________________________________________
# Title     : sort_by_cluster_size
# Usage     : @out=@{&sort_by_cluster_size(\@input_line_array)};
# Function  : it sorts by the 1st digit before '-'  as in 2-183_cluster, 2-140_cluster,
#               etc.
# Example   :
# Keywords  : sort_by_columns, sort_by_text_columns, sort_by_column_numerically
#             sort_by_pattern
# Options   :
# Category  :
# Version   : 1.2
#----------------------------------------------------------------------------
sub sort_by_cluster_size{
		my (@in, @M, $col);
		if(@_ < 1  ){ print "\n# FATAL: sort_by_cluster_size needs 1 argument\n"; die }
		if(ref $_[0] eq 'ARRAY'){        @in = @{$_[0]};      }else{     @in = @_;    }
		$col=0;
		@in= map {$_->[0]} sort { $a->[1] <=> $b->[1] } map { [$_, ($_=~/^(\S+)\-/)[$col] ] } @in;
		return(\@in);
}


#__________________________________________________________________________
# Title     : sort_by_column_bigger_first
# Usage     : @out=@{&sort_by_column_bigger_first(\@input_line_array, 1)};
# Function  : it sorts by the 2nd column(E-value, in mspa file), small comes top
#             by the help of  ts <decoux@moulon.inra.fr>
# Example   :
# Keywords  : sort_by_columns, sort_by_text_columns, sort_by_column_numerically
#
# Options   :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub sort_by_column_bigger_first{
		my (@in, @M);
		unless(@_ ==2  ){ print "\n# FATAL: sort_by_column_bigger_first needs 2 arguments\n"; die }
		if(ref $_[0] eq 'ARRAY'){        @in = @{$_[0]};      }else{     @in = @_;    }
		if(ref $_[1] eq 'SCALAR'){       $col=${$_[1]};       }else{     $col=$_[1];  }
		$col--;
		@in= map {$_->[0]} sort { $b->[1] <=> $a->[1] } map { [$_, ($_=~/(\S+)/g)[$col] ] } @in;
		return(\@in);
}

#______________________________________________________________________________
# Title     : make_2_seq_comparison_matrix
# Usage     :
# Function  :
# Example   :
# Keywords  : make_protein_seq_comparison_matrix, make_matrix,
#             make_sequence_comparison_matrix
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_2_seq_comparison_matrix{
		my(%exchange_matrix, %seq, %comparison_matrix);
		%exchange_matrix=%{$_[0]};
		%seq=%{$_[1]};

		#&show_hash(\%exchange_matrix);
		#&show_hash(\%seq);
		@seq_names=keys %seq;
		@seq1=split(//, $seq{$seq_names[0]});
		@seq2=split(//, $seq{$seq_names[1]});
		for($i=0; $i< @seq1; $i++){
			 for($j=0; $j<@seq2; $j++){
					$comparison_matrix{$seq1[$i]}{$seq2[$j]}=$exchange_matrix{$seq1[$i]}{$seq2[$j]};
					print "\n$comparison_matrix{$seq1[$i]}{$seq2[$j]}";
			 }
		}
		return(\%comparison_matrix);
}

#______________________________________________________________________________
# Title     : make_Fold_domain_interact_network_PML_file
# Usage     : &make_interaction_network_PML_file($PSDIP_file, $PDBG_file);
# Function  : generates various analysis files
# Example   :
#   PSDIP file is like:
#   PROTEIN_NONINTERACT     d168lb_ d168lc_ 168l  4.0 0 b: c:
#   PROTEIN_NONINTERACT     d168lc_ d168ld_ 168l  4.7 0 c: d:
#   PROTEIN_INTERACT        d168ld_ d168le_ 168l  4.2 5 d: e:
#   PROTEIN_INTERACT        d175la_ d175lb_ 175l a: b:
#   PROTEIN_INTERACT        d176la_ d176lb_ 176l a: b:
#  PML file looks like:
#   node pwgel_106 650 675 H2O                             compound        comp_C00001     8
#   node pwgel_108 650 735 Orthophosphate  compound        comp_C00009     8
#   node pwgel_110 650 755 Pyrophosphate   compound        comp_C00013     8
#   node pwgel_112 650 775 S-Adenosyl-L-methionine compound        comp_C00019     8
#
#   arc  pwgel_13 pwgel_12 pwgel_10 expression   expression      expr_AK3_ECOLI  1
#   arc  pwgel_11 pwgel_10 pwgel_1  catalysis    catalysis       cat_AK3_ECOLI_2_7_2_4   1
#   arc  pwgel_17 pwgel_16 pwgel_14 expression   expression      expr_AK1H_ECOLI 1
#   arc  pwgel_15 pwgel_14 pwgel_1  catalysis    catalysis       cat_AK1H_ECOLI_2_7_2_4  1
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub make_Fold_domain_interact_network_PML_file{
    my($PSDIP_file,  $PDBG_file, %pdbg, @sorted_pair, %fold, %folds,
       $i, %psdip, $fold1, $fold2, %fold_pair_interact, $file1, $file2,
       $total_self_self_inter_pair, %self_nelf_inter, %self_self_inter,
       %fold_count, @folds, %fold_versatility, $num_self_self_inter,
       $ratio_self_inter, $total_r_nelf_inter, $total_r_self_inter,
       @FOLD_mem_no_vs_Interact_PAIR_no1, @FOLD_mem_no_vs_Interact_PAIR_no2,
       @FOLD_mem_no_vs_Interact_PAIR_no3, $member_no, $match_FOLD_num,$PDBG_type,
       %non_redun_fold_match, @fold_matched, %fold_pair_interact,
       %pdbg_desc, %total_fold_number, $total_non_interaction_pair, $total_pairing,
       $total_interact_fold_num, %pdbd_count);
    $file1=${$_[0]} || $_[0];   $file2 =${$_[1]} || $_[1];
    if($file1=~/\.[pdbg|mpfa]/ and $file2=~/\.psdip/){ $PDBG_file=$file1; $PSDIP_file=$file2
    }elsif($file1=~/\.psdip/ and $file2=~/\.[pdbg|mpfa]/){ $PDBG_file=$file2; $PSDIP_file=$file1 }
    unless(-s $PSDIP_file and -s $PDBG_file){ die "\n I need PSDIP and PDBG file <- make_interaction_network_PML_file\n";}

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Check what PDBG file(%) was used to add in output file names
    #_________________________________________________________________
    if($PDBG_file=~/pd\w+?(\d+)\w*_/){    $PDBG_type=$1;    }
    open(PDBG, "<$PDBG_file") || die;
    while(<PDBG>){
        if(/\>(\S+)\s(\d+\.\d+)\.\d+\S+\s+(.+)/){
           $pdbg{$1}=$2; $pdbg_desc{$2}.="\t$3\n";
           push(@{$fold{$2}}, $1);
           $total_fold_number{$2}++;
        }
    }
    close(PDBG);
    $total_fold_number=keys %total_fold_number;

    open(PSDIP, "<$PSDIP_file") || die;
    while(<PSDIP>){
       if(/PROTEIN_INTERACT\s+(\S+)\s+(\S+)/){
           $pdbd1=$1; $pdbd2=$2;
           @sorted_pair=sort($pdbd1, $pdbd2);
           $fold1=$pdbg{$pdbd1};
           $fold2=$pdbg{$pdbd2};
           $fold1=~s/\./_/g;
           $fold2=~s/\./_/g;
           if($fold1 and $fold2){
               @sorted_sf_pair=sort($fold1, $fold2);
               $node_id{$fold1}=$fold1;
               $node_id{$fold2}=$fold2;
               $fold_pair{"@sorted_sf_pair"}++;
           }else{ next }
       }elsif(/PROTEIN_NONINTERACT\s+(\S+)\s+(\S+)/){ $total_non_interaction_pair++ }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Creating various files
    #__________________________________________________________________________
    $date=${&get_date_text()};
    $pml_file="PSIFA_$PDBG_type\_$date\_Fold\.pml";
    open(PML_FILE, ">$pml_file") || die ; ## protein interaction versitility
    print PML_FILE "# made by: make_interaction_network_PML_file to make piver file\n";
    print PML_FILE "# Total fold number: $total_fold_number in $PDBG_file\n";

    @node_id=sort keys %node_id;

    for($i=0; $i< @node_id; $i++){
       unless($node_id[$i]=~/\S+/){ next; }
       $node_id[$i]=~s/[\. ]/_/g;
       print PML_FILE "\nnode $node_id[$i]\t0 0 DESC";
    }


    @folds=sort keys %fold_pair;

    print PML_FILE "\n";
    #print "\n@folds\n";
    for($i=0; $i< @folds; $i++){
       $edge_strength= $fold_pair{$folds[$i]};
       unless($folds[$i]=~/\S+/){ next; }
       $folds[$i]=~/(\S+)\s+(\S+)/;
       $edge_orig=$1;
       $edge_dest=$2;
       $edge_orig=~s/\./_/g;
       $edge_dest=~s/\./_/g;
       $edge_id="$edge_orig\_$edge_dest";
       $arc_line=sprintf("arc %-17s %-9s %-9s %-9s\n", $edge_id, $edge_orig, $edge_dest, $edge_strength);
       print PML_FILE $arc_line;
       print $arc_line;

    }
    print "\n";
    print PML_FILE "\n";
    close(PML_FILE);
    print "\n# \$pml_file $pml_file is produced \n";
}


#______________________________________________________________________________
# Title     : make_superfam_superfam_interaction_pair_from_Y2H
# Usage     : $0 pdb100d_1_48.mpfa nonred_scid_interacts_JONG.y2hin psi_pdbisl_merge_assign.strass
# Function  :
# Example   : &make_superfam_superfam_interaction_pair_from_Y2H(@ARGV );
#   y2hin file: nonred_scid_interacts_JONG.y2hin
#
#     YMR229C YGL171W
#     YBR0832 YDR227W
#     YAL001C YDR362C
#
#   strass file: psi_pdbisl_merge_assign.strass
#     YAL003W-206 121-180 d1b64__-91 6-65 2e-24
#     YAL005C-642 388-600 d1dkza_-219 1-209 5e-95
#     YAL005C-642 1-364 d1dkgd_-383 1-369 1e-167
#     YAL011W-638 181-273 d1br0__-120 13-120 3e-07
# Keywords  : BIT
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub make_superfam_superfam_interaction_pair_from_Y2H{
    my($PDBG_file, $pml_file, $base, $file, $y2hin_file, $strass_file,
       $sfinp_file, @ORF1, @ORF2, %non_dup, %superfam_next, $orf,$pdbd,
       @superfam_matched1, @superfam_matched2, $arc_line, @superfams,
       %PDBD_lookup, %ORF_inter, $superfam, $class_type, $i, $j, $k);
    $file1=${$_[0]} || $_[0];   $file2 =${$_[1]} || $_[1];
    $file3=${$_[2]} || $_[2];   $file4 =${$_[3]} || $_[3];

    @files=($file1, $file2, $file3, $file4);
    for($i=0; $i< @files; $i++){
       $file=$files[$i];
       if($file=~/\.pdbg|mpfa/){  $PDBG_file=$file;
       }elsif($file=~/\.y2hin/){  $y2hin_file=$file;
       }elsif($file=~/\.strass/){ $strass_file=$file; }
    }
    $base=${&get_base_names(\$y2hin_file)};
    $sfinp_file="$base\.sfinp";
    open(SFINP, ">$sfinp_file") || die;
    $pml_file="$base\.pml";
    open(PDBG_FILE, "<$PDBG_file") || die "\n Can not open $PDBG_file \n\n";
    while(<PDBG_FILE>){
       if(/^\>([de](\d\w\w\w)\S+)\s+(((\d+)\.\d+)\.\d+)/){
           $PDBD_name=$1;           $PDB_ID=$2;
           $superfam=$3;           $fold_type=$4;
           $class_type=$5;
           $PDBD_lookup{$PDBD_name}=$superfam;
       }
    }
    close(PDBG_FILE);
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Reading in Physical domain interaction pairs to make the table
    #__________________________________________________________________
    open(STRASS_FILE, "<$strass_file") || die;
    while(<STRASS_FILE>){
       if(/(\S+)\-\d+\s+\S+\s+(\S+)\-\d+\s+\S+\s+(\S+)/){
           $orf=$1;
           $pdbd=$2; $eval=$3;
           if($eval < 0.001){
              if($PDBD_lookup{$pdbd}){
                 $superfam=$PDBD_lookup{$pdbd};
                 push(@{$ORF_inter{$1}}, $superfam);
                 print "\n $1 @{$ORF_inter{$1}} ";
              }
           }else{ next }
       }
    }
    close(STRASS_FILE);

    open(Y2H_FILE, "<$y2hin_file") || die ;
    while(<Y2H_FILE>){
        if(/^(\S+)\s+(\S+)/){
            $orf1=$1;
            $orf2=$2;
            @ORF1=sort @{$ORF_inter{$orf1}};
            @ORF2=sort @{$ORF_inter{$orf2}}; ## has 2.2.1 , 2.1.1, etc
            $orf_num1=@ORF1=@{&remove_dup_in_array(\@ORF1)};
            $orf_num2=@ORF2=@{&remove_dup_in_array(\@ORF2)};
            #print "\n$orf_num1 $orf_num2";
            if(@ORF1 and @ORF2){
                for($i=0; $i< @ORF1; $i++){
                    $superfam1=$ORF1[$i];
                    $superfam1=~s/\./_/g;
                    for($j=0; $j< @ORF2; $j++){
                       $superfam2=$ORF2[$j];
                       $superfam2=~s/\./_/g;
                       if($superfam1 and $superfam2){
                           $SFINP{"$superfam1\t$superfam2"}="$superfam1\t$superfam2";
                           push(@{$superfam_next{$superfam1}}, $superfam2);
                           push(@{$superfam_next{$superfam2}}, $superfam1);
                       }
                    }
                }
            }
        }
    }
    close(Y2H_FILE);

    $num_superfam_pair_inter=@superfam_pair=sort keys %SFINP;
    for($i=0; $i<@superfam_pair; $i++){
        print SFINP "\n$superfam_pair[$i]";
    }
    print "\n# \$num_superfam_pair_inter is $num_superfam_pair_inter\n";
    close(SFINP);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Creating various files
    #__________________________________________________________________________
    $PML_file="$base\_Y2H\.pml";
    open(PML_FILE, ">$PML_file") || die ; ## protein interaction versitility
    print PML_FILE "# made by: make_interaction_network_PML_file to make piver file\n";
    print PML_FILE "# Total superfam number: $total_superfam_number in $PDBG_file\n";

    @superfams=sort keys %superfam_next;
    for($i=0; $i< @superfams; $i++){
       unless($superfams[$i]=~/\S+/){ next; }
       $superfams[$i]=~s/\./_/g;
       print PML_FILE "\nnode $superfams[$i]\t0 0 DESC";
       @superfam_matched=@{$superfam_next{$superfams[$i]}};
       @superfam_matched=sort @{&remove_dup_in_array(\@superfam_matched)};
       push(@{$non_dup{$superfams[$i]}}, @superfam_matched);
    }


    @superfams=sort keys %non_dup;
    print PML_FILE "\n";

    for($i=0; $i< @superfams; $i++){
       unless($superfams[$i]=~/\S+/){ next; }
       $superfams[$i]=~s/\./_/g;
       $superfam_before=$superfams[$i];
       @superfam_matched1 = sort @{$non_dup{$superfams[$i]}};
       #print "\n @superfam_matched1 \n";
       for($j=0; $j< @superfam_matched1; $j++){
          $superfam_middle=$superfam_matched1[$j];
          @superfam_matched2 = sort @{$non_dup{$superfam_middle}};
          for($k=0; $k< @superfam_matched2; $k++){
              $superfam_next=$superfam_matched2[$k];
              #if($superfam_before eq $superfam_middle and $superfam_middle eq $superfam_next){
              if($superfam_before eq $superfam_middle or $superfam_middle eq $superfam_next){
                 next;
              }
              $arc_line=sprintf("arc %-9s %-9s %-9s SF:%-9s\n", $superfam_middle, $superfam_before, $superfam_next, $superfam_middle);
              print PML_FILE $arc_line;
              #print $arc_line;
          }

       }
    }
    print "\n";
    print PML_FILE "\n";
    close(PML_FILE);

    print "\n# $sfinp_file, $PML_file : created \n";
}




#______________________________________________________________________________
# Title     : make_scop_domain_interaction_pair_table
# Usage     : ($contact_list_ref, $out_file_name_ref)=
#                       &make_scop_domain_interaction_pair_table($SCOP_domain_def_file,
#                                                $PROT_STR_DOM_interact_pair,
#                                                $PDB_database_dir_path);
# Function  :
# Example   :
# Keywords  : make_protein_domain_interaction_pair_table,
#             make_SCOP_domain_interaction_pair_table
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.4
#------------------------------------------------------------------------------
sub make_scop_domain_interaction_pair_table{
    my($SCOP_domain_def_file, $PROT_STR_DOM_interact_pair, $PDB_database_dir_path,
       $base, $i, $j, $known_interact, $unknown_interact, $out_file_name, @pairs,
       $previous_interact_file, %interacting_PDB_domains, %PROT_STR_DOM_lookup_hash,
       %PROT_STR_DOM_class_hash, @PDB_IDs, $ftp_server_name, $server_directory, $username,
       $client_directory, $domain1, $domain2, $pdbd_name1, $pdbd_name2, @xyz_coord1,
       @xyz_coord2, $distance, @Interact_FLAG, %PDB_entry_checked, $single_domain_num,
       $final_output, $contact_num_thresh, $distance_thresh, $atom_sample_interva);
    $|=1;
    $distance_thresh=5;      # Angstrom
    $contact_num_thresh=10 ; # minimum number of atomic contacts to be considered to be interacting
    $atom_sample_interval=12; # this must be the same or larger than 3
    $SCOP_domain_def_file=$_[0];
    $PROT_STR_DOM_interact_pair=$previous_interact_file=$_[1];
    $PDB_database_dir_path=$_[2];
    $base=${&get_base_names($SCOP_domain_def_file)};
    $out_file_name="$base\_PROT_STR_DOM_interact.psdip"; ## protein structural domain interaction pair file
    print "\n# (0) Reading in $previous_interact_file file \n";
    %protein_str_dom_interact=%{&open_protein_structural_domain_interact_pair_file($previous_interact_file)}; # $protein_str_dom_interact{'PROTEIN_INTERACT'}{$1}=$2;
    &cp($previous_interact_file, "$previous_interact_file\.bak");

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # writing down fresh %protein_str_dom_interact to a PSDIP file (PROT_STR_DOM_interaction_pair.psdip)
    #___________________________________________________________________________________________________________
    open(CONTACT_LIST, ">$out_file_name") || die "can not open \$out_file_name $out_file_name\n";
    @Interact_FLAG=keys %protein_str_dom_interact; ## @Interact_FLAG=(PROTEIN_INTERACT, PROTEIN_NONINTERACT)
    for($i=0; $i< @Interact_FLAG; $i++){
        $num_of_pairs=@pairs=sort keys %{$protein_str_dom_interact{$Interact_FLAG[$i]}};
        print "# There were $num_of_pairs of already known $Interact_FLAG[$i] pairs from \%protein_str_dom_interact\n";
        print "     \%protein_str_dom_interact is from &open_protein_structural_domain_interact_pair_file()\n";
        for($j=0; $j<@pairs; $j++){
           if($pairs[$j]=~/^\S(\d\w\w\w)\S+/){   $PDB_entry_checked{$1}=$1;  }
           print CONTACT_LIST "$Interact_FLAG[$i]\t$pairs[$j]\n";
        }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Openning the main input SCOP domain def. file
    #_________________________________________________________________
    ($interacting_PDB_domains, $PROT_STR_DOM_lookup_hash, $PROT_STR_DOM_class_hash)
               =&open_SCOP_domain_definition_file($SCOP_domain_def_file);
    %interacting_PDB_domains             =%{$interacting_PDB_domains};
    %PROT_STR_DOM_lookup_hash=%{$PROT_STR_DOM_lookup_hash}; ## $PROT_STR_DOM_lookup_hash{"$PDB_ID\U$1"}=$PROT_STR_DOM_name;
    %PROT_STR_DOM_class_hash =%{$PROT_STR_DOM_class_hash};  ## $PROT_STR_DOM_class_hash{$PROT_STR_DOM_name}=$classification;

    $num_interacting_PDB_dom=@PDB_IDs=sort keys %interacting_PDB_domains; ## @interacting_PDB_domains=('a:10-20'...)

    for($i=0; $i< @PDB_IDs; $i++){
         my($sorted_pair, $PDB_ID, @domains, $PDB_file, %PDB_atom_domains, @chains, @files, @atom_numbers1, @atom_numbers2);
         $PDB_ID=$PDB_IDs[$i];
         if($PDB_entry_checked{$PDB_ID}){ next }
         @domains=sort @{$interacting_PDB_domains{$PDB_ID}};  # push(@{$interacting_PDB_domains{$PDB_ID}}, "$domain_num\_$region");
         if(@domains == 1){ $single_domain_num++ ; next }
         if(-s "$PDB_database_dir_path\/$PDB_ID\.brk"){   $PDB_file="$PDB_database_dir_path\/$PDB_ID\.brk";
         }elsif(-s "$PDB_database_dir_path\/$PDB_ID\.brk_mod"){ $PDB_file="$PDB_database_dir_path\/$PDB_ID\.brk_mod"; }

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         #  $DB_atom_domains{$chain}{residue}{$atom_number}=[$x, $y,$z];, The default chain is 'NO_CHAIN'
         #_______________________________________________________________________________________________
         %PDB_atom_domains=%{&open_PDB_atom_files_for_domains($PDB_file)};
         @chains=sort keys %PDB_atom_domains; ## @domains=('a', 'b',,,,)
         if(@chains < 1){
              @files=("$PDB_ID\.brk");   $ftp_server_name='jura.ebi.ac.uk';
              $server_directory='/data/research/pdb';
              $username='jong';  $passwd='7890uiop';
              $client_directory='/DB/PDB/Pdb';
              print "\n Opening $PDB_file failed. FTPing from $ftp_server_name \n\n";
              &ftp_get_files_given_from_a_list(\@files,         $ftp_server_name,
                                                $server_directory,
                                                $username,      $passwd,
                                                $client_directory
                                               );
              %PDB_atom_domains=%{&open_PDB_atom_files_for_domains($PDB_file)};# $DB_atom_domains{$chain}{$atom_number}=[$x, $y,$z];
              @chains=sort keys %PDB_atom_domains; ## @chains=(a, b, c, d,,,)
              if(@chains < 1){ print "\n FTP to get $PDB_file frm $ftp_server_name seems have failed \n\n";
                  push(@list_of_failed_PDB_entry, $PDB_file);
                  &send_mail_to_me(@list_of_failed_PDB_entry);
              }
         }
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If there are only 2 domains to be checked, I assume they interact
         #_________________________________________________________________________
         #if(@domains == 2){ ## @domains have (a:, b:,,,)
         #     $domain1=$domains[0];  $domain2=$domains[1];
         #     $pdbd_name1=$PROT_STR_DOM_lookup_hash{"$PDB_ID${domain1}"};
         #     $pdbd_name2=$PROT_STR_DOM_lookup_hash{"$PDB_ID${domain2}"};
         #     @contacting_pair=sort($pdbd_name1, $pdbd_name2);
         #     $contact_list{'PROTEIN_INTERACT'}{$sorted_pair}="@contacting_pair";
         #     print CONTACT_LIST "PROTEIN_NONINTERACT @contacting_pair\t$PDB_ID $domain1 $domain2\n";
         #     print "PROTEIN_INTERACT\t@contacting_pair\t$PDB_ID $domain1 $domain2 \n";
         #     next;
         #}

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If there are more than 2 scop domain entries for each PDB whole entry
         #________________________________________________________________________
         for($j=0; $j< (@domains-1); $j++){
            my($interact_or_not, @contacting_pair, $domain1_orig, $domain2_orig, @atom_numbers1,
               @xyz_coord1, @xyz_coord2, @atom_numbers2, $shortest, $contact_counter);
            $shortest=1000;
            $domain1=$domains[$j];  $domain2=$domains[$j+1];
            $pdbd_name1=$PROT_STR_DOM_lookup_hash{"$PDB_ID${domain1}"};
            $pdbd_name2=$PROT_STR_DOM_lookup_hash{"$PDB_ID${domain2}"};
            @contacting_pair=sort($pdbd_name1, $pdbd_name2);
            if($protein_str_dom_interact{'PROTEIN_NONINTERACT'}{"@contacting_pair"} or
               $protein_str_dom_interact{'PROTEIN_INTERACT'}{"@contacting_pair"}){
               next
            }
            @xyz_coord1=@{&get_atom_coord_from_SCOP_domain_def_info(\$domain1, \%PDB_atom_domains)};
            @xyz_coord2=@{&get_atom_coord_from_SCOP_domain_def_info(\$domain2, \%PDB_atom_domains)};
            if(@xyz_coord1 < 3 or @xyz_coord2 < 3){ die "\n $pdbd_name1, $pdbd_name2, $domain1 $domain2 \@xyz_coord1 and \@xyz_coord2 are too small \n"; }
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # check_contacts_between_two_molecules
            #_________________________________________________
            ATOM1: for($k=0; $k< @xyz_coord1; $k+= $atom_sample_interval){ ## default is 12
                @xyz1=@xyz_coord1[$k..$k+3];
                if(@xyz1 < 3){ die "\n Can not get \@xyz1 "; }
                for($l=0; $l< @xyz_coord2; $l+= $atom_sample_interval){  ## default is 12
                    @xyz2=@xyz_coord2[$l..($l+3)];
                    if(@xyz2 < 3){ die "\n Can not get \@xyz2 "; }
                    $distance=${&calculate_distance_for_2_points_in_3D(\@xyz1, \@xyz2)};
                    if($distance < $shortest){ $shortest=sprintf("%4.1f", $distance); }
                    if($distance <= $distance_thresh){ $contact_counter++;  }
                    if($contact_counter >= $contact_num_thresh){
                       $sorted_pair=join(' ', sort("$PDB_ID$domain1_orig", "$PDB_ID$domain2_orig"));
                       $pdbd_class1=$PROT_STR_DOM_class_hash{$pdbd_name1};
                       $pdbd_class2=$PROT_STR_DOM_class_hash{$pdbd_name2};
                       $contact_list{'PROTEIN_INTERACT'}{$sorted_pair} = join(' ', sort("$pdbd_name1 $pdbd_class1", "$pdbd_name2 $pdbd_class2"));
                       @contacting_pair=sort($pdbd_name1, $pdbd_name2);
                       print CONTACT_LIST "PROTEIN_INTERACT\t@contacting_pair\t$PDB_ID $shortest $contact_counter $domain1 $domain2\n";
                       print "PROTEIN_INTERACT\t@contacting_pair\t$PDB_ID $shortest $contact_counter $domain1 $domain2\n";
                       $interact_or_not=1;
                       last ATOM1;
                    }
                }
            }
            unless($interact_or_not){
                $contact_counter=0;
                $contact_list{'PROTEIN_NONINTERACT'}{$sorted_pair}="@contacting_pair";
                print CONTACT_LIST "PROTEIN_NONINTERACT @contacting_pair\t$PDB_ID $shortest $contact_counter $domain1 $domain2\n";
                print "PROTEIN_NONINTERACT\t@contacting_pair\t$PDB_ID $shortest $contact_counter $domain1 $domain2\n";
            }
         }
    }
    $final_output="ProStrDomIntPair_$contact_num_thresh\_$distance_thresh\_$atom_sample_interval\.psdip";
    &write_protein_structural_domain_interact_pair_file(\%contact_list, \$final_output);
    print CONTACT_LIST "\n \$single_domain_num : $single_domain_num\n";
    print "\n \$single_domain_num : $single_domain_num\n";
    return(\%contact_list, \$out_file_name);
}






#______________________________________________________________________________
# Title     : make_structure_interact_domain_super_family_links
# Usage     : &make_structure_interact_domain_super_family_links($file[0], $file[1], $file[2]);
#            => psi_pdbisl_merge_assign.txt pdb100d_1_48.pdbg strintergene_pairs.txt
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.5
#------------------------------------------------------------------------------
sub make_structure_interact_domain_super_family_links{
    my($MSPA, %PDB, %interact_pairs, $i, $j, $k, %ORF_desc, $discarded_ORFs,$selected_ORFs,
       @interact_pairs, $total_domain, @PDB, $homolog1, $homolog2, $seq_id_start,
       $seq_id_stop, $seq_id_start, $seq_id_stop, $Eval_thresh, $MSPA, $PDBG_file,
       $strintergene_list);
    $seq_id_start=0.1;
    $seq_id_stop =0.85+$seq_id_start;
    $Eval_thresh=0.00000001;
    $MSPA=$_[0];
    $PDBG_file=$_[1];
    $strintergene_list=$_[2];

    print "\n# Param: \$seq_id_start $seq_id_start, \$Eval_thresh $Eval_thresh\n";
    open(STRINTERGENE, "<$strintergene_list") || die "Can not open $strintergene_list \n";
    while(<STRINTERGENE>){    if(/^(\S+)/){    $strintergene{$1}=$1;     }    }
    close(STRINTERGENE);

    open(ORF_desc, "<orf_descriptions.txt") || die "\n Can not open orf_descriptions.txt \n";
    while(<ORF_desc>){   if(/^(\S+)\s+(.+)/){ $ORF_desc{$1}=$2 }    }
    close(ORF_desc);

    my $domain_number=100; ## 100 is absurdly high. 30 seems the maximum
    open(PDBG_FILE, "<$PDBG_file") || die "\n Can not open $PDBG_file \n\n";
    while(<PDBG_FILE>){
       if(/^\>([de](\d\w\w\w)\S+)\s+(((\d+)\.\d+)\.\d+)/){
           $PDBD_name=$1; $PDB_ID=$2;  $superfam=$3;    $fold_type=$4;     $class_type=$5;
           $domain_counter{$PDB_ID}++;
           $PDBD_lookup{$PDBD_name}=$superfam;
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # If I set $domain_number=2, I get only dimers
           #_______________________________________________
           if($domain_counter{$PDB_ID} > $domain_number){
               print "\n !!! Deleting $domain_counter{$PDB_ID} $PDB_ID $PDBD_name";
               delete ($superfam{$PDB_ID});
               delete ($PDBD_interm{$superfam}{$PDB_ID});
           }else{
               $superfam1{$PDB_ID}{$superfam}= $superfam;
               $superfam{$PDBD_name}{$superfam}= $superfam;
               $PDBD_interm{$superfam}{$PDBD_name}=$PDBD_name;
           }
       }
    }
    close(PDBG_FILE);


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # openning input MSPA file (is MSPA file is given)
    #__________________________________________________________
    open(MSPA, "<$MSPA") || die "\n Can not open $MSPA \n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # 88.8    1e-17   0.32    4    61 d155c__ 7   60  YJR048W     1 GDAAKGEKEFN-KCKACHMIQAPDGTDIKGGKTGPNLYGVVGRKIASEEGFKYGEGILE<=>GSAKKGATLFKTRCLQCHTVEKGGP-----HKVGPNLHGIFGRHSGQAEGYSYTDANIK
    #__________________________________________________________________________________________
    while(<MSPA>){
       if(/^\S+\s+(\S+)\s+(\S+)\s+\d+\s+\d+\s+([de](\d\w\w\w)\S+)\s+\d+\s+\d+\s+(\S+)\s+\d+\s+(\S+)/){
           $PDBD_name=$3; $PDB_ID=$4;  $matched=$5;
           unless($strintergene{$matched}){ $discarded_ORFs++; next }else{ $selected_ORFs++; }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # removing single domain matches
           #_____________________________________________________
           #if($PDBD_name=~/[de]\d\w\w\w__/){ next }

           for($i= $seq_id_start; $i <= $seq_id_stop; $i+=0.05){
              if($1 <= $Eval_thresh and $2 >= $i ){
                  push(@{$PDB{$i}{$PDB_ID}}, $matched);
                  push(@{$PDBD{$i}{$PDBD_name}}, "$matched\_$region");
                  $PDB_domain_count{$PDB_ID}{$PDBD_name}=$PDBD_name;
              }
           }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Sarah's psi_pdbisl_merge_assign.txt file format
       #__________________________________________________________
       }elsif(/^(\S+)\-\d+\s+(\S+)\s+([de](\d\w\w\w)\S+)\-\d+\s+\S+\s+(\S+)/){
           $PDBD_name=$3;   $PDB_ID=$4;  $matched=$1; $evalue=$5;
           $region=$2;
           unless($strintergene{$matched}){ $discarded_ORFs++; next }else{ $selected_ORFs++; }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # removing single domain matches
           #_____________________________________________________
           #if($PDBD_name=~/[de]\d\w\w\w__/){ next }
           $HOMOLOG_superfam_lookup{$matched}{$PDBD_lookup{$PDBD_name}}=$PDBD_lookup{$PDBD_name};
           for($i= $seq_id_start; $i <= $seq_id_stop; $i+=0.05){
              if($evalue <= $Eval_thresh){
                  push(@{$PDB{$i}{$PDB_ID}}, $matched);
                  push(@{$PDBD{$i}{$PDBD_name}}, "$matched\_$region");
                  $PDB_domain_count{$PDB_ID}{$PDBD_name}=$PDBD_name;
                  $PDBD_and_matched{"$matched\_$region"}="$PDBD_lookup{$PDBD_name} $evalue"; ## YALXXXX -> 1.3.1
              }
           }
       }
    }
    close(MSPA);

    @SeqID_thresh=sort {$a<=>$b} keys %PDB;
    open(ID_vs_SINTER_PAIRS, ">Seq_ID_vs_Sinteractio_pairs.txt") || die;

    for($t=0; $t < @SeqID_thresh; $t++){
       my(%interact_pairs, $SeqID_thresh, @PDB);
       $SeqID_thresh=$SeqID_thresh[$t];
       @PDB=sort keys %{$PDB{$SeqID_thresh}}; # @PDB has '1tco 1amu 1amw 1dea 1amy 1xva 1a33..'
       $out_file="Sinteraction_pair_seqID_$SeqID_thresh\_$Eval_thresh.txt";
       $PDB_vs_ORFs="PDB_vs_ORFs_$SeqID_thresh\_$Eval_thresh.txt";
       open(SINTERACION, ">$out_file") || die;
       open(PDB_vs_ORFs, ">$PDB_vs_ORFs") || die;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Structural intermediate connection
       #_________________________________________________________
       for($i=0; $i< @PDB; $i++){
            my(@PDBD_interm, @superfam, $h, @homolog_matched1, @homolog_matched2 );
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # retrieving all the possible superfam for ONE PDB entry AND all the PDB members for all the superfams
            #____________________________________________________________________________________________________
            @superfam=keys %{$superfam1{$PDB[$i]}}; ## all superfam members for 1abc
            if(@superfam > 3){ next }
            if(@superfam < 1){ $missing_PDB_in_PDBG{$PDB[$i]}=$PDB[$i]; next }
            print "#---- $PDB[$i]: @superfam\n";
            for($j=0; $j< (@superfam-1); $j++){

               #if($superfam[$j]=~/3.30.1/){ next }

               unless($superfam[$j]=~/\S/){ die "\n $j \$superfam[$j] is empty. "; next }
               @PDBD_group1=keys %{$PDBD_interm{$superfam[$j]}};
               @PDBD_group2=keys %{$PDBD_interm{$superfam[$j+1]}};
               #print "\n@PDBD_group1\n@PDBD_group2\n";
               $num_pdb_interm += @PDBD_group1 + @PDBD_group2;
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Putting all the homologs of PDBD found(in MIPS) to @homolog_matched
               #_______________________________________________________________
               for($h=0; $h< @PDBD_group1; $h++){
                  if($PDBD{$SeqID_thresh}{$PDBD_group1[$h]}){
                      push(@homolog_matched1, @{$PDBD{$SeqID_thresh}{$PDBD_group1[$h]}});
                  }
               }
               for($h=0; $h < @PDBD_group2; $h++){
                  if($PDBD{$SeqID_thresh}{$PDBD_group2[$h]}){
                      push(@homolog_matched2, @{$PDBD{$SeqID_thresh}{$PDBD_group2[$h]}});
                  }
               }
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # 3bta =>
               # >d3btaa1 2.26.1.5.2 (872-1078) Botulinum neurotoxin serotype A {(Clostridium botulinum)}
               # >d3btaa2 2.37.4.2.2 (1079-1295) Botulinum neurotoxin serotype A {(Clostridium botulinum)}
               # >d3btaa3 4.71.1.5.1 (1-546) Botulinum neurotoxin serotype A {(Clostridium botulinum)}
               #________________________________________________________________________________________
               print PDB_vs_ORFs "\n>$PDB[$i]: $superfam[$j] : \@PDBD_group1 : @homolog_matched1\n";
               print PDB_vs_ORFs ">$PDB[$i]: $superfam[$j+1] : \@PDBD_group2 : @homolog_matched2\n";
               $pair_count_for_2_superfam=0;
               LOOP1: for($b=0; $b< @homolog_matched1; $b++){
                    if($homolog_matched1[$b]=~/(\S+)\_(\d+)\-(\d+)/){
                        $homolog1=$1; $homolog1_start=$2; $homolog1_stop=$3; }
                    LOOP2: for($k=0; $k< @homolog_matched2; $k++){
                        if($homolog_matched2[$k]=~/(\S+)\_(\d+)\-(\d+)/){
                           $homolog2=$1; $homolog2_start=$2; $homolog2_stop=$3;  }
                        if($homolog1 eq $homolog2){
                           if(${&get_sequence_overlap_size($homolog1_start, $homolog1_stop,
                                                           $homolog2_start, $homolog2_stop)} > 30){
                              print "$PDB[$i]: $superfam[$j] $homolog_matched1[$b] : $superfam[$j+1] $homolog_matched2[$k]\n";  next
                           }
                        }
                        print PDB_vs_ORFs " \> $homolog_matched1[$b] $PDBD_and_matched{$homolog_matched1[$b]} <-> $homolog_matched2[$k] $PDBD_and_matched{$homolog_matched2[$k]} $ORF_desc{$homolog1}\n";
                        $pair_count_for_2_superfam++;
                        if($pair_count_for_2_superfam > 20){ last }
                        $interact_pair=join(' ', sort($homolog1, $homolog2));
                        $interact_pairs{$interact_pair}=$interact_pair;
                    }
               }
            }
            $num_pdb_interm=$num_pdb_interm/2;

       }
       $interact_pair_num=@interact_pairs=sort keys %interact_pairs;
       for($p=0; $p< @interact_pairs; $p++){
           print SINTERACION "\n$interact_pairs[$p]";
       }
       push(@out_files, $out_file);
       print  "\n# \$interact_pair_num is $interact_pair_num \n";
       print SINTERACION "\n# \$interact_pair_num is $interact_pair_num \n";
       close(SINTERACION);
       close(PDB_vs_ORFs);
       print ID_vs_SINTER_PAIRS "\n$SeqID_thresh $interact_pair_num";
       print "# $out_file is created. \n";
    }
    close(ID_vs_SINTER_PAIRS);
    open(PDB_STAT, ">PDB_domain_stat.txt") || die;
    $num_PDB=@PDB=keys %PDB_domain_count;
    for($i=0; $i< @PDB; $i++){
       $num_of_domain=@domains=keys %{$PDB_domain_count{$PDB[$i]}};
       print PDB_STAT "\n$PDB[$i] $num_of_domain @domains";
       $total_domain+=$num_of_domain;
    }
    $av_domain=$total_domain/$num_PDB;
    print "\n# \$num_PDB $num_PDB, \$total_domain $total_domain, \$av_domain $av_domain\n";
    print "# Discarded ORF(not found to be assigned from psi_pdbisl_merge_assign.txt: $discarded_ORFs \n";
    print "# Selected  ORF(    found to be assigned from psi_pdbisl_merge_assign.txt: $selected_ORFs \n\n";

    @missin_pdb=keys %missing_PDB_in_PDBG;
    print "\n# \"@missin_pdb\" are missing in PDBG file \n";
    close(PDB_STAT);
    return(\@out_files);
}





#______________________________________________________________________________
# Title     : make_structure_interaction_domain_family.pl
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub make_structure_interaction_domain_family{
    my($MSPA, %PDB, %interact_pairs, $i, $j, $k,
       @interact_pairs, @PDB, $homolog1, $homolog2);
    $Seq_ID_thresh=0.4;
    $Eval_thresh=0.01;
    $MSPA=$_[0];
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # openning input MSPA file
    #__________________________________________________________
    open(MSPA, "<$MSPA") || die "\n Can not open $MSPA \n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # 88.8    1e-17   0.32    4    61 d155c__ 7   60  YJR048W     1 GDAAKGEKEFN-KCKACHMIQAPDGTDIKGGKTGPNLYGVVGRKIASEEGFKYGEGILE<=>GSAKKGATLFKTRCLQCHTVEKGGP-----HKVGPNLHGIFGRHSGQAEGYSYTDANIK
    #__________________________________________________________________________________________
    while(<MSPA>){
       if(/\S+\s+(\S+)\s+(\S+)\s+\d+\s+\d+\s+([de]\w\w\w\w)\S+\s+\d+\s+\d+\s+(\S+)\s+\d+\s+(\S+)/){
           for($i=0.1; $i <= 0.95; $i+=0.05){
              if($1 <= $Eval_thresh and $2 >= $i ){  push(@{$PDB{$i}{$3}}, $4);    }
           }
       }
    }
    close(MSPA);
    @ID_thresh=sort {$a<=>$b} keys %PDB;
    open(ID_vs_SINTER_PAIRS, ">Seq_ID_vs_Sinteractio_pairs.txt") || die;
    for($t=0; $t < @ID_thresh; $t++){
       my(%interact_pairs, $ID_thresh, @PDB);
       $ID_thresh=$ID_thresh[$t];
       @PDB=keys %{$PDB{$ID_thresh}};
       for($i=0; $i<@PDB; $i++){
          @homolog_matched=@{$PDB{$ID_thresh}{$PDB[$i]}};
          for($j=0; $j< @homolog_matched; $j++){
              $homolog1=$homolog_matched[$j];
              for($k=$j; $k< @homolog_matched; $k++){
                  $homolog2=$homolog_matched[$k];
                  if($homolog1 eq $homolog2){ next }
                  $interact_pair=join(' ', sort($homolog1, $homolog2));
                  $interact_pairs{$interact_pair}=$interact_pair;
              }
          }
       }
       $interact_pair_num=@interact_pairs=sort keys %interact_pairs;
       $out_file="Sinteraction_pair_seqID_$ID_thresh\_$Eval_thresh.txt";
       push(@out_files, $out_file);
       open(SINTERACION, ">$out_file") || die;
       for($i=0; $i< @interact_pairs; $i++){
          print SINTERACION "\n$interact_pairs[$i]";
       }
       print  "\n# \$interact_pair_num is $interact_pair_num \n";
       print SINTERACION "\n# \$interact_pair_num is $interact_pair_num \n";
       close(SINTERACION);
       print ID_vs_SINTER_PAIRS "\n$ID_thresh $interact_pair_num";
       print "# $out_file is created \n";
    }
    close(ID_vs_SINTER_PAIRS);
    return(\@out_files);
}


#______________________________________________________________________________
# Title     : make_structure_interact_domain_super_family_links
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.3
#------------------------------------------------------------------------------
sub make_structure_interact_domain_super_family_links{
    my($MSPA, %PDB, %interact_pairs, $i, $j, $k,
       @interact_pairs, $total_domain, @PDB, $homolog1, $homolog2, $seq_id_start,
       $seq_id_stop);
    $seq_id_start=0.6;
    $seq_id_stop =0.7;
    $Eval_thresh=0.00001;
    $MSPA=$_[0];
    $PDBG_file=$_[1];
    $strintergene_list=$_[2];
    open(STRINTERGENE, "<$strintergene_list") || die "Can not open $strintergene_list \n";
    while(<STRINTERGENE>){
       if(/(\S+)/){
          $strintergene{$1}=$1;
       }
    }
    close(STRINTERGENE);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # openning input MSPA file
    #__________________________________________________________
    open(MSPA, "<$MSPA") || die "\n Can not open $MSPA \n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # 88.8    1e-17   0.32    4    61 d155c__ 7   60  YJR048W     1 GDAAKGEKEFN-KCKACHMIQAPDGTDIKGGKTGPNLYGVVGRKIASEEGFKYGEGILE<=>GSAKKGATLFKTRCLQCHTVEKGGP-----HKVGPNLHGIFGRHSGQAEGYSYTDANIK
    #__________________________________________________________________________________________
    while(<MSPA>){
       if(/^\S+\s+(\S+)\s+(\S+)\s+\d+\s+\d+\s+([de](\d\w\w\w)\S+)\s+\d+\s+\d+\s+(\S+)\s+\d+\s+(\S+)/){
           $PDBD_name=$3; $PDB_ID=$4;  $matched=$5;
           unless($strintergene{$matched}){ next }
           for($i= $seq_id_start; $i <= $seq_id_stop; $i+=0.05){
              if($1 <= $Eval_thresh and $2 >= $i ){
                  push(@{$PDB{$i}{$PDB_ID}}, $matched);
                  $PDB_domain_count{$PDB_ID}{$PDBD_name}=$PDBD_name;
              }
           }
       }elsif(/^(\S+)\-\d+\s+\S+\s+([de](\d\w\w\w)\S+)\s+\S+\s+(\S+)/){
           $PDBD_name=$2; $PDB_ID=$3;  $matched=$1; $evalue=$4;
           unless($strintergene{$matched}){ next }
           if($matched=~/^TY/){ next }
           for($i= $seq_id_start; $i <= $seq_id_stop; $i+=0.05){
              if($evalue <= $Eval_thresh){
                  push(@{$PDB{$i}{$PDB_ID}}, $matched);
                  $PDB_domain_count{$PDB_ID}{$PDBD_name}=$PDBD_name;
              }
           }
       }
    }
    close(MSPA);

    open(PDBG_FILE, "<$PDBG_file") || die "\n Can not open $PDBG_file \n\n";
    while(<PDBG_FILE>){
       if(/>[de](\w\w\w\w)\S+\s+(\d+\.\d+\.\d+)/){
           $PDB_ID=$1;  $superfam=$2;
           $superfam{$PDB_ID}{$superfam}=$superfam;
           $PDB_interm{$superfam}{$PDB_ID}=$PDB_ID;
       }
    }
    close(PDBG_FILE);
    print "\n# finished reading in PDBG file \n";
    @ID_thresh=sort {$a<=>$b} keys %PDB;
    open(ID_vs_SINTER_PAIRS, ">Seq_ID_vs_Sinteractio_pairs.txt") || die;
    for($t=0; $t < @ID_thresh; $t++){
       my(%interact_pairs, $ID_thresh, @PDB);
       $ID_thresh=$ID_thresh[$t];
       @PDB=keys %{$PDB{$ID_thresh}};

       $out_file="Sinteraction_pair_seqID_$ID_thresh\_$Eval_thresh.txt";
       $PDB_vs_ORFs="PDB_vs_ORFs_$ID_thresh\_$Eval_thresh.txt";
       open(SINTERACION, ">$out_file") || die;
       open(PDB_vs_ORFs, ">$PDB_vs_ORFs") || die;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Structural intermediate connection
       #_________________________________________________________
       for($i=0; $i< @PDB; $i++){
            my(@PDB_interm, @superfam, $h, @homolog_matched );
            @superfam=keys %{$superfam{$PDB[$i]}};
            for($j=0; $j< @superfam; $j++){
               unless($superfam[$j]=~/\S/){ next }
               push(@PDB_interm, keys %{$PDB_interm{$superfam[$j]}} );
            }
            #@PDB_interm=@{&remove_dup_in_array(\@PDB_interm)};
            print "\n>> @superfam : @PDB_interm\n";

            for($h=0; $h< @PDB_interm; $h++){
               if($PDB{$ID_thresh}{$PDB_interm[$h]}){
                  push(@homolog_matched, @{$PDB{$ID_thresh}{$PDB_interm[$h]}});
               }
            }
            #@homolog_matched=sort @{&remove_dup_in_array(\@homolog_matched)};
            print PDB_vs_ORFs "\n>$PDB[$i]: @homolog_matched";
            for($j=0; $j< @homolog_matched; $j++){
                 $homolog1=$homolog_matched[$j];
                 for($k=($j+1); $k< @homolog_matched; $k++){
                     $homolog2=$homolog_matched[$k];
                     if($homolog1 eq $homolog2){ next }
                     $interact_pair=join(' ', sort($homolog1, $homolog2));
                     $interact_pairs{$interact_pair}=$interact_pair;
                 }
            }
       }
       $interact_pair_num=@interact_pairs=sort keys %interact_pairs;
       for($p=0; $p< @interact_pairs; $p++){
           print SINTERACION "\n$interact_pairs[$p]";
       }
       push(@out_files, $out_file);
       print  "\n# \$interact_pair_num is $interact_pair_num \n";
       print SINTERACION "\n# \$interact_pair_num is $interact_pair_num \n";
       close(SINTERACION);
       close(PDB_vs_ORFs);
       print ID_vs_SINTER_PAIRS "\n$ID_thresh $interact_pair_num";
       print "# $out_file is created \n";
    }
    close(ID_vs_SINTER_PAIRS);
    open(PDB_STAT, ">PDB_domain_stat.txt") || die;
    $num_PDB=@PDB=keys %PDB_domain_count;
    for($i=0; $i< @PDB; $i++){
       $num_of_domain=@domains=keys %{$PDB_domain_count{$PDB[$i]}};
       print PDB_STAT "\n$PDB[$i] $num_of_domain @domains";
       $total_domain+=$num_of_domain;
    }
    $av_domain=$total_domain/$num_PDB;
    print "\n# \$num_PDB $num_PDB, \$total_domain $total_domain, \$av_domain $av_domain";
    close(PDB_STAT);
    return(\@out_files);
}



#______________________________________________________________________________
# Title     : make_revcomp_sequences
# Usage     : %out=%{&make_revcomp_sequences(\@input_string_or_seq)};
#              or %out=%{&make_revcomp_sequences(\%input_string_or_seq)};
# Function  :
# Example   :
# Keywords  : add_revcomp_string, add_revcomp_string_array, insert_revcomp_string_array
#              make_revcomp_NA_sequences make_revcomp_DNA_sequences
#              make_reverse_complementary_sequences
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_revcomp_sequences{
    my(@revcomp_patterns, @patterns, $pattern, $i, %patterns,
       %pattern_revcomp, @names, $input_type, $arbit_name);
    if(ref($_[0]) eq 'ARRAY'){
        @patterns=@{$_[0]};
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Making a hash out of array
        #_________________________________________________
        for($i=0; $i< @patterns; $i++){
            $arbit_name="PAT\_$i";
            $patterns{$arbit_name}=$patterns[$i];
        }
        $input_type='ARRAY';
    }elsif(ref($_[0]) eq 'HASH'){ %patterns=%{$_[0]};
        $input_type='HASH';
    }else{  print "\n# (Error) make_revcomp_sequences get either HASH or ARRAY only \n"; exit }
    @names=sort keys %patterns;
    for($i=0; $i< @names; $i++){
       $pattern =$patterns{$names[$i]};
       $pattern =~ tr/\[\]acgtrymkswhbvdnACGTRYMKSWHBVDN/\]\[tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
       $pattern = reverse $pattern; # reversing it to add complimentary to the original
       $pattern_revcomp{"$names[$i]\_rc"}=$pattern;
    }
    if($input_type eq 'ARRAY'){
       return([values(%pattern_revcomp)]);
    }elsif($input_type eq 'HASH'){
       return(\%pattern_revcomp);
    }
}



#______________________________________________________________________________
# Title     : make_complementary_sequences
# Usage     : %out=%{&make_complementary_sequences(\@input_string_or_seq)};
#              or %out=%{&make_complementary_sequences(\%input_string_or_seq)};
# Function  :
# Example   :
# Keywords  : add_complementary_string, add_complementary_string_array, insert_complementary_string_array
#              make_complementary_NA_sequences make_complementary_DNA_sequences
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_complementary_sequences{
    my(@complementary_patterns, @patterns, $pattern, $i, %patterns,
       %pattern_complementary, @names, $input_type, $arbit_name);
    if(ref($_[0]) eq 'ARRAY'){
        @patterns=@{$_[0]};
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Making a hash out of array
        #_________________________________________________
        for($i=0; $i< @patterns; $i++){
            $arbit_name="PAT\_$i";
            $patterns{$arbit_name}=$patterns[$i];
        }
        $input_type='ARRAY';
    }elsif(ref($_[0]) eq 'HASH'){ %patterns=%{$_[0]};
        $input_type='HASH';
    }else{  print "\n# (Error) make_complementary_sequences get either HASH or ARRAY only \n"; exit }
    @names=sort keys %patterns;
    for($i=0; $i< @names; $i++){
       $pattern =$patterns{$names[$i]};
       $pattern =~ tr/\[\]acgtrymkswhbvdnACGTRYMKSWHBVDN/\]\[tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
       $pattern_complementary{"$names[$i]\_rc"}=$pattern;
    }
    if($input_type eq 'ARRAY'){
       return([values(%pattern_complementary)]);
    }elsif($input_type eq 'HASH'){
       return(\%pattern_complementary);
    }
}



#______________________________________________________________________________
# Title     : make_clean_fasta_file
# Usage     :
# Function  :
# Example   :
# Keywords  : cleanup_fasta_db cleanup_fasta_files
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_clean_fasta_file{
    local($num_seq, $i, @matches, %SEQ, $input_file, $functional_name,
          $PDB_name, $base, $output_file);
    $input_file=${$_[0]} || $_[0];
    $base=${&get_base_names($input_file)};
    $output_file="$base\_clean.mpfa";
    open(FASTA, "$input_file") || die "\n Cannot open $input_file \n\n";
    open(OUT_FASTA, ">$output_file") || die "\n Cannot open $output_file \n\n";
    print "\n  $input_file FASTA file is cleaned up. Please wait....\n";
    while(<FASTA>){
       #  0004.PRO=T:m52(3734>5020);thrC
       if(/\>(\S+)\.(\S+)\:(\S+)\;(\S+)\s*$/){
            $functional_name=$4;
            print OUT_FASTA "\>$functional_name\n";
            $SEQ{$functional_name}++;
            if($SEQ{$functional_name} > 1){ die "\n(1) Duplicate SEQ $functional_name \n$_\n";}
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # SGD protein seq format:  >ORFP:YAL011W YAL011W, Chr I from 132159-134075
       #_____________________________________________________________________________
       }elsif(/^\>ORFP\:(\S+)\s+(.*)/){
            $SEQ{$1}++;
            print OUT_FASTA "\>$1 $2\n";
            if($SEQ{$1} > 1){ die "\n(2) Duplicate SEQ $1 \n$_\n"; }
       }elsif(/^\>P1\;(\S+) ?([\S]?)/){  ## Burkhard Rost's test set
            if($2){
                $PDB_name="\L$1"."\_$2";
            }else{
                $PDB_name="\L$1";
            }
            print OUT_FASTA "\>$PDB_name\n";
            $SEQ{$PDB_name}++;
            if($SEQ{$PDB_name} > 1){ die "\n(3) Duplicate SEQ $PDB_name \n$_\n"; }
       }elsif(/^\>([^\|]+)\|([^\|]+)\|pdb\|(\S+)\|(\w)* */){ ## parsing PDB seq from NCBI blast/db dir
            $PDB_name="\L$3"."$4";
            print OUT_FASTA "\>$PDB_name\n";
            $SEQ{$PDB_name}++;
            if($SEQ{$PDB_name} > 1){ die "\n(4) Duplicate SEQ $PDB_name \n$_\n"; }
       }elsif(/^\>\/\/\:\/\:\S+\|\S+\|(\S+) +(.+)/){ ## to clean up Lisa Holm's nrdb90
            $functional_name=$1;
            print OUT_FASTA "\>$functional_name $2\n";
            $SEQ{$functional_name}++;
            if($SEQ{$functional_name} > 1){ die "\n(5) Duplicate SEQ $functional_name \n$_\n";}
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Liisa's prompt run of : ~dali/RDB/column name seq < /homes/holm/work/test/trivial.rdb.11-Mar-99 | /homes/holm/rdb2fasta.pl
       #_______________________________________________________________________________________________________________________________________________________
       }elsif(/^\>[^\|]+\|([^\|]+)\|([^\|]+)\s*/){ ##  >pironly|I38344|I38344 titin, cardiac muscle - human
            $SEQ{$1}++;
            if($SEQ{$1} > 1){
                if($SEQ{$2} > 0){ die "\n(6) Duplicate SEQ $1 and $2 \n$_\n\n";
                }else{ $SEQ{$2}++; print OUT_FASTA "\>$2\n"; }
            }else{
                print OUT_FASTA "\>$1\n";
            }
       }elsif(/^\>\S+\/\:\S+\|([^\|]+)\|\S+/){ ## to clean up Lisa Holm's nrdb90
            $functional_name=$1;
            print OUT_FASTA "\>$functional_name\n";
            $SEQ{$functional_name}++;
            if($SEQ{$functional_name} > 1){ die "\n(7) Duplicate SEQ $functional_name \n$_\n";}
       }elsif(/^\s*(\w+)\.\*$/){
            $last_line_seq=$1;
            print OUT_FASTA "$last_line_seq\n";
       }elsif(/^\>[^\|+]\|\S*\|\S*\|\S*\|([^\|]+) +/){ ## This is nr format
            print OUT_FASTA "\>$1\n";
            $SEQ{$1}++;
            if($SEQ{$1} > 1){ die "\n(8) Duplicate SEQ $1 \n$_\n";   }
       }elsif(/^\>[^\|]+\|([^\|]+) +/){ ## for >gi|45803 (X04609) gamma subunit (3'terminu
            print OUT_FASTA "\>$1\n";
            $SEQ{$1}++;
            if($SEQ{$1} > 1){ die "\n(9) Duplicate SEQ $1 \n$_\n";    }
       }elsif(/^\>\S+\|\S*\|\S*\|(\S+) +/){ # for gi|386065|bbs|133195 cytochrome c3
            print OUT_FASTA "\>$1\n";
            $SEQ{$1}++;
            if($SEQ{$1} > 1){ die "\n(10) Duplicate SEQ $1 \n$_\n";   }
       }elsif(/\>(\w+)\s*/){
            print OUT_FASTA;
            $SEQ{$1}++;
            if($SEQ{$1} > 1){ die "\n(11) Duplicate SEQ $1 \n$_\n";  }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Actual SEQUENCE
       #______________________________________________
       }elsif(@matches=$_=~/(\w+)\W+/gi){  #  CTAATTTTTG TCAGAATGAT GAGAGTGGCA GCCTCCTGAA GAGCAGCTGT CTCCGTGTGA
            for($i=0; $i< @matches; $i++){  # to handle CPnseq3 genome seq
               print OUT_FASTA "$matches[$i]";
               if($i%7 == 0){ print OUT_FASTA "\n"; }
            }
       }elsif(/^[A-Y]+$/i){  ## prints only CHARs
            print OUT_FASTA;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Burkhard's PHD test set
       #_____________________________________________________________________________
       }elsif(/^   (\w+)$/){
            print OUT_FASTA "$1\n";
            $SEQ{$1}++;
            if($SEQ{$1} > 1){ die "\n(12) Duplicate SEQ $1 \n$_\n"; }
       }
    }
    close(FASTA);
    close(OUT_FASTA);
    $num_seq=keys %SEQ;
    print "\n\n\n $num_seq has been processed producing \"$output_file\"\n\n\n";
    return(\%SEQ);
}





#______________________________________________________________________________
# Title     : merge_superfam_fasta_files_for_ISL
# Usage     : &merge_superfam_fasta_files_for_ISL;
# Function  :
# Example   :
# Keywords  : compile_superfam_fasta_files_for_ISL
# Options   :
# Author    : jong@salt2.med.harvard.edu
# Category  :
# Version   : 1.4
#------------------------------------------------------------------------------
sub merge_superfam_fasta_files_for_ISL{
    my($j, $base, $seq_name, $i, @files);
    @files=@{&read_file_names_only('.', 'mpfa')};
    print "\n# (i) Making compiled_interm_lib.fa, this takes several minutes\n";
    open(COMPILED, ">compiled_interm_lib.mpfa");

    for($j=0; $j< @files; $j++){
       unless($files[$j]=~/^\d+\.\d+\.\d+\.[mps]{0,2}fa/){
           next;
       }
       $base=${&get_base_names($files[$j])};
       open(SUPER, "$files[$j]");
       while(<SUPER>){
           if(/\>(\S+)/){
               $seq_name="\>$1";
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Checks if 1.1.1 is attached or not. If not , attach it now
               #_____________________________________________________________
               unless($seq_name=~/\d+\.\d+\.\d+/){
                  $seq_name="\>$1_$base";
               }
               print COMPILED $seq_name, "\n";
           }elsif(/^(\w+)$/){
               print COMPILED $1, "\n";
           }
       }
       close SUPER;
    }
    print "\n# (i) merge_superfam_fasta_files_for_ISL: compiled_interm_lib.fa has been created. \n";
    return( \"compiled_interm_lib.fa");
}




#______________________________________________________________________________
# Title     : make_thumbnails_of_pictures
# Usage     :
# Function  :
# Example   : <a href="jo.jpg"><img SRC="jo.jpg" BORDER=0 height=111 width=76></a>
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1
#------------------------------------------------------------------------------
sub make_thumbnails_of_pictures{
    my(@pic_files, $thumbnail_index_file, $i);
    @pic_files=@{$_[0]};
    $thumbnail_index_file="index_thumbnail_pictures.html";
    open(HTML_PIC_FILE, ">$thumbnail_index_file") || die "\n Can not open $thumbnail_index_file \n";
    print HTML_PIC_FILE "<HTML>";
    for($i=0; $i<@pic_files; $i++){
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Make thumbnails of pictures which are over 18k byte size
        #_____________________________________________________________
        if(-s $pic_files[$i] > 19000){
           print HTML_PIC_FILE "<a href=\"$pic_files[$i]\"><img SRC=\"$pic_files[$i]\" height=74 width=61></a>\n";
        }
    }
    print HTML_PIC_FILE "<\/html>";
    if(-s $thumbnail_index_file){
       print "\n $thumbnail_index_file has been made \n\n";
    }else{
       die "\n $thumbnail_index_file has not been made\n";
    }
}


#______________________________________________________________________________
# Title     : make_clickable_URL_dir_path
# Usage     :
# Function  :
# Example   :IN : /Bio/Proj/Bio/SAT
#            OUT: <A HREF="/Proj">/Proj</A><A HREF="/Proj/Bio">/Bio</A><A HREF="/Proj/Bio/SAT">/SAT</A>
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub make_clickable_URL_dir_path{
    my ($full_pwd_path, @dir_names, $full_pwd_path_URL, $one_level_above_dir_name,
        $A_HREF_quote, $quote_END, $A_END, $i);
    $full_pwd_path=${$_[0]};
    $A_HREF_quote = '<A HREF="';
    $quote_END = '">';
    $A_END = '</A>';
    @dir_names=split(/\//, $full_pwd_path);
    for($i=2; $i< @dir_names; $i++){
       $full_pwd_path_URL .="$A_HREF_quote\/$one_level_above_dir_name$dir_names[$i]$quote_END$dir_names[$i]$A_END\/";
       $one_level_above_dir_name.="$dir_names[$i]\/";
    }
    if(!$full_pwd_path_URL){ $full_pwd_path_URL="$ENV{DOCUMENT_ROOT}\/" }
    return(\$full_pwd_path_URL);
}


#______________________________________________________________________________
# Title     : make_stragments_from_HSSP_files
# Usage     :
# Function  :
# Example   :
# Keywords  : secondary_structure, sec_str, structural_fragment, HSSP
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_stragments_from_HSSP_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my(%HSSP_secture, @PDB_IDs, $stragment_size, $stragment_end, $stragment_start);
    $stragment_size=5;

    for($f=0; $f< @file; $f++){
       %HSSP_secture=%{&open_HSSP_file_for_secture($file[$f])};
       @PDB_IDs=keys %HSSP_secture;
       for($i=0; $i< @PDB_IDs; $i++){
          $PDB_ID=$PDB_IDs[$i];
          $sequence=$HSSP_secture{$PDB_ID}{'SEQUENCE'};
          $secture =$HSSP_secture{$PDB_ID}{'SECTURE'};
          $leng_seq=length($sequence);
          $leng_seq_stragment_size= $leng_seq - $stragment_size;
          for($j=0; $j<= $leng_seq_stragment_size ; $j++){
             $seqlet  = substr($sequence, $j, $stragment_size);
             $stragment=substr($secture , $j, $stragment_size);
             $stragment_start=$j + 1;
             $stragment_end  =$j+$stragment_size;
             print "\n>$PDB_ID\_$stragment_start\-$stragment_end\_$seqlet:$stragment";
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # This can cause a lot of memory consumption, so becareful over whole HSSP dir
             #_________________________________________________________________________________
             push(@{$stragment{$PDB_ID}{$seqlet}}, $stragment);
          }
       }
    }
    return(\%stragment);
}




#_______________________________________________________________________________
# Title     : make_seq_segments_fasta_files_from_MSP_files
# Usage     : @processed_files=&make_seq_segments_fasta_files_from_MSP_f+(\$input_dir);
#                     $input_dir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something,
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
#
#             ** Check out some subs derived from this:
#              concatenate_seq_files_in_subdir_to_db
#              opendir_and_go_in_and_make_pdb_db
# Options   :
#    $input_dir= by d=
#    $over_write=o by o
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.4
#---------------------------------------------------------------------------
sub make_seq_segments_fasta_files_from_MSP_files{
	  my ($each_file, $file, $new_fasta_name, %pdb_seq, @included_files,
			 $min_seq_leng_accepted, @read_files, $original_dir);

		if($_[0]=~/d=(\S+)/){ $original_dir=$1; }
		if($_[1]=~/o/){ $over_write='o'; }

		@read_files=@{&read_any_dir_simple(\$original_dir)};

		sub read_any_dir_simple { my($in_dir); $in_dir=${$_[0]} || $_[0]; opendir(DIR1,"$in_dir");
				my(@read_files) = readdir(DIR1);closedir(DIR1);	splice(@read_files, 0, 2);  return(\@read_files);
		}

		chomp($pwd=`pwd`);
		foreach $file(@read_files){
				$each_file="$original_dir/$file";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the File read is DIR => Recurse
				#________________________________________________________
				if( -d "$each_file" ){  ## If it is a directory.
						$num=@included_files=(@included_files,
						    &make_seq_segments_fasta_files_from_MSP_files("d=$each_file", $over_write) );   # RECURSION occurrs here!!
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the File read is FILE => PROCESS!
				#________________________________________________________
				}elsif (-f $each_file){     #<<------ This is where things match
						@dir=split(/\//, $each_file);
						$dir=$dir[($#dir-1)];  # $dir is the name of directory in where you are.
						###  put any program which does something here #################################

						if($each_file=~/\/d\S+\.mspa/){
						   #chdir($dir);
							 open(MSP, "$each_file") || die "\n Can not open $each_file";
							 while(<MSP>){
									if(/\d+\s+(d\S+)_(\d+)\-(\d+)\s+\d+\s+\d+\s+nr_(\S+)_(\d+)\-(\d+)_(\S+)_(\d+\.\d+\.\d+)_(\d+)\-(\d+)/){
										 $query=$1;
										 $query_start=$2;
										 $query_stop=$3;
										 $inter=$4;
										 $inter_start=$5;
										 $inter_stop=$6;
										 $match=$7;
										 $match_start=$9;
									   $match_stop=$10;
										 $query_with_range="$query\_$query_start\-$query_stop";
										 $inter_with_range="$inter\_$inter_start\-$inter_stop";
										 $match_with_range="$match\_$match_start\-$match_stop";

										 #print "\n Processing $query $inter $match with $each_file\n";

										 $query_spfa_file="$dir\/$query_with_range\.spfa";
										 $inter_spfa_file="$dir\/$inter_with_range\.spfa";
										 $match_spfa_file="$dir\/$match_with_range\.spfa";

										 open(QUERY_WITH_RANGE, ">$query_spfa_file") unless -s "$query_spfa_file";
										 open(INTER_WITH_RANGE, ">$inter_spfa_file") unless -s "$inter_spfa_file";
										 open(MATCH_WITH_RANGE, ">$match_spfa_file") unless -s "$match_spfa_file";

										 $query_seq_segment=substr($seq{$query}, $query_start-1, ($query_stop-$query_start+1));
										 $inter_seq_segment=substr($seq{$inter}, $inter_start-1, ($inter_stop-$inter_start+1));
										 $match_seq_segment=substr($seq{$match}, $match_start-1, ($match_stop-$match_start+1));
										 #print "\n\$match_seq_segment is  $match_seq_segment\n";
										 print QUERY_WITH_RANGE "\>$query_with_range\n$query_seq_segment\n" unless -s "$query_spfa_file";
										 print INTER_WITH_RANGE "\>$inter_with_range\n$inter_seq_segment\n" unless -s "$inter_spfa_file";
										 print MATCH_WITH_RANGE "\>$match_with_range\n$match_seq_segment\n" unless -s "$match_spfa_file";

										 close(QUERY_WITH_RANGE);
										 close(MATCH_WITH_RANGE);
										 close(INTER_WITH_RANGE);

										 $query_msso_file="$dir\/$query_with_range\_$match_with_range\.msso";
										 $inter_msso_file1="$dir\/$query_with_range\_$inter_with_range\.msso";
										 $inter_msso_file2="$dir\/$match_with_range\_$inter_with_range\.msso";

										 if( !(-s "$query_msso_file") or $over_write){
										    system("ssearch $query_spfa_file $match_spfa_file -m 10 > $query_msso_file");
										 }
										 if(!(-s "$inter_msso_file1") or $over_write){
										    system("ssearch $query_spfa_file $inter_spfa_file -m 10 > $inter_msso_file1");
										 }
										 if( !(-s "$inter_msso_file2") or $over_write){
										    system("ssearch $match_spfa_file $inter_spfa_file -m 10 > $inter_msso_file2");
										 }

									 }
							 }
							 close(MSP);
							 #chdir("..");
						}
				}elsif (-l $each_file){
						print "\n\n$each_file is linked, skipping. \n";
						next;
				}else{  print "\n# (i) ODD?? "; next;  }
		}
		return(@included_files);
}


#______________________________________________________________________________
# Title     : make_6_frame_dna_sequences
# Usage     : %six_dna_frame_seqs=%{&make_6_frame_dna_sequences(\%input_seq)};
# Function  : It makes 3 different types of frames for input seq
#               Then it reverses the input seq and makes another 3 frames!!
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_6_frame_dna_sequences{
		my(%six_frame_seqs, %original_input_seq, $orig_name,
			 $frame_fr1_name, $frame_fr2_name, $frame_fr3_name,
			 $frame_rf1_name, $frame_rf2_name, $frame_rf3_name,
			 $frame_fr1, $frame_fr2, $frame_fr3);
		%original_input_seq=%{$_[0]};
		($orig_name, $frame_fr1)=%original_input_seq;
		$frame_fr1_name="$orig_name\_fr1";
		$frame_fr2_name="$orig_name\_fr2";
		$frame_fr3_name="$orig_name\_fr3";
		$frame_rf1_name="$orig_name\_rf1";
		$frame_rf2_name="$orig_name\_rf2";
		$frame_rf3_name="$orig_name\_rf3";

		$frame_fr1     =$frame_fr1;
		$frame_fr2     =substr($frame_fr1, 1);
		$frame_fr3     =substr($frame_fr1, 2);

		$frame_rf1 =reverse($frame_fr1);
		$frame_rf2 =substr($frame_rf1, 1);
		$frame_rf3 =substr($frame_rf1, 2);

		%six_frame_seqs=($frame_fr1_name, $frame_fr1,
										 $frame_fr2_name, $frame_fr2,
										 $frame_fr3_name, $frame_fr3,
										 $frame_rf1_name, $frame_rf1,
										 $frame_rf2_name, $frame_rf2,
										 $frame_rf3_name, $frame_rf3 );

		return(\%six_frame_seqs);
}

#______________________________________________________________________________
# Title     : make_proportionally_random_sequence
# Usage     :
# Function  :
# Example   :
# Keywords  : make_random_protein_sequence
# Options   :
#   $return_FASTA_format_hash=f by f
#   $make_proportional_random_seq=p by p
#   $number_of_seq_to_be_generated= by n=
#   $length_of_target_rand_seq= by l=
#   $use_this_char_set= by c=
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_proportionally_random_sequence{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($length_of_target_rand_seq, $residue, @out_seq_ref, $number_of_seq_to_be_generated,
			 $make_proportional_random_seq, $length_of_target_rand_seq,
			 %frequency_table, $use_this_char_set, %amino_acid_occurrance_frequency_table,
			 $number_of_element_chars, @element_chars, @frequency, $rand_proportional_seq,
			 $regular_frequency_calculated, $return_FASTA_format_hash, $wrap_seq_lines,
			 @out_seq_ref);
		$number_of_seq_to_be_generated=1; # default
		$length_of_target_rand_seq=100; # random defalut
		$use_this_char_set='ACDEFGHIKLMNPQRSTVWY';
		$make_proportional_random_seq='p';

		if($vars{'t'}=~/HASH/){  %frequency_table=%{ $vars{'t'} } }
		if($vars{'n'}=~/(\d+)/){ $number_of_seq_to_be_generated=$1 }
		if($vars{'l'}=~/(\d+)/){ $length_of_target_rand_seq=$1 }
		if($vars{'c'}=~/(\S+)/){   $use_this_char_set=$1 }; # default is aa seq residues.
		if($char_opt=~/p/i){ $make_proportional_random_seq='p'; } ####### PROPORTIONAL random #####
		if($char_opt=~/w/i){ $wrap_seq_lines='w' }

				 srand(((time/$$)^($>*time))/(time/(time^$$)));
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# If p opt is set but No table given? use AA table
		#______________________________________________________
		if($make_proportional_random_seq and !(%frequency_table) and !$use_this_char_set ){
				@frequency = (.08713, .03347, .04687, .04953, .03977,
								 .08861, .03362, .03689, .08048, .08536,
								 .01475, .04043, .05068, .03826, .04090,
								 .06958, .05854, .06472, .01049, .02992);

				@element_chars=("A",   "C",     "D",    "E",    "F",
								 "G",     "H",     "I",    "K",    "L",
								 "M",     "N",     "P",    "Q",    "R",
								 "S",     "T",     "V",    "W",    "Y");
				%frequency_table = %amino_acid_occurrance_frequency_table=
							 qw(A .08713 C .03347 D .04687 E .04953 F .03977
									G .08861 H .03362 I .03689 K .08048 L .08536
									M .01475 N .04043 P .05068 Q .03826 R .04090
									S .06958 T .05854 V .06472 W .01049 Y .02992);
		}elsif($make_proportional_random_seq and %frequency_table and !$use_this_char_set){
				@frequency=values(%frequency_table);
				@element_chars=keys %frequency_table;
		}elsif($make_proportional_random_seq and $use_this_char_set){
				@element_chars=split(//, $use_this_char_set);
				$regular_frequency_calculated=1/@element_chars;
				print "\n# (i) \$use_this_char_set is given, making regular freq. table of $regular_frequency_calculated\n";
				for($i=0; $i< @element_chars; $i++){
						$frequency_table{$element_chars[$i]}=$regular_frequency_calculated;
				}
				@frequency=values(%frequency_table);
		}else{
				print "\n# (E) I can not handle this combination of options.\n";
				print "\n# (E) I need \$make_proportional_random_seq, \$use_this_char_set, \%frequency_table\n";
		}
		$number_of_element_chars=@element_chars;

		if($debug==1){  &__YELLOW__, printf("> rand%d random, from $0, len %d\n", $i+1, $num_opt[0]); &__RESET__; }

		for($j=0; $j< $number_of_seq_to_be_generated; $j++){
				 my ($a_random_number, $sum, $rand_proportional_seq);
				 for($i=1; $i <= $length_of_target_rand_seq; $i++){
						 $a_random_number=rand;
						 print "\n# (i) \$a_random_number is $a_random_number" if $debug ==1;
						 $sum =0;
						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						 # To get a proportionally chosen random number add $sum. If A occurs often, it will make $sum reach quick
						 #_______________________________________________________________________________
						 for($x=0; $x< $number_of_element_chars; $x++){
									$sum+=$frequency[$x];
									if( $sum >= $a_random_number){
											 #print "$element_chars[$x]";
											 if($return_FASTA_format_hash){
													 $fasta_format_hash{"rand${j}"}.=$element_chars[$x]; last;
											 }else{
													 $rand_proportional_seq .= $element_chars[$x];
													 last;
											 }
									}
						 }
						 if($a_random_number > $sum){ $rand_proportional_seq .= $element_chars[$#element_chars]; }
						 if( (!($i%60)) && ($char_opt=~/f/i) ){ $fasta_format_hash{"rand${j}"} .= "\n" }
						 elsif( !($i%60) and $wrap_seq_lines){ $rand_proportional_seq .= "\n" }
				 }
				 #print "\n";
				 print "\nProportionasl Rand SEQ\n : $rand_proportional_seq \n" if $debug ==1;
				 if($char_opt=~/f/i){ push(@fasta_out_ref, \%fasta_format_hash) }
				 else{ push(@out_seq_ref, \$rand_proportional_seq) }
		}
		if(@out_seq_ref==1){
				return($out_seq_ref[0]);
		}elsif(@out_seq_ref > 1){
				return(@out_seq_ref);
		}
}


#_____________________________________________________________________
# Title     : make_scrambled_seq_database
# Usage     : &make_reverse_seq_database(\@input_database_fasta_file);
# Function  :
# Example   :
# Warning   :
# Keywords  : scramble_seq_database, create_scrambled_seq_database
# Options   :
# Category  :
# Version   : 1.1
#-------------------------------------------------------------------
sub make_scrambled_seq_database{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my (%seqs, %scrambled_seqs, $fasta_file_for_DB,$base,$ext,$out_file_name );

		 for($i=0; $i< @file; $i++){
					$fasta_file_for_DB =$file[$i];
					$base=${&get_base_names($fasta_file_for_DB)};
					#~~~~~~~~~~~~~~~~~~~ To prevent growing of _sc_sc_sc... ~~~~~~~~~~~~`
					if($base=~/^(\S+)_sc[\_sc]*$/){ $base=$1 }

					$ext =${&get_file_extensions($file[$i])};
					if($ext=~/\S/){
								 $out_file_name="$base\_sc\.$ext";
								 $out_bak_file ="$base\_sc_bak\.$ext";
					}else{
						 $out_file_name="$base\_sc\.fasta";
								 $out_bak_file ="$base\_sc_bak\.fasta";
								 print "\n# There was no file ext for $base, attaching \"fa\" as default\n";
					}
					if(-s $out_file_name){
								 print "\n# $out_file_name already exists, moving it to $out_bak_file\n";
					}
					%seqs=%{&open_fasta_files(\$fasta_file_for_DB)};
					%reversed_seqs=%{&scramble_sequences(\%seqs)};
					&write_fasta(\%reversed_seqs, $out_file_name );
					if(-s $out_file_name){
								 print "\n# make_scrambled_seq_database: Supposedly wrote new file: $out_file_name\n";
					}else{
								 print "\n# make_scrambled_seq_database: Error in writing: $out_file_name\n";
					}
		 }
		 print "\n# make_scrambled_seq_database sub finished \n";
}


#__________________________________________________________________________
# Title     : make_2D_identity_matrix_array
# Usage     : @matrix=@{&make_2D_identity_matrix(\@seq1, \@seq2)};
# Function  : @matrix is like  $matrix[1][2]=1;
#             This assigns number 1 to array element
#             If one array is given, it makes self to self matrix.
#             When 2 are given, make matrix for the 2
# Example   :
# Keywords  : make_matrix
# Options   :
#    $skip_gap_char = g  for skipping gap char (any special char)
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#----------------------------------------------------------------------------
sub make_2D_identity_matrix_array{
		 my (@matrix, $skip_gap_char, $k, $l, @seq_1, @seq_0);
		 for($i=0; $i< @_; $i++){
				 if($_[$i]=~/g/){
							$skip_gap_char='g';
							splice (@_, $i, 1);
							$i--;
				 }elsif(ref($_[$i]) eq 'ARRAY'){
							push(@seqs, $_[$i]);
				 }
		 }
		 @seq_0=@{$seqs[0]};
		 @seq_1=@{$seqs[1]};
		 unless(@seq_1){ @seq_1=@seq_0; };
		 for($k=0; $k< @seq_0; $k++){
				for($l=0; $l< @seq_1; $l++){
							 if($seq_1[$l] =~/\W/ and $skip_gap_char){ next };
							 if($seq_0[$k] eq $seq_1[$l]){
											$matrix[$k][$l]=1;
											print "# X\[$k\] Y\[$l\] = 1 \n";
							 }
				}
		 }
		 return(\@matrix);
}


#__________________________________________________________________________
# Title     : make_2D_aa_residue_matrix_array
# Usage     : @matrix=@{&make_2D_aa_residue_matrix_array(\@seq)};
# Function  : @matrix is like  $matrix[1][2]='A'; when aa residue is identical
#             This assigns identical residue to array element
#             If one array is given, it makes self to self matrix.
#             When 2 are given, make matrix for the 2
# Example   :
# Keywords  : make_matrix
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub make_2D_aa_residue_matrix_array{
    my @seq=@{$_[0]};
    my @seq2=@{$_[1]};
    if(@_ == 1){ @seq2=@seq };

    my (@residue_matrix, $k, $l);
    for($k=0; $k< @seq; $k++){
         for($l=0; $l< @seq2; $l++){
                 if($seq[$k] eq $seq2[$l]){
                         $residue_matrix[$k][$l]="$seq[$k]";
                         print "# $seq[$k] = $l \n";
                 }
         }
    }
    return(\@residue_matrix);
}


#__________________________________________________________________________
# Title     : make_2D_identity_matrix
# Usage     : @matrix=@{&make_2D_identity_matrix(\$seq, [\$seq2] )};
# Function  : @matrix is like  $matrix[1][2]=1;
#             This assigns number 1 to array element
# Example   :
# Keywords  : make_matrix, make_identity_matrix
# Options   :
#        s  for show axis
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#----------------------------------------------------------------------------
sub make_2D_identity_matrix{

		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my (@matrix, @seq1, @seq2 );
		 if(@_ > 1){     @seq1=split(//, $string[0]);   @seq2=split(//, $string[1]);
		 }else{      @seq2=@seq1= split(//, $string[0]); }

		 if($char_opt=~/s/){
				@matrix = map {  $m = $_; "$m  ".join('', map {$_ eq $m or ' '} @seq1 )."\n";  } @seq2;
		 }else{
				@matrix = map {  $m = $_; join('', map {$_ eq $m or ' '} @seq1 )."\n";  } @seq2;
		 }
		 foreach (@matrix) {        print ;      }
		 return(\@matrix);
}

#________________________________________________________________________________
# Title     : amino_acid_homology_matrix
# Usage     : $yes_no=${&amino_acid_homology_matrix('E', 'D')};
# Function  :
# Example   :
# Keywords  : are_they_homologous, amino_acid_homology_table, compare_amino_acid_homology
#             single_residue_homology_matrix
# Options   :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub amino_acid_homology_matrix{
    my ($amino_acid1, $amino_acid2,  $hydrophobic_group, $neural_polar,
        $acidic_group, $basic_group, $proline, @groups, $i);
    $amino_acid1=${$_[0]} || $_[0];
    $amino_acid2=${$_[1]} || $_[1];
    if($amino_acid1=~/\W$/ or $amino_acid2=~/\W$/){ return(\0) }
    $hydrophobic_group='LIFV'; # A excluded by me
    $neural_polar ='STCNQ'; # M excluded by me
    $acidic_group='ED';
    $basic_group='KRH';
    $proline='P';
    @groups=($hydrophobic_group, $neural_polar, $acidic_group, $basic_group);
    for($i=0; $i< @groups; $i++){
         if($groups[$i] =~/$amino_acid1/ and $groups[$i] =~/$amino_acid2/){
             return(\1);
         }
    }
    return(\0);
}

#______________________________________________________________________________
# Title     : write_go_back_html_link
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub write_go_back_html_link{
		print "<hr><FONT COLOR=\"#DC143C\"><FONT SIZE=+2><< Go back to ";
		print "<A href=\"http://cyrah.med.harvard.edu/Biosub/bioperl_server.html\">BSS </A></font></font>";
		print "</html>\n";
}

#______________________________________________________________________________
# Title     : write_protein_structural_domain_interact_pair_file
# Usage     :
# Function  :
# Example   :
# Keywords  : write_PDIPF_file
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub write_protein_structural_domain_interact_pair_file{
    my(%contact_list, $out_file_name, @contact_list, @Interact_FLAG);
    %contact_list=%{$_[0]};
    $out_file_name=${$_[1]} || $_[1];
    unless($out_file_name){ $out_file_name='PROT_STR_DOM_interaction_pair_TEMP.psdip'; }
    $base=${&get_base_names($out_file_name)};
    $out_file_name_chain_chain  ="$base\_chain_chain\.psdip";
    $out_file_name_chain_domain ="$base\_chain_domain\.psdip";
    $out_file_name_domain_domain="$base\_domain_domain\.psdip";
    @Interact_FLAG=keys %contact_list; # these have PROTEIN_INTERACT and PROTEIN_NONINTERACT
    open(ALL_CONTACT_LIST, ">$out_file_name") || die;
    open(CHAIN_CHAIN_INTERACT, ">$out_file_name_chain_chain") || die;
    open(CHAIN_DOMAIN_INTERACT, ">$out_file_name_chain_domain") || die;
    open(DOMAIN_DOMAIN_INTERACT, ">$out_file_name_domain_domain") || die;
    for($j=0; $j< @Interact_FLAG; $j++){
       @contact_list=sort keys %{$contact_list{$Interact_FLAG[$j]}};
       for($i=0; $i < @contact_list; $i++){
          if($contact_list[$i]=~/(\S+_)\s+(\S+_)/){
             print CHAIN_CHAIN_INTERACT "$Interact_FLAG[$j]\t$contact_list{$Interact_FLAG[$j]}{$contact_list[$i]}\n";
          }elsif($contact_list[$i]=~/(\S+_)\s+(\S+)/ or $contact_list[$i]=~/(\S+)\s+(\S+_)/){
             print CHAIN_DOMAIN_INTERACT "$Interact_FLAG[$j]\t$contact_list{$Interact_FLAG[$j]}{$contact_list[$i]}\n";
          }elsif($contact_list[$i]=~/(\S+)\s+(\S+)/ or $contact_list[$i]=~/(\S+)\s+(\S+_)/){
             print DOMAIN_DOMAIN_INTERACT "$Interact_FLAG[$j]\t$contact_list{$Interact_FLAG[$j]}{$contact_list[$i]}\n";
          }
          print ALL_CONTACT_LIST "$Interact_FLAG[$j]\t$contact_list{$Interact_FLAG[$j]}{$contact_list[$i]}\n";
       }
    }
    close(ALL_CONTACT_LIST);
    close(CHAIN_CHAIN_INTERACT);
    close(CHAIN_DOMAIN_INTERACT);
    close(DOMAIN_DOMAIN_INTERACT);
    print "\n#(i) $out_file_name are made <-- write_protein_structural_domain_interact_pair_file\n";
    return(\$out_file_name);
}




#______________________________________________________________________________
# Title     : write_AT_GC_ratio_and_contents_ratio_files
# Usage     : $na_prv=&write_AT_GC_ratio_and_contents_ratio_files($base,
#                                             $na_prv, $sample_interval,
#                                                 $win_siz, $orig_seq);
# Function  : Calculates AT, GC ratios, AG, TC ratios and AT, GC content
#              ratios with scanning window over a long seq.
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.5
#------------------------------------------------------------------------------
sub write_AT_GC_ratio_and_contents_ratio_files{
    my($i, %tot_AT_ratio, %tot_GC_ratio, %tot_G_occu, %tot_C_occu,
       %tot_A_occu, %tot_T_occu, %AT_cont, %GC_cont,
       %tot_BASE_occu, $seq_count, %AT_cont_R, %GC_cont_R,
       %tot_AT_cont, %tot_GC_cont, $base, $na_prv, $smpl_intv,
       $win_siz, $orig_seq, $AT_R_atgcr_file, $GC_R_atgcr_F,
       $Ratio_deviation_F, $Final_R_F, $AT_cont_F, $AT_TC_R_dif_sum,
       $GC_cont_F, $seq_length, $seq_length_adjusted, $seq, $stra,
       %A_occu, %A_occu, %G_occu, %C_occu, %stra, @stra, $stra,
       $Accu_AT_GC_R_dif, $AC_R_atgcr_F, $GT_R_atgcr_F,
       %AC_cont, %GT_cont, $tot_AG_cont_R, $tot_TC_cont_R,
       %tot_AC_cont, %tot_GT_cont, %tot_AG_cont, %tot_TC_cont,
       %true_tot_AT_cont, %true_tot_GC_cont, %true_tot_GT_cont, %true_tot_AC_cont,
       %true_tot_AT_R, %true_tot_GC_R, %true_tot_GT_R, %true_tot_AC_R,
       %true_Tot_A_occu, %true_Tot_G_occu, %true_Tot_T_occu, %true_Tot_C_occu,
       $true_tot_AG_TC_R);
    $base        =$_[0];
    $na_prv      =$_[1];
    $smpl_intv   =$_[2];
    $win_siz     =$_[3];
    $orig_seq    =$_[4];
    %stra        =%{$_[5]};
    @stra        =keys %stra;

    for($s=0; $s< @stra; $s++){
       $stra=$stra[$s];
       $AT_R_atgcr_F ="$base\_$na_prv\_$stra\_AT_R_int_$smpl_intv\_$win_siz.atgcr";
       $GC_R_atgcr_F ="$base\_$na_prv\_$stra\_GC_R_int_$smpl_intv\_$win_siz.atgcr";
       $AC_R_atgcr_F ="$base\_$na_prv\_$stra\_AC_R_int_$smpl_intv\_$win_siz.atgcr";
       $GT_R_atgcr_F ="$base\_$na_prv\_$stra\_GT_R_int_$smpl_intv\_$win_siz.atgcr";
       $AG_R_atgcr_F ="$base\_$na_prv\_$stra\_AG_R_int_$smpl_intv\_$win_siz.atgcr";
       $TC_R_atgcr_F ="$base\_$na_prv\_$stra\_TC_R_int_$smpl_intv\_$win_siz.atgcr";
       $Final_R_F     ="$base\_$na_prv\_$stra\_SUMMARY_int_$smpl_intv\_$win_siz.atgcs";
       $AT_cont_F     ="$base\_$na_prv\_$stra\_AT_cont_int_$smpl_intv\_$win_siz.atcnt";
       $GC_cont_F     ="$base\_$na_prv\_$stra\_GC_cont_int_$smpl_intv\_$win_siz.gccnt";
       $AG_cont_F     ="$base\_$na_prv\_$stra\_AG_cont_int_$smpl_intv\_$win_siz.agcnt";
       $TC_cont_F     ="$base\_$na_prv\_$stra\_TC_cont_int_$smpl_intv\_$win_siz.tccnt";
       $AC_cont_F     ="$base\_$na_prv\_$stra\_AC_cont_int_$smpl_intv\_$win_siz.agcnt";
       $GT_cont_F     ="$base\_$na_prv\_$stra\_GT_cont_int_$smpl_intv\_$win_siz.tccnt";
       $Ratio_deviation_F="$base\_$na_prv\_$stra\_ATGC_R_devi_int_$smpl_intv\_$win_siz.ratdv";
       $AT_GC_R_dif_sum_F ="$base\_$na_prv\_$stra\_AT_GC_R_sum_int_$smpl_intv\_$win_siz.ratdv";
       open(AT_R,       ">$AT_R_atgcr_F") || die "\n can not open  $AT_R_atgcr_F\n\n";
       open(GC_R,       ">$GC_R_atgcr_F") || die "\n can not open  $GC_R_atgcr_F\n\n";
       open(AC_R,       ">$AC_R_atgcr_F") || die "\n can not open  $AC_R_atgcr_F\n\n";
       open(GT_R,       ">$GT_R_atgcr_F") || die "\n can not open  $GT_R_atgcr_F\n\n";
       open(AG_R,       ">$AG_R_atgcr_F") || die "\n can not open  $AC_R_atgcr_F\n\n";
       open(TC_R,       ">$TC_R_atgcr_F") || die "\n can not open  $GT_R_atgcr_F\n\n";
       open(AG_cont,    ">$AG_cont_F") || die "\n can not open  $AG_cont_F\n\n";
       open(TC_cont,    ">$TC_cont_F") || die "\n can not open  $TC_cont_F\n\n";
       open(AT_cont,    ">$AT_cont_F") || die "\n can not open  $AT_cont_F\n\n";
       open(GC_cont,    ">$GC_cont_F") || die "\n can not open  $GC_cont_F\n\n";
       open(AC_cont,    ">$AC_cont_F") || die "\n can not open  $AC_cont_F\n\n";
       open(GT_cont,    ">$GT_cont_F") || die "\n can not open  $GT_cont_F\n\n";
       open(RATIO_DEVI, ">$Ratio_deviation_F") || die "\n can not open $Ratio_deviation_F\n\n";
       open(AT_TC_R_dif_sum, ">$AT_GC_R_dif_sum_F") || die "\n can not open $AT_GC_R_dif_sum_F\n\n";
       open(FINAL_R,    ">$Final_R_F") || die "\n can not open $Final_R_F\n\n";

       $seq_length=length($orig_seq);
             if($seq_length < 20000000){
           $true_Tot_A_occu{$stra} =$orig_seq=~s/a/a/ig;
           $true_Tot_G_occu{$stra} =$orig_seq=~s/g/g/ig;
           $true_Tot_T_occu{$stra} =$orig_seq=~s/t/t/ig;
           $true_Tot_C_occu{$stra} =$orig_seq=~s/c/c/ig;
           $true_tot_AT_cont{$stra}  =$true_Tot_A_occu{$stra} + $true_Tot_T_occu{$stra};
           $true_tot_GC_cont{$stra}  =$true_Tot_G_occu{$stra} + $true_Tot_C_occu{$stra};
           $true_tot_AG_cont{$stra}  =$true_Tot_A_occu{$stra} + $true_Tot_G_occu{$stra};
           $true_tot_TC_cont{$stra}  =$true_Tot_T_occu{$stra} + $true_Tot_C_occu{$stra};
           $true_tot_AC_cont{$stra}  =$true_Tot_A_occu{$stra} + $true_Tot_C_occu{$stra};
           $true_tot_GT_cont{$stra}  =$true_Tot_G_occu{$stra} + $true_Tot_T_occu{$stra};
           $true_tot_AT_R{$stra}  =sprintf("%-.3f", $true_Tot_A_occu{$stra} / $true_Tot_T_occu{$stra});
           $true_tot_GC_R{$stra}  =sprintf("%-.3f", $true_Tot_G_occu{$stra} / $true_Tot_C_occu{$stra});
           $true_tot_AG_R{$stra}  =sprintf("%-.3f", $true_Tot_A_occu{$stra} / $true_Tot_G_occu{$stra});
           $true_tot_TC_R{$stra}  =sprintf("%-.3f", $true_Tot_T_occu{$stra} / $true_Tot_C_occu{$stra});
           $true_tot_AC_R{$stra}  =sprintf("%-.3f", $true_Tot_A_occu{$stra} / $true_Tot_C_occu{$stra});
           $true_tot_GT_R{$stra}  =sprintf("%-.3f", $true_Tot_G_occu{$stra} / $true_Tot_T_occu{$stra});
           $true_tot_AT_cont_R=sprintf("%-.3f", $true_tot_AT_cont{$stra}/$seq_length);
           $true_tot_GC_cont_R=sprintf("%-.3f", $true_tot_GC_cont{$stra}/$seq_length);
           $true_tot_AC_cont_R=sprintf("%-.3f", $true_tot_AC_cont{$stra}/$seq_length);
           $true_tot_GT_cont_R=sprintf("%-.3f", $true_tot_GT_cont{$stra}/$seq_length);
           $true_tot_AG_cont_R=sprintf("%-.3f", $true_tot_AG_cont{$stra}/$seq_length);
           $true_tot_TC_cont_R=sprintf("%-.3f", $true_tot_TC_cont{$stra}/$seq_length);
           $true_tot_AG_TC_R  =sprintf("%-.3f", $true_tot_AG_cont{$stra}/$true_tot_TC_cont{$stra});
           print "# True contnt: A: $true_Tot_A_occu{$stra} T: $true_Tot_T_occu{$stra} G: $true_Tot_G_occu{$stra} C: $true_Tot_C_occu{$stra}  Total: $seq_length AG/TC:$true_tot_AG_TC_R\n";
       }
       %true_Tot_A_occu=%true_Tot_G_occu=%true_Tot_T_occu=%true_Tot_C_occu=();

       $half_win =$win_siz/2;
       $seq_length_adjusted=$seq_length - $half_win;
       for($i=0; $i <= $seq_length_adjusted; $i+=$smpl_intv){ ## $i+=2 is a 2 base stepping to save time
           $seq=substr($orig_seq, $i, $win_siz);
           $seq_count=($i+$half_win);

           $A_occu{$stra} =$seq=~s/a/a/ig;
           $G_occu{$stra} =$seq=~s/g/g/ig;
           $T_occu{$stra} =$seq=~s/t/t/ig;
           $C_occu{$stra} =$seq=~s/c/c/ig;

           if($T_occu{$stra} and $C_occu{$stra}){
               $AT_R{$stra}=sprintf("%-.3f", $A_occu{$stra}/$T_occu{$stra});
               $GC_R{$stra}=sprintf("%-.3f", $G_occu{$stra}/$C_occu{$stra});
               $AC_R{$stra}=sprintf("%-.3f", $A_occu{$stra}/$C_occu{$stra});
               $GT_R{$stra}=sprintf("%-.3f", $G_occu{$stra}/$T_occu{$stra});
               $AG_R{$stra}=sprintf("%-.3f", $A_occu{$stra}/$G_occu{$stra});
               $TC_R{$stra}=sprintf("%-.3f", $T_occu{$stra}/$C_occu{$stra});
           }
           $AT_cont{$stra}  =$A_occu{$stra} + $T_occu{$stra};
           $GC_cont{$stra}  =$G_occu{$stra} + $C_occu{$stra};
           $AG_cont{$stra}  =$A_occu{$stra} + $G_occu{$stra};
           $TC_cont{$stra}  =$T_occu{$stra} + $C_occu{$stra};
           $AC_cont{$stra}  =$A_occu{$stra} + $C_occu{$stra};
           $GT_cont{$stra}  =$G_occu{$stra} + $T_occu{$stra};
           $sum_ATGC{$stra} =$AT_cont{$stra}+ $GC_cont{$stra};

           $AT_cont_R{$stra}=sprintf("%-.3f", $AT_cont{$stra} / $sum_ATGC{$stra});
           $GC_cont_R{$stra}=sprintf("%-.3f", $GC_cont{$stra} / $sum_ATGC{$stra});
           $AG_cont_R{$stra}=sprintf("%-.3f", $AG_cont{$stra} / $sum_ATGC{$stra});
           $TC_cont_R{$stra}=sprintf("%-.3f", $TC_cont{$stra} / $sum_ATGC{$stra});
           $AC_cont_R{$stra}=sprintf("%-.3f", $AC_cont{$stra} / $sum_ATGC{$stra});
           $GT_cont_R{$stra}=sprintf("%-.3f", $GT_cont{$stra} / $sum_ATGC{$stra});

           $tot_AT_cont{$stra}+=$AT_cont{$stra};
           $tot_GC_cont{$stra}+=$GC_cont{$stra};
           $tot_AG_cont{$stra}+=$AG_cont{$stra};
           $tot_TC_cont{$stra}+=$TC_cont{$stra};
           $tot_AC_cont{$stra}+=$AC_cont{$stra};
           $tot_GT_cont{$stra}+=$GT_cont{$stra};

           $tot_A_occu{$stra}    += $A_occu{$stra};
           $tot_G_occu{$stra}    += $G_occu{$stra};
           $tot_T_occu{$stra}    += $T_occu{$stra};
           $tot_C_occu{$stra}    += $C_occu{$stra};
           $tot_BASE_occu{$stra}  =$tot_A_occu{$stra}+$tot_G_occu{$stra}+
                                   $tot_T_occu{$stra}+$tot_C_occu{$stra};

           if($tot_T_occu{$stra}  and $tot_C_occu{$stra} ){
               $tot_AT_R{$stra} =sprintf("%-.3f",$tot_A_occu{$stra} /$tot_T_occu{$stra});
               $tot_GC_R{$stra} =sprintf("%-.3f",$tot_G_occu{$stra} /$tot_C_occu{$stra});
               $tot_AC_R{$stra} =sprintf("%-.3f",$tot_A_occu{$stra} /$tot_C_occu{$stra});
               $tot_GT_R{$stra} =sprintf("%-.3f",$tot_G_occu{$stra} /$tot_T_occu{$stra});
               $tot_AG_R{$stra} =sprintf("%-.3f",$tot_A_occu{$stra} /$tot_G_occu{$stra});
               $tot_TC_R{$stra} =sprintf("%-.3f",$tot_T_occu{$stra} /$tot_C_occu{$stra});
           }

           $R_deviation   =(abs(1-$AT_R{$stra}) + abs(1-$GC_R{$stra}))/2;
           $Accu_AT_GC_R_dif= $AT_R{$stra}-1 + $GC_R{$stra}-1;
           $AT_TC_R_dif_sum   =sprintf("%-.3f", $Accu_AT_GC_R_dif);
           $A_occu{$stra} =$G_occu{$stra} =$T_occu{$stra} =$C_occu{$stra} =0;

           print AT_R "\n$seq_count $AT_R{$stra}";
           print GC_R "\n$seq_count $GC_R{$stra}";
           print AC_R "\n$seq_count $AC_R{$stra}";
           print GT_R "\n$seq_count $GT_R{$stra}";
           print AG_R "\n$seq_count $AG_R{$stra}";
           print TC_R "\n$seq_count $TC_R{$stra}";
           print AT_cont "\n$seq_count $AT_cont_R{$stra}";
           print GC_cont "\n$seq_count $GC_cont_R{$stra}";
           print AG_cont "\n$seq_count $AG_cont_R{$stra}";
           print TC_cont "\n$seq_count $TC_cont_R{$stra}";
           print AC_cont "\n$seq_count $AC_cont_R{$stra}";
           print GT_cont "\n$seq_count $GT_cont_R{$stra}";
           print RATIO_DEVI "$seq_count $R_deviation\n";
           print AT_TC_R_dif_sum "$seq_count $AT_TC_R_dif_sum\n";
        }
        $orig_seq=''; ## <--------------- !!!
        print "\n>$na_prv ";
        $tot_AT_cont_R=sprintf("%-.3f", $tot_AT_cont{$stra}/$tot_BASE_occu{$stra});
        $tot_GC_cont_R=sprintf("%-.3f", $tot_GC_cont{$stra}/$tot_BASE_occu{$stra});
        $tot_AC_cont_R=sprintf("%-.3f", $tot_AC_cont{$stra}/$tot_BASE_occu{$stra});
        $tot_GT_cont_R=sprintf("%-.3f", $tot_GT_cont{$stra}/$tot_BASE_occu{$stra});
        $tot_AG_cont_R=sprintf("%-.3f", $tot_AG_cont{$stra}/$tot_BASE_occu{$stra});
        $tot_TC_cont_R=sprintf("%-.3f", $tot_TC_cont{$stra}/$tot_BASE_occu{$stra});
        print "\n  AT rate: $tot_AT_R{$stra} $tot_A_occu{$stra}/$tot_T_occu{$stra} tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_AT_R{$stra}";
        print "\n  GC rate: $tot_GC_R{$stra} $tot_G_occu{$stra}/$tot_C_occu{$stra} tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_GC_R{$stra}";
        print "\n  AC rate: $tot_AC_R{$stra} $tot_A_occu{$stra}/$tot_C_occu{$stra} tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_AC_R{$stra}";
        print "\n  GT rate: $tot_GT_R{$stra} $tot_G_occu{$stra}/$tot_T_occu{$stra} tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_GT_R{$stra}";
        print "\n  AG rate: $tot_AG_R{$stra} $tot_A_occu{$stra}/$tot_G_occu{$stra} tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_AG_R{$stra}";
        print "\n  TC rate: $tot_TC_R{$stra} $tot_T_occu{$stra}/$tot_C_occu{$stra} tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_TC_R{$stra}";
        print "\n  AT cont: $tot_AT_cont_R tot $seq_count $tot_BASE_occu{$stra}";
        print "\n  GC cont: $tot_GC_cont_R tot $seq_count $tot_BASE_occu{$stra}";
        print "\n  AC cont: $tot_AC_cont_R tot $seq_count $tot_BASE_occu{$stra}";
        print "\n  GT cont: $tot_GT_cont_R tot $seq_count $tot_BASE_occu{$stra}";
        print "\n  AG(purine) cont: $tot_AG_cont_R tot $tot_BASE_occu{$stra}, $true_tot_AT_cont{$stra}/$true_tot_GC_cont{$stra}";
        print "\n  TC(pyrim)  cont: $tot_TC_cont_R tot $seq_count $tot_BASE_occu{$stra}";
        print "\n  Accu. AT GC ratio diff sum: $Accu_AT_GC_R_dif , True: $true_tot_AT_cont{$stra}:$true_tot_GC_cont{$stra}";
        print FINAL_R "# True cont: A: $true_Tot_A_occu{$stra} T: $true_Tot_T_occu{$stra} G: $true_Tot_G_occu{$stra} C: $true_Tot_C_occu{$stra}  Total: $seq_length AG/TC:$true_tot_AG_TC_R\n";
        print FINAL_R "\n Tot AT R: $tot_AT_R{$stra} $tot_A_occu{$stra}/$tot_T_occu{$stra} tot $seq_count true: $true_tot_AT_R{$stra}";
        print FINAL_R "\n Tot GC R: $tot_GC_R{$stra} $tot_G_occu{$stra}/$tot_C_occu{$stra} tot $seq_count true: $true_tot_GC_R{$stra}";
        print FINAL_R "\n Tot AC R: $tot_AC_R{$stra} $tot_A_occu{$stra}/$tot_C_occu{$stra} tot $seq_count true: $true_tot_AC_R{$stra}";
        print FINAL_R "\n Tot GT R: $tot_GT_R{$stra} $tot_G_occu{$stra}/$tot_T_occu{$stra} tot $seq_count true: $true_tot_GT_R{$stra}";
        print FINAL_R "\n Tot AG R: $tot_AG_R{$stra} $tot_A_occu{$stra}/$tot_G_occu{$stra} tot $seq_count true: $true_tot_AG_R{$stra}";
        print FINAL_R "\n Tot TC R: $tot_TC_R{$stra} $tot_T_occu{$stra}/$tot_C_occu{$stra} tot $seq_count true: $true_tot_TC_R{$stra}";
        print FINAL_R "\n Tot AT cont: $tot_AT_cont_R tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_AT_cont_R{$stra}";
        print FINAL_R "\n Tot GC cont: $tot_GC_cont_R tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_GC_cont_R{$stra}";
        print FINAL_R "\n Tot AC cont: $tot_AC_cont_R tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_AC_cont_R{$stra}";
        print FINAL_R "\n Tot GT cont: $tot_GT_cont_R tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_GT_cont_R{$stra}";
        print FINAL_R "\n Tot AG cont: $tot_AG_cont_R tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_AG_cont_R{$stra}";
        print FINAL_R "\n Tot TC cont: $tot_TC_cont_R tot $seq_count $tot_BASE_occu{$stra} true: $true_tot_TC_cont_R{$stra}";
        print FINAL_R "\n  AG(purine) cont: $tot_AG_cont_R tot $tot_BASE_occu{$stra}, $true_tot_AT_cont{$stra}/$true_tot_GC_cont{$stra}";
        print FINAL_R "\n  TC(pyrim)  cont: $tot_TC_cont_R tot $seq_count $tot_BASE_occu{$stra}, AG/TC:$true_tot_AG_TC_R";
        print FINAL_R "\n  Accu. AT GC ratio diff sum: $Accu_AT_GC_R_dif , True: $true_tot_AT_cont{$stra}:$true_tot_GC_cont{$stra}";
        close(AT_R);
        close(GC_R);
        close(AC_R);
        close(GT_R);
        close(AG_R);
        close(TC_R);
        close(AG_cont);
        close(TC_cont);
        close(AT_cont);
        close(GC_cont);
        close(AC_cont);
        close(GT_cont);
        close(FINAL_R);
        close(AT_TC_R_dif_sum);
        close(RATIO_DEVI);
     }
     print "\n\n# Files produced: \n$AT_R_atgcr_F\n$GC_R_atgcr_F\n$Ratio_deviation_F\n$Final_R_F\n$AT_cont_F\n$GC_cont_F
           $AT_GC_R_dif_sum_F\n$AC_R_atgcr_F\n$GT_R_atgcr_F\n\n";
     $na_prv=$name;
     return($na_prv);
}




#______________________________________________________________________________
# Title     : write_SDDIF_file
# Usage     :
# Function  :
# Example   :
# Keywords  : write_sddif_file
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub write_SDDIF_file{
    my($i, %DIFF_classification_domains, $SDDIF_file, @diff_types,
       $pdbd1, $pdbd2, $t1, $t2, $t3, %pdbd1_fasta, %pdbd2_fasta, %pdbd1_fas_swapped,
       %pdbd2_fas_swapped, $changed_pdbd1_fasta, $changed_pdbd2_fasta,
       $missing_in_pdbd1_fasta, $missing_in_pdbd2_fasta,@pdbd1_unchanged_seqs,
       %missing_in_pdbd1_fas, %missing_in_pdbd2_fas, @pdbd1_fasta_seqs,
       @pdbd2_fasta_seqs, %pdbd1_unchanged, %pdbd2_unchanged, $unchaged_pdbd1_fasta);
    %DIFF_classification_domains=%{$_[0]};
    $pdbd1=${$_[1]} || $_[1];
    $pdbd2=${$_[2]} || $_[2];
    $file_base1=${&get_base_names($pdbd1)};
    $file_base2=${&get_base_names($pdbd2)};
    $SDDIF_file="$file_base1\_$file_base2\.sddif"; ## SDDIF : Structural Domain DIfference File (like SCOP domain compa.)
    $changed_pdbd1_fasta="$file_base1\_changed_to_$file_base2\.mpfa";
    $changed_pdbd2_fasta="$file_base2\_changed_to_$file_base1\.mpfa";
    $missing_in_pdbd1_fasta="$file_base1\_missing_in_$file_base2\.mpfa";
    $missing_in_pdbd2_fasta="$file_base2\_missing_in_$file_base1\.mpfa";
    $unchaged_pdbd1_fasta="$file_base1\_unchanged_with_$file_base2\.mpfa";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # %pdbd1_fasta has %pdbd1_fasta{$pdbdomain}{'SEQUENCE'}
    # %pdbd1_fasta has %pdbd1_fasta{$pdbdomain}{'DESCRIPTION'}
    #__________________________________________________________
    %pdbd1_fasta=%{&open_fasta_files($pdbd1, 'd')}; ## getting descriptive seq entry by 'd' option
    %pdbd2_fasta=%{&open_fasta_files($pdbd2, 'd')};
    @pdbd1_fasta_seqs=keys %pdbd1_fasta;
    @pdbd2_fasta_seqs=keys %pdbd2_fasta;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # %DIFF_classification_domains{'DIF_CLASSIFICATION'}{$pdbd1_domain}
    # $DIFF_classification_domains{'MISSING_IN_PDBD1'}{$pdbd2_domain}
    # $DIFF_classification_domains{'MISSING_IN_PDBD2'}{$pdbd1_domain}
    #______________________________________________________________________
    open(SDDIF_file, ">$SDDIF_file") || die "Cannt open $SDDIF_file\n\n";
    @diff_types=sort keys %DIFF_classification_domains;
    $t1=@domains_with_diff_classification=keys %{$DIFF_classification_domains{$diff_types[0]}};
    $t2=@domains_missing_in_PDBD1=keys %{$DIFF_classification_domains{$diff_types[1]}};
    $t3=@domains_missing_in_PDBD2=keys %{$DIFF_classification_domains{$diff_types[2]}};

    $num_of_pdbd1_unchanged=@pdbd1_unchanged_seqs=@{&subtract_array(\@pdbd1_fasta_seqs, \@domains_with_diff_classification)};
    $num_of_pdbd2_unchanged=@pdbd2_unchanged_seqs=@{&subtract_array(\@pdbd2_fasta_seqs, \@domains_with_diff_classification)};

    print SDDIF_file "# Diff classification domains: $t1\n";
    print SDDIF_file "# Missing domains in 1st file: $t2\n";
    print SDDIF_file "# Missing domains in 2st file: $t3\n";
    print SDDIF_file "# Unchanged in $pdbd1 : $num_of_pdbd1_unchanged\n";

    for($i=0; $i<@pdbd1_unchanged_seqs; $i++){
       $pdbd1_unchanged{$pdbd1_unchanged_seqs[$i]}{'DESCRIPTION'}=$pdbd1_fasta{$pdbd1_unchanged_seqs[$i]}{'DESCRIPTION'};
       $pdbd1_unchanged{$pdbd1_unchanged_seqs[$i]}{'SEQUENCE'}=$pdbd1_fasta{$pdbd1_unchanged_seqs[$i]}{'SEQUENCE'};
    }
    for($i=0; $i<@pdbd2_unchanged_seqs; $i++){
       $pdbd2_unchanged{$pdbd2_unchanged_seqs[$i]}{'DESCRIPTION'}=$pdbd2_fasta{$pdbd1_unchanged_seqs[$i]}{'DESCRIPTION'};
       $pdbd2_unchanged{$pdbd2_unchanged_seqs[$i]}{'SEQUENCE'}=$pdbd2_fasta{$pdbd1_unchanged_seqs[$i]}{'SEQUENCE'};
    }
    for($i=0;  $i<@domains_with_diff_classification; $i++){
       print SDDIF_file ">$domains_with_diff_classification[$i]: $DIFF_classification_domains{$diff_types[0]}{$domains_with_diff_classification[$i]}\n";
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Swapping description of the seq entries
       #__________________________________________
       $pdbd1_fas_swapped{$domains_with_diff_classification[$i]}{'DESCRIPTION'}=$pdbd2_fasta{$domains_with_diff_classification[$i]}{'DESCRIPTION'};
       $pdbd1_fas_swapped{$domains_with_diff_classification[$i]}{'SEQUENCE'}=$pdbd2_fasta{$domains_with_diff_classification[$i]}{'SEQUENCE'};
       $pdbd2_fas_swapped{$domains_with_diff_classification[$i]}{'DESCRIPTION'}=$pdbd1_fasta{$domains_with_diff_classification[$i]}{'DESCRIPTION'};
       $pdbd2_fas_swapped{$domains_with_diff_classification[$i]}{'SEQUENCE'}=$pdbd1_fasta{$domains_with_diff_classification[$i]}{'SEQUENCE'};
    }
    for($i=0;  $i<@domains_missing_in_PDBD1 ; $i++){
       print SDDIF_file ">$domains_missing_in_PDBD1[$i]: $DIFF_classification_domains{$diff_types[1]}{$domains_missing_in_PDBD1[$i]} Missing_in_1st_file\n";
       $missing_in_pdbd1_fas{$domains_with_diff_classification[$i]}{'SEQUENCE'}=$pdbd2_fasta{$domains_with_diff_classification[$i]}{'SEQUENCE'};
       $missing_in_pdbd1_fas{$domains_with_diff_classification[$i]}{'DESCRIPTION'}=$pdbd2_fasta{$domains_with_diff_classification[$i]}{'DESCRIPTION'};
    }
    for($i=0;  $i<@domains_missing_in_PDBD2 ; $i++){
       $missing_in_pdbd2_fas{$domains_with_diff_classification[$i]}{'SEQUENCE'}=$pdbd1_fasta{$domains_with_diff_classification[$i]}{'SEQUENCE'};
       $missing_in_pdbd2_fas{$domains_with_diff_classification[$i]}{'DESCRIPTION'}=$pdbd1_fasta{$domains_with_diff_classification[$i]}{'DESCRIPTION'};
       print SDDIF_file ">$domains_missing_in_PDBD2[$i]: $DIFF_classification_domains{$diff_types[2]}{$domains_missing_in_PDBD2[$i]} Missing_in_2nd_file\n";
    }
    unless(-f $SDDIF_file){ die "\n $SDDIF_file does not exist, write_SDDIF_file failed \n"; }
    print SDDIF_file "# Diff classification domains: $t1\n";
    print SDDIF_file "# Missing domains in 1st file: $t2\n";
    print SDDIF_file "# Missing domains in 2st file: $t3\n";
    print SDDIF_file "# Unchanged $pdbd1 : $num_of_pdbd1_unchanged\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # NOTE!! I do not remove old entries in the first PDBD file
    #___________________________________________________________
    &write_fasta(\%pdbd1_fas_swapped, \$changed_pdbd1_fasta);
    &write_fasta(\%missing_in_pdbd1_fas, \$missing_in_pdbd1_fasta);
    &write_fasta(\%pdbd1_unchanged, \$unchaged_pdbd1_fasta);

    return(\$SDDIF_file);
}



#______________________________________________________________________________
# Title     : write_D3FA_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub write_D3FA_file{
    my(@regions, $DDID_file, $MPFA_file, %MPFA_hash, $base_DDID, $missing_PDB_id);
    $DDID_file=$_[0]; # DDD_ids.ddid
    $MPFA_file=$_[1]; # pdb100d_1_41.mpfa

    %MPFA_hash=%{&open_fasta_files($MPFA_file)};

    open(DDID_FILE, "$DDID_file") || die "\n Can not open DDID file $DDID_file\n";
    while(<DDID_FILE>){
       if(/^((\S\S\S\S\S)\d+)\s+\S+\s+\S+\s+\S+\s+\d+\s+([\d\- ]+)\s+D.C./){
          my($region);
          $DDD_id=$1;
          $PDB_id=$2;
          $DDD_region=$3;
          @regions=split(/\s+/, $DDD_region);
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # If regions has only one regin like 1-333, split would have failed
          #____________________________________________________________________
          unless(@regions){
              @regions=($DDD_region);
          }
          if($MPFA_hash{$PDB_id}){
              #print "\n Fetching regional sequence for $PDB_id";
              $region .=${&fetch_seqlet_from_sequence($MPFA_hash{$PDB_id}, \@regions)};
              if($region=~/\S/){
                 $D3FA_hash{$DDD_id}=$region;
              }else{
                 print "\n Region is empty, error? $region @regions $DDD_id \"$MPFA_hash{$PDB_id}\" $PDB_id\n";
                 die;
              }
          }else{
              $missing_PDB_id ++;
              print "\n <$missing_PDB_id> $PDB_id does not exist in $MPFA_file, skipping";
          }
       }
    }
    close(DDID_FILE);
    $base_DDID=${&get_base_names($DDID_file)};
    $out_D3FA_file="$base_DDID\_domain.d3fa";
    &write_fasta(\%D3FA_hash, \$out_D3FA_file);
    print "\n There were $missing_PDB_id \$missing_PDB_id in $MPFA_file\n";
    return(\%D3FA_hash);
}


#______________________________________________________________________________
# Title     : write_MRC_search_result_file
# Usage     :
# Function  :
# Example   :
# Keywords  : show_seqlet_alignment, write_mrc_search_file, write_MRC
# Options   :
#   $NO_screen_print=Q         by Q
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.3
#------------------------------------------------------------------------------
sub write_MRC_search_result_file{
    my($herta_input_file, $sequence_1_file, $sequence_2_file,
       @seq1_aligned, @seq2_aligned, @scores, %align_position_seq1_seq2_rv,
       %align_position_seq1_seq2, $herta_input_file_rv, %sequence_1, %sequence_2,
       %sequence_rv, %sequence, @positions1_rv, @positions2_rv,
       @positions1, @positions2, @seq1_start, @seq2_start, @residues1, @residues2,
       @seq1_start_final, @seq2_start_final, @scores_gap, @seq2_start_final_rv,
       @seq1_start_final_rv, $query_seq, $DB_seq, $seq1_len, $seq2_len,
       %MRC_search_alignment, %MRC_search_alignment_rv, $each_MRCS_file,
       $HERTA_open_gap_penalty, $HERTA_extend_gap_penalty, $HERTA_algorithm_type,
       $NO_screen_print, $MRCS_FILE_HANDLE, $write_EACH_MRCS_pair_file,
       $Mutual_Seq_Id_aligned, $ALIGNMENT_LENG);

    $MRCS_FILE_HANDLE="MRCS_FILE_HANDLE";
    $herta_input_file=${$_[0]} || $_[0];
    $herta_input_file_rv=${&attach_suffix_in_file_name($herta_input_file, 'rv', 'e')};

    $sequence_1_file          =${$_[1]} || $_[1];
    $sequence_2_file          =${$_[2]} || $_[2];
    $query_seq                =${$_[3]} || $_[3];
    $DB_seq                   =${$_[4]} || $_[4];
    $HERTA_open_gap_penalty   =${$_[5]} || $_[5];
    $HERTA_extend_gap_penalty =${$_[6]} || $_[6];
    $HERTA_algorithm_type     =${$_[7]} || $_[7];
    $NO_screen_print          =${$_[8]} || $_[8];
    $MRCS_FILE_HANDLE         =${$_[9]} || $_[9];
    $write_EACH_MRCS_pair_file=${$_[10]} || $_[10];

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # This will not be used normally
    #___________________________________________________
    $each_MRCS_file ="$query_seq\_$DB_seq\_OG$HERTA_open_gap_penalty\_EG$HERTA_extend_gap_penalty\_$HERTA_algorithm_type\.mrcs";

    %sequence_1=%{&open_fasta_files(\$sequence_1_file)};
    %sequence_2=%{&open_fasta_files(\$sequence_2_file)};
    @keys1=keys %sequence_1;
    @keys2=keys %sequence_2;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # In herta, there is no seq name, so I note them as 1 and 2
    #______________________________________________________________
    $sequence{1}=$sequence_1{$keys1[0]}; # the first key is for seq (only 1 key in fact)
    $sequence{2}=$sequence_2{$keys2[0]};
    $sequence_rv{1}=$sequence_1{$keys1[0]}; #!!!!!!!!!!!!!!!! <<<<<<<<<<<<
    $sequence_rv{2}=reverse $sequence_2{$keys2[0]};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  $herta_align_hash{$seq_name}{$seq_pos}=$align_score;
    #_______________________________________________________________
    %align_position_seq1_seq2   =%{&open_herta_files(\$herta_input_file)};
    %align_position_seq1_seq2_rv=%{&open_herta_files(\$herta_input_file_rv)};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # temporarily assign 1, 2 as herta can not distinguish them
    #______________________________________________________________
    ($seq_name1, $seq_name2)=(1,2);

    @residues1   =split(//, $sequence{$seq_name1});
    @residues2   =split(//, $sequence{$seq_name2});
    @residues1_rv=split(//, $sequence_rv{$seq_name1});
    @residues2_rv=split(//, $sequence_rv{$seq_name2});
    @positions1   =sort {$a <=> $b} keys %{$align_position_seq1_seq2{$seq_name1}};
    @positions2   =sort {$a <=> $b} keys %{$align_position_seq1_seq2{$seq_name2}};
    @positions1_rv=sort {$a <=> $b} keys %{$align_position_seq1_seq2_rv{$seq_name1}};
    @positions2_rv=sort {$a <=> $b} keys %{$align_position_seq1_seq2_rv{$seq_name2}};

    $seq1_len=@residues1;
    $seq2_len=@residues2;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # MRC hash has the following structure
    # %MRC_search_alignment=("$query_seq", \@seq1_aligned,
    #                           "$DB_seq", \@seq2_aligned,
    #                   'RAW_ALIGN_SCORE', \@scores,
    #                   'SUM_HERTA_SCORE', \@herta_align_score);
    #____________________________________________________________________

    %MRC_search_alignment=%{&align_herta_inputs_with_adjustments(\@residues1, \@residues2,
                                                              \@positions1, \@positions2,
                                                              \%align_position_seq1_seq2,
                                                              $query_seq,
                                                              $DB_seq,
                                                              $NO_screen_print)};

    %MRC_search_alignment_rv=%{&align_herta_inputs_with_adjustments(\@residues1_rv, \@residues2_rv,
                                                              \@positions1_rv, \@positions2_rv,
                                                              \%align_position_seq1_seq2_rv,
                                                              $query_seq,
                                                              "$DB_seq\_rv",
                                                              $NO_screen_print)};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # openning and making FILE_HANDLE to pass to print_seq_in_block sub
    #____________________________________________________________________
    if($write_EACH_MRCS_pair_file eq 'E'){
        open($MRCS_FILE_HANDLE, ">$each_MRCS_file") || die "\n Cannt open $each_MRCS_file in write_MRC_search_result_file\n\n";
    }else{
        unless($MRCS_FILE_HANDLE){ die "\n $MRCS_FILE_HANDLE is not passed from do_MRC_search \n"; }
    }

    print $MRCS_FILE_HANDLE "\n#<<START>>$query_seq $DB_seq OpenGap:$HERTA_open_gap_penalty, ExtGap:$HERTA_extend_gap_penalty, Algo:$HERTA_algorithm_type\n";
    &print_seq_in_block(\%MRC_search_alignment,     100, "F=$MRCS_FILE_HANDLE",
                        "E=SUM_HERTA_SCORE SEQ_IDENTITY ALIGNMENT_LENG",
                        $NO_screen_print);
    &print_seq_in_block(\%MRC_search_alignment_rv,  100, "F=$MRCS_FILE_HANDLE",
                        "E=SUM_HERTA_SCORE SEQ_IDENTITY ALIGNMENT_LENG",
                        $NO_screen_print);

    $herta_align_score    =   ${$MRC_search_alignment{'SUM_HERTA_SCORE'}}[0];
    $herta_align_score_rv =${$MRC_search_alignment_rv{'SUM_HERTA_SCORE'}}[0];
    $Mutual_Seq_Id_aligned=${$MRC_search_alignment_rv{'SEQ_IDENTITY'}};
    $ALIGNMENT_LENG       =${$MRC_search_alignment_rv{'ALIGNMENT_LENG'}};

    $forward_minus_backward_score = $herta_align_score - $herta_align_score_rv;

    print $MRCS_FILE_HANDLE "#<<STOP>> $query_seq($seq1_len)<->$DB_seq($seq2_len), ForBackScore: $forward_minus_backward_score, ForScore: $herta_align_score, BackScore: $herta_align_score_rv ID: $Mutual_Seq_Id_aligned L:$ALIGNMENT_LENG\n\n";

    close($MRCS_FILE_HANDLE) if $write_EACH_MRCS_pair_file;
    return(\%MRC_search_alignment, %MRC_search_alignment_rv);
}





#______________________________________________________________________________
# Title     : write_amino_acid_propensity_matrix_files
# Usage     :
# Function  : Calculates the propensity with all permutations of sequences aligned
#
# Example   :
# Keywords  : write_AAPM_files, write_aapm_files, write_dipeptide_AA_propensity_matrix_files
# Options   :
#   $overwrite_opt=o by o
#   $NO_write_each_AAPM_file=n by n
#   $NO_sub_dir_creation=d by d   # this writes the AAPM files in the PWD (messy!)
#
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub write_amino_acid_propensity_matrix_files{
    my(@alignment_files, $i, $j, $h, $upper_concentration_threshold, $k,
       %total_seq_used_hash, $lower_concentration_threshold, %total_PROPENSITY_MATRIX,
       $overwrite_opt, $NO_write_each_AAPM_file, $AAPM_result_subdir);
    $upper_concentration_threshold=70;
    $lower_concentration_threshold=20;

    @alignment_files=@{$_[0]};

    if(${$_[1]}){ $upper_concentration_threshold= ${$_[1]} || $_[1]; }
    if(${$_[2]}){ $lower_concentration_threshold= ${$_[2]} || $_[2]; }
    if($_[3]=~/o=o/i){ $overwrite_opt='o'; }
    if($_[4]=~/n/i){ $NO_write_each_AAPM_file='n'; }
    if($_[5]=~/d/i){ $NO_sub_dir_creation='d'; }

    unless($NO_sub_dir_creation){
       $AAPM_result_subdir="..\/AAPM_$lower_concentration_threshold\-$upper_concentration_threshold\/";
       unless(-d "$AAPM_result_subdir"){  mkdir ("$AAPM_result_subdir", 0777); }
    }else{
       $AAPM_result_subdir='';
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parsing Each Alignment file (like HSSP file)
    #_____________________________________________________________________________________
    for($h=0; $h<@alignment_files; $h++){
        my(%seq_used_hash, @seqs, $k, $i, $j, %ALIGNMENT, $ali_file_type,
           $first_seq, $second_seq, $file_base_name, @residues_1, @residues_2,
           $dipeptide_1, $dipeptide_2, %PROPENSITY_MATRIX, $aligned_dipeptide_count,
           %dipeptide_occurrance, %aa_composition);

        $file_base_name=${&get_base_names($alignment_files[$h])};

        $AAPM_filename_for_each_alignment_file="$AAPM_result_subdir$file_base_name\.aapm";
        $AAPM_filename_for_each_alignment_file_gz="$AAPM_result_subdir$file_base_name\.aapm\.gz";
        if(!$overwrite_opt and
            (-s $AAPM_filename_for_each_alignment_file > 100000
            or -s $AAPM_filename_for_each_alignment_file_gz > 100000) ){
            print "\n $AAPM_filename_for_each_alignment_file exists \n";
            next
        }

        print "\n opening $alignment_files[$h]";
        $ali_file_type=${&get_extension_names(\$alignment_files[$h])};

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # check what alignement file the input is and parse
        #____________________________________________________
        if($ali_file_type=~/hssp/i){
            %ALIGNMENT=%{&open_HSSP_file($alignment_files[$h])};
        }

        unless(%ALIGNMENT){ warn "\nwrite_amino_acid_propensity_matrix_files: \%ALIGNMENT is empty\n\n"; next; }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Concentrated means non-redundant representative
        # This is to make 'RSDB matrix'
        #______________________________________________________________
        %concentrated_seqs=%{&concentrate_seq_alignments(\%ALIGNMENT,
                                                         \$upper_concentration_threshold,
                                                         \$lower_concentration_threshold)};

        $num=keys %concentrated_seqs;
        print "\n \$num is $num\n";

        if($num < 2){
           print EACH_AAPM_FILE "\n# $AAPM_filename_for_each_alignment_file had $num alignment, which is too small\n";
           next
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # %concentrated_seqs is the meaning alignment data to process
        #________________________________________________________________
        @seqs=keys %concentrated_seqs;

        for($i=0; $i<@seqs; $i++){
           $seq_used_hash{$seqs[$i]}++;
           $total_seq_used_hash{$seqs[$i]}++;

           for($j=$i; $j<@seqs; $j++){

               if($i==$j){ next }

               $seq_used_hash{$seqs[$j]}++;
               $total_seq_used_hash{$seqs[$i]}++;

               $first_seq =$concentrated_seqs{$seqs[$i]};
               $second_seq=$concentrated_seqs{$seqs[$j]};

               @residues_1=split(//, $first_seq);
               @residues_2=split(//, $second_seq);

               for($k=0; $k< @residues_1; $k++){
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # Ignores any gap regions or insertions (lowercase in HSSP)
                  #___________________________________________________________________
                  if($residues_1[$k  ] =~/[ACDEFGHIKLMNPQRSTVWY]/ and
                     $residues_1[$k+1] =~/[ACDEFGHIKLMNPQRSTVWY]/ and
                     $residues_2[$k  ] =~/[ACDEFGHIKLMNPQRSTVWY]/ and
                     $residues_2[$k+1] =~/[ACDEFGHIKLMNPQRSTVWY]/ ){

                     $dipeptide_1=join('', $residues_1[$k], $residues_1[$k+1]);
                     $dipeptide_2=join('', $residues_2[$k], $residues_2[$k+1]);

                     #@sorted_dipeptides=sort ($dipeptide_1, $dipeptide_2);

                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # Acutual counting of the occurances. Note that I add 2 instead of 1 in each pair of dipeptide
                     #     | cc | cd      <-- In the alignment of  .CCE.
                     # ---------------                             .CCD.
                     #  cc |  2 |  0                  (2/4)
                     # ---------------   =    -log -------------  =  -log(4)  <--- The final propensity in the matrix
                     #  ce |  0 |  2               (1/4) x (2/4)
                     #_________________________________________________________________________________________________
                     $PROPENSITY_MATRIX{$dipeptide_1}{$dipeptide_2} += 2;
                     $PROPENSITY_MATRIX{$dipeptide_2}{$dipeptide_1} += 2;

                     $aligned_dipeptide_count   +=2;
                     $dipeptide_occurrance{$dipeptide_1}++;
                     $dipeptide_occurrance{$dipeptide_2}++;
                     $aa_composition{$residues_1[$k]}++;
                     $aa_composition{$residues_1[$k+1]}++;
                     $aa_composition{$residues_2[$k]}++;
                     $aa_composition{$residues_2[$k+1]}++;

                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # This skips any sequence which has appeard once in order to make RSDB matrix extremely non-redundant (for Global matrix only)
                     #____________________________________________________________________________________________________________
                     if($total_seq_used_hash{$seqs[$i]} == 1 or $total_seq_used_hash{$seqs[$j]} == 1 ){
                          $total_PROPENSITY_MATRIX{$dipeptide_1}{$dipeptide_2} +=2;
                          $total_PROPENSITY_MATRIX{$dipeptide_2}{$dipeptide_1} +=2;
                          $TOTAL_aligned_dipeptide_count +=2;
                          $TOTAL_dipeptide_occurrance{$dipeptide_1}++;
                          $TOTAL_dipeptide_occurrance{$dipeptide_2}++;
                          $TOTAL_aa_composition{$residues_1[$k]}++;
                          $TOTAL_aa_composition{$residues_1[$k+1]}++;
                          $TOTAL_aa_composition{$residues_2[$k]}++;
                          $TOTAL_aa_composition{$residues_2[$k+1]}++;
                     }
                  }
               }

           }

        }
        unless($NO_write_each_AAPM_file){
            &write_aapm_file(\$AAPM_filename_for_each_alignment_file,
                             \%PROPENSITY_MATRIX, \%aa_composition, \%dipeptide_occurrance, \%seq_used_hash,
                             \$aligned_dipeptide_count, \$overwrite_opt);
        }

    }## FOR loop for each alignment file

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Global AAPM file
    #___________________________________________________________________________________________
    $AAPM_filename_for_all_alignment_file    ="$AAPM_result_subdir\AA_propten_matrix\_$lower_concentration_threshold\_$upper_concentration_threshold\.aapm";
    $AAPM_filename_for_all_alignment_file_gz = "$AAPM_filename_for_all_alignment_file\.gz";
    if(!$overwrite_opt and
       (-s $AAPM_filename_for_all_alignment_file > 100000
        or -s $AAPM_filename_for_all_alignment_file_gz > 100000) ){
        print "\n $AAPM_filename_for_each_alignment_file exists \n";
        return;
    }
    &write_aapm_file(\$AAPM_filename_for_all_alignment_file,
                     \%total_PROPENSITY_MATRIX, \%TOTAL_aa_composition, \%TOTAL_dipeptide_occurrance, \%total_seq_used_hash,
                     \$TOTAL_aligned_dipeptide_count, \$overwrite_opt);

}





#______________________________________________________________________________
# Title     : write_aapm_file
# Usage     :
# Function  :
# Example   :
# Keywords  : write_each_aapm_file
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub write_aapm_file{
    my($AAPM_filename_for_each_alignment_file, %PROPENSITY_MATRIX, %aa_composition,
       %dipeptide_occurrance, @dipeptides1, @AA, @total_dipep, @all_dipep,
       $all_peplet_count, $total_AA_occur, $num, $aligned_dipeptide_count,
       %seq_used_hash, %expected_propen_for_a_dipep, $Prob_DIPEP_pair,
       $log_propen_for_each_dipep, $the_lowest_propen_observed, $overwrite_opt,
       $AAPM_filename_for_each_alignment_file_gz, @SEQ_names);
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # The default for 0 occurrance of pairs of AA to AA
    #__________________________________________________
    $the_lowest_propen_observed = -5.5; ## this is from a empirical data. the lowest I saw was -4.46 (1 occurance)

    $AAPM_filename_for_each_alignment_file=${$_[0]} || $_[0];
    $AAPM_filename_for_each_alignment_file_gz="$AAPM_filename_for_each_alignment_file\.gz";

    %PROPENSITY_MATRIX=%{$_[1]};
    %aa_composition   =%{$_[2]};
    %dipeptide_occurrance=%{$_[3]};
    %seq_used_hash    =%{$_[4]};
    $aligned_dipeptide_count=${$_[5]} || $_[5];
    $overwrite_opt =${$_[6]} || $_[6];

    if(!$overwrite_opt
       and (-s $AAPM_filename_for_each_alignment_file > 100000
            or -s $AAPM_filename_for_each_alignment_file_gz > 100000) ){
        print "\n $AAPM_filename_for_each_alignment_file exists\n";
        return
    }

    open(AA_PROPENSITY_FILE, ">$AAPM_filename_for_each_alignment_file") || die "\n Can not open $AAPM_filename_for_each_alignment_file\n";

    $num= @dipeptides1=sort keys %PROPENSITY_MATRIX;
    print AA_PROPENSITY_FILE "# Generated by write_aapm_file in $0\n# There were $num dipeptide kinds.\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Writing used sequence names
    #______________________________________________________________________
    @SEQ_names=sort keys %seq_used_hash;
    for($i=0; $i< @SEQ_names; $i++){
        print AA_PROPENSITY_FILE "$SEQ_names[$i] $seq_used_hash{$SEQ_names[$i]}\n";
    }

    @AA=sort keys  %aa_composition;

    for($i=0; $i<@AA; $i++){
       print AA_PROPENSITY_FILE "# Residue $AA[$i] $aa_composition{$AA[$i]}\n";
       $total_AA_occur += $aa_composition{$AA[$i]};
    }
    print AA_PROPENSITY_FILE "# Total Single residue : $total_AA_occur\n";

    @total_dipep=sort keys %dipeptide_occurrance;
    for($i=0; $i< @total_dipep; $i++){
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
        # Peplit : small Peptide fragment
        #_____________________________________________
        print AA_PROPENSITY_FILE  "# Peplet: $total_dipep[$i] : $dipeptide_occurrance{$total_dipep[$i]}\n";
        $expected_propen_for_a_dipep{$total_dipep[$i]}=$dipeptide_occurrance{$total_dipep[$i]}/$aligned_dipeptide_count;
        $all_peplet_count += $dipeptide_occurrance{$total_dipep[$i]};
    }

    print AA_PROPENSITY_FILE "\n# The count of all the AA peplet: $all_peplet_count , $aligned_dipeptide_count\n\n";

    @all_dipep=sort keys %PROPENSITY_MATRIX;

    for($i=0; $i< @all_dipep; $i++){
        for($j=0; $j < @all_dipep; $j++){
           if($PROPENSITY_MATRIX{$all_dipep[$i]}{$all_dipep[$j]}){
              $Prob_DIPEP_pair=($PROPENSITY_MATRIX{$all_dipep[$i]}{$all_dipep[$j]}/$aligned_dipeptide_count);
              $Exp_1st_DIPEP  =$expected_propen_for_a_dipep{$all_dipep[$i]};
              $Exp_2nd_DIPEP  =$expected_propen_for_a_dipep{$all_dipep[$j]};
              $log_propen_for_each_dipep = log($Prob_DIPEP_pair/($Exp_1st_DIPEP*$Exp_2nd_DIPEP));
              if($log_propen_for_each_dipep < $the_lowest_propen_observed){
                  $the_lowest_propen_observed=$log_propen_for_each_dipep;
              }
              printf AA_PROPENSITY_FILE "$all_dipep[$i] $all_dipep[$j] $PROPENSITY_MATRIX{$all_dipep[$i]}{$all_dipep[$j]}\t$log_propen_for_each_dipep\n";

           }else{
              print AA_PROPENSITY_FILE "$all_dipep[$i] $all_dipep[$j] 0\t$the_lowest_propen_observed\n";
           }
        }
    }
    close(AA_PROPENSITY_FILE);
    if(-s $AAPM_filename_for_each_alignment_file){
       print "\n  Wrote $0:write_aapm_file ->$AAPM_filename_for_each_alignment_file\n";
       system("gzip $AAPM_filename_for_each_alignment_file");
       print "\n  $0:write_aapm_file GZIPPED $AAPM_filename_for_each_alignment_file\n";
    }
    return(\$AAPM_filename_for_each_alignment_file);
}






#______________________________________________________________________________
# Title     : write_ercf_files
# Usage     : $0 standard_ranked_expression_file.srex expression_ABX_file.abx
# Function  :
# Example   :
# Keywords  :
# Options   :
#   $sort_numerically_RV=r by r  # for sorting the standard Ranked Expression file(SREX)
# Author    : jong@biosophy.org,
# Category  : ercf : Expression Rank Comparison File
#              RXU : Relative eXpression Unit
# Version   : 1.0
#------------------------------------------------------------------------------
sub write_ercf_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($sort_numerically_RV, $SREX, $ABX, $i, $ORF_name, $RXU, $Ranking,
		   %gene_exp_level, @SREX_keys);
		$SREX=$file[0];
		$ABX =$file[1];
		$base=${&get_base_names(\$ABX)};
		open(SREX, "<$SREX");
		open(ABX,  "<$ABX");
		while(<SREX>){
			 if(/(\S+)\s+(\S+)/){
					$ORF_name=$1;
					$RXU =$2;
					$Ranking++;
			    $SREX{$ORF_name}=$Ranking;
			 }
		}
		close(SREX);
		while(<ABX>){
			 if(/^(\S+)\s+(\S+)\s+\S+/){
					$ORF_name=$1;
					$RXA=$2;  ## Relative eXpression Abundance Unit

					if($ORF_name=~/^(\S+)\/_ex\d/){
							$ORF_name="\U$1";
					}elsif($ORF_name=~/^(\S+)\/\w+_ex\d/){
							$ORF_name="\U$1";
					}elsif($ORF_name=~/^(\S+)\/\w+/){
							$ORF_name="\U$1";
					}elsif($ORF_name=~/^(\S+)\//){
							$ORF_name="\U$1";
					}
					$gene_exp_level{$ORF_name}=$RXA;
				}
		}
		close(ABX);

		open(ERCF, ">$base\.ercf");
		open(ERCF_1COL, ">$base\.1col");

		@SREX_keys=@{&sort_hash_by_value(\%SREX, $sort_numerically_RV)}; ##
		@ABX_keys=keys %gene_exp_level;
		for($i=0; $i< @SREX_keys; $i++){
				if($gene_exp_level{$SREX_keys[$i]} > 0){
						printf ERCF ("%-14s %-10s\n", $SREX_keys[$i], $gene_exp_level{$SREX_keys[$i]});
						printf ERCF_1COL ("%-10s\n", $gene_exp_level{$SREX_keys[$i]});
				}else{
						printf ERCF ("%-14s %-10s\n", $SREX_keys[$i], 0);
						printf ERCF_1COL ("%-10s\n", 0);
				}
		}
		close(ERCF);
		close(ERCF_1COL);
}

#______________________________________________________________________________
# Title     : write_to_selected_www_socket_filehandle
# Usage     :
# Function  : The socket should have been selected like: select(SOCKET_FOR_POST);
# Example   : &write_to_selected_www_socket_filehandle($relativeURL, $length, $content);
# Keywords  : write_to_socket
# Options   :
# Author    : jong@biosophy.org,
# Version   : 1.0
#------------------------------------------------------------------------------
sub write_to_selected_www_socket_filehandle{
    my($URL, $length, $content)=@_; ## URL looks like:  /cgi-bin/BLAST/nph-newblast
    print "POST $URL HTTP\/1.0";
    print "\nContent-Type:application\/x-www-form-urlencoded";
    print "\nContent-Length:$length";
    print "\n\n$content\n"; ## <<---- The '\n' should be exactly TWO !!!, Ridiculous isn't it?
}

#______________________________________________________________________________
# Title     : write_to_www_socket_filehandle
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub write_to_www_socket_filehandle{
    my($SOCKET_FOR_POST, $relativeURL, $length, $content, $old_file_handle);
    ($SOCKET_FOR_POST, $relativeURL, $length, $content)=@_;
    ## set socket to be command buffered by $|=1
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # To save the old default Filehandle, I do the following line
    #_____________________________________________________________
    $old_file_handle=select STDERR; $|=1; ## <--- This is to save the old (current) filehandle
    select($SOCKET_FOR_POST); $|=1;
    print $SOCKET_FOR_POST "POST $relativeURL HTTP\/1.0"; ## URL looks like:  /cgi-bin/BLAST/nph-newblast
    print $SOCKET_FOR_POST "\nContent-Type:application\/x-www-form-urlencoded";
    print $SOCKET_FOR_POST "\nContent-Length:$length";
    print $SOCKET_FOR_POST "\n\n$content\n"; ## <<---- The '\n' should be exactly TWO !!!, Ridiculous isn't it?
    select($old_file_handle); # changing back to default(I assume STDOUT)
}



#______________________________________________________________________________
# Title     : write_reverse_seq_files
# Usage     :
# Function  :
# Example   :
# Keywords  : write_rev_seq_files, write_reverse_msf_files
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub write_reverse_seq_files{
    my $inputfile=$_[0];
    my $base=${&get_base_names(\$inputfile)};
    my $ext=${&get_extension_names(\$inputfile)};
    my $out_rev_file="$base\_rv\.$ext";
    my ($hash_out, $order_array)=&open_msf_files(\$inputfile, 'o');
    my %seq=%{$hash_out};
    my @order=@{$order_array};
    my @file_written=@{&write_msf(\%seq, \$out_rev_file, \@order)};
    print "\n# (INFO)  \@file_written: @file_written\n";
    return(\@file_written);
}



#_____________________________________________________________________
# Title     : make_reverse_seq_database
# Usage     : &make_reverse_seq_database(\@input_database_fasta_file);
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sub make_reverse_seq_database{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		$| = 1;
		for($i=0; $i< @file; $i++){
				my $fasta_file_for_DB =$file[$i];
				my $base=${&get_base_names($fasta_file_for_DB)};
				my $ext =${&get_file_extensions($file[$i])};
				my($out_file_name, %seqs, %reversed_seqs);
				if($ext=~/\S/){
							 $out_file_name="$base\_rv\.$ext";
				}else{
					 $out_file_name="$base\_rv\.mpfa";
				}
				%seqs=%{&open_fasta_files(\$fasta_file_for_DB)};
				%reversed_seqs=%{&reverse_sequences(\%seqs)};
				&write_fasta(\%reversed_seqs, $out_file_name );
				if(-s $out_file_name){
							 print "\n# make_reverse_seq_database: Supposedly wrote: $out_file_name\n";
				}else{
							 print "\n# make_reverse_seq_database: Error in writing: $out_file_name\n";
				}
		}
		print "\n# make_reverse_seq_database sub finished \n";
}


#__________________________________________________________________________
# Title     : make_hmm_from_alignment
# Usage     : @out_hmm_file_names=@{&make_hmm_from_alignment(\@file, "$over_write")};
# Function  :
# Example   :
# Keywords  : HMM, hidden markov model, make_HMM_from_alignment,
#             make_hmm_from_msf_file, create_hmm_from_alignment,
#             create_hmm_from_msf_file,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub make_hmm_from_alignment{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	local (@out_hmm_files, $base, $out_hmm_file);
	for($i=0; $i< @file; $i++){
	   if($file[$i]=~/\.msf/){
							 $base=${&get_base_names($file[$i])};
							 $out_hmm_file= "$base\.hmm";
							 if($char_opt=~/o/ or !(-s $out_hmm_file) ){
											system("hmmb -P BLOSUM62 -B 200 -w $out_hmm_file $file[$i]");
											push(@out_hmm_files, $out_hmm_file);
							 }else{
											print "\n# The $out_hmm_file file already exists. To overwrite use -o opt\n";
							 }
	   }
	}
	if(@out_hmm_files > 1){
	   return(\@out_hmm_files);
	}else{
	   return(\$out_hmm_files[0]);
	}
}

#________________________________________________________________________
# Title     : get_non_overlapping_elements_in_array
# Usage     : @subs = @{&subtract_array(\@array1, \@array2)};
# Function  : removes any occurances of certain elem. of the first
#             input array with second input array.
# Example   : Following will produce (A K C X);
#		  @array1= qw( A B K B B C);
#  		@array2= qw( B E D X);
#  		@subs = @{&get_non_overlapping_elements_in_array(\@array1, \@array2)};
# Keywords  : array_subtract, substract_array, ary1_minus_ary2
# Options   :
# Returns   :
# Argument  :
# Authors   : jong@biosophy.org
# Version   : 1.0
#--------------------------------------------------------------------
sub get_non_overlapping_elements_in_array{
		my(@first, @second, %counter1, %counter2);
		@first=@{$_[0]};
		@second=@{$_[1]};
		grep($counter1{$_}++, @first );
		grep($counter2{$_}++, @second );
		return([ grep(!$counter2{$_}, @first), grep(!$counter1{$_}, @second)]);
}

#______________________________________________________________________________
# Title     : get_atom_coord_from_SCOP_domain_def_info
# Usage     : @xyz_coord1=@{&get_atom_coord_from_SCOP_domain_def_info(\$domain1, \%PDB_atom_domains)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.5
#------------------------------------------------------------------------------
sub get_atom_coord_from_SCOP_domain_def_info{
    my($dom_def_long, $dom_def, %PDB_atom_domains, $region, @region, $dom_start1, $dom_stop,
       @residue_num, @xyz_coord, $chain, $i, $d, $v, $domain, @dom_def);
    $dom_def_long=${$_[0]} || $_[0];
    %PDB_atom_domains=%{$_[1]};
    @keys=keys %PDB_atom_domains;
    @dom_def=split(/\,/, $dom_def_long);
    for($i=0; $i< @dom_def; $i++){
        $dom_def=$dom_def[$i];
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  d1vdea1 1vde    a:416-454   1.002.076.001.002.001,  \w? is necessary as some has a form h:114-223b
        #________________________________________________________________
        if($dom_def=~/^(\w+):(\d+)\w?\-(\d+)\w?$/){     $domain=$1; $dom_start=$2+1;  $dom_stop=$3-1;
            #print "\n$dom_def => $domain $dom_start $dom_stop \n";
            for($d=$dom_start; $d< $dom_stop; $d++){
                push(@xyz_coord, @{$PDB_atom_domains{$domain}{$d}}); # push(@{$ATOM{"$chain\_$region"}{$residue_number}}, $x, $y, $z);
            }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # d1a0h.2 1a0h    271-320    1.002.041.001.002.012, \w? is necessary as some has a form h:114-223b
        #________________________________________________________________
        }elsif($dom_def=~/^(\d+)\w?\-(\d+)\w?$/){   $dom_start=$1+1; $dom_stop=$2-1;
            if(@{$PDB_atom_domains{'NO_CHAIN'}{$dom_start}} or @{$PDB_atom_domains{'NO_CHAIN'}{$dom_stop}}){
                for($d=$dom_start; $d< $dom_stop; $d++){
                     push(@xyz_coord, @{$PDB_atom_domains{'NO_CHAIN'}{$d}}); # push(@{$ATOM{"$chain\_$region"}{$residue_number}}, $x, $y, $z);
                }
            }else{ &send_mail_to_me("\n Can not get \$PDB_atom_domains{ NO_CHAIN } for $dom_def_long \n"); }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # d1a0h.2 1a0h    d:    1.002.041.001.002.012
        #________________________________________________________________
        }elsif($dom_def=~/^(\w+):$/){    $chain=$1;
            #print "\n(3) get_atom_coord_from_SCOP_domain_def_info : $dom_def => $chain \n";
            if($PDB_atom_domains{$chain}){ @residue_num= sort {$a<=>$b} keys %{$PDB_atom_domains{$chain}};
                for($v=0; $v < @residue_num; $v++){
                     push(@xyz_coord, @{$PDB_atom_domains{$chain}{$residue_num[$v]}});
                }
            }else{ &send_mail_to_me("\n Can not get \$PDB_atom_domains{ \$chain } for $dom_def_long \n"); }
        }else{
            &send_mail_to_me(" $dom_def  did not match anything right. $dom_def_long\n");
        }
    }
    return(\@xyz_coord);
}



#________________________________________________________________________
# Title     : get_array_average
# Usage     : $output = &array_average(\@any_array);
# Function  : (the same as average_array)
# Example   :
# Warning   : If divided by 0, it will automatically replace it with 1
# Keywords  : get_array_average, av_array, average_array, get_average_array
#             average_of_array, average_array, get_average_array,
#             get_average_of_array, calculate_array_average
# Options   :
# Returns   : single scaler digit.
# Argument  : takes one array reference.
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub get_array_average{
		my(@input)= @{$_[0]};
		my $int_option = ${$_[1]} || $_[1];
		my($item,$average,$num,$sum);
		my $num_of_elem = @input;

		for $item(@input){
			 if( $item =~ /^$/ ){  ## If it matches nothing. '$item == 0' does not work !!!
				$num_of_elem --; ## This is to make sure that the denominator does not
			 }                  ## count blank element. (to get correct element number)
			 else{ $sum += $item;  }
		}
		if($num_of_elem ==0){ $num_of_elem =1; }  ## To prevent 'Division by 0' error
		if($int_option =~ /[\-]*i[nt]*/){
			$average= int( $sum/$num_of_elem );
		}else{   $average = $sum/$num_of_elem }

		return(\$average);
}


#______________________________________________________________________________
# Title     : get_prefix_arrays_for_seqlet_alignment
# Usage     : (@seq1_start_final, @seq2_start_final, @scores_gap)
#                 =@{&get_prefix_arrays_for_seqlet_alignment(\@residue1, \@residues2,
#                                                     \@positions1, \@positions2)};
#
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub get_prefix_arrays_for_seqlet_alignment{
    my(@scores_gap, @seq1_start_final, @seq2_start_final, $start_point,
       @seq1_start, @residues1, @seq2_start, @residues2, @positions1, @positions2);
    @residues1 =@{$_[0]};
    @residues2 =@{$_[1]};
    @positions1=@{$_[2]};
    @positions2=@{$_[3]};
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # adjusting the starting point\
    #___________________________________________________
    if($positions1[0] != 1){
       $start_point=$positions1[0]-1;
       @seq1_start=splice(@residues1, 0, $start_point);
       #print "\n(1) $start_point @seq1_start\n";
    }
    if($positions2[0] != 1){
       $start_point=$positions2[0]-1;
       @seq2_start=splice(@residues2, 0, $start_point);
       #print "\n(2) $start_point @seq2_start\n";
    }

    if(@seq1_start){
        push(@seq1_start_final, @seq1_start);
        push(@seq2_start_final, split(//, "."x@seq1_start) );
    }
    if(@seq2_start){
        push(@seq2_start_final, @seq2_start);
        push(@seq1_start_final, split(//, "."x@seq2_start) );
    }
    push(@scores_gap, split(//, "."x(@seq1_start+@seq2_start) ) );
    #print "\n\n<1>", @seq1_start_final, "\n<2>", @seq2_start_final, "\n<3>", @scores_gap, "\n\n\n";
    return(\@seq1_start_final, \@seq2_start_final, \@scores_gap);
}


#______________________________________________________________________________
# Title     : get_psdip_subset
# Usage     : &get_psdip_subset($PDBG_file, $PSDIP_file);
# Function  : This checks the protein interaction pairs from PSDIP
#              and shows ONLY IF the pdbd domains are found to be in
#              the given MPFA(or PDBG) file such as pdb100d_1_48.mpfa.
#             To make sure the interacting domains are all found in
#              PDB100D or PDB90D etc.
# Example   :
# Keywords  : get_PSDIP_subset
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_psdip_subset{
    my($PSDIP_file, $PDBG_file);
    $file1=${$_[0]} || $_[0];   $file2 =${$_[1]} || $_[1];
    if($file1=~/\.[pdbg|mpfa]/ and $file2=~/\.psdip/){ $PDBG_file=$file1; $PSDIP_file=$file2
    }elsif($file1=~/\.psdip/ and $file2=~/\.[pdbg|mpfa]/){ $PDBG_file=$file2; $PSDIP_file=$file1 }
    unless(-s $PSDIP_file and -s $PDBG_file){ die "\n I need PSDIP and PDBG file <- calculate_versability_of_domain_interaction\n";}

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Check what PDBG file(%) was used to add in output file names
    #_________________________________________________________________
    if($PDBG_file=~/pd\w+?(\d+)\w*_/){    $PDBG_type=$1;    }
    open(PDBG, "<$PDBG_file") || die;
    while(<PDBG>){  if(/\>(\S+)\s(\d+\.\d+\.\d+)\S+\s+(.+)/){ $pdbg{$1}=$2; $pdbg_desc{$2}.="\t$3\n"; push(@{$superfam{$2}}, $1); } }
    close(PDBG);

    open(PSDIP, "<$PSDIP_file") || die;
    while(<PSDIP>){
       if(/PROTEIN_INTERACT\s+(\S+)\s+(\S+)/){
           if($pdbg{$1} and $pdbg{$2}){
               print;
           }
       }elsif(/PROTEIN_NONINTERACT\s+(\S+)\s+(\S+)/){
           if($pdbg{$1} and $pdbg{$2}){
               print;
           }
       }
    }
    close(PDBG);
    close(PSDIP);
}




#______________________________________________________________________________
# Title     : get_DDD_domain_length_from_segment_ranges
# Usage     :
# Function  :
# Example   :
# Keywords  : get_sequence_length_from_DDD_domain_segments,
#             get_seq_length_from_range calculate_length_from_segments
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub get_DDD_domain_length_from_segment_ranges{
    my(@seq_ranges, $i, $seq_seqments_length);
    @seq_ranges=@{$_[0]};
    if(@seq_ranges <= 1){
       print "\n get_DDD_domain_length_from_segment_ranges, SEQ ranges num. can not be odd\n@seq_ranges\n\n";
       die
    }
    for($i=0; $i< @seq_ranges; $i+=2){
       if($seq_ranges[$i]+1=~/\S/){
          $seq_seqments_length+=$seq_ranges[$i+1]-$seq_ranges[$i]+1;
       }else{
          print "\n WARN: get_DDD_domain_length_from_segment_ranges, \$seq_ranges\[\$i\]\+1 is blank or empty\n\n";
       }
    }
    return(\$seq_seqments_length);
}



#______________________________________________________________________________
# Title     : get_PWD_from_HTTP_REFERER_variable
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_PWD_from_HTTP_REFERER_variable{
    my($PWD,$HTTP_REFERER);
    if(${$_[0]}){ $HTTP_REFERER=$$_[0]};
    }else{  $HTTP_REFERER =$ENV{HTTP_REFERER}; }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # matching http://cyrah.ebi.ac.uk:1111/Misc/
    #_________________________________________________________
    if( $HTTP_REFERER =~/http:\/\/\w[^\/]+\w+\/(\S+)\/$/){
       $PWD=$1;
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # matching http://cyrah.ebi.ac.uk:1111/
    #__________________________________________________________
    }elsif($HTTP_REFERER =~/http:\/\/\w[^\/]+\w\/$/){
       $PWD='';
    }
    return(\$PWD);
}


#______________________________________________________________________________
# Title     : get_2_most_similar_strings_in_array
# Usage     :($INT_sq1, $INT_sq2, $sq1, $sq2)=@{&get_2_most_similar_strings_in_array(\@seq_names)};
# Function  : returns the common sequence names(usually Intermediates in search)
#             The sequence names can be XXXX or XXXX_30-66
#             Accepts 4 strings in an array.
# Example   :
# Keywords  : get_common_seq_names, get_identical_seq_names
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub get_2_most_similar_strings_in_array{
		my @seq_names=sort @{$_[0]};
		my ($i, $previous_seq_name, @seq_names_out, $previous_seq_name_orig,
		    $highest_iden);
		for($i=0; $i< @seq_names; $i++){
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If seq names have RANGE information XXX_10-30
			 #______________________________________________
			 if($seq_names[$i]=~/(\S+)_(\d+)\-\d+/){
					if($1 eq $previous_seq_name){
					    if($i == 1){
					       if($previous_seq_name_start > $2){
										 @seq_names_out=($seq_names[$i], $previous_seq_name_orig, $seq_names[$i+1], $seq_names[$i+2]);
					       }else{
										 @seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i+1], $seq_names[$i+2]);
								 }
							}elsif($i > 1){
								 @seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i-2], $seq_names[$i+1]);
							}
					}
					$previous_seq_name=$1;
					$previous_seq_name_start=$2;
					$previous_seq_name_orig=$seq_names[$i];
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If seq names DO NOT have range info  XXXXXX
			 #______________________________________________
			 }elsif($seq_names[$i] eq $seq_names[$i+1]){
					if($i == 0){
							@seq_names_out=($seq_names[$i], $seq_names[$i+1], $seq_names[$i-1], $seq_names[$i+2]);
					}elsif($i == 1){
							@seq_names_out=($seq_names[$i], $seq_names[$i+1], $seq_names[$i-2], $seq_names[$i-1]);
					}elsif($i == 2){
							@seq_names_out=($seq_names[$i], $seq_names[$i+1], $seq_names[$i-3], $seq_names[$i-2]);
					}
					return(\@seq_names_out)
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If seq names DO NOT have range info and there is not identical seq pairs
			 #__________________________________________________________________________________
			 }else{
			    my ($counter, $j, $non_char_count);
					$counter=1;
					@name_chars1=split(//, $previous_seq_name);
					@name_chars2=split(//, $seq_names[$i]);
					for($j=0; $j < @name_chars1; $j++){
							if($name_chars1[$j] eq $name_chars2[$j]){
									$counter++;
									if($counter > $highest_iden){
											$highest_iden=$counter;
											if($i == 1){
													@seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i+1], $seq_names[$i+2]);
													print "\n# $i, @seq_names_out H=$highest_iden";
											}elsif($i == 2){
													@seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i-2], $seq_names[$i+1]);
													print "\n# $i, @seq_names_out H=$highest_iden";
											}elsif($i == 3){
													@seq_names_out=($seq_names[$i-1], $seq_names[$i], $seq_names[$i-3], $seq_names[$i-2]);
													print "\n# $i, @seq_names_out H=$highest_iden";
													return(\@seq_names_out);
											}
									}
							}else{ ## When there is non-identical char comes, skip it.
									#$non_char_count++;
									next;
							}
					}
					$previous_seq_name=$seq_names[$i];
					$previous_seq_name_orig=$seq_names[$i];
			 }
		}
		return(\@seq_names_out);
}


#______________________________________________________________________________
# Title     : get_file_creation_date
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_file_creation_date{
    my($file,$file_creation_date);
    $file=${$_[0]} || $_[0];
    $file_creation_date=localtime( (stat($file))[9] );
    return(\$file_creation_date);
}


#__________________________________________________________________
# Title     : get_false_positive_seq_matches
# Usage     : %seq=%{&get_false_positive_seq_matches(\%mspa_1, \%mspa2)};
# Function  : gets sequences which are wrongly matched from intermediate seq search
# Example   :
#
#  OUTPUT looks like the following;
#	d1dvh__=d1fcdc1     7.1e-08
#	d1fcdc1=d1dvh__     7.1e-08
#	d5cytr_=d351c__     5.3e-08
#	d351c__=d5cytr_     5.3e-08
#	d1cyi__=d2mtac_     9.1e-06
#	d2mtac_=d1cyi__     9.1e-06
#	d1cyi__=d5cytr_     0.00045
#	d5cytr_=d1cyi__     0.00045
#
# Warning   : The default is to show the best E value(lowest that is)
#
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sub get_false_positive_seq_matches{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%iss_input)= %{$hash[0]};
	my(%final_table_Evalue, %final_table_score, $inter_seq_seq_name, $inter_seq_score,
	   $inter_seq_E_value, $match_seq_seq_name, $match_seq_score, $match_seq_E_value,
	   $name_combi1, $name_combi2, $each_iss_line, $all_enquiry_seqs);
	@iss_lines = sort values %iss_input;

	if(@array > 0){ ## When the names of enquiry was given as an array, use it!
		$all_enquiry_seqs=join(' ', sort @{$array[0]} );
	}else{    ## otherwise, detect yourself.
						for($i=0; $i< @iss_lines; $i++){
							 $each_iss_line=$iss_lines[$i];
							 if($each_iss_line=~/^\s*(\S+)\s+/){
											$all_enquiry_seqs{$1}++;
							 }
						}
						$all_enquiry_seqs=join(' ', sort keys %all_enquiry_seqs );
	}

	for($i=0; $i< @iss_lines; $i++){
	   $each_iss_line=$iss_lines[$i];
	   if($each_iss_line=~/^\s*(\S+)\s+(\S+)\((\d+)\)\((\S+)\)\s+(\S+)\((\d+)\)\((\S+)\)/){
								$inter_seq_seq_name= $2;
								$inter_seq_score   = $3;
								$inter_seq_E_value = $4;
								$match_seq_seq_name= $5;
								$match_seq_score   = $6;
								$match_seq_E_value = $7;
								$name_combi1="$1\=$match_seq_seq_name";
								$name_combi2="$match_seq_seq_name\=$1";
								if($all_enquiry_seqs !~/$match_seq_seq_name/){
											 $false_positive_matches{$name_combi1}="$inter_seq_score $inter_seq_E_value";
											 next;
								}
	   }
	}
	if($char_opt=~/v/){
	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	   # Wrting the false positives
	   #__________________________________
	   @keys_false=sort keys %false_positive_matches;
	   print "\n\n# False positives: " if @keys_false > 0;
	   for $key_false (@keys_false){
								if($key_false =~/\S+/){
											 printf ("\n%-30s %-30s",  $key_false,  $false_positive_matches{$key_false});
								}
	   }
	   print "\n";
	}
	return(\%false_positive_matches);
}

#______________________________________________________________________________
# Title     : convert_aminio_acid_to_binary_pattern
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub convert_aminio_acid_to_binary_pattern{
		my (%aa_pattern_table);

		%aa_pattern_table
			 = (
					'P', '1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'G', '0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'C', '0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'M', '0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'H', '0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'D', '0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'E', '0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0',
					'A', '0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0',
					'F', '0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0',
					'I', '0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0',
					'V', '0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0',
					'L', '0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0',
					'R', '0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0',
					'K', '0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0',
					'S', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0',
					'T', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0',
					'Q', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0',
					'N', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0',
					'W', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0',
					'Y', '0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1'
				 );
		 return(\%aa_pattern_table);
}

#______________________________________________________________________________
# Title     : convert_genbank_to_fasta
# Usage     : &convert_genbank_to_fasta(\%genbank, \$out_file, \$block_size)
# Function  :
# Example   :
# Keywords  : convert_genbank_to_fasta_hash
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub convert_genbank_to_fasta{
    my(%genbank_hash, $sequence, $block_size, $out_file_name);
    $block_size=80;
    $out_file_name="default_genank_fasta.spfa";
    %genbank_hash=%{$_[0]};
    $out_file_name=${$_[1]} || $_[1];
    $block_size=${$_[2]} || $_[2];
    open(FASTA, ">$out_file_name") || die "\nCan not open $out_file_name\n\n";
    print FASTA "\>$genbank_hash{'seq_name'}\n";
    $sequence=$genbank_hash{'sequence'};
    $sequence=~s/\s+//g;
    $seq_leng=length($sequence);
    for($i=0; $i< $seq_leng; $i+= $block_size){
       print FASTA substr($sequence, $i, $block_size);
    }
    return(\$out_file_name);
}


#______________________________________________________________________________
# Title     : convert_genbank_to_fasta_file
# Usage     : &convert_genbank_to_fasta_file(\@ARGV, \$block_size);
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub convert_genbank_to_fasta_file{
    my($i, $j, @genbank_files, %genbank, @keys, $seq_leng,
       $sequence, $base, $block_size,  $out_file_name,
       @fasta_files, $accession_no);
    $block_size=80;
    @genbank_files=@{$_[0]};
    if(ref($_[1]) and ${$_[1]}){   $block_size=${$_[1]} || $_[1]; }
    for($i=0; $i< @genbank_files; $i++){
       unless($genbank_files[$i]=~/\.embl/ or $genbank_files[$i]=~/\.genbank/){
          print "\n Can you change the extension of $genbank_files[$i] to genbank?\n\n";
       }
       print "\n# (i) Parsing $genbank_files[$i] to make FASTA ouput\n";
       $base=${&get_base_names($genbank_files[$i])};
       %genbank=%{&open_genbank_files($genbank_files[$i])};
       @accession_no=keys %genbank;
       for($k=0; $k<@accession_no; $k++){
           $accession_no=$accession_no[$k];
           $sequence=$genbank{$accession_no}{'sequence'};
           $sequence=~s/\s+//g;
           $seq_leng=length($sequence);
           if($sequence=~/[DEFGHIKLMNPQRSTVWY]+/i){
               $out_file_name="$base\_$accession_no.spfa";
           }elsif($sequence=~/^[ATGCU]+$/i){
               $out_file_name="$base\_$accession_no.snfa";
           }
           open(FASTA, ">$out_file_name") || die "\nCan not open $out_file_name\n\n";
           print FASTA "\>$genbank{$accession_no}{'seq_name'} $seq_leng bp\n";
           for($j=0; $j< $seq_leng; $j+= $block_size){
              print FASTA substr($sequence, $j, $block_size), "\n";
           }
           close(FASTA);
           if(-s $out_file_name){  push(@fasta_files, $out_file_name); }else{ die "\nERROR \n"; }
       }
    }
    return(\@fasta_files);
}



#______________________________________________________________________________
# Title     : convert_MRCS_to_MSP_format
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
#    $get_Forward_search_scores=F by F
#    $get_Backward_search_scores=B by B
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub convert_MRCS_to_MSP_format{
    my(%MRCS_hash, $i, $MRCS_file, $query_seq, $target_seq, $openning_gap_penalty,
       $elongation_gap_penalty, $algorithm, $ForBackScore, $ForScore, $mspa_line,
       $BackScore, $MutualSeqID, $Alignment_leng, $sorted_paired_seqs,
       @sorted_paired_seqs, $read_point_found, $query_range_start,
       $query_range_stop, $match_string_start, $match_string_stop,
       %MSP_hash, $wanted_score_type, $get_Backward_search_scores);
    $read_point_found=1;

    %MRCS_hash=%{$_[0]};
    $get_Forward_search_scores='F' if $_[1]=~/F/;
    $get_Backward_search_scores='B' if $_[2]=~/B/;

    if($get_Forward_search_scores and $get_Backward_search_scores){
        $get_Forward_search_scores=$get_Backward_search_scores='';
    }

    @sorted_paired_seqs=sort keys %MRCS_hash;
    for($i=0; $i< @sorted_paired_seqs; $i++){
        $sorted_paired_seqs=$sorted_paired_seqs[$i];
        $ForBackScore    =$MRCS_hash{$sorted_paired_seqs}{'ForBackScore'};
        $ForScore        =$MRCS_hash{$sorted_paired_seqs}{'ForScore'};
        $BackScore       =$MRCS_hash{$sorted_paired_seqs}{'BackScore'};
        $MutualSeqID     =$MRCS_hash{$sorted_paired_seqs}{'MutualSeqID'};
        $Alignment_leng  =$MRCS_hash{$sorted_paired_seqs}{'Alignment_leng'};
        $query_seq_align_range =$MRCS_hash{$sorted_paired_seqs}{'QUERY_SEQ_RANGE'};
        ($query_range_start, $query_range_stop)=$query_seq_align_range=~/^(\d+)\-(\d+)$/;
        $target_seq_align_range=$MRCS_hash{$sorted_paired_seqs}{'TARGET_SEQ_RANGE'};
        ($match_string_start, $match_string_stop)=$target_seq_align_range=~/^(\d+)\-(\d+)$/;
        $query_seq       =$MRCS_hash{$sorted_paired_seqs}{'QUERY_SEQ_NAME'};
        $target_seq      =$MRCS_hash{$sorted_paired_seqs}{'TARGET_SEQ_NAME'};

        if($get_Forward_search_scores){       $wanted_score_type=$ForScore
        }elsif($get_Backward_search_scores){  $wanted_score_type=$BackScore
        }else{ $wanted_score_type=$ForBackScore }

        $mspa_line=sprintf("%-6s %-8s %-5s %-5s %-5s %-32s %-5s %-s\t%-25s\t%-s\n",
                           $wanted_score_type, 0.0, $MutualSeqID, $query_range_start,
                           $query_range_stop, $query_seq, $match_string_start,
                           $match_string_stop, $target_seq, $read_point_found);
        $MSP_hash{$sorted_paired_seqs}=$mspa_line;

    }
    return(\%MSP_hash);
}




#______________________________________________________________________________
# Title     : concentrate_HSSP_seq_alignments
# Usage     :   %concentrated_seqs=%{&concentrate_seq_alignments(\%HSSP_align,
#                                                 \$upper_concentration_threshold,
#                                                 \$lower_concentration_threshold)};
# Function  :
# Example   : INPUT: $HSSP_align{$seq_ids[$i]}{$names[$j]}
#
# Keywords  : dilute_sequence_alignments, concentrate_sequence_alignment
#             concentrate_seq_alignments, HSSP
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub concentrate_seq_alignments{
    my(%Alignment, $i, $j, @seq_ids, @seq_names, $upper_concentration_threshold,
       $mutual_seq_id, %Concentrated_seq_HASH, $lower_concentration_threshold);
    $upper_concentration_threshold=60;
    $lower_concentration_threshold=20;

    %Alignment=%{$_[0]};
    $upper_concentration_threshold=${$_[1]};
    $lower_concentration_threshold=${$_[2]};
    @seq_ids=sort {$a<=>$b} keys %Alignment;

    for($i=0; $i< @seq_ids; $i++){
        my($NOT_chosen);
        $seq_number_id=$seq_ids[$i];
        ($seq_name, $each_sequence) = %{$Alignment{$seq_number_id}};
        @each_sequence_residues=split(//, $each_sequence);
        @concentrated_seqs=keys %Concentrated_seq_HASH;
        if(!@concentrated_seqs){
            $Concentrated_seq_HASH{$seq_name}=$each_sequence;
            next;
        }else{
            for($j=0; $j< @concentrated_seqs; $j++){
                $already_chosen_seq_name=$concentrated_seqs[$j];
                $already_chosen_sequence=$Concentrated_seq_HASH{$already_chosen_seq_name};
                $mutual_seq_id=${&get_seq_identity({$seq_name,
                                                    $each_sequence,
                                                    $already_chosen_seq_name,
                                                    $already_chosen_sequence})};
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # Select the sequence which has appropriate seq. id. here
                #_______________________________________________________________
                if($mutual_seq_id > $upper_concentration_threshold or $mutual_seq_id < $lower_concentration_threshold ){
                   $NOT_chosen=1;
                   last;
                }
            }
            unless($NOT_chosen){
                $Concentrated_seq_HASH{$seq_name}=$each_sequence;
            }
        }
    }
    return(\%Concentrated_seq_HASH);
}



#______________________________________________________________________________
# Title     : convert_sec_str_to_binary_pattern
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub convert_sec_str_to_binary_pattern{
		my (%ss_pattern_table);

		%ss_pattern_table
			 = (
					'H', '1 0 0',
					'E', '0 1 0',
					'C', '0 0 1',
				 );
		 return(\%ss_pattern_table);
}



#__________________________________________________________________
# Title     : make_sequence_match_table
# Usage     : %sequence_match_table=%{&make_sequence_match_table(\%mspa_1, \%mspa2)};
# Function  : makes a table of match with the values for E values.
# Example   :
#
#  INPUT looks like this: (the iss file format), first column is key
#
#   d1ten__(110)(0.00031)     d1fna__    d1fna___1-91(578)(6.9e-37)       d1ten__(110)(0.00031)
#   d1cfb_2(255)(7.8e-16)     d1cfb_2    HSU55258_741-838(255)(5.6e-12)   d1cfb_2(255)(7.8e-16)
#
#  OUTPUT looks like the following;
#   d1dvh__=d1fcdc1    Correct: 7.1e-08
#	d1fcdc1=d1dvh__    Correct: 7.1e-08
#	d5cytr_=d351c__    Correct: 5.3e-08
#	d351c__=d5cytr_    Correct: 5.3e-08
#	d1cyi__=d2mtac_    Wrong:   9.1e-06
#
# Keywords  : make_sequence_match_Evalue_table, Evalue_table, make_Evalue_table
#             make_iss_sequence_match_table
# Options   : _  for debugging.
#             #  for debugging.
#             s  for skip SELF to SELF match entries
#             w  for Smith-Waterman score result out than E value out
#             r  for reflexive output
#
# Reference : http://sonja.acad.cai.cam.ac.uk/perl_for_bio.html
# Returns   :
# Argument  :
# Category  :
# Version   : 1.5
#-------------------------------------------------------------------------------
sub make_sequence_match_table{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%iss_input)= %{$hash[0]};
	my(%final_table_Evalue, %final_table_score, $inter_seq_seq_name, $inter_seq_score,
	   $inter_seq_E_value, $match_seq_seq_name, $match_seq_score, $match_seq_E_value, $key_seq,
	   $each_iss_line, $all_enquiry_seqs, $name_combi1, $name_combi2, @sorted_names, $name_sorted,
	   %final_table_interm_and_matched_score, %final_table_interm_and_matched_Evalue, %scop_bugs);
	@iss_lines = sort values %iss_input;

	if($char_opt=~/v/){ print "\n# make_sequence_match_table: \$char_opt is $char_opt\n" ; }

	if($char_opt=~/r/){ $non_reflexive=0;
	}else{    $non_reflexive=1; } # default , not to print result in two ways

	if(@array > 0){ ## When the names of enquiry was given as an array, use it!
						$all_enquiry_seqs=join(' ', sort @{$array[0]} );
	}else{    ## otherwise, detect yourself.
						for($i=0; $i< @iss_lines; $i++){
							 $each_iss_line=$iss_lines[$i];
							 if($each_iss_line=~/^\s*(\S+)\s+/){  $all_enquiry_seqs{$1}++;             }
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# $all_enquiry_seqs contains all the sequences in the group
						#____________________________________________________________________
						$all_enquiry_seqs=join(' ', sort keys %all_enquiry_seqs );
	}

	for($i=0; $i< @iss_lines; $i++){
	   my $each_iss_line=$iss_lines[$i];
	   if($each_iss_line=~/^\s*(\S+)\s+(\S+)\((\d+)\)\((\S+)\)\s+(\S+)\((\d+)\)\((\S+)\)/){
		  $key_seq=$1;
		  $inter_seq_seq_name= $2;
		  $inter_seq_score   = $3;
		  $inter_seq_E_value = $4;
		  $match_seq_seq_name= $5;
		  $match_seq_score   = $6;
		  $match_seq_E_value = $7;
		  if( $key_seq eq $match_seq_seq_name and $char_opt=~/s\s*/ ){ next } ## avoiding self self match
		  @sorted_names=sort ($1, $match_seq_seq_name);
		  $name_combi1="$1\=$match_seq_seq_name";
		  $name_combi2="$match_seq_seq_name\=$1";
		  $name_sorted="$sorted_names[0]\=$sorted_names[1]";
		  if($all_enquiry_seqs !~/$match_seq_seq_name/){
											if($non_reflexive){
															$false_positive_matches{$name_sorted}="$inter_seq_score $inter_seq_E_value : $match_seq_score $match_seq_E_value";
											}else{
															$false_positive_matches{$name_combi1}="$inter_seq_score $inter_seq_E_value : $match_seq_score $match_seq_E_value";
											}
											next;
		  }elsif($final_table_score{$name_combi1} < $inter_seq_score or
		      $final_table_score{$name_combi2} < $inter_seq_score or
		      $final_table_score{$name_sorted} < $inter_seq_score){
											$final_table_score{$name_combi1}=$inter_seq_score;
											$final_table_score{$name_combi2}=$inter_seq_score;
											$final_table_Evalue{$name_combi1}=$inter_seq_E_value;
											$final_table_Evalue{$name_combi2}=$inter_seq_E_value;

											if($non_reflexive){
													$final_table_interm_and_matched_score{$name_sorted} = "$inter_seq_score $match_seq_score";
													$final_table_interm_and_matched_Evalue{$name_sorted} = "$inter_seq_E_value $match_seq_E_value";
											}else{
													$final_table_interm_and_matched_score{$name_combi1} = "$inter_seq_score $match_seq_score";
													$final_table_interm_and_matched_score{$name_combi2} = "$inter_seq_score $match_seq_score";
													$final_table_interm_and_matched_Evalue{$name_combi1} = "$inter_seq_E_value $match_seq_E_value";
													$final_table_interm_and_matched_Evalue{$name_combi2} = "$inter_seq_E_value $match_seq_E_value";
											}
		  }
	   }
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# printing out to screen
	#__________________________________________________________
	if($char_opt =~/w/){ ## returning Smith-waterman score than E value
	   @keys = sort keys %final_table_interm_and_matched_Evalue;
	   for $key (@keys){
							 if($key =~/\S+/){
											printf ("\n%-30s Correct: %-50s",  $key, $final_table_interm_and_matched_Evalue{$key});
							 }
	   }
	}else{
	   @keys = sort keys %final_table_interm_and_matched_score;
	   for $key (@keys){
							 if($key =~/\S+/){
											printf ("\n%-30s Correct: %-50s",  $key,  $final_table_interm_and_matched_score{$key});
							 }
	   }
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# Writing the false positives
	#__________________________________
	@keys_false=sort keys %false_positive_matches;
	#print "\n\n# False positives: " if @keys_false > 0;
	for $key_false (@keys_false){
	   if($key_false =~/\S+/){
	      if($scop_bugs{$key_false}){
	          printf ("\n%-30s Correct: %-50s",  $key_false,  $false_positive_matches{$key_false});
	      }else{
			  printf ("\n%-30s Wrong:   %-50s",  $key_false,  $false_positive_matches{$key_false});
		  }
		  %scop_bugs=qw(d2kauc1=d2kauc  1 d1pkya2=d1pkya1 1 d1pbe_1=d1pbe_2 1
																d1dih_1=d1dih_2 1 d2ohxa2=d2ohxa1 1 d1poxa3=d1pvda2 1
																d1efga1=d1efga2 1 d1bct__=d1brd__ 1 d1qora1=d1qora2 1
																d2ohxa1=d2ohxa2 1);
	   }
	}
	print "\n";

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Returning the hash result
	#_____________________________________
	if($char_opt =~/w/){ ## returning Smith-waterman score than E value
	   return(\%final_table_interm_and_matched_score);
	}else{
	   return(\%final_table_interm_and_matched_Evalue);
	}
}



#__________________________________________________________________
# Title     : write_iss_file
# Usage     : &write_iss_file(\%mspa1, \%mspa2);  ## for 2 mspa_x file input
# Function  : writes the intermediate sequence search file.
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : write_interm_seq_search_file
#             v  for showing the output in STDOUT
# Reference : http://sonja.acad.cai.cam.ac.uk/perl_for_bio.html
# Category  :
# Version   : 1.2
#---------------------------------------------------------------------------
sub write_iss_file{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my(%mspa_1, %mspa_2, %merged_1, %merged_2);

	 %mspa_1=%{$hash[0]};
	 %mspa_2=%{$hash[1]};

	 @mspa1_keys=sort keys  %mspa_1;
	 @mspa2_keys=sort keys  %mspa_2;

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
	 # removing the empty matches and merging matches according to the enquiry seqs.
	 #  Following input will become;
	 # ..
	 # xxxxx
	 # xxxxx  YYYYY(xx)(yy)
	 # xxxxx  zzzzz(xx)(yy) ttttt(xx)(yy)
	 # ..
	 #  ->  xxxxx  'YYYYY(xx)(yy) zzzzz(xx)(yy) ttttt(xx)(yy)'
	 #____________________________________________________________________________________
	 for($i=0; $i< @mspa1_keys; $i++){
						 $enquiry_seq = $mspa1_keys[$i];
						 #my ($seq_name,  $sw_score, $evalue)=$enquiry_seq=~/(\S+)\((\S+)\)\((\S+)\)/;

						 #-- if $mspa_1{$enquiry_seq} is not empty, assigns name, score, evalue etc to vars, or next
						 if($mspa_1{$enquiry_seq}=~/\S+/){
										($seq_name, $sw_score, $evalue)=$enquiry_seq=~/(\S+)\((\S+)\)\((\S+)\)/;
										 $merged_mspa1{$seq_name} .=$mspa_1{$enquiry_seq};
						 }else{
										next;
						 }
	 }
	 for($i=0; $i< @mspa2_keys; $i++){
						 $enquiry_seq = $mspa2_keys[$i];

						 #-- if $mspa_2{$enquiry_seq} is not empty, assigns name, score, evalue etc to vars, or next
						 if($mspa_2{$enquiry_seq}=~/\S+/){
										 $merged_mspa2{$enquiry_seq} .=$mspa_2{$enquiry_seq};
						 }else{
										next;
						 }
	 }

	 @merged_mspa1_keys=sort keys  %merged_mspa1;
	 @merged_mspa2_keys=sort keys  %merged_mspa2;

	 for($i=0; $i< @merged_mspa1_keys; $i++){
	  $enquiry_seq=$merged_mspa1_keys[$i];
	  @intermediate_seqs=sort split(/\s+/, $merged_mspa1{$enquiry_seq});
	  for($j=0; $j< @intermediate_seqs; $j++){

		 $intermediate_seq=$intermediate_seqs[$j];

		 ($inter_seq_name, $sw_score, $evalue)=$intermediate_seq=~/(\S+)\((\S+)\)\((\S+)\)/;
		 @final_matches=sort split(/\s+/,  $merged_mspa2{$inter_seq_name});
		 for($k=0; $k < @final_matches; $k ++){
		     $final_matched_seq = $final_matches[$k];
		     if($char_opt=~/v/){
			 printf ("%-18s %-40s %-38s\n", $enquiry_seq, $intermediate_seq, $final_matched_seq);
		     }
		     $final_out{$final_matched_seq}=
	             sprintf ("%-18s %-40s %-38s\n", $enquiry_seq, $intermediate_seq, $final_matched_seq);
		 }
		 #print "\n";
	  }
	  #print "\n";
	 }
	 #print "\n";
	 return(\%final_out);
}

#______________________________________________________________________________
# Title     : get_perl_keywords
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_perl_keywords{
		my(%perl_keywords);
		my @keywords=qw( AUTOLOAD BEGIN CORE DESTROY END abs accept alarm and atan2 bind binmode bless caller chdir chmod chop chown chr chroot
			 close closedir cmp connect continue cos crypt dbmclose dbmopen defined delete die do dump each else elsif endgrent endhostent endnetent endprotoent endpwent endservent
			 eof eq eval exec exit exp fcntl fileno flock for foreach fork format formline ge getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin
			 getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname
			 getservbyport getservent getsockname getsockopt glob gmtime goto grep gt hex if index int ioctl join keys kill last lc lcfirst le length link listen local localtime log lstat
			 lt m mkdir msgctl msgget msgrcv msgsnd my ne next no not oct open opendir or ord pack package pipe pop print printf push q qq quotemeta qw qx rand read readdir readline
			 readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir s scalar seek seekdir select
			 semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift
			 shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat
			 study sub substr symlink syscall sysread system syswrite tell telldir tie time times tr truncate uc ucfirst
			 umask undef unless unlink unpack unshift untie until use utime values vec wait waitpid wantarray
			 warn while write x xor y
		 );
		 foreach(@keywords){
				$perl_keywords{$_}=$_;
		 }
		 return(\%perl_keywords);
}




#______________________________________________________________________________
# Title     :  get_homology_info_of_seq_pairs
# Usage     :
# Function  :
# Example   : %seq_pair_homology_table=%{&get_homology_info_of_seq_pairs(\%pairs_excluded,
#                                         \%pdbg_hash_table)};
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_homology_info_of_seq_pairs{
	 my($i, %pairs_to_be_checked,%seq_pairs_homology_table, @pairs,
			$homology_info, %pdbg_hash_table);
	 for($i=0; $i< @_; $i++){
			my %in_hash=%{$_[$i]};
			my @seq_names=keys %in_hash;
			if($in_hash{$seq_names[0]}=~/^\S+\s+\S+$/){
					%pairs_to_be_checked=%in_hash; %in_hash=();
			}elsif($in_hash{$seq_names[0]}=~/^\S+$/){
					%pdbg_hash_table=%in_hash; %in_hash=();
			}
	 }

	 @pairs=keys %pairs_to_be_checked;

	 for($i=0; $i< @pairs; $i++){
			if($pairs[$i]=~/^(\S+)\s+(\S+)/){
					$homology_info=${&check_homology_of_seq_pair(\$pairs[$i], \%pdbg_hash_table)};
					$seq_pairs_homology_table{$pairs[$i]}=$homology_info;
					print "\n#>> $pairs[$i] $homology_info" if $verbose;
			}
	 }
	 return(\%seq_pairs_homology_table);
}

#______________________________________________________________________________
# Title     : get_sequence_region_distance
# Usage     : $range_distance=${&get_sequence_region_distance(\@range)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_sequence_region_distance{
    my(@ranges, $range_1_stop, $range_2_start, $distance);
    @ranges=@{$_[0]};
    @ranges= map {$_->[0]} sort { $a->[1] <=> $b->[1] } map {/(\d+)\-\d+/ && [$_, $1] } @ranges;
    $ranges[0]=~/\d+\-(\d+)/;
    $range_1_stop=$1;
    $ranges[1]=~/(\d+)\-\d+/;
    $range_2_start=$1;
    $distance=$range_2_start-$range_1_stop;
    return(\$distance);
}



#________________________________________________________________________________
# Title     : get_sequence_overlap_size
# Usage     : $ovlapsize=${&get_sequence_overlap_size($st1, $en1, $st2, $en2)
# Function  :
# Example   :
# Keywords  : CF: get_overlapping_range, get_overlapping_seq_match
#             get_sequence_overlap_size, get_overlap_size, check_overlap_size
#             check_sequence_overlap_size
# Options   :
# Category  :
# Author    : jong@biosophy.org
# Version   : 1.1
#--------------------------------------------------------------------------------
sub get_sequence_overlap_size{
    my($start1, $end1, $start2, $end2, $overlapping_region_matched);
    if(@_ == 4){  $start1=$_[0]; $end1 =$_[1];  $start2=$_[2]; $end2  =$_[3];
    }elsif(@_==2){
        if( $_[0]=~/(\d+)\-(\d+)/ ){
              $start1=$1;      $end1  =$2;
        }elsif($_[1]=~/(\d+)\-(\d+)/ ){
              $start2=$1;      $end2  =$2;
        }else{print "\n# (ERROR) get_overlapping_seq_match_size: I need 2 or 4 arguments for regions\n";
              print "   They look like ($start1, $end1, $start2, $end2) or ('10-100', '20-211')\n";
              print "   You got it, Sarah?? Try again my dear!\n";
        }
    }else{    print "\n# (ERROR) get_overlapping_seq_match_size: I need 2 or 4 arguments for regions\n";
              print "   They look like ($start1, $end1, $start2, $end2) or ('10-100', '20-211')\n";
              print "   You got it, Sarah?? Try again my dear!\n";
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #     ---------
    #  ------
    #___________________________________
    if($start1 >= $start2 and $end1 >= $end2){  $overlapping_region_matched=$end2-$start1;  }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # ---------
    #     ----------
    #___________________________________
    elsif($start1 <= $start2 and $end1 <= $end2){ $overlapping_region_matched=$end1-$start2;}
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #      -----
    #    ----------
    #___________________________________
    elsif($start1 >= $start2 and $end1 <= $end2){ $overlapping_region_matched=$end1-$start1;}
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  ---------
    #    ----
    #___________________________________
    elsif($start1 <= $start2 and $end1 >= $end2){ $overlapping_region_matched=$end2-$start2;}
    return(\$overlapping_region_matched);
}


#________________________________________________________________________________
# Title     : get_overlapping_seq_match_size
# Usage     : $ovlapsize=${&get_overlapping_seq_match_size($st1, $en1, $st2, $en2)
# Function  :
# Example   :
# Keywords  : CF: get_overlapping_range, get_overlapping_seq_match
#             get_sequence_overlap_size, get_overlap_size, check_overlap_size
#             check_sequence_overlap_size
# Options   :
# Category  :
# Author    : jong@biosophy.org
# Version   : 1.1
#--------------------------------------------------------------------------------
sub get_overlapping_seq_match_size{
    my($start1, $end1, $start2, $end2, $overlapping_region_matched);
    if(@_ == 4){  $start1=$_[0]; $end1 =$_[1];  $start2=$_[2]; $end2  =$_[3];
    }elsif(@_==2){
        if( $_[0]=~/(\d+)\-(\d+)/ ){
              $start1=$1;      $end1  =$2;
        }elsif($_[1]=~/(\d+)\-(\d+)/ ){
              $start2=$1;      $end2  =$2;
        }else{print "\n# (ERROR) get_overlapping_seq_match_size: I need 2 or 4 arguments for regions\n";
              print "   They look like ($start1, $end1, $start2, $end2) or ('10-100', '20-211')\n";
              print "   You got it, Sarah?? Try again my dear!\n";
        }
    }else{    print "\n# (ERROR) get_overlapping_seq_match_size: I need 2 or 4 arguments for regions\n";
              print "   They look like ($start1, $end1, $start2, $end2) or ('10-100', '20-211')\n";
              print "   You got it, Sarah?? Try again my dear!\n";
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #     ---------
    #  ------
    #___________________________________
    if($start1 >= $start2 and $end1 >= $end2){  $overlapping_region_matched=$end2-$start1;  }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # ---------
    #     ----------
    #___________________________________
    elsif($start1 <= $start2 and $end1 <= $end2){ $overlapping_region_matched=$end1-$start2;}
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #      -----
    #    ----------
    #___________________________________
    elsif($start1 >= $start2 and $end1 <= $end2){ $overlapping_region_matched=$end1-$start1;}
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  ---------
    #    ----
    #___________________________________
    elsif($start1 <= $start2 and $end1 >= $end2){ $overlapping_region_matched=$end2-$start2;}
    return(\$overlapping_region_matched);
}

#______________________________________________________________________________
# Title     : get_username
# Usage     : $user_name=${&get_username};
# Function  :
# Example   :
# Keywords  : get_login_name
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub get_username{
    my $who = getpwuid($>);
    return(\$who);
}

#______________________________________________________________________________
# Title     : get_unix_shell_name
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org, On commercial use issue, Email me.
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_unix_shell_name{
		my($shell_env);
		if($ENV{'SHELL'}=~/\/(\w+)$/ or $ENV{'SHELL'}=~/(\w+)$/){
				$shell_env=$1
		}else{
				print "\n# (ERROR) SHELL env setting is not on, I can not give you SHELL type\n";
				die;
		}
		return(\$shell_env);
}


#______________________________________________________________________________
# Title     : get_stat_FASTA_search_result_in_mspa_0_files
# Usage     : &get_stat_FASTA_search_result_in_mspa_0_files(\@file);
# Function  :
# Example   :
# Keywords  : get_stat00_result, get_stat_mspa0_files, get_stat_single_search_result
# Options   :
#
#  $E_value= by e=
#  $verbose=v by v
#  $show_options=o by o
#  $step   =  by s=
#  $score_thresh1=   by t1=
#  $score_thresh2=   by t2=
#  $E_mult_factor1 = by m1=
#  $E_mult_factor2 = by m2=
#
# Category  : statistics, search, bio
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_stat_FASTA_search_result_in_mspa_0_files{
		my($num_enq_seq, $pdbg_file, %input_file_base, $score_thresh1, $score_thresh2,
				$E_mult_factor1, $E_mult_factor2, @seqs, @pdbg_seqs, @MSP0, @array,
				$E_value, %final_stat_big_hash, @bases, $i, $j, $k);
		my $leng_thresh=10;
		$score_thresh1 = 73;
		my $simple_pdbg_read_opt='b';
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Arguments handling
		#_____________________________________
		for($i=0; $i< @_; $i++){
			 if($_[$i]=~/e=(\S+)/){          $E_value=$1;
					splice(@_, $i, 1); $i--;
			 }elsif(ref($_[$i]) eq 'ARRAY'){
					 @array=@{$_[$i]};
					 for($j=0; $j < @array; $j++){
							 if($array[$j]=~/(\S+)\.pdbg$/){         $input_file_base{$1}=$1;
							 }elsif($array[$j]=~/(\S+)\.mspa_?0$/){   $input_file_base{$1}=$1;
							 }
					 }
			 }elsif($_[$i]=~/(\S+)\.pdbg$/){
					 $input_file_base{$1}=$1;
			 }elsif($_[$i]=~/(\S+)\.mspa_?0$/){
					 $input_file_base{$1}=$1;
			 }elsif($_[$i]=~/m1=(\S+)/){          $E_mult_factor1=$1;
					splice(@_, $i, 1); $i--;
			 }elsif($_[$i]=~/m2=(\S+)/){          $E_mult_factor2=$1;
					splice(@_, $i, 1); $i--;
			 }elsif($_[$i]=~/t1=(\S+)/){          $score_thresh1=$1;
					splice(@_, $i, 1); $i--;
			 }elsif($_[$i]=~/t2=(\S+)/){          $score_thresh2=$1;
					splice(@_, $i, 1); $i--;
			 }elsif($_[$i]=~/o=(\S+)/){          $show_options=$1;
					splice(@_, $i, 1); $i--;
			 }
		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Handling options
		#_________________________________
		if($E_value=~/^\s*$/){
			 $E_value=5;
			 print "\n# WARNING: you did not set 'e=x.xxx' option default $E_value used\n";
		}
		if($E_mult_factor1 !~/\S/){  $E_mult_factor1 =1; }
		if($E_mult_factor2 !~/\S/){  $E_mult_factor2 =1; }
		if($show_options=~/o/){
			 print "\n#---- \$step          : $step";
			 print "\n#---- \$score_thresh1 : $score_thresh1";
			 print "\n#---- \$score_thresh2 : $score_thresh2\n";
		}


		@bases=keys %input_file_base;
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Main loop
		#__________________________________________
		for($i=0; $i< @bases; $i++){
				my(%mspa_0, %mspa_00, $score, $evalue, $enquiry, @keys0, @keys2, $j,
					 %stat, %stat2, $sum_correct, $sum_false, @non_dup, $base, $pdbg_file,
					 @seqs, @pdbg_seqs, $mspa_0_file, @MSP0, @keys, $k, %correct );
				$base=$bases[$i];
				$pdbg_file ="$base\.pdbg";
				$mspa_0_file="$base\.mspa0";
				print "\n# $base $pdbg_file $mspa_0_file\n" if $verbose;

				unless(-s $pdbg_file or -s $mspa_0_file){
					 print "\n", __LINE__, "# file is missing. I need xxx.pdbg, xxx.mspa_0\n\n";
				}

				@seqs=@pdbg_seqs= keys %{&open_pdbg_files($pdbg_file, $simple_pdbg_read_opt)};

				if(@pdbg_seqs < 2){
					 print "\n# too little sequneces @pdbg_seqs $pdbg_file\n";
					 die;
				}

				print "\n# Result of open_pdbg_files, \@seqs are        : @seqs \n" if $verbose;
				open(MSP0, "$mspa_0_file");
				@MSP0=<MSP0>;
				close(MSP0);

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# opening each mspa0 file
				#______________________________________
				for(@MSP0){
						if(/^(\S+)\s+(\S+)\s+\S*\s*(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
								# Length checking
								#__________________________________________________
								$seq_leng1=$4-$3;
								$seq_leng2=$7-$6;
								if($seq_leng1 < $leng_thresh or $seq_leng2 < $leng_thresh){
									 if($verbose){
											 print "\n# LENG $seq_leng1, $seq_leng2: $seq_leng1 $seq_leng2  $5 => $8 $1 $2 skipping\n";
											 next;
									 }
								}

								$score=$1;
								$evalue=$2;
								$enquiry=$5;
								$match_seq=$8;
								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								#  Evalue checking
								#__________________________________________________
								if($evalue > $E_value ){
										if($enquiry=~/^(\S+)_\d+\-\d+/){
											 $mspa_0{"$1"} ="" unless $mspa_0{"$1"};
											 next;
										}else{
											 $mspa_0{"$enquiry"} ="" unless $mspa_0{"$enquiry"};;
											 next;
										}
								}

								if($score < $score_thresh1){     next;     }
								if($enquiry=~/^(\S+)_\d+\-\d+/){
										$mspa_0{"$1"} .="$match_seq ";
								}else{
										$mspa_0{"$enquiry"} .="$match_seq ";
										$mspa_00{join(' ', sort($enquiry, $match_seq))} = " $score $evalue";
								}
						}
				}
				%stat=%mspa_0;

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				# filtering duplicates
				#____________________________________________
				@keys=keys %stat;
				for($k=0; $k< @keys; $k++){
						@split=split(/\s+/,$stat{$keys[$k]});
						@non_dup=@{&remove_dup_in_array(\@split)};
						for($j=0; $j<@non_dup; $j++){
								if($non_dup[$j]=~/^\s*$/){
										splice(@non_dup, $j, 1);       $j--;
										next;
								}
								if($non_dup[$j] eq $keys[$k]){
										splice(@non_dup, $j, 1);       $j--;
										next;
								}
						}
						$stat2{$keys[$k]}=join(' ', @non_dup);
				}

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# Showing the actual matched sequences
				# %stat has following contents
				#    d1ash__ d1bam__ d1mba__ d2lhb__
				#    d1baba_ d1flp__ d1hbg__ d1hlb__ d1mba__ d1mbd__ d2lhb__ d3aaha_ d3sdha_
				#    d1cpca_ d1cpcb_ d1gof_1 d2ts1_1
				#______________________________________________________________________________
				if($verbose=~/v/){
					 @keys= sort keys %stat2;
					 for($k=0; $k< @keys; $k++){
							print "$keys[$k]: $stat2{$keys[$k]}\n";
					 }
				}

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# Getting statistics
				#_________________________________________
				$evalue=$s;
				$E_mult_factor1=1;
				@output=@{&get_isearch_result_stat(\%stat2, \@pdbg_seqs, \$evalue,
									\$base, \$E_mult_factor1,  $leng_thresh, \%mspa_00)};
				%correct=%{$output[3]};
				%final_stat_big_hash=(%final_stat_big_hash, %correct);
				if($verbose){
						@keys=sort keys %correct;
						for($k=0; $k< @keys; $k++){
							 print "$keys[$k] $correct{$keys[$k]}\n";
						}
				}
		}
		return(\%final_stat_big_hash);
}


#________________________________________________________________________________
# Title     : get_scop_correcting_pairs
# Usage     : %correct=%{&get_scop_correcting_pairs()};
# Function  :
# Example   :
# Keywords  : get_pdb_correcting_pairs , correct_pairs_in_scop, correct_homology_pairs
# Options   :
# Category  :
# Version   : 1.4
#--------------------------------------------------------------------------------
sub get_scop_correcting_pairs{
		my (%correcting_pairs, @correcting_pairs);

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# %correcting_pairs is a correcting table for old pdb40d file classi
		#_____________________________________________________________________
		@correcting_pairs=(  # should be pairs
				'd2kauc1 d2kauc2', 'd1pkya1 d1pkya2',
				'd1pvda2 d1trka1', 'd1pbe_1 d1pbe_2',
				'd1poxa3 d1pvda2', 'd1efga1 d1efga2',
				'd1dsba1 d1dsba2', 'd2gsta1 d2gsta2',
				'd1bct__ d1brd__', 'd1qora1 d1qora2',
				'd2ohxa1 d2ohxa2', 'd1efga2 d1eft_1',
				'd1tada1 d1tada2', 'd1gsea1 d1gsea2',
				'd1gesa2 d2tmda3', 'd1lvl_2 d2tmda3',
				'd2tmda3 d2tpra2', 'd1tde_1 d2tmda3',
				'd1nhp_2 d2tmda3', 'd1gesa1 d2tmda3',
				'd1lvl_1 d2tmda3', 'd2tmda3 d2tpra1',
				'd1fcda1 d2tmda3', 'd1nhp_1 d2tmda3',
				'd1tde_2 d2tmda3', 'd1pbe_1 d2tmda3',
				'd1ebha1 d1ebha2', 'd1gesa2 d2dlda2', ## 3.4.1  with
				'd1gesa2 d1psda2', 'd1nhp_2 d2dlda2',
				'd1ldm_1 d1tde_2', 'd1coy_1 d1ldb_1',
				'd1lvl_2 d1psda2', 'd1psda2 d1tde_2',
				'd1hyha1 d1tde_2', 'd1fcda1 d1ldm_1',
				'd1hdca_ d1nhp_2', 'd1fcda1 d1hlpa1',
				'd1llda1 d1lvl_2', 'd2dlda2 d2tpra2',
				'd1ldm_1 d1nhp_2', 'd1llda1 d1pbe_1',
				'd1gdha2 d2tpra1', 'd1ldb_1 d1nhp_2',
				'd1gesa2 d1scua2', 'd1fcda1 d1hyha1',
				'd1gesa1 d1hlpa1', 'd1gdha2 d1gesa2',
				'd1lvl_2 d2dlda2', 'd1gesa1 d2dlda2',
				'd1nhp_2 d2ohxa2', 'd1tde_2 d2dlda2', # 3.4.1. with 3.18.1, 3.17.1.
				'd1nhp_1 d2cmd_1', 'd1fcda1 d1ldb_1',
				'd1lvl_1 d2ohxa2', 'd1nhp_2 d2naca2',
				'd1pbe_1 d2ohxa2', 'd1gdha2 d1nhp_2',
				'd2cmd_1 d2tpra1', 'd1tde_1 d2cmd_1',
				'd1llda1 d1nhp_2', 'd1hlpa1 d1nhp_2',
				'd1nhp_1 d2dlda2', 'd1hyha1 d1nhp_2',
				'd1nhp_2 d1psda2', 'd1fcda1 d2cmd_1',
				'd1fcda1 d1llda1', 'd1lvl_2 d1udpa_',
				'd1psda2 d2tpra2', 'd1hdca_ d1lvl_2',
				'd1gesa2 d1llda1', 'd1nhp_2 d1qora2',
				'd1ldm_1 d2tpra1', 'd1coy_1 d2dlda2',
				'd2dlda2 d2tpra1', 'd1hdca_ d1pbe_1',
				'd1coy_1 d1gdha2', 'd1nhp_2 d2cmd_1',
				'd1llda1 d1tde_1', 'd1llda1 d1lvl_1',
				'd1bdma1 d2tpra1', 'd1gd1o1 d2tpra2',
				'd1ldb_1 d1lvl_1', 'd1hlpa1 d1tde_2',
				'd1coy_1 d1psda2', 'd1nhp_2 d1udpa_',
				'd1llda1 d1tde_2', 'd1tde_2 d2cmd_1',
				'd1llda1 d2tpra2', 'd1ldb_1 d1tde_1',
				'd1coy_1 d1hlpa1', 'd1coy_1 d2cmd_1',
				'd1bdma1 d1gesa2', 'd1hyha1 d2tpra2',
				'd1gesa2 d1hyha1', 'd1gesa2 d2ohxa2',
				'd1ldb_1 d1tde_2', 'd1hlpa1 d1pbe_1',
				'd1ldm_1 d2tpra2', 'd2ohxa2 d2tpra1',
				'd1ldb_1 d2tpra2', 'd1gesa2 d1ldm_1',
				'd1lvl_2 d1qora2', 'd1gesa1 d2naca2',
				'd1coy_1 d1llda1', 'd1coy_1 d1hyha1',
				'd1coy_1 d1ldm_1', 'd1ldm_1 d1lvl_2',
				'd1eny__ d1nhp_2', 'd1pbe_1 d2pgd_2',
				'd1ldb_1 d1pbe_1', 'd1ldb_1 d1lvl_2',
				'd1gesa2 d1hlpa1', 'd1dhr__ d1nhp_2',
				'd1hdca_ d1tde_1', 'd1gesa1 d1psda2',
				'd1pbe_1 d2cmd_1', 'd1tde_2 d1udpa_',
				'd1pbe_1 d2dlda2', 'd1hdca_ d1tde_2',
				'd1gesa2 d1ldb_1', 'd1psda2 d2tpra1',
				'd1gdha2 d1lvl_2', 'd1tde_1 d2dlda2',
				'd1ldm_1 d1pbe_1', 'd1pbe_1 d1scua2',
				'd1gesa1 d2ohxa2', 'd1lvl_2 d2naca2',
				'd1gd1o1 d1lvl_1', 'd1fvl__ d1kst__',
				'd1kst__ d2ech__', 'd1hsaa2 d1std__', ## d1hsaa.. is NOT homol, but to fix a problem in E_100_e_0.0005_j30_segged_2092
				'd1afp__ d1hfi__'
				);

		 for($i=0; $i< @correcting_pairs; $i++){
										 $correcting_pairs{$correcting_pairs[$i]}=$correcting_pairs[$i];
		 }
		 return(\%correcting_pairs);
}

#__________________________________________________________________
# Title     : get_isearch_result_stat
# Usage     : &get_self_isearch_stat(\%stat2, \@pdbg_seqs, \$evalue);
# Function  :
# Example   : Following input (hash eg: %stat2, input with the first word as key)
#              will become columnar output.
#
#    d1ash__ d1bam__ d1mba__ d2lhb__
#    d1baba_ d1flp__ d1hbg__ d1hlb__ d1mba__ d1mbd__ d2lhb__ d3aaha_ d3sdha_
#    d1cpca_ d1cpcb_ d1gof_1 d2ts1_1
#
#    Will become:
#      ....
#      d1ash__ d2lhb__ Homolog: G1   98 0.012
#      d1baba_ d1flp__ Homolog: G1   82 0.072
#      d1baba_ d1hbg__ Homolog: G1   79 0.13
#      d1baba_ d2lhb__ Homolog: G1   228 8e-12
#      d1baba_ d3aaha_ Nomolog: G1   74 2
#      d1baba_ d3sdha_ Homolog: G1   92 0.012
#      d1cola_ d1hbg__ Nomolog: G1   79 0.59
#      d1cpca_ d1cpcb_ Homolog: G1   176 4.9e-08
#      ....
#
# Keywords  : get_stat_interm_search, get_intermediate_search_stat
# Options   : _  for debugging.
#             #  for debugging.
# Package   : Bio
# Reference : http://sonja.acad.cai.cam.ac.uk/perl_for_bio.html
# Returns   : [$av_correct, $num_enq_seq]
# Tips      :
# Argument  :
# Todo      :
# Author    : A Scientist
# Category  :
# Version   : 2.2
#-----------------------------------------------------------------------------
sub get_isearch_result_stat{
	my (@keys, $num_enq_seq, @pdbg_seqs_ori, $c, $d, $i, %correct_pairs,
	    $sum_correct, $sum_false, $match_seq, $percent_correct, $correct, @correct,
	    $av_correct, $av_false, $actual_e_value, $correct_matched,
	    %correcting_pairs, @correcting_pairs, %correct);

	my %seqs=%{$_[0]};
	my @pdbg_seqs=@{$_[1]};
	my $evalue=${$_[2]};
	my $pdbg_base=${$_[3]} || $ARGV[3];
	my $E_mult_factor1=${$_[4]};
	my $E_mult_factor2=${$_[4]};
				if(ref($_[5])){  $leng_thresh =${$_[5]}  }else{ $leng_thresh=$_[5]; }
	my %mspa_0=%{$_[6]};
	my %mspa_00=%{$_[7]};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# %correcting_pairs is a correcting table for old pdb40d file classi
		#_____________________________________________________________________
		@correcting_pairs=(  # should be pairs
																'd2kauc1 d2kauc2',              'd1pkya1 d1pkya2',
																'd1pvda2 d1trka1',                              'd1pbe_1 d1pbe_2',
				'd1poxa3 d1pvda2',				'd1efga1 d1efga2',
				'd1dsba1 d1dsba2',				'd2gsta1 d2gsta2',
				'd1bct__ d1brd__',				'd1qora1 d1qora2',
				'd2ohxa1 d2ohxa2',				'd1efga2 d1eft_1',
				'd1tada1 d1tada2',				'd1gsea1 d1gsea2',
				'd1gesa2 d2tmda3',				'd1lvl_2 d2tmda3',
				'd2tmda3 d2tpra2',				'd1tde_1 d2tmda3',
				'd1nhp_2 d2tmda3',				'd1gesa1 d2tmda3',
				'd1lvl_1 d2tmda3',				'd2tmda3 d2tpra1',
				'd1fcda1 d2tmda3',				'd1nhp_1 d2tmda3',
				'd1tde_2 d2tmda3',				'd1pbe_1 d2tmda3',
				'd1ebha1 d1ebha2',				'd1gesa2 d2dlda2', ## 3.4.1  with 3.15.1
				'd1gesa2 d1psda2',				'd1nhp_2 d2dlda2',
				'd1ldm_1 d1tde_2',				'd1coy_1 d1ldb_1',
				'd1lvl_2 d1psda2',				'd1psda2 d1tde_2',
				'd1hyha1 d1tde_2',				'd1fcda1 d1ldm_1',
				'd1hdca_ d1nhp_2',				'd1fcda1 d1hlpa1',
				'd1llda1 d1lvl_2',				'd2dlda2 d2tpra2',
				'd1ldm_1 d1nhp_2',				'd1llda1 d1pbe_1',
				'd1gdha2 d2tpra1',				'd1ldb_1 d1nhp_2',
				'd1gesa2 d1scua2',        'd1fcda1 d1hyha1',
				'd1gesa1 d1hlpa1',        'd1gdha2 d1gesa2',
				'd1lvl_2 d2dlda2',        'd1gesa1 d2dlda2',
				'd1nhp_2 d2ohxa2',        'd1tde_2 d2dlda2',
				'd1nhp_1 d2cmd_1',        'd1fcda1 d1ldb_1',
				'd1lvl_1 d2ohxa2',        'd1nhp_2 d2naca2',
				'd1pbe_1 d2ohxa2',        'd1gdha2 d1nhp_2',
				'd2cmd_1 d2tpra1',        'd1tde_1 d2cmd_1',
				'd1llda1 d1nhp_2',        'd1hlpa1 d1nhp_2',
				'd1nhp_1 d2dlda2',        'd1hyha1 d1nhp_2',
				'd1nhp_2 d1psda2',        'd1fcda1 d2cmd_1',
				'd1fcda1 d1llda1',        'd1lvl_2 d1udpa_',
				'd1psda2 d2tpra2',        'd1hdca_ d1lvl_2',
				'd1gesa2 d1llda1',        'd1nhp_2 d1qora2',
				'd1ldm_1 d2tpra1',        'd1coy_1 d2dlda2',
				'd2dlda2 d2tpra1',        'd1hdca_ d1pbe_1',
				'd1coy_1 d1gdha2',        'd1nhp_2 d2cmd_1',
				'd1llda1 d1tde_1',        'd1llda1 d1lvl_1',
				'd1bdma1 d2tpra1',        'd1gd1o1 d2tpra2',
				'd1ldb_1 d1lvl_1',        'd1hlpa1 d1tde_2',
				'd1coy_1 d1psda2',        'd1nhp_2 d1udpa_',
				'd1llda1 d1tde_2',        'd1tde_2 d2cmd_1',
				'd1llda1 d2tpra2',        'd1ldb_1 d1tde_1',
				'd1coy_1 d1hlpa1',        'd1coy_1 d2cmd_1',
				'd1bdma1 d1gesa2',        'd1hyha1 d2tpra2',
				'd1gesa2 d1hyha1',        'd1gesa2 d2ohxa2',
				'd1ldb_1 d1tde_2',        'd1hlpa1 d1pbe_1',
				'd1ldm_1 d2tpra2',        'd2ohxa2 d2tpra1',
				'd1ldb_1 d2tpra2',        'd1gesa2 d1ldm_1',
				'd1lvl_2 d1qora2',        'd1gesa1 d2naca2',
				'd1coy_1 d1llda1',        'd1coy_1 d1hyha1',
				'd1coy_1 d1ldm_1',        'd1ldm_1 d1lvl_2',
				'd1eny__ d1nhp_2',        'd1pbe_1 d2pgd_2',
				'd1ldb_1 d1pbe_1',        'd1ldb_1 d1lvl_2',
				'd1gesa2 d1hlpa1',        'd1dhr__ d1nhp_2',
				'd1hdca_ d1tde_1',        'd1gesa1 d1psda2',
				'd1pbe_1 d2cmd_1',        'd1tde_2 d1udpa_',
				'd1pbe_1 d2dlda2',        'd1hdca_ d1tde_2',
				'd1gesa2 d1ldb_1',        'd1psda2 d2tpra1',
				'd1gdha2 d1lvl_2',        'd1tde_1 d2dlda2',
				'd1ldm_1 d1pbe_1',        'd1pbe_1 d1scua2',
				'd1gesa1 d2ohxa2',        'd1lvl_2 d2naca2',
				'd1gd1o1 d1lvl_1'
				);


		for($i=0; $i< @correcting_pairs; $i++){
				$correcting_pairs{$correcting_pairs[$i]}=$correcting_pairs[$i];
		}
	if($E_mult_factor1=~/^\s*$/){ $E_mult_factor1=1; };


	@keys=sort keys %seqs;
	@keys=@{&strip_sequence_ranges(\@keys)};
	@keys=@{&remove_dup_in_array(\@keys)};
	@pdbg_seqs_ori=@pdbg_seqs;
	$num_enq_seq=@pdbg_seqs;
	print "\n# In get_isearch_result_stat: PDBG seqs $num_enq_seq \n=> @pdbg_seqs\n\n" if $verbose;

	#@pdbg_seqs=@{&strip_sequence_ranges(\@pdbg_seqs)};
	#@pdbg_seqs=@{&remove_dup_in_array(\@pdbg_seqs)};

	if($num_enq_seq < 2){ print "\n# \$num_enq_seq is less than 2 @pdbg_seqs $base\n"; die; }

	for($c=0; $c < @keys; $c++){
	   my($enq_seq, $correct, $false_positive);
	   $num_of_matched=@match_seqs=split(/\s+/, $seqs{$keys[$c]});
			 $enq_seq=$keys[$c];

	   for($d=0; $d< @match_seqs; $d++){
								my($correct_matched, @sorted);

								$match_seq=$match_seqs[$d];
																			$sorted=join(' ', sort ($enq_seq, $match_seq) );

								for($i=0; $i< @pdbg_seqs; $i++){
										 if($match_seq =~/d?$pdbg_seqs[$i]/i or $correcting_pairs{$sorted} ){
													print "\n# \$match_seq = $match_seq, \$pdbg_seqs $pdbg_seqs[$i] \$enq_seq: $enq_seq\n"  if $verbose;
													$correct++;
													$correct_matched=1;
													unless($correct{$sorted}){
																	 $correct_group{$base} .="Homolog: $sorted $base  $mspa_0{$sorted}\n";
													}
													$correct{$sorted} = "Homolog: $base  $mspa_0{$sorted}";
										 }
								}
								if($correct_matched !=1){
										 $false_positive++;
										 unless( $correct{$sorted} ){
													$correct_group{$base} .="Nomolog: $sorted $base  $mspa_0{$sorted}\n";
										 }
										 $correct{$sorted} = "Nomolog: $base  $mspa_0{$sorted}";
								}
	   }
					 if(@match_seqs == 0){ @match_seqs=1; $percent_correct=0; }
	   $sum_correct += $correct;
	   $sum_false   += $false_positive;
	}
	$av_correct = $sum_correct/$num_enq_seq;
	$av_false   = $sum_false  /($num_enq_seq);

	#### $actual_e_value becomes whatever $E_mult_factor1 defined ~~~~~~~~~~~~
	if($E_mult_factor1 != 1){
	   $actual_e_value=$evalue * $E_mult_factor1;
	}elsif($E_mult_factor2 != 1){
	   $actual_e_value= $evalue * $E_mult_factor2;
	}else{ $actual_e_value=$evalue }

	$num_enq_seq--;
	$sum_correct_for_additional = $num_enq_seq+1;
	$match_count=$sum_correct_for_additional * $av_correct;
	#$sum_correct= $sum_correct_for_additional;
	if($verbose){
					 printf ("%-10s %-12s %-13f %-13f %-7s %-7s %-7s %-7s %-4s\n", $pdbg_base,
		$actual_e_value, $av_correct, $av_false, $num_enq_seq,
		$sum_correct_for_additional, $sum_false, $match_count, $leng_thresh);
	}

	@correct_new=@{&remove_dup_in_array(\@correct_new)};
	for($i=0; $i< @correct_new; $i++){
	    print "\n# correct new: $correct_new[$i]" ;
	}
	$num_correct=$match_count/2;

	print "Num of non-reflective correcct:  $num_correct  Nomolog: $sum_false  \n\n" if $verbose;
	return([$av_correct, $sum_correct, $num_enq_seq, \%correct, \%correct_group]);
}



#__________________________________________________________________
# Title     : strip_sequence_ranges
# Usage     :
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : remove_sequence_ranges, remove_sequence_name_ranges,
#             remove_ranges_in_sequences, strip_sequence_name_ranges,
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sub strip_sequence_ranges{
		my (@out, $i);
		my @in=@{$_[0]} or @in=@_;
		for($i=0; $i< @in; $i++){
				if($in[$i]=~/^(\S+)_\d+\-\d+/){
	     push(@out, $1);
	}else{
	     push(@out, $in[$i]);
				}
		}
		return(\@out);
}


#______________________________________________________________
# Title     : delete_files
# Usage     : delete_files *.zip  (delete files except xxxx.zip)
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub delete_files{
    my ($i, @del_files);
    @del_files=@{$_[0]} || @_;
	for($i=0; $i< @del_files; $i++){
	    if(-d $del_files[$i]){
	        next;
		}else{
            unlink($del_files[$i]);
		    print "\n>> $del_files[$i] has been deleted";
	    }
	}
}


#______________________________________________________________________________
# Title     : open_DOMSEL_file
# Usage     :
# Function  :
# Example   : DOMSEL_file is: ~/Proj/Bio/3Dserver/domsel-y
#             1waj(10,9,7,5,21,20)
#             1bdg(4,5,3)
#             1bg3A(6,7,5,22,23,21)
#             1hjrA(2)
#             1tgoA(6,8,11,12,10,13,21,22)
#
#    Assigned this way>>
#           $DOMSEL_hash{$structure}=[@domains];
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub open_DOMSEL_file{
    my($DOMSEL_file, %DOMSEL_hash, $structure, @domains);
    $DOMSEL_file=${$_[0]} || $_[0];
    open(DOMSEL, "<$DOMSEL_file") || die "\n open_DOMSEL_file: Can not open $DOMSEL_file \n\n";
    while(<DOMSEL>){
       if(/^\s*(\S+)\(([\d+\,]*)\)/){
          $structure=$1;
          @domains=split(/\,/, $2);
       }
       $DOMSEL_hash{$structure}=[@domains];
    }
    close(DOMSEL);
    return(\%DOMSEL_hash);
}

#____________________________________________________________________
# Title     :  open_psipred_files
# Usage     :
# Function  : gets sec. str. prediction of psipred(sec. str pred program)
#             and puts in hash If 's' option is given, it also gives
#             sequence hash ref as the second output ref.
#             This can handle the 2 types of output format of
#             psipred. So, the output can will be different according
#             to inputs.
# Example   :
#
#   Conf: Confidence (0=low, 9=high)
#   Pred: Predicted secondary structure (H=helix, E=strand, C=coil)
#     AA: Target sequence
#
#   Conf: 988776544676303321158888868999999999999999987615763468723587
#   Pred: CCCCCCCCCCCCCHHHHHCCCCCCCHHHHHHHHHHHHHHHHHHHHHHCCCCCCCCEECCC
#     AA: MSNPGDVRPVPHRSKVCRCLFGPVDSEQLRRDCDALMAGCLQEARERWNFDFVTETPLEG
#                 10        20        30        40        50        60
#
# Warning   :
# Keywords  : open_PSIPRED_files, open_PSI-PRED_files, psipred, open_psi_pred_files{
#             open_pred_files, secondary structure prediction file
# Options   : 's' for sequence output as well (\%sec_str, \%seq)
# Options   : 's' for sequence output as well (\%sec_str, \%seq)
#             'p' for percentage of the sec. str.
#             'a' for accumulated percentage. This will
#                  set 'p' automatically
#             'n' for NO name when outputing Percentage of chars with
#                 HASH input to get_occurances_of_char sub.
#    $reverse_residue_order=r by r
#    $use_universal_seq_hash_format=u by u -u
#    $consider_top_X_percent_only= by T=
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#-----------------------------------------------------------
sub open_psipred_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my( @out_ref, $seq_out, %sec_str, %seq, $percent_out, $NO_name_out,
        $short_form_out_detected, $long_form_out_detected, $accumulate, $sequence,
        $reverse_residue_order, %rev_sec_str, $use_universal_seq_hash_format,
        @seq, @sec_str, $sec_str, $secondary_structure, @reliability_sorted,
        $num_of_diff_pred_for_both_methods, %mismatch_stats, $num_of_residues,
        $name_found, $consider_top_X_percent_only, @posi_under_threshold_arr,
        @residues_array, $top_X_perc_sec_str);
    $consider_top_X_percent_only=100; # the default
    if($vars{'T'}=~/(\d+)/i){ $consider_top_X_percent_only=$1; }
    if($char_opt=~/s/i){ $seq_out=1 }
    if($char_opt=~/a/i){ $accumulate=1  }
    if($char_opt=~/p/i){ $percent_out=1 }
    if($char_opt=~/n/i){ $NO_name_out='n' }
    if($char_opt=~/r/){  $reverse_residue_order='r' }
    if($char_opt=~/u/){  $use_universal_seq_hash_format='u'; print "\n# (i) \$use_universal_seq_hash_format is set";}

    for($i=0; $i< @file; $i++){
       my (%sec_str, $sec_str, %seq) if($accumulate !=1);
       my ($secondary_structure, $cut_off_position, @reliability, $top_X_perc_sec_str,
           @posi_under_threshold_arr, $cut_off_relia_value, $sequence, @sec_str,
           $line_counter, $residue_num_count, $reliability);

       open(PSIPRED_FILE, "$file[$i]");
       $name=${&get_base_names($file[$i])};
       print "\n# (INFO) open_psipred_files: opening $file[$i]";
       while(<PSIPRED_FILE>){
             $line_counter++;
             if($line_counter < 4){ next }
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
             # Simple sec str input form
             #________________________________________________
             if(/^Conf:\s+(\d+)$/){
                $reliability .=$1;
             }elsif(/Pred:\s+([CHE]+)$/){
                $sec_str.=$1;
             }elsif(/AA:\s+(\S+)$/){
                $sequence.=$1;
             }
       }
       close (PSIPRED_FILE);
       push(@residues_array,  split(//, $sequence));
       $residue_num_count=@residues_array;
       push(@reliability, split(//, $reliability));
       @sec_str=split(//, $sec_str);
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Making a simple HASH style output(OLD form)
       #_______________________________________________________
       for($i=0; $i<@residues_array; $i++){
           $position=$i+1;
           $sec_str{$position}=[$residues_array[$i], $sec_str[$i],
                                $reliability[$i], $name, $position];
           if( $use_universal_seq_hash_format ){  $residues ={$position, $residue_1_letter};  }
       }
       $num_of_residues=@residues_array;

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Considering only certain high ranking predictions (this is to make the same sample size as commonly predicted region
      #______________________________________________________________________________________________________________________
      if($consider_top_X_percent_only < 100){  # as default $consider_top_X_percent_only has 100
         my ($exclusion_count, @top_X_perc_sec_str, @reliability_sorted, $cut_off_position, $cut_off_relia_value);
         @reliability_sorted  = sort {$a<=>$b} @reliability;
         $cut_off_position    = int( $num_of_residues *(1-$consider_top_X_percent_only/100) );
         $cut_off_relia_value = $reliability_sorted[$cut_off_position];
         print  "\n\$cut_off_relia_value $cut_off_relia_value \$cut_off_position $cut_off_position \/$residue_num_count\n";
         for($j=0; $j< @sec_str; $j++){
            if($reliability[$j] <= $cut_off_relia_value or $reliability[$j] == 0){
                $exclusion_count++;
                if($exclusion_count >= $cut_off_position){
                    $top_X_perc_sec_str[$j]=$sec_str[$j];
                }else{
                    $top_X_perc_sec_str[$j]='-'; ## strike out
                    push(@posi_under_threshold_arr, $j);
                }
            }elsif($reliability[$j] > $cut_off_relia_value){
                $top_X_perc_sec_str[$j]=$sec_str[$j];
            }else{    print "\n# Error ,,, "; exit;      }
         }
         $top_X_perc_sec_str=join('', @top_X_perc_sec_str);
     }
     if($reverse_residue_order){
         $secondary_structure   =[reverse @sec_str];
         $prediction_reliability=[reverse @reliability];
         $sequence=reverse($sequence);
         $sec_str =reverse($sec_str);
     }else{
         $secondary_structure=[@sec_str];
         $prediction_reliability=[@reliability];
     }
     $matched_prediction_count=$residue_num_count-$num_of_diff_pred_for_both_methods;

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # This is the general Seq object format
     #_______________________________________________
     if( $use_universal_seq_hash_format ){
        @seq=split(//, $sequence);
        for($s=0; $s< @sec_str; $s++){
            $position=$s+1;
            $residues ={$position, $seq[$s]};
        }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        # Definition of Seq information detail, Ver 1.5
        #______________________________________________________________________________
        %sec_str=('name'                    =>$name,
                  'ID'                      =>$name,
                  'PDB_chain_number'        =>$chain,
                  'chain_number'            =>$chain,
                  'protein_name'            =>$name,
                  'seq_name'                =>$name,
                  'top_X_perc_sec_str'      =>$top_X_perc_sec_str,
                  'residue_hash'            =>$residues,
                  'residue_array'           =>[@residues_array],
                  'residue_string'          =>$sequence,
                  'sec_str_array'           =>$secondary_structure,
                  'sec_str_string'          =>$sec_str,
                  'sec_str'                 =>$sec_str,
                  'mol_type'                =>'protein',
                  'type'                    =>'protein',
                  'prediction_reliability'  =>$prediction_reliability,
                  'cut_off_reliability_val' =>$cut_off_relia_value,
                  'prediction'              =>'prediction',
                  'sequence'                =>"$sequence",
                  'seq_string'              =>$sequence,
                  'structure_assignment'    =>0,
                  'matched_prediction_count'   =>$matched_prediction_count,
                  'mismatched_prediction_count'=>$num_of_diff_pred_for_both_methods,
                  'num_of_diff_pred_for_both_methods'=>$num_of_diff_pred_for_both_methods,
                  'num_of_residues'         =>$num_of_residues,
                  'size_of_sequence'        =>$num_of_residues,
                  'mismatch_stats'          =>{%mismatch_stats},
                  'reverse_residue_order'   =>$reverse_residue_order,
                  'posi_under_threshold_arr'=>[@posi_under_threshold_arr]
                  ); # this is not a struc. assignment as in DSSP
        #__________________________________________________________________________________
     }
	 if($seq_out==1){ push(@out_ref, \%sec_str, \%seq);
	 }elsif($percent_out==1 ){
	      push(@out_ref, [%{&get_occurances_of_char(\%sec_str, $NO_name_out, 'p')}] );
	 }elsif($percent_out !=1){ push(@out_ref, \%sec_str) }

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
         # If -r option is set
         #____________________________________________________________
         if($reverse_residue_order){
              @keys=keys %sec_str;
              for($r=0; $r<@keys; $r++){
                  $rev_sec_str{$keys[$r]}=reverse($sec_str{$keys[$r]});
              }
              %sec_str=%rev_sec_str;
         }
    }
    if(@out_ref==1){
       return($out_ref[0]);
    }elsif(@out_ref>1){
       return(@out_ref);
    }
}




#______________________________________________________________________________
# Title     : open_protein_structural_domain_interact_pair_file
# Usage     :
# Function  :
# Example   :
# Keywords  : open_PDIP_file open_protein_domain_interaction_pair_file
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.5
#------------------------------------------------------------------------------
sub open_protein_structural_domain_interact_pair_file{
    my($previous_interact_file, %protein_str_dom_interact, @contact_pair,
       %total_PDB_entry, $total_PDB_entry);
    $previous_interact_file=$_[0];
    if(-s $previous_interact_file > 100){
       open(CONTACT_LIST, $previous_interact_file) || die;
       while(<CONTACT_LIST>){
          if(/^PROT_INTERACT\s+(\S(\S+))\s+(\S(\S+))/ or /^INTERACT\s+(\S(\S+))\s+(\S(\S+))/ or
             /^PROTEIN_INTERACT\s+(\S(\S+))\s+(\S(\S+))/){
              @contact_pair=sort($1, $3);
              $total_PDB_entry{$2}++; $total_PDB_entry{$4}++;
              $protein_str_dom_interact{'PROTEIN_INTERACT'}{"@contact_pair"}="@contact_pair";
          }elsif(/^NO\S*INTERACT\s+(\S(\S+))\s+(\S(\S+))/ or /^NONINTERACT\s+(\S(\S+))\s+(\S(\S+))/
              or /^NO_PROTEIN_INTERACT\s+(\S(\S+))\s+(\S(\S+))/){
              @contact_pair=sort($1, $3);
              $protein_str_dom_interact{'PROTEIN_NONINTERACT'}{"@contact_pair"}="@contact_pair";
              $total_PDB_entry{$2}++; $total_PDB_entry{$4}++;
          }
       }
    }else{
       print "\n \$previous_interact_file $previous_interact_file does not exist or very small \n";
    }
    $total_PDB_entry=keys %total_PDB_entry;
    print "\n#  \$total_PDB_entry is $total_PDB_entry <- \&open_protein_structural_domain_interact_pair_file\n\n";
    return(\%protein_str_dom_interact);
}

#______________________________________________________________________________
# Title     : open_SCOP_domain_definition_file
# Usage     :
# Function  :
# Example   :
#     d1abya1 1aby    a:1-142 1.001.001.001.001.016
#     d1abya2 1aby    a:143-283       1.001.001.001.001.016
#     d1rvwa_ 1rvw    a:      1.001.001.001.001.016
#     d1ithb_ 1ith    b:      1.001.001.001.001.045
#     d1hlb__ 1hlb    -       1.001.001.001.001.046
# Keywords  : open_scop_domain_definition_file open_scop_file
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   : (\%interacting_PDB_domains, \%PROT_STR_DOM_lookup_hash, \%PROT_STR_DOM_class_hash)
# Version   : 1.8
#------------------------------------------------------------------------------
sub open_SCOP_domain_definition_file{
    my($SCOP_domain_def_file, $dom_def, $PDB_ID, $PROT_STR_DOM_name,
       $classification, %interacting_PDB_domains, %PROT_STR_DOM_lookup_hash, %PROT_STR_DOM_class_hash,
       %known_interactions, $domain_num, %all_PDB_entry, $single_domain_PDB);
    $SCOP_domain_def_file=$_[0];
    open(SCOP_DOM_DEF, "$SCOP_domain_def_file") || die;
    while(<SCOP_DOM_DEF>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # I ignore '0lpc' like entry in the following pattern matching
       #_______________________________________________________________
       if(/^(\S+)\s+(\S+)\s+\-\s+(\S+)/){
          $single_domain_PDB++;
       }elsif(/^(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
          $PROT_STR_DOM_name=$1;
          $PDB_ID=$2;
          $dom_def=$3;
          $classification=$4;
          #$PROT_STR_DOM_name=~s/\./_/g; ## changing . to _
          if($PDB_ID =~/^0\S+/){ next  }
          $all_PDB_entry{$PDB_ID}=$PDB_ID;
          push(@{$interacting_PDB_domains{$PDB_ID}}, $dom_def);
          $PROT_STR_DOM_lookup_hash{"$PDB_ID$dom_def"}=$PROT_STR_DOM_name;
          $PROT_STR_DOM_class_hash{$PROT_STR_DOM_name}=$classification;
       }
    }
    print "\n(i) There were $single_domain_PDB \$single_domain_PDB proteins <- open_SCOP_domain_definition_file\n";
    return(\%interacting_PDB_domains, \%PROT_STR_DOM_lookup_hash, \%PROT_STR_DOM_class_hash, \%all_PDB_entry);
}



#___________________________________________________________________________________________________
# Title     : open_PDB_atom_files
# Usage     : %Atom_coord=%{&open_PDB_atom_files($ARGV[0])};
#             @keys= map {$_->[0]} sort {$a->[1] <=> $b->[1]} map{[$_, /(\S+)/]} keys %Atom_coord;
# Function  :
# Example   :
#      ATOM      1  N   LYS A   2      -3.152  12.128  50.432  1.00 48.77      1GDH 177
#      ATOM      2  CA  LYS A   2      -2.090  12.595  49.538  1.00 49.58      1GDH 178
#      ATOM      3  C   LYS A   2      -1.272  11.417  49.018  1.00 49.32      1GDH 179
#      ATOM      4  O   LYS A   2      -0.596  10.717  49.790  1.00 50.21      1GDH 180
#      ATOM      5  CB  LYS A   2      -1.167  13.596  50.250  1.00 49.34      1GDH 181
#      ATOM      6  CG  LYS A   2      -1.478  15.056  49.941  1.00 48.84      1GDH 182
#      ATOM      7  N   LYS A   3      -1.400  11.155  47.720  1.00 43.99      1GDH 183
#      ATOM      8  CA  LYS A   3      -0.719  10.028  47.117  1.00 37.29      1GDH 184
#      ATOM      9  C   LYS A   3       0.749  10.340  47.110  1.00 32.72      1GDH 185
#      ATOM     10  O   LYS A   3       1.132  11.466  47.353  1.00 30.49      1GDH 186
#      ATOM     11  CB  LYS A   3      -1.227   9.806  45.706  1.00 36.99      1GDH 187
#      ATOM     12  CG  LYS A   3      -2.696   9.436  45.674  1.00 39.38      1GDH 188
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#---------------------------------------------------------------------------------------------------
sub open_PDB_atom_files{
    my ($input, $pdb_name, $i, $j, $keys, $temp,$outseq, $SEQRES, $res_numb, $structure, %ATOM, @fields,
        %AA, @residues);
    if(ref($_[0]) eq 'SCALAR'){ $input=${$_[0]}; }else{  $input=$_[0]; }
    $AA{"ALA"} = "A";  $AA{"MET"} = "M";  $AA{"ASP"} = "D";  $AA{"PRO"} = "P";
    $AA{"CYS"} = "C";  $AA{"ASN"} = "N";  $AA{"GLU"} = "E";  $AA{"GLN"} = "Q";
    $AA{"PHE"} = "F";  $AA{"ARG"} = "R";  $AA{"GLY"} = "G";  $AA{"SER"} = "S";
    $AA{"HIS"} = "H";  $AA{"THR"} = "T";  $AA{"ILE"} = "I";  $AA{"VAL"} = "V";
    $AA{"LYS"} = "K";  $AA{"TRP"} = "W";  $AA{"LEU"} = "L";  $AA{"TYR"} = "Y";
    open(INPUT_PDB_FILE, "$input") || die "\n Can not open PDB Atom files \n";
    while (<INPUT_PDB_FILE>){
       my($chain, $seq_size, $residues);
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       #    ATOM     1       N      LYS      A          2    -3.152  12.128   50.432   1.00   48.77
       #____________________________________________________________________________________________
       if(/^ATOM\s+(\d+)\s+(\w+)\*?\s+\+?(\w+)\s+(\S)\s+(\-?\d+)\S*\s+(\S+)\s+(\S+)\s+(\S+)\s+/){ ## NOTE \s*
          $atom_number=$1;
          $element_type=$2;
          $SEQRES = "\L$3";
          $chain =$4;
          $residue_number=$5;
          $x=$6;
          $y=$7;
          $z=$8;
          $pdb_name="\L$11";
          $ATOM{"$atom_number $element_type"}=[$x, $y, $z];
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       #        ATOM     1       N      LYS     2     -3.152  12.128   50.432  1.00    48.77
       #____________________________________________________________________________________________
       }elsif(/^ATOM\s+(\d+)\s+(\w+)\*?\s+\+?(\w+)\s+(\-?\d+)\S*\s+(\S+)\s+(\S+)\s+(\S+)\s+/){ ## NOTE \s*
          $atom_number=$1;
          $element_type=$2;
          $SEQRES = "\L$3";
          $residue_number=$4;
          $x=$5;
          $y=$6;
          $z=$7;
          $ATOM{"$atom_number $element_type"}=[$x, $y, $z];
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       #        ATOM     1       N      LYS             A2187          -3.152  12.128   50.432   1.00   48.77
       #____________________________________________________________________________________________
       }elsif(/^ATOM\s+(\d+)\s+(\w+)\*?\s+\+?(\w+)\s+([^\d])(\-?\d+)\S*\s+(\S+)\s+(\S+)\s+(\S+)\s+/){ ## NOTE \s*
          $atom_number=$1;
          $element_type=$2;
          $SEQRES = "\L$3";
          $chain =$4;
          $residue_number=$5;
          $x=$6;
          $y=$7;
          $z=$8;
          $pdb_name="\L$11";
          $ATOM{"$atom_number $element_type"}=[$x, $y, $z];
       }elsif(/^ATOM/){
          die "\n$_\n (E) open_PDB_atom_files_for_domains ($input), something is wrong in pattern matching \n";
       }
	}
	close(INPUT_PDB_FILE);
	return( \%ATOM );
}



#___________________________________________________________________________________________________
# Title     : open_PDB_atom_files_for_domains
# Usage     : %Atom_coord=%{&open_PDB_atom_files($ARGV[0])};
#
# Function  :
# Example   :
#      ATOM      1  N   LYS A   2      -3.152  12.128  50.432  1.00 48.77      1GDH 177
#      ATOM      2  CA  LYS A   2      -2.090  12.595  49.538  1.00 49.58      1GDH 178
#      ATOM      3  C   LYS A   2      -1.272  11.417  49.018  1.00 49.32      1GDH 179
#      ATOM      4  O   LYS A   2      -0.596  10.717  49.790  1.00 50.21      1GDH 180
#      ATOM      5  CB  LYS A   2      -1.167  13.596  50.250  1.00 49.34      1GDH 181
#      ATOM      6  CG  LYS A   2      -1.478  15.056  49.941  1.00 48.84      1GDH 182
#      ATOM      7  N   LYS A   3      -1.400  11.155  47.720  1.00 43.99      1GDH 183
#      ATOM      8  CA  LYS A   3      -0.719  10.028  47.117  1.00 37.29      1GDH 184
#      ATOM      9  C   LYS A   3       0.749  10.340  47.110  1.00 32.72      1GDH 185
#      ATOM     10  O   LYS A   3       1.132  11.466  47.353  1.00 30.49      1GDH 186
#      ATOM     11  CB  LYS A   3      -1.227   9.806  45.706  1.00 36.99      1GDH 187
#      ATOM     12  CG  LYS A   3      -2.696   9.436  45.674  1.00 39.38      1GDH 188
# Warning   :
# Keywords  : open_PDB_atom_files_for_chains
# Options   :
# Returns   :  $ATOM{"$chain\_$region_$region"}{$atom_number}=[$x, $y, $z];
# Argument  :
# Category  :
# Version   : 1.7
#---------------------------------------------------------------------------------------------------
sub open_PDB_atom_files_for_domains{
    my ($input, $pdb_name, $i, $j, $keys, $temp,$outseq, $SEQRES, $res_numb, $structure, %ATOM,
        $region, @fields, %AA, @residues, $reg_start, @region, $range_stop, $i, $residue_number);
    if(ref($_[0]) eq 'SCALAR'){ $input=${$_[0]}; }else{  $input=$_[0]; }
    if(ref($_[1]) eq 'SCALAR'){ $region=${$_[1]}; }else{  $region=$_[1]; }
    if($region){ @region=$region=~/(\d+)\-(\d+)/g; }

    open(INPUT_PDB_FILE, "$input") || warn "\n#open_PDB_atom_files_for_domains: Can not open PDB Atom files \n";

    while (<INPUT_PDB_FILE>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       #   ATOM      1       N            LYS      A         2       -3.152  12.128   50.432
       #____________________________________________________________________________________________
       if(/^ATOM\s+(\d+)\s+(\w+)\*?\s+\+?(\w+)\s+(\S)\s+(\-?\d+)\S*\s+(\S+)\s+(\S+)\s+(\S+)\s+/){ ## NOTE \s*
          $atom_number=$1;
          $element_type=$2;
          $SEQRES = "\L$3";
          $chain ="\L$4";    ##<----- I change it to lowercase.
          $residue_number=$5;
          $x=$6;  $y=$7;    $z=$8;
          $pdb_name="\L$11";
          if(@region){
             for($i=0; $i< @region; $i+=2){
                 $range_start=$region[$i]; $range_stop=$region[$i+1];
                 if($residue_number >= $range_start and $residue_number <= $range_stop){
                     push(@{$ATOM{"$chain:$region"}{$residue_number}}, $x, $y, $z);
                 }
             }
          }else{
             push(@{$ATOM{$chain}{$residue_number}}, $x, $y, $z);
          }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       #        ATOM     1       N            LYS        2      -3.152  12.128   50.432  1.00    48.77
       #____________________________________________________________________________________________
       }elsif(/^ATOM\s+(\d+)\s+(\w+)\*?\s+\+?(\w+)\s+(\-?\d+)\S*\s+(\S+)\s+(\S+)\s+(\S+)\s+/){ ## NOTE \s*
          $atom_number=$1;
          $element_type=$2;
          $SEQRES = "\L$3";
          $residue_number=$4;
          $x=$5;  $y=$6;   $z=$7;
          if(@region){
             for($i=0; $i< @region; $i+=2){
                 $range_start=$region[$i]; $range_stop=$region[$i+1];
                 if($residue_number >= $range_start and $residue_number <= $range_stop){
                    push(@{$ATOM{"NO_CHAIN:$region"}{$residue_number}}, $x, $y, $z);
                 }
             }
          }else{
             push(@{$ATOM{'NO_CHAIN'}{$residue_number}}, $x, $y, $z);
          }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       #        ATOM     1       N            LYS          B2187          -3.152  12.128   50.432   1.00   48.77
       #____________________________________________________________________________________________
       }elsif(/^ATOM\s+(\d+)\s+(\w+)\*?\s+\+?(\w+)\s+([^\d])(\-?\d+)\S*\s+(\S+)\s+(\S+)\s+(\S+)\s+/){ ## NOTE \s*
          $atom_number=$1;
          $element_type=$2;
          $SEQRES = "\L$3";
          $chain ="\L$4";    ##<----- I change it to lowercase.
          $residue_number=$5;
          $x=$6;  $y=$7;  $z=$8;
          if(@region){
             for($i=0; $i< @region; $i+=2){
                 $range_start=$region[$i]; $range_stop=$region[$i+1];
                 if($residue_number >= $range_start and $residue_number <= $range_stop){
                    push(@{$ATOM{"$chain:$region"}{$residue_number}}, $x, $y, $z);
                 }
             }
          }else{
             push(@{$ATOM{$chain}{$residue_number}}, $x, $y, $z);
          }
       }elsif(/^TER/){
          $residue_number=0;
       }elsif(/^ATOM/){
          die "\n$_\n (E) open_PDB_atom_files_for_domains ($input), something is wrong in pattern matching \n";
       }
	}
	close(INPUT_PDB_FILE);
	return(\%ATOM);
}




#______________________________________________________________________________
# Title     : open_list_file
# Usage     :
# Function  :
# Example   :
# Keywords  : open_list_file_HASH
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub open_list_file{
    my($list_file, %list);
    $list_file=${$_[0]} || $_[0];
    open(LIST_FILE, "$list_file") || die "\n Can not open $list_file \n";
    while(<LIST_FILE>){
       if(/(\S+)/){
          $list{$1}=$1;
       }
    }
    close(LIST_FILE);
    return(\%list);
}


#______________________________________________________________________________
# Title     : open_list_file_ARRAY
# Usage     :
# Function  :
# Example   :
# Keywords  : open_list_file_array
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub open_list_file_ARRAY{
    my($list_file, @list);
    $list_file=${$_[0]} || $_[0];
    open(LIST_FILE, "$list_file") || die "\n Can not open $list_file \n";
    while(<LIST_FILE>){
       if(/(\S+)/){
          push(@list, $1);
       }
    }
    close(LIST_FILE);
    return(\@list);
}



#______________________________________________________________________________
# Title     : open_trivial_taxonomy_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub open_trivial_taxonomy_file{
    my(%keep_orig, $trivial_taxonomy_file, @list,
       $hid,$lseq,$species,$ppid,$taxon,$name,$unk,$rep);
    $trivial_taxonomy_file=${$_[0]} || $_[0];

    open(IN, "$trivial_taxonomy_file") || die;
    while(<IN>) {
        chop;
        ($hid,$lseq,$species,$ppid,$taxon,$name,$unk,$rep)=split(/\t+/);
        next if(!defined($rep));
        if(!defined($keep_orig{$rep})) { push(@list, $rep); }
        $keep_orig{$rep}=1;
    }
    close(IN);
    return(\%keep_orig);
}





#______________________________________________________________________________
# Title     : open_MRCS_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.3
#------------------------------------------------------------------------------
sub open_MRCS_file{
    my(%MRCS_hash, $i, $MRCS_file, $query_seq, $target_seq, $openning_gap_penalty,
       $elongation_gap_penalty, $algorithm, $ForBackScore, $ForScore,
       $BackScore, $MutualSeqID, $Alignment_leng, $sorted_paired_seqs,
       $forward_search_area_end);
    $MRCS_file=${$_[0]} || $_[0];
    open(MRCS_FILE_HANDLE, "$MRCS_file") || die "\n Cannt open $MRCS_file \n";
    while(<MRCS_FILE_HANDLE>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # #<<START>>d1acf__ d1aco_1 OpenGap:10, ExtGap:1, Algo:lss_dipeptide
       #_______________________________________________________________________
       if(/START\>+(\S+)\s+(\S+)\s+OpenGap:(\d+)\,\s+ExtGap:(\d+)\,\s+Algo:(\S+)/){
           $query_seq=$1;
           $target_seq=$2;
           $openning_gap_penalty=$3;
           $elongation_gap_penalty=$4;
           $algorithm=$5;
           $forward_search_area_end=$SELF_seq_matched=0;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # d1acf___1-124   SWQTYVDTNLVGTGAVTQAAILGLDGNTWATSAGFAVTPAQGTTLAGAFNNADAIRAGGFDLAGVH
       #_____________________________________________________________________________________
       }elsif(/^$query_seq\_(\d+\-\d+)\s+\S/ and $forward_search_area_end==1){
           $query_seq_align_range=$1;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # d1acf___1-124   SWQTYVDTNLVGTGAVTQAAILGLDGNTWATSAGFAVTPAQGTTLAGAFNNADAIRAGGFDLAGVH
       #_____________________________________________________________________________________
       }elsif(/^$target_seq\_(\d+\-\d+)\s+\S/ and $forward_search_area_end==1){
           $target_seq_align_range=$1;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # d1acf___1-124   SWQTYVDTNLVGTGAVTQAAILGLDGNTWATSAGFAVTPAQGTTLAGAFNNADAIRAGGFDLAGVH
       #_____________________________________________________________________________________
       }elsif(/# Created by print_seq_in_block sub/){
           $forward_search_area_end++;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # SELF            SWQTYVDTNLVGTGAVTQAAILGLDGNTWATSAGFAVTPAQGTTLAG
       #_____________________________________________________________________________________
       }elsif(/^SELF\s+\S/ and $forward_search_area_end == 1){
           $target_seq_align_range=$query_seq_align_range;
           $SELF_seq_matched=1;  ##<--- this flag is used in case whre SELF line comes earlier than the query line
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # SELF            SWQTYVDTNLVGTGAVTQAAILGLDGNTWATSAGFAVTPAQGTTLAG
       #_____________________________________________________________________________________
       }elsif(/STOP\>.+ForBackScore:\s*(\S+)\,\s+ForScore:\s+(\S+)\,\s+BackScore:\s+(\S+)\s+ID:\s+(\S+)\s+L:(\d+)/){
           $ForBackScore=sprintf("%-.1f", $1);
           $ForScore=$2;
           $BackScore=$3;
           $MutualSeqID=$4;
           $Alignment_leng=$5;
           $sorted_paired_seqs=join(' ', sort($query_seq, $target_seq));
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Following line is to prevent empty range for target
           #_________________________________________________________
           if($SELF_seq_matched and !$target_seq_align_range){ $target_seq_align_range=$query_seq_align_range }
           $MRCS_hash{$sorted_paired_seqs}{'ForBackScore'}    =$ForBackScore;
           $MRCS_hash{$sorted_paired_seqs}{'ForScore'}        =$ForScore;
           $MRCS_hash{$sorted_paired_seqs}{'BackScore'}       =$BackScore;
           $MRCS_hash{$sorted_paired_seqs}{'MutualSeqID'}     =$MutualSeqID;
           $MRCS_hash{$sorted_paired_seqs}{'Alignment_leng'}  =$Alignment_leng;
           $MRCS_hash{$sorted_paired_seqs}{'QUERY_SEQ_RANGE'} =$query_seq_align_range;
           $MRCS_hash{$sorted_paired_seqs}{'TARGET_SEQ_RANGE'}=$target_seq_align_range;
           $MRCS_hash{$sorted_paired_seqs}{'QUERY_SEQ_NAME'}  =$query_seq;
           $MRCS_hash{$sorted_paired_seqs}{'TARGET_SEQ_NAME'} =$target_seq;
           $forward_search_area_end=0;
       }
    }
    return(\%MRCS_hash);
}

#________________________________________________________________________
# Title     : open_pdbfinder_file
# Usage     : %PDBFINDER_hash=%{&open_pdbfinder_file($ARGV[0])};
# Function  :
# Example   :
# Warning   :
# Keywords  : open_pdfi_file, open_PDFI_file
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub open_pdbfinder_file{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($input_file, $sequence, %PDBFINDER_hash, $PDB_id, $ID, $chain);
    $input_file=$file[0];
    open(PDBFINDER_FILE, "$input_file") || die ;
    while(<PDBFINDER_FILE>){
       if(/^ID\s+:\s+(\S+)/){
          $ID="\L$1";
          if($ID eq '1hfe'){ print "\n $ID \n"; }
       }elsif(/^Chain\s+:\s+(\S)/){
          $chain=$1;
          if($ID eq '1hfe'){ print "\n Chain $chain \n";  }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Thi is to skip
       #____________________________________________
       #}elsif(/non-Std\s+/){
       #   $chain='';
       #   next;
       }elsif($chain and /\S*Sequence\s+:\s+(\S+)/){
          $sequence=$1;
          $PDB_id="$ID$chain";
          if($PDBFINDER_hash{$PDB_id}){
              # This is a case where there are identical chain IDs
          }else{
              $PDBFINDER_hash{$PDB_id}=$sequence;
          }
          if($ID eq '1hfe'){ print "\n $sequence \n";  }
       }elsif(/\/\//){
          $ID=$chain=$PDB_id=$sequence='';
       }
    }
    return(\%PDBFINDER_hash);
}



#______________________________________________________________________________
# Title     : open_db_file_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub open_db_file_DALI {
    local($dir, $ext, $file,$fatal,$cd,%dbdir);
    ($fatal,$cd,%dbdir)=@_;
    foreach $dir (keys(%dbdir)) {
         $ext=$dbdir{$dir};
         $file=$dir . $cd . $ext;
       #print "open_db_file_DALI : test : $file\n";
         open(IN, $file) || warn "\n Can not open $file \n";  next;
       #print "open_db_file_DALI : reading : $file\n";
         return(0);
    }
    if($fatal) {die "FATAL can't open $file\n";} else { return(1);}
}



#______________________________________________________________________________
# Title     : open_DDDF_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub open_DDDF_file{
    my($input_file, $PDBID, $NChain, $Chain, $Domain, $Range, $Parent, $DC_number,
       $AliLen, %DDDF_hash, $DDD_ID);
    $input_file=${$_[0]} || $_[0];
    print "\n (i) Openning $input_file \n";
    open(IN_FILE, "$input_file") || die "\n Can not open \"$input_file\" \n";
    while(<IN_FILE>){
      if(/PDBID\s+\:\s+(\S+)/){
         $PDBID=$1;
      }elsif(/NChain\s+\:\s+(\d+)/){
         $NChain=$1;
      }elsif(/Chain\s+\:\s+(\S+)/){
         $Chain=$1;
      }elsif(/Domain\s+\:\s+(\d+)/){
         $Domain=$1;
      }elsif(/Range\s+\:\s+(.+)/){
         $Range=$1;
      }elsif(/Paren\s+\:\s+(\S+)/){
         $Parent=$1;
      }elsif(/D\.C\.\s+\:\s+(\S+)/){
         $DC_number=$1;
      }elsif(/AliLen\s+\:\s+(\d+)/){
         $AliLen=$1;
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Write in to HASH
         #____________________________________________
         $DDD_ID="$PDBID$Chain$Domain";
         $DDDF_hash{$DDD_ID}=[ $PDBID,
                               $NChain,
                               $Chain,
                               $Domain,
                               $Range,
                               $Parent,
                               $DC_number,
                               $AliLen ];
      }
   }
   close(IN_FILE);
   unless(%DDDF_hash){ warn "\n\n\n\t!!!! \%DDDF_hash is empty. Something is wrong \n\n\n"; }
   return(\%DDDF_hash);
}


#______________________________________________________________________________
# Title     : open_HSSP_file_for_secture
# Usage     :
# Function  : returns str. alignment information from HSSP
# Example   : %HSSP_align=%{&open_HSSP_file_for_secture($ARGV[0])};
#       $HSSP_alignment_1to1_residue_map{$Representative_name}{$HSSP_homolog_name}{$i}={$j};
#
#     The hash looks like:
#       $HSSP_ALIGNMENT{$SEQ_NUMBER_ID}{$SEQ_NAME} .= $AA_HOMO_RESIDUES[$i];
#
# Keywords  : open_hssp_file, open_hssp_files
# Options   :
#      $get_ranges_info=r by r
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub open_HSSP_file_for_secture{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($HSSP_file_name, $PDBID, $DATE, $SEQLENGTH, $NCHAIN, $NALIGN,
       $SEQ_NUMBER_ID, $SEQ_NAME, $MUTUAL_PERCENT_SEQ_ID, $NUM_OF_ALIGNMENT_START,
       $NUM_OF_ALIGNMENT_STOP, $NUM_OF_ALIGNMENT_SHOWN, $Residue_Position_No,
       $PDB_Res_Position_No, $AA_REP, $AA_HOMO, @AA_HOMO_RESIDUES,
       $ALIGNMENTS_line_counter,  %HSSP_secture);
    $HSSP_file_name=$file[0];
    if($char_opt=~/r/i){  $get_ranges_info='r' }

    open(HSSP_FILE, $HSSP_file_name) || die "\n Can not open $HSSP_file_name\n";
    while(<HSSP_FILE>){
       if(/^PDBID\s+(\S+)$/){
          $PDBID=$1;
       }elsif(/^DATE\s+(.+)/){
          $DATE=$1;
       }elsif(/^SEQLENGTH\s+(\d+)/){
          $SEQLENGTH=$1;
       }elsif(/^NCHAIN\s+(\d+)/){
          $NCHAIN=$1;
       }elsif(/^NALIGN\s+(\d+)/){
          $NALIGN=$1;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
       # matching     1 : myg_phyca   1CIO    1.00  1.00    1  153    1  153  153    0    0  153  P02185     MYOGLOBIN.
       #____________________________________________________________________________________________________________________
       }elsif(/^\s+(\d+)\s+:\s+(\S+)\s+\S*\s*(\d\.\d+)\s+(\d\.\d+)/){
          $SEQ_NUMBER_ID=$1;
          $SEQ_NAME=$2;
          $MUTUAL_PERCENT_SEQ_ID=$3;
          $WEIGHTED_SIMILARITY_ID=$4;
       }elsif(/^\s*##\s+ALIGNMENTS\s+(\d+)\s+\-\s+(\d+)/){
          $NUM_OF_ALIGNMENT_START=$1;
          $NUM_OF_ALIGNMENT_STOP =$2;
          $NUM_OF_ALIGNMENT_SHOWN=$2-$1+1;
          $ALIGNMENTS_line_counter++;
       }elsif(/SeqNo\s+PDBNo\s+AA\s+STRUCTURE\s+BP1\s+BP2\s+ACC\s+NOCC\s+VAR\s+(\S+)/){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
       # matching SeqNo  PDBNo AA STRUCTURE BP1 BP2  ACC NOCC  VAR  ....:....1....:....2....:....3....:....4....:....5....:....6....:....7
       # matching     1    1   V              0   0  125    7    0  VVVV   V  V
       # matching     9  116   Y  E     -ab  44  52A  13  103   10  YYYYYYYY YY YYYYYYYYYYYYYYYYYY YY YYYY YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYF
       # matching     3    5 A W  S    S+     0   0    6   50   44  WWWWWWWWW  LLWW VWVVVVVVVVRVR RRRRRRIRRVIVIIVF LL  F F  H S  LF
       #____________________________________________________________________________________________________________________________________________
       }elsif(/^\s+(\d+)\s+(\d+)\s\s+(\S)\s\s(\S*)/){
          $Residue_Position_No=$1;
          $PDB_Res_Position_No=$2;
          $AA_REP =$3;
          $Chain_ID='_';
          if($4){ $SEC_str=$4 }else{ $SEC_str='C' }
          $HSSP_secture{"$PDBID$Chain_ID"}{'SEQUENCE'} .=$AA_REP;
          $HSSP_secture{"$PDBID$Chain_ID"}{'SECTURE'}  .=$SEC_str;  ## secture means secondary structure
       }elsif(/^\s+(\d+)\s+(\d+)\s+(\S)\s+(\S)\s\s(\S*)/){
          $Residue_Position_No=$1;
          $PDB_Res_Position_No=$2;
          $Chain_ID=$3;
          $AA_REP =$4;
          if($5){ $SEC_str=$5 }else{ $SEC_str='C' }
          $HSSP_secture{"$PDBID$Chain_ID"}{'SEQUENCE'} .=$AA_REP;
          $HSSP_secture{"$PDBID$Chain_ID"}{'SECTURE'}  .=$SEC_str;  ## secture means secondary structure

       }elsif(/^\s*## SEQUENCE PROFILE AND ENTROPY/){
          last;
       }

    }
    return(\%HSSP_secture);
}



#______________________________________________________________________________
# Title     : open_HSSP_file
# Usage     :
# Function  : returns str. alignment information from HSSP
# Example   : %HSSP_align=%{&open_HSSP_file($ARGV[0])};
#       $HSSP_alignment_1to1_residue_map{$Representative_name}{$HSSP_homolog_name}{$i}={$j};
#
#     The hash looks like:
#       $HSSP_ALIGNMENT{$SEQ_NUMBER_ID}{$SEQ_NAME} .= $AA_HOMO_RESIDUES[$i];
#
# Keywords  : open_hssp_file, open_hssp_files
# Options   :
#      $get_ranges_info=r by r
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub open_HSSP_file{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($HSSP_file_name, $PDBID, $DATE, $SEQLENGTH, $NCHAIN, $NALIGN,
       $SEQ_NUMBER_ID, $SEQ_NAME, $MUTUAL_PERCENT_SEQ_ID, $NUM_OF_ALIGNMENT_START,
       $NUM_OF_ALIGNMENT_STOP, $NUM_OF_ALIGNMENT_SHOWN, $Residue_Position_No,
       $PDB_Res_Position_No, $AA_REP, $AA_HOMO, @AA_HOMO_RESIDUES,
       %SEQ_NAME_and_NUM_lookup_hash, %HSSP_ALIGNMENT, $ALIGNMENTS_line_counter);
    $HSSP_file_name=$file[0];
    if($char_opt=~/r/i){  $get_ranges_info='r' }

    open(HSSP_FILE, $HSSP_file_name) || die "\n Can not open $HSSP_file_name\n";
    while(<HSSP_FILE>){
       if(/^PDBID\s+(\S+)$/){
          $PDBID=$1;
          $SEQ_NAME_and_NUM_lookup_hash{0}=$PDBID;
       }elsif(/^DATE\s+(.+)/){
          $DATE=$1;
       }elsif(/^SEQLENGTH\s+(\d+)/){
          $SEQLENGTH=$1;
       }elsif(/^NCHAIN\s+(\d+)/){
          $NCHAIN=$1;
       }elsif(/^NALIGN\s+(\d+)/){
          $NALIGN=$1;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
       # matching     1 : myg_phyca   1CIO    1.00  1.00    1  153    1  153  153    0    0  153  P02185     MYOGLOBIN.
       #____________________________________________________________________________________________________________________
       }elsif(/^\s+(\d+)\s+:\s+(\S+)\s+\S*\s*(\d\.\d+)\s+(\d\.\d+)/){
          $SEQ_NUMBER_ID=$1;
          $SEQ_NAME=$2;
          $MUTUAL_PERCENT_SEQ_ID=$3;
          $WEIGHTED_SIMILARITY_ID=$4;
          $SEQ_NAME_and_NUM_lookup_hash{$SEQ_NUMBER_ID}=$SEQ_NAME;
       }elsif(/^\s*##\s+ALIGNMENTS\s+(\d+)\s+\-\s+(\d+)/){
          $NUM_OF_ALIGNMENT_START=$1;
          $NUM_OF_ALIGNMENT_STOP =$2;
          $NUM_OF_ALIGNMENT_SHOWN=$2-$1+1;
          $ALIGNMENTS_line_counter++;
       }elsif(/SeqNo\s+PDBNo\s+AA\s+STRUCTURE\s+BP1\s+BP2\s+ACC\s+NOCC\s+VAR\s+(\S+)/){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
       # matching SeqNo  PDBNo AA STRUCTURE BP1 BP2  ACC NOCC  VAR  ....:....1....:....2....:....3....:....4....:....5....:....6....:....7
       # matching     1    1   V              0   0  125    7    0  VVVV   V  V
       # matching     9  116   Y  E     -ab  44  52A  13  103   10  YYYYYYYY YY YYYYYYYYYYYYYYYYYY YY YYYY YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYF
       # matching     3    5 A W  S    S+     0   0    6   50   44  WWWWWWWWW  LLWW VWVVVVVVVVRVR RRRRRRIRRVIVIIVF LL  F F  H S  LF
       #____________________________________________________________________________________________________________________________________________
       }elsif(/^\s+(\d+)\s+(\d+)\s+\S*\s*(\S).{12,14}(\w+)\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)..([ \w]+)/){
          $Residue_Position_No=$1;
          $PDB_Res_Position_No=$2;
          $AA_REP =$3;
          $AA_HOMO=$9;
          $AA_HOMO=~tr/ /\./; ## change the space gap to '.' gap
          @AA_HOMO_RESIDUES=split(//, $AA_HOMO);
          if($NUM_OF_ALIGNMENT_SHOWN > @AA_HOMO_RESIDUES){
             $diff=$NUM_OF_ALIGNMENT_SHOWN-@AA_HOMO_RESIDUES;
             for($i=0; $i<$diff; $i++){
                push(@AA_HOMO_RESIDUES, '.');
             }
          }

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # putting the very first rep. seq
          #________________________________________________________________________
          $HSSP_ALIGNMENT{0}{$PDBID} .= $AA_REP if $ALIGNMENTS_line_counter==1;

          #$AA_HOMO=join('', @AA_HOMO_RESIDUES);
          #print "\n\"$AA_HOMO  $ALIGNMENTS_line_counter\"";
          for($i = 0; $i< @AA_HOMO_RESIDUES; $i++){
             $SEQ_NUMBER_ID=$i + $NUM_OF_ALIGNMENT_START;
             $SEQ_NAME=$SEQ_NAME_and_NUM_lookup_hash{$SEQ_NUMBER_ID};
             $HSSP_ALIGNMENT{$SEQ_NUMBER_ID}{$SEQ_NAME} .= $AA_HOMO_RESIDUES[$i];
          }
       }elsif(/^\s*## SEQUENCE PROFILE AND ENTROPY/){
          last;
       }

    }
    return(\%HSSP_ALIGNMENT);
}



#______________________________________________________________________________
# Title     : open_FSSP_file
# Usage     :
# Function  : returns str. alignment information from FSSP
# Example   : %FSSP_align=%{&open_FSSP_file($ARGV[0])};
#       $FSSP_alignment_1to1_residue_map{$Representative_name}{$FSSP_homolog_name}{$i}={$j};
# Keywords  : open_fssp_file, open_fssp_files open_FSSP_files
# Options   :
#      $get_ranges_info=r by r
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.4
#------------------------------------------------------------------------------
sub open_FSSP_file{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($Alignment_section_found, $FSSP_file_name, %FSSP_alignment_1to1_residue_map,
       $i, $j, $REP_position, $REP_region_start, $HOMOL_position, $HOMOL_position,
       $length_of_alignment, $Representative_name, $HOMOLOG_ID_num,
       $FSSP_homolog_name, $HOMOL_region_start, $HOMOL_region_stop);
    $FSSP_file_name=$file[0];
    if($char_opt=~/r/i){  $get_ranges_info='r'; print "\n open_FSSP_file: \$get_ranges_info is set to $get_ranges_info\n"; }

    open(FSSP_FILE, $FSSP_file_name) || die "\n (E) open_FSSP_file: Can not open $FSSP_file_name\n";
    while(<FSSP_FILE>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
       # Following is the Alignment part extraction only. Other parts will be made later
       #________________________________________________________________________________________
       if(/## EQUIVALENCES: ranges of aligned residues/){
          $Alignment_section_found=1;      #      NR     STRID1 <=> STRID2
       }elsif($Alignment_section_found
          and /^\s+(\d+)\:\s+(\S+)\s+(\S+)\s+(\d+)\s+\-\s+(\d+)\s+\<=\>\s+(\d+)\s+\-\s+(\d+)/){
          $HOMOLOG_ID_num=$1;
          $Representative_name=$2;
          $FSSP_homolog_name=$3;
          $REP_region_start=$4;
          $REP_region_stop =$5;
          $HOMOL_region_start=$6;
          $HOMOL_region_stop=$7;
          $REP_range  = "$REP_region_start\-$REP_region_stop";
          $HOMOL_range= "$HOMOL_region_start\-$HOMOL_region_stop";

          if($get_ranges_info eq 'r'){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Making a hash which stores ranges information
              #______________________________________________________________
              $FSSP_alignment_1to1_residue_map{$Representative_name}{$FSSP_homolog_name}{$REP_range}=$HOMOL_range;
          }else{
              #print "\n    Alignment region matched\n$HOMOLOG_ID_num $Representative_name $FSSP_homolog_name $REP_region_start $HOMOL_region_start ";
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
              # Making a hash which stores 1 to 1 residue position
              #______________________________________________________

              $length_of_alignment=$REP_region_stop-$REP_region_start + 1;

              for($i=0; $i < $length_of_alignment; $i++){
                  $REP_position=$i+$REP_region_start;
                  $HOMOL_position=$i+$HOMOL_region_start;
                  $FSSP_alignment_1to1_residue_map{$Representative_name}{$FSSP_homolog_name}{$REP_position}=$HOMOL_position;
              }
          }
       }
    }
    close(FSSP_FILE);
    return(\%FSSP_alignment_1to1_residue_map);
}

#______________________________________________________________________________
# Title     : open_FDAT_file
# Usage     :
# Function  :
# Example   : There are 2 main entries:
#          $Dali_subdomains{$structure_ID}{$subdomain_number}=[$subdomain1,
#                                                              $subdomain2,
#                                                              $residue_leng,
#                                                              $numb_of_segments,
#                                                              $ranges
#                                                              ]
#          $Dali_subdomains{$structure_ID}{'SEQUENCE'}
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 2.0
#------------------------------------------------------------------------------
sub open_FDAT_file{
    my($i, $j, $FDAT_file, $entry_sign_count, $structure_ID, $subdomain_number,
       $strand_number, $residue_leng, $secondary_str_element_num, $helix_number,
       $strand_number, %Dali_subdomains, $subdomain1, $subdomain2, $residue_leng,
       $numb_of_segments, $ranges, $sequence, $correct_node_number,
       @delete_targets, @nodes, @final_ranges);
    $FDAT_file=${$_[0]} || $_[0];
    if($FDAT_file=~/([\S+]*)\/([^\/]+)\.dat/ and length($2) < 5){ $FDAT_file="$1\/$2\_.dat"
    }elsif($FDAT_file=~/^(\w+)\.dat/ and length($1) < 5){ $FDAT_file="$1\_.dat" }

    open(FDAT, "<$FDAT_file") || warn "open_FDAT_file: Can not open $FDAT_file file \n";
    while(<FDAT>){
       if(/\>\>\>\>\s+(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+([HE]*)/){
          $entry_sign_count++;
          $structure_ID=$1;
          $residue_leng=$2;
          $secondary_str_element_num=$3;
          $helix_number=$4;
          $strand_number=$5;
          $PDB_sec_str_data{$1}=[$residue_leng,
                                 $secondary_str_element_num,
                                 $helix_number, $strand_number];
       # >>>> 1tgoA   69
       }elsif(/\>\>\>\>\s+(\S+)\s+(\d+)/){
          $entry_sign_count++;
       # >>>> 1tgoA   69                      NODE     +*=-    (sub domains)   Leng    Seg No.  ranges
       }elsif($entry_sign_count > 2 and /^\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s*(\d*)\s*(\d*)\s*(.*)/){
          $subdomain_number=$1;
          $subdomain1=$3;
          $subdomain2=$4;
          $residue_leng=$5;
          $numb_of_segments=$6;
          $ranges=$7;

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # This checks a line like: '   1 +    2   31017   1   11017' in 1kcw_.dat
          #_____________________________________________________________________________
          if(length($subdomain2) > 4 and !$ranges){
              $ranges = $numb_of_segments;
              $numb_of_segments=$residue_leng;
              ($subdomain2, $residue_leng)=$subdomain2=~/(\d+)(\d\d\d\d)/;
              if(length($ranges) > 4){
                  @ranges=$ranges=~/(\d+)(\d\d\d\d)$/;
                  $ranges=join(' ', @ranges);
              }
              print "$ranges, $numb_of_segments $residue_leng $subdomain2\n";
          }

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Mark nodes which are less than 40 aa size (to be deleted later)
          #___________________________________________________________________________
	      # accept 1ppt(1) = 36 residue peptide
          if($residue_leng < 40 && $subdomain_number>1){
              push(@delete_targets, $subdomain_number);
          }else{
              my(@final_ranges);
              $correct_node_number++;
              @ranges= split(/\s+/, $ranges);
              for($i=0; $i < @ranges; $i++){
                  if(length($ranges[$i]) > 4){
                      print "\n$ranges[$i]";
                      push(@final_ranges, $ranges[$i]=~/(\d+)(\d\d\d\d)$/);
                  }else{
                      push(@final_ranges, $ranges[$i]);
                  }
              }
              $ranges=join(' ', @final_ranges);
              $Dali_subdomains{$structure_ID}{$correct_node_number}=[$subdomain1,
                                                                  $subdomain2,
                                                                  $residue_leng,
                                                                  $numb_of_segments,
                                                                  $ranges
                                                                  ];
          }

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # -sequence "MILDTDYITEDGKPVIRIFKKENGEFKIDYDRNFEPYIYALLKDDSAIEDVK
       #______________________________________________________________________
       }elsif(/\-sequence \"(\w+)/){
          $sequence=$1;
          $Dali_subdomains{$structure_ID}{'SEQUENCE'}=$sequence;
       }
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Final processing of the Dali_subdomains hash to remove the deleted nodes the anon. array
    #______________________________________________________________________________________________
    @nodes=sort {$a<=>$b} keys %{$Dali_subdomains{$structure_ID}};
    for($i=0; $i< @delete_targets; $i++){
       for($j=0; $j< @nodes; $j++){
           if($Dali_subdomains{$structure_ID}{$nodes[$j]}[0] == $delete_targets[$i]){
               $Dali_subdomains{$structure_ID}{$nodes[$j]}[0]=0;
           }elsif($Dali_subdomains{$structure_ID}{$nodes[$j]}[1] == $delete_targets[$i]){
               $Dali_subdomains{$structure_ID}{$nodes[$j]}[1]=0;
           }
       }
    }

    close(FDAT);
    return(\%Dali_subdomains);
}



#______________________________________________________________________________
# Title     : open_stragment_library_file
# Usage     :
# Function  :
# Example   :
# Keywords  : open_STRL_file, open_strl_file STRL: stragment library file
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub open_stragment_library_file{
    my($stragment_file, $stragment, $PDB_ID, $seqlet);
    $stragment_file=${$_[0]} || $_[0];
    open(STRAGMENT_FILE, "$stragment_file") || die "\n Can not open $stragment_file\n\n";
    while(<STRAGMENT_FILE>){
       if(/\>(\S+_(\w+)):(\w+)/){
          $PDB_ID=$1;
          $seqlet=$2;
          $stragment=$3;
          push(@{$stragment{$PDB_ID}}, $stragment);
       }
    }
    return(\%stragment);
}




#______________________________________________________________________________
# Title     : open_socket
# Usage     : $SOCKET_FILEHANDLE=${&open_socket("H=$local_hostname",
#                                     "S=$target_server_IP", "FH=$file_handle",
#                                     "P=$port")};
#
# Function  : opens Socket filehandle and returns the filehandle name
#             which is 'SOCKET_FOR_POST' by default
# Example   :
# Keywords  : open_SOCKET
# Options   :
# Author    : jong@biosophy.org, ali@genet.sickkids.on.ca
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub open_socket{
	my($arg, $name, $altname, $proto, $port, $client, $server, $clientAddress,
			 $serverAddress, $AF_INET, $SOCK_STREAM, $SOCKET_FILEHANDLE,
			 $local_hostname, $target_server_IP, $type, $len);

		$SOCKET_FILEHANDLE='SOCKET_FOR_POST';
		$SOCK_STREAM=1; # in Linux it is 1 /usr/include/socketbits.h
		$AF_INET = 2;   # unix users: can be found in /usr/include/sys/socket.h, or /usr/include/socketbits.h
							      # In Linux, it is the same as PF_INET and PF_INET has 2
		$port=80; # default is set to HTTPD port
		$|=1;

		for $arg(@_){
		   if(ref($arg)){ $arg=${$arg}; }
			 if($arg=~/FH=(\S+)/){
					$SOCKET_FILEHANDLE=$1;
			 }elsif($arg=~/S=(\S+)/i){
					$target_server_IP=$1;
			 }elsif($arg=~/H=(\S+)/i){
					$local_hostname=$1;
			 }elsif($arg=~/P=(\S+)/i){
					$port=$1;
			 }
		}

		($name, $altname, $proto) = getprotobyname('tcp');
		($name, $altname, $port)  = getservbyname($port, 'tcp') unless $port =~ /^\d+$/;;
		($name, $altname, $type, $len, $clientAddress) = gethostbyname($local_hostname);
		($name, $altname, $type, $len, $serverAddress) = gethostbyname($target_server_IP);

		if(!$name){
				die "\n# (E) No hostname defined $!\n\n$name, $altname, $proto, $type, $len\n\a";
		}

		$client = pack("Sna4x8", $AF_INET, 0,     $clientAddress); # $AF_INET = 2;   ## unix users: can be found in /usr/include/sys/socket.h, or /usr/include/socketbits.h
		$server = pack("Sna4x8", $AF_INET, $port, $serverAddress);

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# make the socket filehandle
	#______________________________________________________
	if (!socket("$SOCKET_FILEHANDLE", $AF_INET, $SOCK_STREAM, $proto)) {
				die ("Cannot open socket. Error code: $!\n");
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# give the socket an address
		#______________________________________________________
		if (!bind("$SOCKET_FILEHANDLE", $client)) {
				die("Cannot bind. Error code: $!\n");
				close($SOCKET_FILEHANDLE);
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Connect to the server
		#______________________________________________________
		if (!connect("$SOCKET_FILEHANDLE", $server)) {
				print "\n# (E) \$local_hostname    : $local_hostname";
				print "\n# (E) \$target_server_IP  : $target_server_IP";
				print "\n# (E) \$clientAddress     : $clientAddress";
				print "\n# (E) \$serverAddress     : $serverAddress";
				print "\n# (E) \$proto             : $proto";
				print "\n# (E) \$type              : $type";
				print "\n# (E) \$port              : $port";
				print "\n# (E) \$SOCKET_FILEHANDLE : $SOCKET_FILEHANDLE";
				print "\n# (E) \$len               : $len\n";
				die("# (E) $0: Cannot connect to $server. Error code: $!\n");
				close($SOCKET_FILEHANDLE);
	}
	return(\$SOCKET_FILEHANDLE);
}


#________________________________________________________________________________
# Title     : open_parf_files
# Usage     : @output_hashes=&open_parf_files(@files);
#
#              %parf_hash_homology_info          =%{$output_hashes[0]};
#              %parf_hash_score                  =%{$output_hashes[1]};
#              %parf_hash_classification_column_1=%{$output_hashes[2]};
#              %parf_hash_classification_column_2=%{$output_hashes[3]};
#              %parf_hash_Homologous_rank        =%{$output_hashes[4]};
#              %parf_hash_Nomologous_rank        =%{$output_hashes[5]};
#
# Function  :
# Example   :
#    PARF file looks like this>
#   d1nsca_   d3nn9__   Homolog -664.92 2.43.1.1.3  2.43.1.1.2
#   d1dppa_   d2olba_   Homolog -617.41 3.68.1.1.6  3.68.1.1.1
#   d2ach.1a1 d9api.1a1 Homolog -556.38 5.2.1.1.3   5.2.1.1.4
#
# Keywords  :
# Options   :
# Author    :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub open_parf_files{
     #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
     my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
     my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
     my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
     my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
     my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
     if($debug==1){print "\n\t\@hash=\"@hash\"
     \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
     \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
     #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
     my (@parf_file, $number_of_lines_read,  %all_parf_file_hash,
         %parf_hash_homology_info, %parf_hash_score,
         %parf_hash_classification_column_1, %parf_hash_classification_column_2,
         %parf_hash_Homologous_rank,  %parf_hash_Nomologous_rank);

     my $number_of_lines_to_read   = 50000;
     my $number_of_Homologs_to_read= 7000; # 699 is for 1% error in 935 PDB40D
     my $number_of_Nomologs_to_read= 90; # 9 is for 1% error in 935 PDB40D

     if($vars{'l'}=~/\S+/){ $number_of_lines_to_read=$vars{'l'} }
     for($i=0; $i< @file; $i++){
         my ($counter);
         if($file[$i]=~/\.parf/i){
             push(@parf_file, $file[$i]);
         }else{
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Check if it is parf file inside the file
             #__________________________________________________________
             open(INPUT_FILE, "<$file[$i]");
             while(<INPUT_FILE>){
                  $counter++;
                  if(/^\s*\S+\s+\S+\s+[NFUH]omolog\s+\S+\s+\S+\s+\S+/){
                      push(@parf_file, $file[$i]);
                      last;
                  }else{
                      if($counter > 100){  ## giving up, it is not PARF file!
                          print "\n# $0 needs to have PARF files, others are ignored";
                          last;
                      }else{
                          next;
                      }
                  }
             }
             close(INPUT_FILE);
         }
     }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # Processing the parf file contents
     #__________________________________________________________
     for($i=0; $i< @parf_file; $i++){
         my($nomolog_counter, $homolog_counter, $sorted_pair, @sorted_seq_name_pairs);
         open(PARF_FILE, "<$parf_file[$i]");
         while(<PARF_FILE>){
              if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
                   $number_of_lines_read++;
                   $sorted_pair=join('', sort($1, $2));
                   $homology_info=$3;
                   $score=$4;
                   $classification_column_1=$5;
                   $classification_column_2=$6;

                   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   # Count the NO-HOmology
                   #____________________________________
                   if($homology_info =~/Nomolog/i){
                       $nomolog_counter++;
                   }elsif($homology_info =~/Homolog/i){
                       $homolog_counter++;
                   }

                   $parf_hash_homology_info{$sorted_pair}=$homology_info;
                   $parf_hash_score{$sorted_pair}=$score;
                   $parf_hash_classification_column_1{$sorted_pair}=$classification_column_1;
                   $parf_hash_classification_column_2{$sorted_pair}=$classification_column_2;
                   $parf_hash_Homologous_rank{$sorted_pair}=$homolog_counter;
                   $parf_hash_Nomologous_rank{$sorted_pair}=$nomolog_counter;

              }
              if($number_of_lines_read == $number_of_lines_to_read){  last;     }
              if($nomolog_counter == $number_of_Nomologs_to_read){    last;     }
              if($homolog_counter == $number_of_Homologs_to_read){    last;     }
         }
         close(PARF_FILE);

     }
     return(\%parf_hash_homology_info,
            \%parf_hash_score,
            \%parf_hash_classification_column_1,
            \%parf_hash_classification_column_2,
            \%parf_hash_Homologous_rank,
            \%parf_hash_Nomologous_rank);
}



#______________________________________________________________________________
# Title     : open_upro_files
# Usage     :
# Function  : User Profile file (for NetBioServ)
# Example   : input example is:
#
#  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  User      : Jong
#  Seq_name  : 128U_DROME
#  Sequence  : MITILEKISAIESEMARTQKNKATSAHLGLLKANVAKLRRELISPKGGGGGTGEAGFEVAK
#              LLDLPGIIEGAKDGKGRGRQVIAVARTCNLIFMVLDCLKPLGHKKLLEHELEGFGIRLNKKPPNIY
#              SDDLIDVIEGNRIYIPCIYLLNKIDQISIEELDVIYKIPHCVPISAHHHWNFDDLLELMWEYLRLQ
#              WGSSVKHQPQKVGIEHVLNDEDVVQIVKKV
#  ____________________________________________________________
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub open_upro_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my(%UPRO, $query_seq_name, $user_name, $sequence, @final_hash_out);
		if(@file<1){
				print "\n \@file has less than 1 elem. There is no fileinput for open_embl_files\n";
				die
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# (1) opening UPRO files
		#_______________________________________________________________________
		for($i=0; $i< @file; $i++){
			 unless(-s $file[$i]){ print "\n# (E) File not found $file[$i]\n"; next; } ## this is essential as handle_arguments has a problem
			 open(UPRO, $file[$i]) || die "\n $0 open_upro_files failed to open $file[$i] \n";
			 while(<UPRO>){
					if(/User\s+:\s*(\S+)/i){
							$user_name=$1;
					}elsif(/Seq_name\s+:\s*(\S+)/i){
							$query_seq_name="$1\_$user_name";
					}elsif(/Sequence\s+:\s*(\S[\S ]+)/i){
							$sequence=$1;
					}elsif($sequence and /^\s*[^_]+([\S ]+)/i){
					    $sequence.=$1;
					}elsif(/^\s*#?________+/){
					    last;
					}
		   }
		   close(UPRO);
			 %UPRO=('USER', $user_name, 'SEQ_NAME', $query_seq_name, 'SEQUENCE', $sequence);
			 push(@final_hash_out, \%UPRO);
		}
		if(@final_hash_out > 1){
			 return(\@final_hash_out);
		}else{
			 return(\%UPRO);
		}

}



#__________________________________________________________________________
# Title     : open_sequence_index_files
# Usage     : open_sequence_index_files(<indexfilename>, <sequencename>);
# Function  : returns seqname with its seek pos in fasta sequence db file.
# Example   : %index=%{&open_sequence_index_files(\@INDEX_FILE, \@input_seq_names)};
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : open_seq_index_files, open_seq_idx_files, open_idx_files,
#             get_sequence_index, get_seq_index, get_sequence_with_index
# Options   : _ or # for debugging
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------
sub open_sequence_index_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my( %final_index, %long_index);

    for($i=0; $i< @file; $i++){
        open(INDEX, "$file[$i]");
        while(<INDEX>){
           if(/^(\S+)\s+(\S+)$/){
               $long_index{$1}=$2;
           }
        }
        for($j =0; $j < @string; $j++){ #<<<< @string has the sequence NAMEs >>>>
            if($input_seq_names[$j]=~/^(\S+)_\d+\-\d+/){
                 $seq_with_index{$input_seq_names[$j]}=$long_index{$1};
            }else{
                 $seq_with_index{$input_seq_names[$j]}=$long_index{$input_seq_names[$j]};
            }
        }

	}
	return(\%final_index);
}



#______________________________________________________________________________
# Title     : do_MRC_search
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
#   $HERTA_algorithm_type=     by M=
#   $HERTA_open_gap_penalty=   by A=
#   $HERTA_extend_gap_penalty= by B=
#   $HERTA_coded_seq1=         by P=
#   $HERTA_coded_seq2=       by Q=
#   $HERTA_coded_seq1_rv     by p=
#   $HERTA_coded_seq2_rv     by q=
#   $HERTA_Matrix_name=      by R=
#   $Query_sequences=        by Q=
#   $DB_sequences=           by D=
#   $raw_matrix_name=        by X=
#   $NO_screen_print=Q       by Q
#   $overwrite_opt=o         by o
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.6
#------------------------------------------------------------------------------
sub do_MRC_search{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my(@scores, @codes, $count, $out_matrix_name, $algorithm, $HERTA_algorithm_type,
       $openning_gap_penalty, $elongation_gap_penalty, $coded_seq1,
       $coded_seq2, $coded_Matrix_name, $HERTA_coded_seq1_rv, $HERTA_coded_seq2_rv,
       $coded_seq1_rv, $coded_seq2_rv, $output_herta_file_rv, $raw_matrix_name,
       %DB_input, %seq_input, $HERTA_open_gap_penalty, $HERTA_extend_gap_penalty,
       $query_seq, $DB_seq, $NO_screen_print, $MRCS_file_query, $MRCS_FILE_HANDLE,
       $write_EACH_MRCS_pair_file, @HERTA_files_made, $keep_HERTA_files,
       $num_of_queries, $num_of_DB_seq, %sorted_pair_seqs, $overwrite_opt);

    $HERTA_algorithm_type    ='lss_dipeptide';
    $openning_gap_penalty    =5;
    $elongation_gap_penalty  =1;
    $MRCS_FILE_HANDLE="MRCS_FILE_HANDLE";

    if($vars{'M'}=~/(\S+)/){ $algorithm=$1 } # gss_dipeptide, lss_dipeptide
    if($vars{'A'}=~/(\S+)/){ $openning_gap_penalty=$1 }
    if($vars{'B'}=~/(\S+)/){ $elongation_gap_penalty=$1 }
    if($vars{'P'}=~/(\S+)/){ $coded_seq1=$1 }
    if($vars{'Q'}=~/(\S+)/){ $coded_seq2=$1 }
    if($vars{'p'}=~/(\S+)/){ $coded_seq1_rv=$1 }
    if($vars{'q'}=~/(\S+)/){ $coded_seq2_rv=$1 }
    if($vars{'R'}=~/(\S+)/){ $coded_Matrix_name=$1 }
    if($vars{'F'}=~/(\S+)/){ $Query_sequences=$1 }
    if($vars{'D'}=~/(\S+)/){ $DB_sequences=$1 }
    if($vars{'X'}=~/(\S+)/){ $raw_matrix_name=$1 }
    if($char_opt=~/o/){ $overwrite_opt='o' }
    if($char_opt=~/Q/){      $NO_screen_print='Q' }
    if($vars{'E'}=~/(\S+)/){ $write_EACH_MRCS_pair_file='E'; }
    if($char_opt=~/k/){      $keep_HERTA_files='k' }

    unless(-s $coded_Matrix_name){
       print "\n $0: do_MRC_search, \$coded_Matrix_name ($coded_Matrix_name) not here!, will check AA_matrix.matx \n";
       if(-s $raw_matrix_name and !(-b $raw_matrix_name)){
           $HERTA_Matrix_name=${&encode_residue_exchange_matrix("$raw_matrix_name")};
       }elsif( !(-e $raw_matrix_name) and -b "$coded_Matrix_name"){  $coded_Matrix_name="$coded_Matrix_name";
       }elsif(-s "AA_matrix.matx"){  $coded_Matrix_name="AA_matrix.matx";
       }else{                    die "\n \$coded_Matrix_name and \$raw_matrix_name are not given/found \n";       }
    }else{
       print "\n Using \$coded_Matrix_name : $coded_Matrix_name, GOOD!!\n\n";
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Openning $Query_sequences and $DB_sequences
    #_____________________________________________________
    #print "\n(1) Reading and writing $Query_sequences and $DB_sequences sequences \n\n";
    %seq_input=%{&open_fasta_files(\$Query_sequences)};
    %DB_input =%{&open_fasta_files(\$DB_sequences)};
    &write_fasta_seq_by_seq(\%seq_input, 'e'); ## e makes skip writing when file already
    &write_fasta_seq_by_seq(\%DB_input, 'e'); ## e makes skip writing when file already
    @Query_seq_names= sort keys %seq_input;
    @DB_seq_names   = sort keys %DB_input;
    $num_of_queries=@Query_seq_names;
    $num_of_DB_seq =@DB_seq_names;

    for($i=0; $i< @Query_seq_names; $i++){
        $query_seq=$Query_seq_names[$i];
        $query_seq_file="$query_seq\.spfa";
        $MRCS_file_query="$query_seq\_OG$openning_gap_penalty\_EG$elongation_gap_penalty\_$algorithm.mrcs";
        if(-s $MRCS_file_query and !$overwrite_opt){
           print " :-o  skipping $MRCS_file_query\n"; next;
        }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Openning output $MRCS_FILE_HANDLE
        #________________________________________________________
        open($MRCS_FILE_HANDLE, ">$MRCS_file_query") || die "Cannot open $MRCS_file_query, do_MRC_search\n";
        print $MRCS_FILE_HANDLE "# $0: $query_seq -> $DB_sequences\n";
        for($j=$i; $j< @DB_seq_names; $j++){
           $DB_seq=$DB_seq_names[$j];
           $DB_seq_file="$DB_seq\.spfa";
           #if($query_seq eq $DB_seq){ next }
           $sorted_pair=join('_', sort($query_seq, $DB_seq));
           print "$sorted_pair: $j / $num_of_DB_seq DB seqs with $i / $num_of_queries queries\n";

           #print "\n  (2) \$sorted_pair is $sorted_pair, encoding $query_seq_file and $DB_seq_file";
           $sorted_pair_seqs{$sorted_pair}++;

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Checks if the pair has been compared. If not, do search
           #___________________________________________________________
           if($sorted_pair_seqs{$sorted_pair} == 1){
              ($coded_seq1, $coded_seq1_rv,
               $coded_seq2, $coded_seq2_rv)=@{&encode_fasta_sequences($query_seq_file, $DB_seq_file)};
               #print "\n  (3) Coded seqs are: $coded_seq1, $coded_seq2, $coded_seq1_rv, $coded_seq2_rv";
               $base1=${&get_base_names($coded_seq1)};
               $base2=${&get_base_names($coded_seq2)};
               $base1_rv=${&get_base_names($coded_seq1_rv)};
               $base2_rv=${&get_base_names($coded_seq2_rv)};
               $output_herta_file   ="$base1\_$base2\.herta";
               $output_herta_file_rv="$base1\_$base2_rv\.herta";
               push(@HERTA_files_made, $output_herta_file, $output_herta_file_rv);
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Running forward ($coded_seq1 <-> $coded_seq2)
               #________________________________________________
               #print "\n  (5) Running herta with $coded_seq1 $coded_seq2\n Now running $coded_seq1 <=> $coded_seq2_rv";
               system("herta -M $algorithm -A $openning_gap_penalty -B $elongation_gap_penalty -P $coded_seq1 -Q $coded_seq2 -R $coded_Matrix_name > $output_herta_file");
               if(-s $output_herta_file){ #print "\n $output_herta_file is written with A=$openning_gap_penalty\n";
               }else{  die "\n $output_herta_file does not exist, something is wrong \n\n"; }

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Running backward ($coded_seq1 <-> $coded_seq2_rv)
               #________________________________________________
               system("herta -M $algorithm -A $openning_gap_penalty -B $elongation_gap_penalty -P $coded_seq1 -Q $coded_seq2_rv -R $coded_Matrix_name > $output_herta_file_rv");
               if(-s $output_herta_file_rv){ #print "\n $output_herta_file is written with A=$openning_gap_penalty\n";
               }else{  die "\n $output_herta_file does not exist, something is wrong \n\n"; }

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Writing alignment
               #____________________________________________________________
               &write_MRC_search_result_file(\$output_herta_file,
                                             \$query_seq_file,
                                             \$DB_seq_file,
                                             \$query_seq,
                                             \$DB_seq,
                                             \$openning_gap_penalty,
                                             \$elongation_gap_penalty,
                                             \$HERTA_algorithm_type,
                                             $NO_screen_print,
                                             \$MRCS_FILE_HANDLE,
                                             $write_EACH_MRCS_pair_file);

           }
        }
        unlink($coded_seq1, $coded_seq1_rv, $coded_seq2, $coded_seq2_rv);
        unless($keep_HERTA_files){
           unlink(@HERTA_files_made);
        }
        close($MRCS_FILE_HANDLE);
    }

}




#______________________________________________________________________________
# Title     : do_fasta_and_ssearch
# Usage     : $gzipped_mspa_file=${&do_fasta_and_ssearch("a=$algorithm",
#                        "O=$out_file_mspa_name", "File=$temp_file_name", "e=$E_val",
#                        "DB=$sequence_DB", "k=$k_tuple", "$machine_readable")};
#
# Function  : runs FASTA or SSEARCH algorithm (given by a= option)
# Example   :
# Keywords  : run_ssearch_sequence_search, do_fasta_sequence_search,
#             do_fasta_search
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             i= to get file base(root) name. same as File=
#             m  for MSP format directly from FASTA or Ssearch result than through sso_to_mspa to save mem
#             s  for the big single output (mspa file output I mean)
#             s= for the single big mspa file name
#             O= for Out file name, same as s=
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             d  for very simple run and saving the result in xxxx.gz format in sub dir starting with one char
#             r  for reverse the query sequence
#             R  for attaching ranges of sequences
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             l= for $lower_expect_limit
#             a= for choosing either fasta or ssearch algorithm
#             d= for defining the size of subdir made. 2 means it creates
#                    eg, DE while 1 makes D
#             d  for $make_gz_in_sub_dir_opt, putting resultant sso files in gz format and in single char subdir
#             D  for $make_mspa_in_sub_dir_opt, convert sso to mspa and put in sub dir like /D/, /S/
#             n  for new format to create new mspa file format with sso_to_mspa routine
#          PVM=  for PVM run of FASTA (FASTA only)
#             M  for machine readable format -m 10 option
#             M= for machine readable format -m 10 option
#             N  for 'NO' do not do any processing but, do the searches only.
#       FILE_AGE for defining the age of file in days to be overwritten.
# Author    : Jong Park, jong@biosophy.org, for commercial use, ask me.
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub do_fasta_and_ssearch{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($algorithm, $E_val, $sequence_DB, $k_tuple, $machine_readable,$create_sso,
			 @mspa_from_temp, $gzipped_mspa_file, @temp, $temp_file_name, $add_range,
			 $out_file_mspa_name, $input_file_name, $out_file_sso_name,
			 $gzipped_sso_file, $machine_readable);
		$algorithm='fasta';    $out_file_mspa_name='default_out_file.mspa';
		$E_val=1;              $sequence_DB=$ENV{'NRDB_FASTA'};
		$k_tuple=1;            $machine_readable='M';
		$upper_expect_limit=1; $lower_expect_limit=0;
		$Score_thresh=100;

		if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}            };
		if($vars{'O'}=~/\S+/){ $out_file_mspa_name  = $vars{'O'}            };
		if($vars{'e'}=~/\S+/){ $E_val              = $vars{'e'}            };
		if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
		if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
		if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'}            };
		if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
		if($vars{'r'}=~/\S+/){ $add_range          = 'r'                   };
		if($vars{'s'}=~/\S+/){ $single_big_mspa     = 's'                   };
		if($vars{'DB'}=~/\S+/){            $sequence_DB=$vars{'DB'} ;
				if(-s $sequence_DB){
				}elsif(-s "../$sequence_DB"){  $sequence_DB= "../$sequence_DB"
				}elsif(-s "../../$sequence_DB"){  $sequence_DB= "../../$sequence_DB";
				}else{
						print "\n# (ERROR) do_sequence_search: You set DB param, but I can\'t find $sequence_DB\n";
						die;
				}
		}else{  print "\n# (ERROR) do_sequence_search: I need DB param defined, sorry, aborting\n"; }

		if($vars{'FILE'}=~/\S+/){ $input_file_name = $vars{'FILE'}; };
		if($vars{'File'}=~/\S+/){ $input_file_name = $vars{'File'}; };
		if($vars{'FILE_AGE'}=~/\S+/){ $age_in_days_of_out_file= $vars{'FILE_AGE'};  };
		if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
		if($vars{'Query'}=~/\S+/){      %seq_input = %{$vars{'Query'}}};
		if($vars{'u'}    =~/\S+/){ $E_val          = $vars{'u'}            };
		if($vars{'PVM'}  =~/\S+/){ $PVM_FASTA_run  = $vars{'PVM'}; print "\n# PVM opt is set\n";     };
		if($vars{'M'}  =~/\S+/){ $machine_readable = $vars{'M'};           };

		if($char_opt=~/r/){    $add_range          = 'r' }
		if($char_opt=~/o/){    $over_write         = 'o' }
		if($char_opt=~/c/){    $create_sso         = 'c' }
		if($char_opt=~/s/){    $single_big_mspa     = 's'; print "\n# Single file opt is set\n"; }
		if($char_opt=~/M/){    $machine_readable   = 'M' }
		if($char_opt=~/N/){    $No_processing      = 'N'; $create_sso='c'; }
		print "\n# (INFO) do_fasta_and_ssearch: $algorithm,$out_file_mspa_name,$input_file_name,$E_val,DB=$sequence_DB,$k_tuple,$machine_readable\n";

		if(!$algorithm or !$input_file_name or !$sequence_DB){
				print "\n# (ERROR) One of \$sequence_DB, \$input_file_name, \$algorithm is missing\n";
				die;
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (1) Machine readable opt for fasta and ssearch set ??
		#____________________________________________________
		if($machine_readable=~/M/){
		   if(-s "./Bin/$algorithm"){
					 print "\n# (INFO) Running $algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple\n";
					 @temp=`./Bin/$algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple`;
			 }else{
					 print "\n# (INFO) Running $algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple\n";
					 @temp=`$algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple`;
			 }
		}else{
		   if(-s "./Bin/$algorithm"){
					 print "\n# (INFO) Running $algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple\n";
					 @temp=`./Bin/$algorithm -H  -E $E_val $input_file_name $sequence_DB $k_tuple`;
			 }else{
					 print "\n# (INFO) Running $algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple\n";
					 @temp=`$algorithm -H  -E $E_val $input_file_name $sequence_DB $k_tuple`;
			 }
		}
		print "\n# (INFO) \@temp has ",scalar(@temp), " lines @temp!\n" if $verbose;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (2) @temp is parsed directly by open_sso_files to make MSP hashes
		#_______________________________________________________________________
		@mspa_hashes_from_temp = @{&open_sso_files(\@temp, $add_range, "u=$upper_expect_limit", "l=$lower_expect_limit")};
		if(@mspa_hashes_from_temp < 1){
				print "\n# (ERROR) do_sequence_search : Error, something is wrong with open_sso_files, LINE=", __LINE__, "\n";
				die;
		}else{   print "\n# (INFO) Good, \@mspa_from_temp has ",scalar(@mspa_hashes_from_temp), " lines !\n";   }
		@mspa_from_temp= values %{$mspa_hashes_from_temp[0]};
		print "\n# (INFO) @mspa_from_temp\n" if $verbose;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (3) Writing MSP file, and gzipping if possible
		#________________________________________________
		open(MSP, ">$out_file_mspa_name") or die "\n# (ERROR) $out_file_mspa_name could not be open\n";
		for(@mspa_from_temp){    print MSP $_;  }
		close MSP;
		$gzipped_mspa_file=${&compress_files_by_gzip($out_file_mspa_name)};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (4) making SSO file if asked
		#__________________________________________________
		if($create_sso){
			 $seq_name=${&get_base_names($input_file_name)};
			 if($algorithm=~/ssearch/){
					$out_file_sso_name="$seq_name\.ssso";
					$out_file_sso_name_gz="$seq_name\.ssso\.gz";
			 }elsif($algorithm=~/fasta/){
					$out_file_sso_name="$seq_name\.fsso";
					$out_file_sso_name_gz="$seq_name\.fsso\.gz";
			 }
			 open(SSO, ">$out_file_sso_name");
			 for(@temp){  print SSO $_;  }; close (SSO);
			 if($machine_readable){
					 $out_file_msso_name="$seq_name\.msso";
					 &cp( $out_file_sso_name, $out_file_msso_name);
			 }
			 @gzipped_sso_files=@{&compress_files_by_gzip($out_file_sso_name, $out_file_msso_name)};

			 if(@gzipped_sso_files > 0){  print "\n# (INFO) @gzipped_sso_files are created"; }
		}
		if(-s $gzipped_mspa_file and !(-s $out_file_mspa_name)){
			 print "\n# (INFO) $gzipped_mspa_file is found and will be returned";
			 return(\$gzipped_mspa_file);
		}elsif(-s $out_file_mspa_name){
			 print "\n# (INFO) $out_file_mspa_name is found and will be returned";
			 return(\$out_file_mspa_name);
		}
}## end of do_fasta_and_ssearch



#__________________________________________________________________
# Title     : do_intermediate_sequence_search
# Usage     : &do_intermediate_sequence_search(\%pdb_seq, $owl_db_fasta, $ARGV[0], $single_mspa, $over_write,
#                    "u=$upper_expect_limit", "l=$lower_expect_limit", "k=$k_tuple" );
#
# Function  :
# Example   : &do_intermediate_sequence_search(\%pdb_seq, $owl_db_fasta, $ARGV[0], $single_mspa, $over_write,
#                    "u=$upper_expect_limit", "l=$lower_expect_limit", "k=$k_tuple" );
#
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             m  for MSP format directly from FASTA or Ssearch result than through sso_to_mspa to save mem
#             s  for the big single output (mspa file output I mean)
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             R  for adding ranges to the enquiry sequences as well.
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             l= for $lower_expect_limit
#             a= for choosing either fasta or ssearch algorithm
#
# Returns   : the names of files created (xxxxx.mspa, yyy.mspa,,)
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------------------
sub do_intermediate_sequence_search{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my (@final_out, $add_range, $single_big_mspa, $base_name, $create_sso, @nondup,
	   $Single_mspa_out_file, %duplicate, $Evalue_thresh, $Score_thresh, @SSO, $sequence_DB,
	   @sso, @temp, $algorithm, $margin, $out_mspa_file, @MSP, @final_mspa_file_names_out,
	   $upper_expect_limit, $lower_expect_limit, $k_tuple, %seq_input, %MSP, $add_range_to_enquiry );
	my ($E_val) = 5;  ## default 5 <<<<<<<<<<<<<<<<<<<<<

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# DEFAULTS
	#________________________________________
	$k_tuple=1;
	$algorithm='fasta';
	$upper_expect_limit=10;
	$lower_expect_limit=0;
	$Score_thresh      =75;
	$margin            =0;
	$add_range         ='';
	$sequence_DB       =$ENV{'PDB40D_FASTA'};

	if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}            };
	if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
	if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
	if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'}            };
	if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
	if($vars{'m'}=~/\d+/){ $margin             = $vars{'m'}            };
	if($vars{'r'}=~/\S+/){ $add_range          = 'r'                   };
	if($vars{'s'}=~/\S+/){ $single_big_mspa     = 's'                   };
	if($vars{'DB'}=~/\S+/){ $sequence_DB       = $vars{'DB'}           };
	if($vars{'File'}=~/\S+/){ $input_file_name = $vars{'File'}         };
	if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
	if($vars{'e'}         =~/\S+/){ $E_val     = $vars{'e'}            };

	if($char_opt=~/r/){    $add_range            = 'r' }
	if($char_opt=~/R/){    $add_range_to_enquiry = 'R'  }
	if($char_opt=~/c/){    $create_sso           = 'c' }
	if($char_opt=~/s/){    $single_big_mspa       = 's'; print "\n# Single file opt is set\n"; }
	if($char_opt=~/m/){    $mspa_directly_opt     = 'm' }
	if($char_opt=~/i/){    $do_intermediate_search   = 'i' }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 #  When, you didn't use "DB=$XXX" and "File=$FXXX" format, first file input is DB etc
	 #_______________________________________________________________________________________
	 if($input_file_name=~/^$/){  $input_file_name=$file[1];
	  print "\n# You did not use \"File=\$XXX\" format\n"  };
	 if($sequence_DB=~/^$/){      $sequence_DB    =$file[0];
	  print "\n# You did not use \"DB=\$XXX\" format\n"   };
	 print "\n# Finished writing the enquiry fasta files from \%seq_input by write_fasta_seq_by_seq";
	 print "\n# I am in do_sequence_search sub, Target database used :  $sequence_DB \n";

	 my $base = ${&get_base_names($input_file_name)};
				 $out_mspa_file="$base\.mspa";
	 @temp=`$algorithm -m 10 -H  -E $E_val $input_file_name $sequence_DB $k_tuple`;
	 if(@temp < 40){	  print "\n# There must be error , \@temp is too small\n\n";   }
	 my @mspa_hashes_from_temp = @{&open_sso_files(\@temp, $add_range,
												"u=$upper_expect_limit",
												"l=$lower_expect_limit",
												$add_range_to_enquiry)};
	 my @mspa_from_temp= values %{$mspa_hashes_from_temp[0]};
	 $MSP{$out_mspa_file} = \@mspa_from_temp;
	 open(MSPOUT, ">$out_mspa_file");
	 for($i=0; $i< @mspa_from_temp; $i++){
						 print MSPOUT $mspa_from_temp[$i];
						 print $mspa_from_temp[$i];
	 }
	 close MSPOUT;
	 return(\$out_mspa_file);
}


#____________________________________________________________________________________
# Title     : do_sequence_search
# Usage     : &do_sequence_search("Query_seqs=\%pdb_seq", "DB=$sequence_DB",
#  		         "File=$ARGV[0]", $single_mspa, $over_write,
# 	        	 "u=$upper_expect_limit", "l=$lower_expect_limit",
#       		 "k=$k_tuple", $No_processing );
# Function  : do FASTA, SSEARCH or BLASTPGP(psi-blast) search
# Example   : &do_sequence_search(\%pdb_seq, $owl_db_fasta, $ARGV[0], $single_mspa, $over_write,
#                    "u=$upper_expect_limit", "l=$lower_expect_limit", "k=$k_tuple" );
#
# Keywords  : sequence_search
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             m  for MSP format directly from FASTA or Ssearch result than through sso_to_mspa to save mem
#             s  for the big single output (mspa file output I mean)
#             s= for the single big mspa file name
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             d  for very simple run and saving the result in xxxx.gz format in sub dir starting with one char
#             r  for reverse the query sequence
#             R  for attaching ranges of sequences
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             l= for $lower_expect_limit
#             E= for $Evalue_thresh
#             a= for choosing either fasta or ssearch algorithm
#             d= for defining the size of subdir made. 2 means it creates
#                    eg, DE while 1 makes D
#             d  for $make_gz_in_sub_dir_opt, putting resultant sso files in gz format and in single char subdir
#             D  for $make_mspa_in_sub_dir_opt, convert sso to mspa and put in sub dir like /D/, /S/
#             n  for new format to create new mspa file format with sso_to_mspa routine
#          PVM=  for PVM run of FASTA (FASTA only)
#             M  for machine readable format -m 10 option
#             M= for machine readable format -m 10 option
#             N  for 'NO' do not do any processing but, do the searches only.
#       FILE_AGE for defining the age of file in days to be overwritten.
#             L  for Lean output(removes xxxx.fasta query seq file)
#   $take_last_iter_psi_bla=l by l
#
# Returns   : the names of files created (xxxxx.mspa, yyy.mspa,,)
# Version   : 5.8
#----------------------------------------------------------------------------------------
sub do_sequence_search{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (@final_out, $add_range, $single_big_mspa, $base_name, $create_sso, @nondup,
         $Single_mspa_out_file, %duplicate, $Evalue_thresh, $Score_thresh, @SSO, $sequence_DB,
         @sso, @temp, $algorithm, $margin, $out_mspa_file, @MSP, @final_mspa_file_names_out,
         $upper_expect_limit, $lower_expect_limit, $k_tuple, %seq_input, %MSP, $No_processing,
         $new_format, $PVM_FASTA_run, $over_write, $sub_dir_size, $age_in_days_of_out_file,
         $over_write_by_age, $Lean_output, $gzipped_mspa_file, $gzipped_sso_file,
         $defined_all_ok, $make_mspa_in_sub_dir_opt, $upper_expect_limit, $Evalue_thresh,
         $take_last_iter_psi_bla );

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # DEFAULTS
    #________________________________________
    $k_tuple           =1;  # 1 or 2, 1 is more sensitive
    $algorithm         ='fasta';
    $sub_dir_size      =2;  # the default char number taken from seq name to make sub dirs
    $upper_expect_limit=5;
    $lower_expect_limit=0;
    $Score_thresh      =75; # FASTA or SSSEARCH score
    $margin            =0;  # sequence region margin. If it is 2, 2 more edged residues will be added
    $add_range         ='';
    $pwd               =`pwd`; chomp($pwd);
    $age_in_days_of_out_file=1000; ## If the files being tested is older than this, let's make anew

    if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}            };
    if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
    if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
    if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'}            };
    if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
    if($vars{'m'}=~/\d+/){ $margin             = $vars{'m'}            };
    if($vars{'d'}=~/\d+/){ $sub_dir_size       = $vars{'d'}            };
    if($vars{'r'}=~/\S+/){ $add_range          = 'r'                   };
    if($vars{'s'}=~/\S+/){ $single_big_mspa     = 's'                   };
    if($vars{'DB'}=~/\S+/){            $sequence_DB=$vars{'DB'} ;
        if(-s $sequence_DB){
        }elsif(-s "../$sequence_DB"){  $sequence_DB= "../$sequence_DB"
        }elsif(-s "../../$sequence_DB"){  $sequence_DB= "../../$sequence_DB";
        }else{
                print "\n# (E) do_sequence_search: You set DB param, but I can\'t find $sequence_DB\n";
                die;
        }
    }else{  print "\n# (E) do_sequence_search: I need DB param defined, sorry, aborting\n"; }

    if($vars{'FILE'}=~/\S+/){ $query_File = $vars{'FILE'}; push(@file,$query_File) };
    if($vars{'File'}=~/\S+/){ $query_File = $vars{'File'}; push(@file,$query_File) };
    if($vars{'FILE_AGE'}=~/\S+/){ $age_in_days_of_out_file= $vars{'FILE_AGE'};  };
    if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
    if($vars{'Query'}=~/\S+/){      %seq_input = %{$vars{'Query'}}};
    if($vars{'u'}    =~/\S+/){ $upper_expect_limit          = $vars{'u'}            };
    if($vars{'PVM'}  =~/\S+/){ $PVM_FASTA_run  = $vars{'PVM'}; print "\n# PVM opt is set\n";     };
    if($vars{'M'}  =~/\S+/){ $machine_readable = $vars{'M'};           };
    if($vars{'E'}  =~/\S+/){ $Evalue_thresh = $vars{'E'};           };

    if($char_opt=~/l/){    $take_last_iter_psi_bla= 'l' }
    if($char_opt=~/r/){    $add_range             = 'r' }
    if($char_opt=~/L/){    $Lean_output           = 'L' }
    if($char_opt=~/o/){    $over_write            = 'o' }
    if($char_opt=~/c/){    $create_sso            = 'c' }
    if($char_opt=~/s/){    $single_big_mspa        = 's'; print "\n# Single file opt is set\n"; }
    if($char_opt=~/m/){    $mspa_directly_opt      = 'm' }
    if($char_opt=~/M/){    $machine_readable      = 'M' }
    if($char_opt=~/d/){    $save_in_gz_in_sub_dir = 'd' }
    if($char_opt=~/D/){$make_mspa_in_sub_dir_opt   = 'D' } # for simple search and storing mspa file
    if($char_opt=~/N/){    $No_processing         = 'N'; $create_sso='c'; }
    if($char_opt=~/q/){    $make_MSP_files        = 'q' }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
    # When no %seq is given, but files
    #___________________________________________
    if(@hash==0 and @file > 0){
         print "\n# (i) do_sequence_search: You did not put sequences as in \%seq, but raw sequence file @file!\n";
         print "        I will run \'open_fasta_files\' sub to fetch sequences to store in \%seq_input\n";
         %seq_input=%{&open_fasta_files(\@file)};
         unless(%seq_input > 1){
            print "\n !!!! \%seq_input hash is too small, Error opening \@file : @file, in do_sequence_search sub \n\n";
            die;
         }
    }else{
         #print "\n# (i) do_sequence_search: I will use given seqs in \%seq_input from \%\{\$hash\[0\]\}\n";
         %seq_input=%{$hash[0]};
    }
    my (@seq_names) = keys %seq_input;

    $base_name = ${&get_base_names($query_File)};
    print "\n# (i) line:",__LINE__, ", do_sequence_search, \$algorithm => $algorithm, \$base_name:$base_name
                         $query_File <--> $sequence_DB\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
    # If one of the files is missing, ask if it is for self self search and
    #  make query=target, else die
    #_______________________________________________________________________
    $defined_all_ok=&check_if_defined($query_File, $sequence_DB);
    unless($defined_all_ok){
         print "\n  Did you want to do self self search? ->(y/n) ";
         $answer_for_self_self=getc;
         if($answer_for_self_self =~/y/i){
              if($query_File){  $sequence_DB=$query_File }
              else{ $query_File=$sequence_DB }
         }else{
              print "\n# You seemed made a mistake, O.K., I will kill myself!\n\n";
              print chr(7);  die;
         }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # [0] If blast is chosen run Blast
    #_________________________________________________________
    if($algorithm=~/[psi\-]*[pb][last]*/i){
         print "\n# (i) Doing PSI search with @file\n";
         @final_out=@{&do_psi_blast_search(\@file, "d=$source_DB_file",
                                            "i=$input_seq_file",
                                            $over_write,
                                            $make_mspa_in_sub_dir_opt,
                                            $Lean_output,
                                            $make_MSP_files,
                                            $take_last_iter_psi_bla)};
         return(\@final_out); #<<<<<<----------- F I N I S H
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # [1] Controlling which kind of search it should do. Do save_in_gz_in_sub_dir first if d is set
    #______________________________________________________________________________________________
    if( $make_mspa_in_sub_dir_opt ){  ## convert sso to mspa and put in sub dir like /D/, /S/
        print "[1] \$make_mspa_in_sub_dir_opt";
        for($x=0; $x < @seq_names; $x++){
             my ($over_write_sso_by_age, $over_write_mspa_by_age,  %single_seq, $out_file_sso_gz_name, $out_file_mspa_name, $out_file_gz_name, $existing_sso);
             my ($seq_name, $seq)= ($seq_names[$x], $seq_input{$seq_names[$x]});
             my $first_char= substr("\U$seq_name", 0, $sub_dir_size);
             mkdir ("$first_char", 0777) unless -d $first_char;
             chdir("$first_char");
             #print "\n# (i) do_sequence_search: You set \'d\' or \'D\' opt\n";
             #print "# (i) making subDIRs ($first_char) with $seq_name $sequence_DB to store MSP files\n";

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Let's make each fasta file for each seq to be used in searching
             #_____________________________________________________________________
             my $temp_file_name="$seq_name.fasta";
             %single_seq=($seq_name, $seq_input{$seq_name});
             &write_fasta(\%single_seq, $temp_file_name ); ## e for writing each file

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Making output file name according to the option given
             #_______________________________________________________________________
             if($machine_readable and $algorithm=~/[fastassearch]+/){  $out_file_sso_name="$seq_name\.msso";
             }else{ $out_file_sso_name="$seq_name\.sso";      }
             $out_file_sso_gz_name    ="$out_file_sso_name\.gz";
             $out_file_mspa_name       ="$seq_name\.mspa";
             $out_file_gz_name        ="$seq_name\.mspa\.gz";

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Check if SSO file already there
             #_______________________________________________________________________
             if(-s $out_sso_file){ $existing_sso=$out_file_sso_name }
             elsif(-s $out_sso_gz_name){ $existing_sso=$out_file_sso_gz_name }
             if(-s $out_mspa_name){ $existing_mspa=$out_file_mspa_name }
             elsif(-s $out_gz_name){ $existing_mspa=$out_file_gz_name }

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # If the dates of files created are long ago, overwrite to refresh
             #____________________________________________________________________
             if(  (localtime(time- (stat($existing_sso))[9]))[3] > $age_in_days_of_out_file ){  $over_write_sso_by_age='o';  }
             if(  (localtime(time- (stat($existing_mspa))[9]))[3] > $age_in_days_of_out_file ){  $over_write_mspa_by_age='o';  }

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             #  To check if the target seq DB is in ../
             #________________________________________________
             if(-s $sequence_DB){     #print "\n# (i) Good, target \$sequence_DB $sequence_DB is in this working dir\n";
             }elsif( -s "../$sequence_DB"){ $sequence_DB="../$sequence_DB"; }

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # [1.1] Searching: Making MSP files directly,  MSP file format is the major format used in prescop!, Default
             #_____________________________________________________________________________________________________________
             if($char_opt =~/D/){ #### To make MSP file
                 print "\n [1.1] \$char_opt = D";
                 if( !(-s $out_file_gz_name or -s $out_file_mspa_name) or $over_write or $over_write_mspa_by_age){
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # (2.1) Running  run_fasta_sequence_search !!
                      #_______________________________________________________
                      print "\n  [1.1.1] Running  run_fasta_sequence_search, \$create_sso = $create_sso!!\n";
                      $gzipped_mspa_file=${&run_fasta_sequence_search(
                                                  "a=$algorithm",
                                                  "O=$out_file_mspa_name",
                                                  "File=$temp_file_name", "u=$upper_expect_limit", "E=$Evalue_thresh",
                                                  "DB=$sequence_DB", "k=$k_tuple", "$machine_readable", $create_sso,
                                                  $verbose)};

                      $gzipped_sso_file=${&compress_files_by_gzip($out_file_sso_name)};
                   }else{
                      print "\n#  [1.1.2] Line No. ", __LINE__,", $out_file_gz_name already exists or
                                     \$over_write is set or NOT older than $age_in_days_of_out_file\n";
                   }
             }
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # [1.2] To make gzipped SSO files and MSP files
             #_______________________________________________
             elsif($create_sso or $char_opt=~/m/){ ### To make gzipped SSO files
                  print "\n [1.2] \$char_opt = D";
                      if( !(-s $out_file_sso_name or -s $out_file_sso_gz_name ) or $over_write or $over_write_sso_by_age){
                          print "\n#  [1.2.1] Running  run_fasta_sequence_search with \"\$create_sso option\"!!\n\n";
                          $gzipped_mspa_file=${&run_fasta_sequence_search(
                                               "a=$algorithm",
                                               "O=$out_file_mspa_name", "$create_sso",
                                               "File=$temp_file_name", "u=$upper_expect_limit", "E=$Evalue_thresh",
                                               "DB=$sequence_DB", "k=$k_tuple", "$machine_readable", $create_sso,
                                               $verbose)};

                          $gzipped_sso_file=${&compress_files_by_gzip($out_file_sso_name)};
                      }else{
                          print "\n#  [1.2.2]Line No. ", __LINE__,", $out_file_gz_name already exists or
                                      \$over_write is set or NOT older than $age_in_days_of_out_file\n";
                      }
             }else{
                  if( !(-s $out_file_sso_name or -s $out_file_sso_gz_name ) or $over_write or $over_write_sso_by_age){
                          system(" $algorithm -m 10 -H  -E $upper_expect_limit $temp_file_name $sequence_DB $k_tuple > $out_file_sso_name");
                          system("gzip $out_file_sso_name");
                  }else{
                          print "\n#  Line No. ", __LINE__,", $out_file_gz_name already exists or
                                      \$over_write is set or NOT older than $age_in_days_of_out_file\n";
                  }
             }
             if(-s "$seq_name.fasta"){  unlink("$seq_name.fasta")
             }elsif(-s "$first_char/$seq_name.fasta"){ unlink("$first_char/$seq_name\.fasta") ; }
             #print "\n# Sub dir $first_char and $seq_name\.mspa has been made, finishing do_sequence_search\n";
             chdir ('..');
          }
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # F I N I S H
          #________________________________________
          goto EXIT;
	 } # if ($char_opt =~/[dD]/){  is finished


	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # (2) Writing on PWD. This is the big single MSP output
	 #____________________________________________________________
	 $Single_mspa_out_file="$base_name\.mspa" if($single_big_mspa eq 's');
	 if(-s $Single_mspa_out_file and !$over_write ){
			 print "\n# (i) $Single_mspa_out_file exists, and no \$over_write is set, skipping \n";
			 push(@final_out, $Single_mspa_out_file);
	 }else{  $over_write  ='o';  }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # Check if it is necessary to write each sequences.fasta files
	 #______________________________________________________
	 if( $over_write ){  &write_fasta_seq_by_seq(\%seq_input, 'e'); } ## e for writing each seq file

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 #  When, you didn't use "DB=$XXX" and "File=$FXXX" format, first file input is DB etc
	 #_______________________________________________________________________________________
	 $defined_all_ok=&check_if_defined($query_File, $sequence_DB);
	 if(!$defined_all_ok){ print "\n# (E) FATAL: do_sequence_search: You did not use \"DB=\$XXX\" format\n"; die   };

	 print "\n# Finished writing the enquiry fasta files from \%seq_input by write_fasta";
	 print "\n# I am in do_sequence_search sub, Target database used :  $sequence_DB with seqs of \'@seq_names\'\n";


	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  Main search with given @seq_names
	 #______________________________________________________________
	 for($j=0; $j< @seq_names; $j++){  # @seq_names has sequence names coming from  (@seq_names) = keys %seq_input;
			 my ($over_write_sso_by_age, @temp, $existing_sso, $out_gz_name,
					 $over_write_mspa_by_age, $existing_mspa, $out_mspa_file, $seq_name);
			 $seq_name=$seq_names[$j];
			 $each_seq_fasta="$seq_name\.fasta";
			 $out_mspa_file="$seq_name\.mspa";
			 $out_gz_name="$seq_name\.mspa\.gz";
			 $out_msso_file="$seq_name\.msso";

			 &die_if_file_not_present($each_seq_fasta);

			 print "\n# (i) :-) Found $each_seq_fasta is searched against $sequence_DB\n";
			 if($algorithm=~/fasta/){       $out_sso_file="$seq_name\.fsso";
			 }elsif($algorithm=~/ssearch/){ $out_sso_file="$seq_name\.ssso"; }
			 $out_sso_gz_name="$out_sso_name\.gz";

			 if(-s $out_sso_file){ $existing_sso=$out_sso_file }
			 elsif(-s $out_sso_gz_name){ $existing_sso=$out_sso_gz_name }
			 if(-s $out_mspa_file){ $existing_mspa=$out_mspa_file }
			 elsif(-s $out_gz_name){ $existing_mspa=$out_gz_name }
			 if(  (localtime(time- (stat($existing_sso))[9]))[3] > $age_in_days_of_out_file ){
						$over_write_sso_by_age='o';
			 }
			 if(  (localtime(time- (stat($existing_mspa))[9]))[3] > $age_in_days_of_out_file ){
						$over_write_mspa_by_age='o';
			 }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 #  To check if the target seq DB is in ../
			 #________________________________________________
			 if(-s $sequence_DB){ print "\n# (i) \$sequence_DB $sequence_DB exists, Good\n";
			 }elsif( -s "../$sequence_DB"){ $sequence_DB="../$sequence_DB";
			 }elsif( -s "../../$sequence_DB"){ $sequence_DB="../../$sequence_DB"; }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If MSP file already exist
			 #_____________________________________________________________
			 if( -s $out_mspa_file and !$over_write_mspa_by_age and !$over_write ){
						print "\n# (i) File: $out_mspa_file exists, skipping, to overwrite use \'o\' opt or set days";
						push(@final_out, $out_mspa_file);
			 }else{  ## -E is for e value cutoff. -b is for num of seq fetched
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~
					 #  K-tuple is 1 by default. If xxxx.sso exsts, skip running fasta or ssearch
					 #________________________________________________________________________________
					 if(-s $out_sso_file and !$over_write ){ ## If SSO is already present, JUST READ IT!
								print "\n# (i) Just opening existing $out_sso_file $out_sso_file $out_mspa_file $over_write_mspa_by_age $over_write\n";
                                open(SSO_ALREADY, "$out_sso_file") || warn "\nWarnning. Can not open $out_sso_file\n";
								@temp=<SSO_ALREADY>;
								print "\n# (i) \@temp has ", scalar(@temp), " lines\n";
								close(SSO_ALREADY);
								&compress_files_by_gzip($out_sso_file);
					 }else{ ## Run FASTA HERE
							print "\n# (i) Running \"run_fasta_sequence_search\" ";
							$gzipped_mspa_file=${&run_fasta_sequence_search( "a=$algorithm",
																 "O=$out_mspa_file", "$create_sso",
																 "File=$each_seq_fasta", "E=$upper_expect_limit",
																 "DB=$sequence_DB", "k=$k_tuple", "$machine_readable")};
							push(@final_out, $gzipped_mspa_file) if -s $gzipped_mspa_file ;
							unlink($each_seq_fasta) if $Lean_output;
					 }
			 }
			 if($machine_readable and $create_sso and -s $out_sso_file){ &cp($out_sso_file, $out_msso_file); }
	 } # end of for($j=0; $j< @seq_names; $j++){
	 return(\@final_out);
	 EXIT:

} # do_sequence_search



#__________________________________________________________________________
# Title     : do_hmm_sequence_search
# Usage     : &do_hmm_sequence_search(\@file, "method=$default_search_method",
#								$over_write, "DB=$pdbd40_seq_fasta");
#
# Function  : does hmm sequence search using Sean Eddy's HMMER (hmmls, hmmfs)
# Example   :
# Keywords  : do_seq_search_with_hmm, do_hmmt_sequence_search
# Options   :
#    "method=ls"  for turning hmmls search option on (default)
#    "method=fs"  for turning hmmfs search option on
#    method= by method=
#   o  for overwriting existint xxxxx.hmm files
#   E=Enguiry_name    for specifying enquiry seq name rather than 'HMM', the default
#   t=20  for score thresh at the level of hmmls. Default of hmmls is 0. example showed has 15
#   $evalue_cutoff= by e=
#   $over_write = o by -o o
# Returns   :
# Argument  :
# Version   : 1.6
#----------------------------------------------------------------------------
sub do_hmm_sequence_search{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($version_number, @out_hmm_file_names, $evalue_cutoff);
		my $score_thresh=5; # default threshold

		$evalue_cutoff=3;
		$default_search_method='hmmsearch';
		$version_number=2; ## default

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# checking the existence of hmm search file
		#_____________________________________________________
		if(&check_file_exists_in_path("hmmsearch")){
				$default_search_method='hmmsearch';
				$version_number=2;
		}elsif(&check_file_exists_in_path("hmmls")){
				$default_search_method='hmmls';
				$version_number=1;
		}else{
				print "\n# (ERROR) $0 can not find hmmsearch or hmmls, Please put them in the PATH\n\n";
				if($vars{'method'}=~/ls/){
				}elsif( $vars{'method'}=~/fs/){ $default_search_method='hmmfs';
				}else{ die; }
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# Checking the target DB file
		#______________________________________________________________
		if( $vars{'DB'} =~/\S/ and -s $vars{'DB'}){  $target_DB = $vars{'DB'}
		}else{  print "\n# (WARN) I need target DB to search for hmmls-fs. Use: DB=xxxx.fasta form";
				print "\n#     or Default PDB40D_FASTA ENV setting will be used for DB\n";
				$target_DB= $ENV{'PDBD40_SEQ_FASTA'};
				unless(-s $target_DB){
					 print "\n# (ERROR) Even the default DB setting $target_DB does not exist, check path/file\n\n";
					 die;
				}
		}
		if($vars{'E'}=~/\S/){ $enquiry_name        =$vars{'E'} }
		if($vars{'t'}=~/\S/){ $score_thresh        =$vars{'t'} }
		if($vars{'e'}=~/\S/){ $evalue_cutoff       =$vars{'e'} }

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# running hmm with @file (hmmb files) against target_DB
		#____________________________________________________________
		for($i=0; $i< @file; $i++){
				print "\n# Running do_hmm_sequence_search with $file[$i], options are: $char_opt\n";
				if($vars{'E'}=~/\S/){ $base=$enquiry_name;   # When $enquiry_name is given, it uses for output name
				}else{
						$base=${&get_base_names($file[$i])};
				}

				if($default_search_method=~/hmmfs/){
						$output_hmm_result = "$base\.hmmfs";
				}elsif($default_search_method=~/hmmsearch/ or $default_search_method=~/hmmls/){
						$output_hmm_result = "$base\.hmmls";
				}
				if($char_opt=~/o/ or !(-s $output_hmm_result) ){
						if($version_number==2){
								print "Running: $default_search_method -T $score_thresh -E $evalue_cutoff $file[$i] $target_DB \> $output_hmm_result\n";
								system("$default_search_method -T $score_thresh -E $evalue_cutoff $file[$i] $target_DB > $output_hmm_result");
						}else{
								print "Running: $default_search_method -t $score_thresh $file[$i] $target_DB \> $output_hmm_result\n";
								system("$default_search_method -t $score_thresh $file[$i] $target_DB > $output_hmm_result");
						}
				}else{
						print "\n# The $out_hmm_file file already exists. To overwrite use -o opt\n";
				}
				push(@out_hmm_file_names, $output_hmm_result);
		}
		if(@out_hmm_file_names > 1){
			 return(\@out_hmm_file_names);
		}else{
			 return(\$out_hmm_file_names[0]);
		}
}

#_______________________________________________________________________
# Title     : divide_clusters
# Usage     : &divide_clusters(\@file);
# Function  : This is the main funciton for divclus.pl
#               divides complex single linkage cluster into smaller duplication
#               module level sub clusters.
# Example   : &divide_clusters(\@file, $verbose, $range, $merge, $sat_file,
# 	                $dindom, $indup, "T=$length_thresh", "E=$Evalue_thresh", $over_write,
#                   $optimize, "s=$score", "f=$factor");
#
# Keywords  : divicl, divclus, div_clus, divide clusters
# Options   : _  for debugging.
#   f=<digit>   for determing the factor in filtering out non-homologous
#                  regions, 7 = 70% now!!
#   l=<digit>   for seqlet(duplication module) length threshold
#   t=<digit>   for seqlet(duplication module) length threshold
#                  (same as l opt, confusing, huh? )
#   s=<digit>   for score threshold
#   E=<digit>   for evalue threshold
#   z           for activating remove_similar_sequences, rather than remove_dup....
#   o           for overwriting
#   v           for verbose printout (infor)
#   D           for dynamic factor
#   S  $short_region=  S by S -S  # taking shorter region overlap in removing similar reg
#   L  $large_region=  L by L -L  # taking larger  region overlap in removing similar reg
#   A  $average_region=A by A -A  # taking average region overlap in removing similar reg
#   o  for $over_write
#
# Version   : 3.3
#------------------------------------------------------------------------
sub divide_clusters{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($merge, $verbose, $sat_file, $length_thresh, $factor, $indup, $indup_percent,
         $score, @temp_show_sub, $optimize, $file, $Evalue_thresh, $over_write, $din_dom,
         $sum_seq_num, $base_1, $output_clu_file, $short_region, $large_region,
         $average_region, $dynamic_factor, @sub_clustering_clu_files,
         @splited1, $link_or_not,  %duplicate);

    $Evalue_thresh=0.001; # the default
    $factor=7; # default factor is 7 for 70%
    $length_thresh=30;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Dealing with options
    #_________________________________________
    if($char_opt=~/m/){        $merge='m';
    }if($char_opt=~/v/){       $verbose='v'; # for showing debugging information
    }if($char_opt=~/i/){       $indup='i';
    }if($char_opt=~/z/){       $optimize='z';
    }if($char_opt=~/o/){       $over_write='o';
    }if($char_opt=~/d/){       $din_dom='d';
    }if($char_opt=~/s/){       $sat_file='s';
    }if($char_opt=~/y/){       $dynamic_factor='y';
    }if($char_opt=~/S/){       $short_region  ='S';
    }if($char_opt=~/L/){       $large_region  ='L';
    }if($char_opt=~/A/){       $average_region='A';
    }if($vars{'T'}=~/\d+/){    $length_thresh= $vars{'T'};
    }if($vars{'l'}=~/\d+/){    $length_thresh= $vars{'l'}; ## synonym of 't'
    }if($vars{'f'}=~/\S+/){    $factor= $vars{'f'};
    }if($vars{'s'}=~/\d+/){    $score = $vars{'s'};
    }if($vars{'e'}=~/\d+/){    $Evalue_thresh= $vars{'e'}; # synonym of e
    }if($vars{'E'}=~/\d+/){    $Evalue_thresh= $vars{'E'}; # synonym of e
    }
    $percent_fac=$factor*10; # <-- this is just to show the factor in %
    print "\n(i) Input to divide_clusters sub are: \"@file\"";
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # (0) When one file input was given (yes, divclus can handle multiple files, Sarah!)
    #________________________________________________________________________________
    if(@file == 1){  #<=== @file has xxxx.mspa, yyyy.mspa  zzzz.mspa ....,
		$file=$file[0];
		$base_1=${&get_base_names($file)};
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (2) Define the output cluster file name:  eg, 3-232_cluster_F7.clu , F7 means factor used is 7
		#______________________________________________________________________________________________
		$output_clu_file="$base_1\_F${factor}\.clu";

		if( !$over_write and -s $output_clu_file){
			print "\n# $output_clu_file Already EXISTS, skipping. Use \'o\' opt to overwrite\n"; exit;
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (3) merge_sequence_in_mspa_file does not do much. Just filtering and producing
		#     sequences in ISPA_PBS_21-215 VPR_PBS_160-354 format from mspa format
		#________________________________________________________________________________
        print "\n(i) Running merge_sequence_in_mspa_file";
        @grouped_seq_names=@{&merge_sequence_in_mspa_file(\@file, "s=$score", $optimize, $din_dom, $sat_file,
							$optimize, "T=$length_thresh", "E=$Evalue_thresh", "f=$factor", "$range", "$merge", $verbose,
							$short_region, $large_region, $average_region, $over_write, $dynamic_factor)};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (4) This is critical seqlet merging step. Up to now, things are fine usually.!!!
		#________________________________________________________________________________
		unless(@grouped_seq_names == 1){  ##  if @grouped_seq_names has one string like 'FAM_8_7 FAM_8_4 FAM_8_3' skip
			F1: for($i=0; $i< @grouped_seq_names; $i++){
                @splited1=split(/\s+/, $grouped_seq_names[$i]);
				for($j=0; $j< @grouped_seq_names; $j++){
    				 if($grouped_seq_names[$i] eq $grouped_seq_names[$j]){ next  }
					 @splited2=split(/\s+/, $grouped_seq_names[$j]);
                     $link_or_not=${&check_linkage_of_2_similar_seqlet_sets(\@splited1,
                                                                           \@splited2,
                                                                           "f=$factor")};
					if($link_or_not){
                        $optimize=1; ## This should be nearly always 1 !!!!!!!
                        if($optimize){ ##---- This will also remove similar seqlets, not only identical ones
                            $grouped_seq_names[$i]=join(' ', sort @{&remove_similar_seqlets( [@splited1, @splited2],
																		$short_region, $large_region, $average_region)} );
     				    }else{
							$grouped_seq_names[$i]=join(' ', grep { ! $duplicate{$_}++ } (@splited1, @splited2) );
					    }
                        splice(@grouped_seq_names, $j,1);
						$j--; $i--; next F1;
					}
				}

             }
		}
		#~~~~~~~~~~~~~~ I used to use a sub, but to save time above is inserted ~~~~~~~~~~~~~
        #@grouped_seq_names=@{&cluster_merged_seqlet_sets(\@grouped_seq_names, $dynamic_factor,
	    #				 "f=$factor", $short_region, $large_region, $average_region, $optimize)};

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (5) This is showing the result in clu file format
				#________________________________________________________________________________
                @temp_show_sub=&show_subclusterings(\@grouped_seq_names, $file, $sat_file, $dindom, $indup,
						   "E=$Evalue_thresh", "p=$percent_fac", "f=$factor" );
				$good_bad       = $temp_show_sub[0];
				$indup_c        = $temp_show_sub[1];
				$sum_seq_num   += $temp_show_sub[2];
				push(@sub_clustering_out_files, @{$temp_show_sub[3]});

				if($good_bad==1){      push(@good, $file);
				}else{                 push(@bad, $file);       }

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (6) Final write up stage (unecessary)
				#_______________________________________________________________
          &write_good_bad_list_in_divide_clusters(\@good, \@bad);

	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # when more than one single file input is given (Default usually)
	 #_________________________________________________________________
	 elsif(@file >1 ){
			 my (@good, @bad);
			 if($indup =~/i/i){   open (INDUP, ">indup_stat\.txt");  } # this is not essential.

			 for($i=0; $i< @file; $i++){
						my (@grouped_seq_names, @temp_show_sub, $indup_c, $big_mspa_file);
						$indup_c=0;
						$big_mspa_file=$file[$i];
						unless(-s $big_mspa_file){ print "\n# (E) \$big_mspa_file does not exist\n"; exit }

						$base_1=${&get_base_names($big_mspa_file)};
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# (1) Define the output cluster file name:  eg, 3-232_cluster_F7.clu , F7 means factor used is 7
						#______________________________________________________________________________________________
						$output_clu_file="$base_1\_F${factor}\.clu";

						if( !$over_write and -s $output_clu_file){
							print "\n# $output_clu_file Already EXISTS, skipping. Use \'w\' opt to overwrite\n";
							next;  }

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						#  (2) If clu file(eg 2-1618_ss.clu ) is in pwd, tries to skip
						#____________________________________________________________
						if((-s $output_clu_file) > 10 and $over_write !~/o/){
							print "# $output_clu_file exists, skipping, use \"o\" option to overwrite\n";  next;
						}

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# (3) merge_sequence_in_mspa_file does not do much. Just filtering and producing
						#     sequences in ISPA_PBS_21-215 VPR_PBS_160-354 format of STRING from mspa format
						#     $big_mspa_file is an MSPA file
						#________________________________________________________________________________
                        @grouped_seq_names=@{&merge_sequence_in_mspa_file(\$big_mspa_file, "s=$score", $din_dom, $sat_file, $optimize,
																"T=$length_thresh", "E=$Evalue_thresh", "f=$factor", "$range", "$merge", $verbose, $over_write,
																 $short_region, $large_region, $average_region, $dynamic_factor )};
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						#  (4) Clustering the sets of merged seqlets => CORE algorithm
						#_____________________________________________________________________
						unless(@grouped_seq_names == 1){  ##  if @grouped_seq_names has one string like 'FAM_8_7 FAM_8_4 FAM_8_3' skip
								F2: for($g=0; $g< @grouped_seq_names; $g++){
										@splited1=split(/ +/, $grouped_seq_names[$g]);
										for($h=0; $h< @grouped_seq_names; $h++){
												if($grouped_seq_names[$g] eq $grouped_seq_names[$h]){ next  }
												@splited2=split(/ +/, $grouped_seq_names[$h]);
												$link_or_not=${&check_linkage_of_2_similar_seqlet_sets(\@splited1, \@splited2, "f=$factor")};
												if($link_or_not){
														if($optimize){ ##---- This will also remove similar seqlets, not only identical ones
															 $grouped_seq_names[$g]=join(' ', sort @{&remove_similar_seqlets( [@splited1, @splited2],
																													 $short_region, $large_region, $average_region)} );
														}else{
															 $grouped_seq_names[$g]=join(' ', grep { ! $duplicate{$_}++ } (@splited1, @splited2) );
														}
														splice(@grouped_seq_names, $h, 1); $h--; $g--; %duplicate=(); next F2;
												}
										}
								}
						}
						#~~~~~~~~~~~~~~ I used to use a sub, but to save time above is inserted ~~~~~~~~~~~~~
						#@grouped_seq_names=@{&cluster_merged_seqlet_sets(\@grouped_seq_names, "f=$factor", $optimize, $dynamic_factor,
						#			 $short_region, $large_region, $average_region)};
						@temp_show_sub=&show_subclusterings(\@grouped_seq_names, $big_mspa_file, $sat_file, $dindom, $indup,
																										"E=$Evalue_thresh", "p=$percent_fac", "f=$factor");
												$good_bad       = $temp_show_sub[0];
												$indup_c        = $temp_show_sub[1];
												$sum_seq_num   += $temp_show_sub[2];
						push(@sub_clustering_out_files, @{$temp_show_sub[3]});

						if($good_bad==1){          push(@good, $big_mspa_file);
						}else{         push(@bad, $big_mspa_file);       }

					}
					#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
					&write_good_bad_list_in_divide_clusters(\@good, \@bad);
					sub write_good_bad_list_in_divide_clusters{
							 my  (@good, $i, @bad); @good=@{$_[0]}; @bad=@{$_[1]};
                             open(GOODBAD, ">good_bad.list") || warn "\n Can not open good_bad.list \n\n";
							 print GOODBAD "GOOD: all link    : 000\n";
							 for($i=0; $i< @good; $i++){  print GOODBAD "$good[$i]\n";  }
							 print GOODBAD "BAD : Not all link: 000\n";
							 for($i=0; $i< @bad; $i++){   print GOODBAD "$bad[$i]\n";   }
							 close(GOODBAD);
					}
					#_______________________________________________________________

	 }
	 return(\@sub_clustering_out_files); # contains (xxxx.clu, yyy.clu,, )
}







#______________________________________________________________________________
# Title     : remove_file_extension
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub remove_file_extension{
		my (@modified_files, $i, @files);
		@files=@_;
		for($i=0; $i< @files; $i++){
				$base=${&get_base_names($files[$i])};
				rename($files[$i], $base);
				push(@modified_files, $base);
		}
		return(\@modified_files);
}




#______________________________________________________________________________
# Title     : remove_lines_in_text_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub remove_lines_in_text_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($line_counter, $line_num_from, $line_num_to);
    if($vars{'r'}=~/(\S*)\-(\S*)/){
       if($1){
           $line_num_from=$1;
       }else{
           $line_num_from=0;
       }
       if($2){
           $line_num_to=$2;
       }else{
           $line_num_to=10000000000000000;
       }
    }
    if($vars{'f'}=~/\S/ and  $vars{'t'}=~/\S/){
       $line_num_from=$vars{'f'};
       $line_num_to=$vars{'t'}
    }
    for($i=0; $i< @files; $i++){
       $file=$files[$i];
       print "\n Opening $file with From: $line_num_from TO: $line_num_to\n\n";
       open(FILE, "<$file") || die "\n Can not open $file \n\n";
       while(<FILE>){
           $line_counter++;
           if($line_counter <= $line_num_from or $line_counter >= $line_num_to){
               print;
           }
       }
       close(FILE);
    }
    return(\"$line_num_from\-$line_num_to");
}





#______________________________________________________________________________
# Title     : remove_entry_line_in_fasta_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub remove_entry_line_in_fasta_file{
    my($fasta_in_file, $remove_count);
    $fasta_in_file=${$_[0]} || $_[0];
    open(FASTA, "<$fasta_in_file") || die "\n cannot open $fasta_in_file\n";
    while(<FASTA>){
       if(/\>/){ $remove_count++; next
       }else{
          print
       }
    }
    return(\$remove_count);
}




#______________________________________________________________________________
# Title     : remove_small_files
# Usage     : @files_removed=@{&remove_small_files(@ARGV)};
# Function  :
# Example   :
# Keywords  : delete_small_files
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub remove_small_files{
	my($file_size_cut_line, $creation_time, $size, @files_removed, $i, @files);

    @files=@_;
    for($i=0; $i< @files; $i++){
        if($i == 0 and !(-s $files[$i])){
           $file_size_cut_line=$files[$i];
           splice(@files, $i, 1); $i--;
        }elsif($i == 1 and !(-s $files[$i])){
           $file_size_cut_line_bigger_than=$files[$i];
           splice(@files, $i, 1); $i--;
        }
    }
    if(@files < 1){
        @files=@{&read_file_names_only('.')};
    }

    for($i=0; $i< @files; $i++){
        $size= -s $files[$i];
        $creation_time= localtime( (stat($files[$i]))[9] );
        if($size <= $file_size_cut_line and $size >= $file_size_cut_line_bigger_than){
            unlink($files[$i]);
            push(@files_removed, $files[$i]);
            print "\n# (i) $files[$i] is removed , size= $size byte, $creation_time";
        }
    }
    print "\n$0 finished. You might have killed some useful files :-)  \n\n\n\n";
    return(\@files_removed);
}



#______________________________________________________________________________
# Title     : remove_mail_header_in_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub remove_mail_header_in_files{
		my (@modified_files, $i, @files);
		@files=@_;
		for($i=0; $i< @files; $i++){
				my ($line_count);
				&cp("$files[$i]", "$files[$i]\.bak");
				open(FILE_BAK, "$files[$i]\.bak");
				open(FILE, ">$files[$i]");
				while(<FILE_BAK>){
					 $line_count++;
					 if($line_count > 33){
							 print FILE $_; next;
					 } # No point in looking very far down !
					 if(/^From\s+\S/){               next;
					 }elsif(/^Received\:\s+/){           next;
					 }elsif(/^Message\-Id\:\s+/){           next;
					 }elsif(/id \S+; \S+ \d+\s+\S+\s+\d{4} \d+\:\d+:\d+/){   next;
					 }elsif(/by \w+\.\w+\.\w+\.+\w+ \(+\d/){   next;
					 }elsif(/for\s+\<\w+\@\w+\.\w+\S*\>\; \S+\, \d+ \S+\s+\d+/){   next;
					 }elsif(/^Date\:\s+/){           next;
					 }elsif(/^From:\s+/){            next;
					 }elsif(/^To:\s+/){              next;
					 }elsif(/^Subject\:\s+/){         next;
					 }elsif(/^Status\:\s+/){         next;
					 }elsif(/^X\-Mozilla\-/){         next;
					 }elsif(/^X\-UIDL\:\s+/){         next;
					 }else{                   print FILE;
					 }
				}
				close(FILE_BAK);
				close(FILE);
				if(-s $files[$i] > ( $original_file_size - 400) ){
						push(@modified_files,$files[$i]);
						print "\n# (i) $files[$i] has real size, I am removing $files[$i]\.bak\n";
				}else{
						print "\n# (i) The file size of new $files[$i] is a bit small, I am leaving $files[$i]\.bak\n";
				}
		}
		return(\@modified_files);
}

#________________________________________________________________________
# Title     : subtract_similar_seq_elements
# Usage     : @subs = @{&subtract_similar_seq_elements(\@match_seqs1, \@match_seqs2, "Percent_similarity=80")};
# Function  : removes any occurances of certain elem. of the first
#             input array with second input array.
# Example   :
#
#     @match_seqs1=('xxxx_1-30', 'YYYYY_30-44', 'ZZZZ_1-4000');
#     @match_seqs2=('xxxx_4-32', 'YYYYY_25-41', 'ZZZZ_2000-3000');
#
# Keywords  : remove_similar_seq_elements, subtract_similar_sequence_elements
#              remove_similar_sequence_elements
# Options   :
# Returns   :
# Argument  :
#     $Percent_similarity= by Percent_similarity=
#
# Authors   : jong@biosophy.org
# Version   : 1.0
#--------------------------------------------------------------------
sub subtract_similar_seq_elements{
		my($i, $j, @seq_match_array1, @seq_match_array2, $Percent_similarity, %counter,
		   @diff_elements, $seq1, $start1, $end1, $tail1,
		   $seq2, $start2, $end2, $tail2, $diff_start, $diff_end,
		   $leng1, $leng2, $smaller_leng, @truly_diff_elements);
		$Percent_similarity=80; # 80% similarity is accepted
		$leng_thresh=10;

		@seq_match_array1=@{$_[0]};
		@seq_match_array2=@{$_[1]};
		if($_[2]=~/Percent_similarity=(\S+)/){
				$Percent_similarity=$1;
		}

		grep($counter{$_}++, @seq_match_array2 );
		@diff_elements= grep(!$counter{$_}, @seq_match_array1);

		for($i=0; $i< @diff_elements; $i++){  ## @diff_elements is from  @seq_match_array1
			 if($diff_elements[$i]=~/^(\S+)_(\d+)\-(\d+)(\S*)/){
					 ($seq1, $start1, $end1, $tail1)=($1, $2, $3, $4);
					 for($j=0; $j< @seq_match_array2; $j++){
							if($seq_match_array2[$j]=~/^(\S+)_(\d+)\-(\d+)(\S*)/){
									($seq2, $start2, $end2, $tail2)=($1, $2, $3, $4);
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
									# Check if the seqs are identicl (from the two arrays), no point to merge which are not identical from the first
									#__________________________________________________________________________________________
									if($seq1 eq $seq2){
											 $diff_start=abs($start1-$start2);
											 $diff_end  =abs($end1  -$end2  );
											 $leng1=$end1-$start1;
											 $leng2=$end2-$start2;
											 if($leng1 >= $leng2){
													 $smaller_leng=$leng2;
													 $larger_leng =$leng1
											 }else{
													 $smaller_leng=$leng1;
													 $larger_leng =$leng2
											 }

											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
											 # Checking the minimal seq region leng here
											 #______________________________________________________
											 if($smaller_leng < $leng_thresh){ next }
											 $overlapping_seq_match_size=${&get_overlapping_seq_match_size($start1, $end1, $start2, $end2)};
											 $averge_seq_leng_of_2_seqs=($leng1+$leng2)/2;

											 $finally_adjusted_seq_leng=$smaller_leng*($Percent_similarity/100);

											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
											 # Now let's check if we regard them homologous or not\
											 #_______________________________________________________
											 if( $overlapping_seq_match_size >=  $finally_adjusted_seq_leng){
													 push(@truly_diff_elements, $diff_elements[$i]);
											 }
									 }
							 }
					  }
				}
		} # END of for($i=0; $i< @diff_elements; $i++){
		return(\@truly_diff_elements);
}



#_____________________________________________________________________________
# Title     : remove_similar_seqlets
# Usage     : @seqlets=@{&remove_similar_seqlets(\@split)};
# Function  : merges(gets average starts and ends ) of similar
#             seqlets to reduce them into smaller numbers. This can also handle
#              names like XLBGLO2R_8-119_d1hlm__.
#
# Example   : @seqlets=@{&remove_similar_seqlets(\@mrg1, $mrg2, \@mrg3)};
#               while @mrg1=qw(M_2-100 M_2-110 M_8-105 M_4-108 N_10-110 N_12-115);
#                     $mrg2='Z_3-400 Z_2-420';
#                     @mrg3=('X_2-300 X_3-300', 'X_2-300', 'X_5-300 X_2-301' );
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : merge_sequence_names, merge_seq_names, merge_sequence_ranges
#             merge_seq_ranges
# Options   : _  for debugging.
#             #  for debugging.
#             f= for factor
#             S  for shorter region matched is used
#             A  for average region matched is used
#             L  for larger region matched is used
#
# Version   : 2.1
#-------------------------------------------------------------------------------
sub remove_similar_seqlets{
	 my ($i, $j, $seq1, $smaller_leng, $leng1, $leng2, $start1, $end1, $seq2, $start2,
	   $av_diff, $num_of_seq, $av_end, $av_start, $end2, @seqlets,
	   @array_input, @seqlet, $tail1, $tail2, $shorter_region, $larger_region,
	   $average_region, $factor);
	 $factor=7;  ## !!! This var makes big difference in the final clustering
	 $average_region = 'A'; ## default is to get the average of comparing regions

	 for($i=0; $i< @_; $i++){
	    if(ref($_[$i]) eq 'ARRAY'){
		     @array_input=@{$_[$i]};
		     for($j=0; $j<@array_input; $j++){
			      @seqlet=split(/\s+/, $array_input[$j]);
					  push(@seqlets, @seqlet);
		     }
		     #if($verbose){
				 #   print "\n# remove_similar_seqlets: ARRAY ref is given as input\n";
				 #   print "#  They are: @seqlets\n";
				 #}
	    }elsif($_[$i]=~/f=(\S+)/){   $factor=$1
	    }elsif($_[$i]=~/^(S)\s*$/){   $shorter_region=$1 ; $average_region=0;
	    }elsif($_[$i]=~/^(L)\s*$/){   $larger_region =$1 ; $average_region=0;
	    }elsif($_[$i]=~/^(A)\s*$/){   $average_region=$1 ; $shorter_region=$larger_region=0;
	    }elsif($_[$i]=~/\S+\_\d+\-\d+/){
		     push(@seqlets, split(/\s+/, $_[$i]) );
	    }elsif(ref($_[$i]) eq 'SCALAR' and ${$_[$i]}=~/\S+\_\d+\-\d+/){
	       push(@seqlets, split(/\s+/, ${$_[$i]}) );
	    }
	 }
	 #print "\n# remove_similar_seqlets : I am using \$factor : $factor\n" if $verbose;

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # Sorting is necessary as I am not doing the real thorough comparison
	 #______________________________________________________________________
	 $num_of_seq=@seqlets=sort @seqlets;

	 my ($short_start, $large_start, $short_end, $large_end);

	 for($i=0; $i< @seqlets; $i++){
			if($seqlets[$i]=~/^\s*(\S+)_(\d+)\-(\d+)(\S*)/){  ## last (\S*) is necessary for XLBGLO2R_8-119_d1hlm__
				 my($seq1, $start1, $end1, $tail1)=($1, $2, $3, $4);
				 if($seqlets[$i+1]=~/^(\S+)_(\d+)\-(\d+)(\S*)/){
						 ($seq2, $start2, $end2, $tail2)=($1, $2, $3, $4);
						 if($seq1 eq $seq2){
								$diff_start=abs($start1 - $start2);
								$diff_end  =abs($end1   - $end2  );
								$leng1=$end1-$start1;
								$leng2=$end2-$start2;

								if($leng1 >= $leng2){ $smaller_leng=$leng2; }else{ $smaller_leng=$leng1; }
								if( ($diff_start+$diff_end)/2 <= $smaller_leng*($factor/10) ){

										if($average_region){
											 $av_start=int(($start1+$start2) / 2);
											 $av_end  =int(($end1 + $end2) / 2);
															 $seqlets[$i]="$seq1\_$av_start\-${av_end}$tail1";  # $tail1 is for names like XLBGLO2R_8-119_d1hlm__
															 # print "\n# new seqlet : $seqlets[$i]\n" if $verbose;
											 splice(@seqlets, $i+1, 1);
											 $i--;
										}else{
											 if($start1 < $start2){
											 $short_start=$start2; $large_start=$start1;  ## note that short start should be $start2 if $start2 is bigger
											 }else{
													$short_start=$start1; $large_start=$start2;
											 }
											 if($end1 < $end2){
													$short_end=$end1;  $large_end=$end2;
											 }else{
													$short_end=$end2;  $large_end=$end1;
											 }
											 if($shorter_region){
													 $seqlets[$i]="$seq1\_$short_start\-${short_end}$tail1";
											 }elsif($larger_region){
													 $seqlets[$i]="$seq1\_$large_start\-${large_end}$tail1";
											 }

											 splice(@seqlets, $i+1, 1);
											 $i--;
										}
								}
						 }
		     }
	    }
	 }
	 #print "\n# (3) remove_similar_seqlets: The final out are: @seqlets\n" if $verbose;
	 return(\@seqlets);
}


#______________________________________________________________________________
# Title     : show_FDAT_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_FDAT_hash{
    my(@structure, $i,@subdomains, $structure, $j, @details);
    @structure=keys %{$_[0]};

    for($i=0; $i< @structure; $i++){
      $structure=$structure[$i];
      @subdomains=keys %{$FDAT_hash{$structure}};
      for($j=0; $j< @subdomains; $j++){
         @details=@{$FDAT_hash{$structure}{$subdomains[$j]}};
         print "\n$structure $subdomains[$j] : @details \n";
      }
    }
}


#______________________________________________________________________________
# Title     : show_codon_lookup_table_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_codon_lookup_table_hash{
    my(%amino_acid_codon_lookup_table, $i, $amino_acid, @amino_acid_residues);
    %amino_acid_codon_lookup_table=%{$_[0]};
    @amino_acid_residues=sort keys %amino_acid_codon_lookup_table;
    for($i=0; $i< @amino_acid_residues; $i++){
        $amino_acid=$amino_acid_residues[$i];
        print "$amino_acid : @{$amino_acid_codon_lookup_table{$amino_acid}}\n";
        push(@codon_table, "$amino_acid : @{$amino_acid_codon_lookup_table{$amino_acid}}");
    }
    return(\@codon_table);
}



#______________________________________________________________________________
# Title     : show_alignment_for_herta
# Usage     :
# Function  :
# Example   :
# Keywords  : show_seqlet_alignment
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.3
#------------------------------------------------------------------------------
sub show_alignment_for_herta{
    my($herta_input_file, $sequence_1_file, $sequence_2_file,
       @seq1_aligned, @seq2_aligned, @scores, %align_position_seq1_seq2_rv,
       %align_position_seq1_seq2, $herta_input_file_rv, %sequence_1, %sequence_2,
       %sequence_rv, %sequence, @positions1_rv, @positions2_rv,
       @positions1, @positions2, @seq1_start, @seq2_start, @residues1, @residues2,
       @seq1_start_final, @seq2_start_final, @scores_gap, @seq2_start_final_rv,
       @seq1_start_final_rv, $query_seq, $DB_seq);

    $herta_input_file=${$_[0]} || $_[0];
    $herta_input_file_rv=${&attach_suffix_in_file_name($herta_input_file, 'rv', 'e')};

    $sequence_1_file=${$_[1]} || $_[1];
    $sequence_2_file=${$_[2]} || $_[2];
    $query_seq      =${$_[3]} || $_[3];
    $DB_seq         =${$_[4]} || $_[4];
    #print "\n $sequence_1_file $sequence_2_file\n\n";

    %sequence_1=%{&open_fasta_files(\$sequence_1_file)};
    %sequence_2=%{&open_fasta_files(\$sequence_2_file)};
    @keys1=keys %sequence_1;
    @keys2=keys %sequence_2;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # In herta, there is no seq name, so I note them as 1 and 2
    #______________________________________________________________
    $sequence{1}=$sequence_1{$keys1[0]}; # the first key is for seq (only 1 key in fact)
    $sequence{2}=$sequence_2{$keys2[0]};
    $sequence_rv{1}=$sequence_1{$keys1[0]}; #!!!!!!!!!!!!!!!! <<<<<<<<<<<<
    $sequence_rv{2}=reverse $sequence_2{$keys2[0]};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  $herta_align_hash{$seq_name}{$seq_pos}=$align_score;
    #_______________________________________________________________
    %align_position_seq1_seq2   =%{&open_herta_files(\$herta_input_file)};
    %align_position_seq1_seq2_rv=%{&open_herta_files(\$herta_input_file_rv)};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # temporarily assign 1, 2 as herta can not distinguish them
    #______________________________________________________________
    ($seq_name1, $seq_name2)=(1,2);

    @residues1   =split(//, $sequence{$seq_name1});
    @residues2   =split(//, $sequence{$seq_name2});
    @residues1_rv=split(//, $sequence_rv{$seq_name1});
    @residues2_rv=split(//, $sequence_rv{$seq_name2});
    @positions1   =sort {$a <=> $b} keys %{$align_position_seq1_seq2{$seq_name1}};
    @positions2   =sort {$a <=> $b} keys %{$align_position_seq1_seq2{$seq_name2}};
    @positions1_rv=sort {$a <=> $b} keys %{$align_position_seq1_seq2_rv{$seq_name1}};
    @positions2_rv=sort {$a <=> $b} keys %{$align_position_seq1_seq2_rv{$seq_name2}};

    $herta_align_score   =${&align_herta_inputs_with_adjustments(\@residues1, \@residues2,
                                                              \@positions1, \@positions2,
                                                              \%align_position_seq1_seq2,
                                                              $query_seq,
                                                              $DB_seq)};

    $herta_align_score_rv=${&align_herta_inputs_with_adjustments(\@residues1_rv, \@residues2_rv,
                                                              \@positions1_rv, \@positions2_rv,
                                                              \%align_position_seq1_seq2_rv,
                                                              $query_seq,
                                                              "$DB_seq\_rv")};

    ($seq1_len, $seq2_len)=(@residues1, @residues2);
    $forward_minus_backward_score = $herta_align_score - $herta_align_score_rv;
    print "# ForBackScore: $forward_minus_backward_score, ForScore: $herta_align_score, BackScore: $herta_align_score_rv\n\n";
}





#______________________________________________________________________________
# Title     : show_ENV_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_ENV_hash{
    my(@keys, $i);
    @keys=sort keys %ENV;

    for($i=0; $i< @keys; $i++){
       print "\n $keys[$i]  $ENV{$keys[$i]}";
    }
}




#______________________________________________________________________________
# Title     : show_DDDF_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_DDDF_hash{
    my(%DDDF_hash, @DDD_IDs, $i);
    %DDDF_hash=%{$_[0]};
    @DDD_IDs=sort keys %DDDF_hash;
    for($i=0; $i <@DDD_IDs; $i++){
       print "$DDD_IDs[$i] @{$DDDF_hash{$DDD_IDs[$i]}}\n";
    }
}




#______________________________________________________________________________
# Title     : show_FSSP_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub show_FSSP_hash{
    my($i);
    my %FSSP_alignment_1to1_residue_map=%{$_[0]};
    @rep_names=keys %FSSP_alignment_1to1_residue_map;
    for($i=0; $i< @rep_names; $i++){
       print ">>$rep_names[$i]\n";
       @homol_names=keys %{$FSSP_alignment_1to1_residue_map{$rep_names[$i]}};
       for($j=0; $j<@homol_names; $j++){
          @rep_posi=sort {$a<=>$b} keys %{$FSSP_alignment_1to1_residue_map{$rep_names[$i]}{$homol_names[$j]}};
          print "  >$rep_names[$i] <=> $homol_names[$j]\n";
          for($k=0; $k< @rep_posi; $k++){
              print "    R: $rep_posi[$k] - H: $FSSP_alignment_1to1_residue_map{$rep_names[$i]}{$homol_names[$j]}{$rep_posi[$k]}\n";
          }
       }
    }
    print "\n Finished running  show_FSSP_hash\n";
}


#______________________________________________________________________________
# Title     : show_DALI_domain_table_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_DALI_domain_table_hash{
    my(%DOM_table_hash);
    %DOM_table_hash=%{$_[0]};
    @DALI_str_ID=keys %DOM_table_hash;
    for($i=0; $i< @DALI_str_ID; $i++){
       @DALI_node_ID= keys %{$DOM_table_hash{$DALI_str_ID[$i]}};
       for($j=0; $j<@DALI_node_ID; $j++){
          print "$DALI_str_ID[$i] $DALI_node_ID[$j] @{$DOM_table_hash{$DALI_str_ID[$i]}{$DALI_node_ID[$j]}}\n";
       }
    }
    print "\n";

}



#______________________________________________________________________________
# Title     : show_information_on_perd
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  : Tk
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_information_on_perd{
    my ($t) = @_;
    my ($count_time);
    my ($perd_version)='0.1';

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Prepare for choosing bg color randomly
    #_________________________________________
    my(@colors_array)=qw(cyan bisque steelblue pink yellow white red blue green
                         black violet darkgreen wheat grey20 green4);
    until($bg_color ne $fg_color and $fg2 ne $bg2 and $fg_color ne $bg2){
       srand(time()|$$);
       ($bg_color, $fg_color, $fg2, $bg2)=@{&pick_randomly(\@colors_array, 4)};
    }

    $message="  PERD version $perd_version Jong Park.  ";
    my $d=$t->{'show_information_on_perd'}=$t->Toplevel(-popover => 'cursor', -popanchor => 'nw');
    $frame1=$d->Frame(-label=>'1st Frame -relief ridge Button', -relief=>ridge,  -borderwidth=>3)->pack;
    $frame2=$d->Frame(-label=>'2nd Frame -relief groove Button', -relief=>groove, -borderwidth=>4)->pack;
    $frame3=$d->Frame(-label=>'3rd Frame -relief raised Containing Button', -relief=>raised, -borderwidth=>5)->pack;
    $frame4=$d->Frame(-label=>'4th Frame -relief sunken Containing Button', -relief=>sunken, -borderwidth=>3)->pack;

    $label1=$frame1->Label(-fg=>$fg_color, -bg=>$bg2,
                      -text=>'I am PERD',
                      -font=>'12x24');

    $label1->pack( -fill => 'both', -expand => 1 );
    $m1 = $frame2->Label(-fg=>$fg_color, -bg=>$bg_color,
                    -textvariable => \$message, -width => 30, -font=>'10x20' );
    $m2 = $frame4->Label(-wrap=>1, -fg=>$fg_color, -bg=>$bg_color,
                    -textvariable => \$message2, -width=>1, -height=>3 );
    $m3 = $frame4->Label(-wrap=>1, -fg=>$bg2, -bg=>$fg_color,
                    -textvariable => \$message3, -width=>1, -height=>3 );
    $m4 = $frame4->Label(-wrap=>1, -fg=>$fg_color, -bg=>$bg_color,
                    -textvariable => \$message4, -width=>1, -height=>3 );
    $m5 = $frame4->Label(-wrap=>1, -fg=>$bg_color, -bg=>$fg2,
                    -textvariable => \$message5, -width=>1, -height=>3 );
    $m6 = $frame4->Label(-wrap=>1, -fg=>$fg2, -bg=>$bg_color,
                    -textvariable => \$message6, -width=>1, -height=>3 );
    $m7 = $frame4->Label(-wrap=>1, -fg=>$bg_color, -bg=>$fg_color,
                    -textvariable => \$message7, -width=>1, -height=>3 );
    $m1->pack();
    $m2->pack(-anchor=>'w', -side=>left);
    $m3->pack(-anchor=>'w', -side=>left);
    $m4->pack(-anchor=>'w', -side=>left);
    $m5->pack(-anchor=>'e', -side=>right);
    $m6->pack(-anchor=>'e', -side=>right);
    $m7->pack(-anchor=>'e', -side=>right);

    $CLOSE_button=$frame3->Button( -text    =>'O.K., Enough..', -bg=>$fg_color, -borderwidth=>4,
                               -command => sub{ $d->withdraw; $count_time=0; }
                              )->pack;

    after(2, \&scroll_it);
    ($bg_color, $fg_color, $fg2, $bg2)=@{&pick_randomly(\@colors_array, 4)};
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # scroll_it, from terry@encompass.is.net (Contrib/TickerTape)
    #_______________________________________________________
    sub scroll_it {
        $count_time++;
        if($count_time > 50){ $d-> withdraw; $count_time=0  }
        $message =~ /(.)(.*)/;
        $message=$message4="$2$1";
        $message2=$message5=$message7=reverse($message);
        $message3=$message6=${&scramble_string(\$message)};
        $t->after(250, \&scroll_it);
    }

}

#______________________________________________________________________________
# Title     : show_written_html_file_content
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_written_html_file_content{
		my(@lines);
		my($html_file_input)=$_[0];
		open(PSUB_FILE, "<$html_file_input") or die "Couldn't open $html_file_input";
		print "\n<br># (i) Following lines were written<br><br><pre><B><font COLOR=\"#DC143C\">\n";
		@lines=<PSUB_FILE>;
		for(@lines){
			 print $_, "<br>";
		}
		print "</pre></font>";
		return(\$html_file_input);
}


#__________________________________________________________________________
# Title     : show_subclusterings
# Usage     : &show_subclusterings(\@out);
# Function  : This is the very final sub of divclus.pl
# Example   : @temp_show_sub=&show_subclusterings(\@out, $file, $sat_file, $dindom, $indup);
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : print_subclusterings, sum_subclusterings, write_subclustering
#             show_clusterings, display_subclusterings
# Options   :
#             f  for file output, eg: xxxxxxx.sat
# Category  :
# Version   : 2.9
#-------------------------------------------------------------------------
sub show_subclusterings{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my ($max_size, $sat_file_name, $clu_file_name,
	$ori_cluster_size, $ori_cluster_num, $good_bad, @keys, $percentage_fac,
	$indup, @sizes, $sum_seq_num, $indup_percent, $indup_count, %tem4,
	@sub_clustering_out_files);  # clusall_1e-5_clu_14-324_ss.sat
	my @out=@{$array[0]};
	$indup_count=0;

	if($char_opt=~/d/){	    $dindom=1;	}
	if($char_opt=~/i/){		$indup=1;	}
	if($vars{'f'}=~/\S+/){     $factor= $vars{'f'}; }
	if($vars{'p'}=~/\d+/){ $percentage_fac= int($vars{'p'}); }
	if($vars{'s'}=~/\d+/){	   $score = $vars{'s'};	}
	if($vars{'e'}=~/\d+/){	   $evalue= $vars{'e'};	}

	print "\n# (1) show_subclusterings : \@file has : @file";
    if( $file[0]=~/([\S+_]*?(\d+)\-(\d+)[_\w]*)\.mspa/  or
		$file[0]=~/([\S+_]*?(\d+)\-(\d+)[_\w]*)\.sat/   ){
         $ori_cluster_size=$2;
         $ori_cluster_num =$3;
         $base=$1;
		 $sat_file_name="$base\.sat";
         $clu_file_name="$base\.clu";
	}else{
         $ori_cluster_size="0000";
	     $ori_cluster_num ="0000";
	     $base=${&get_base_names($file[0])};
	     $clu_file_name="$base\.clu";
		 warn "\n# (2) LINE:",__LINE__," WARN: the \@file input to show_subclusterings is not the right format, dying\n";
		 warn "     Sarah!, right format looks like: 13-234.mspa or 8-420_cluster.mspa \n";
	}

	open(CLU, ">$clu_file_name") || die "\n# (ERROR) show_subclusterings failed miserably to CREATE \"$clu_file_name\" \n";
	push(@sub_clustering_out_files, $clu_file_name);


	@out=@{&sort_string_by_length(\@out)};

	for($i=0; $i< @out; $i++){ # @out has ( 'YAL054C_98-695 YBR041W_90-617', 'YBR115C_230-842 YBR222C_16-537 YER015W_121-686', etc)
	   my $count+=$i+1;
	   my ( $int_dup_number, $sub_clu_size, $seq_with_range, @sp, $new_clus_NAME,
	        %tem, %tem2, %tem3, $j, @keys, $num_seq);
	   if($out[$i]=~/^\s*$/){ next }
	   @sp=sort split(/\s+/, $out[$i]);

	   for($j=0; $j < @sp; $j++){
		  $seq_with_range=$sp[$j];
		  if($seq_with_range=~/^((\S+)_((\d+)\-(\d+)))/){
			 $tem{$2}++;
			 $tem2{$2}.=sprintf("%-15s ", $1);
			 $tem3{$2} =$3;
			 $tem4{$2} =$5-$4;
		  }
	   }

	   @keys=sort keys %tem;
	   $num_seq=$sub_clu_size=@keys;

	   if($max_size < $sub_clu_size){
		  $max_size=$sub_clu_size; ## This is to collect the sizes of clusters to see if it is good.
	   }
	   $indup_count= &print_summary_for_divclus(
		         $count, \%tem2, \%tem,
		         $ori_cluster_num,
		         $ori_cluster_size,
		         $dindom,
		         $clu_file_name,
								 \%tem3, \%tem4,
								 $indup, );

					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # Local subroutine
					 #_______________________________________________________________
	   sub print_summary_for_divclus{ #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 my(@keys, $indup_count, $x, $m, $percentage_fac);
							 my $count=$_[0]; # count of cluster
	       my %tem2=%{$_[1]};	my $num_seq=@keys=sort keys %tem2;
	       my %tem=%{$_[2]};	my $ori_cluster_num=$_[3];
	       my $new_clus_NAME=$ori_cluster_num.'0'.$count.'0'.$num_seq;
	       my $ori_cluster_size=$_[4];
	       my $dindom=$_[5];	my %tem3=%{$_[7]};
	       my $indup=$_[9];	my (%internal_dup);
	       my %tem4=%{$_[8]};
							 #~~~~~~~~~~ Domain Inside Domain ~~~~~~~~~~~~~~~~~
	       if($dindom){
	          for($x=0; $x <@keys; $x++){
											 @domain_inside_domain=@{&get_domain_inside_domain($tem2{$keys[$x]})};
											 @domain_inside_domain=@{&remove_dup_in_array(\@domain_inside_domain)};
											 for($m=0; $m< @domain_inside_domain; $m++){ print "  # Dindom: $m : $domain_inside_domain[$m]\n";   }
											 print "\n";
		  }
							 }
							 #==========================================================================================

	       #~~~~~~~~~~ Internal duplication  ~~~~~~~~~~~~~~
	       if($indup==1){
		   # @keys is the same as sub cluster size,
		   for($x=0; $x < @keys; $x++){
														 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
														 # Checks each sequence for duplication
														 #___________________________________________________
														 my %internal_dup=%{&get_internal_dup_in_a_cluster( $tem2{$keys[$x]} )};
														 my @dup_keys=keys %internal_dup;
														 if(@dup_keys > 0){
																		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
																		 #  This calculates the actual duplicated number rather than jus tthe sequences
																		 #______________________________________________________________________________
																		 $indup_count++;
																		 printf ("%-14s %-12s %-4s", $keys[$x], $new_clus_NAME, $num_seq);
																		 for($m=0; $m< @dup_keys; $m++){
																						 printf ("%-19s=> %s\n", $dup_keys[$m], $internal_dup{ $dup_keys[$m] } );
																		 }
														 }
										}
								 }

								#~~~~~~~~~~ Summary ~~~~~~~~~~~~~~~~~~~~~~~~~~~
								print  CLU  "Cluster size $num_seq\n";
																				printf CLU ("Cluster number %-12s # E:%-5s Factor:%-2s P:%-2s, Ori size:%-4s Sub:%-4s From:%-12s\n",
																					$new_clus_NAME, $evalue, $factor, $percentage_fac,
																					$ori_cluster_size, $num_seq, $ori_cluster_num);
								print       "Cluster size $num_seq\n";
								printf     ("Cluster number %-12s # E:%-5s Factor:%-2s P:%-2s, Ori size:%-4s Sub:%-4s From:%-12s\n",
															$new_clus_NAME, $evalue, $factor, $percentage_fac,
															$ori_cluster_size, $num_seq, $ori_cluster_num);
								for($x=0; $x <@keys; $x++){
									 printf CLU ("   %-4s %-5s %-17s %-10s %-3s leng: %-s\n",
															 $num_seq, $ori_cluster_num, $keys[$x], $tem3{$keys[$x]}, $tem{$keys[$x]}, $tem4{$keys[$x]});
									 printf ("   %-4s %-5s %-17s %-10s %-3s leng: %-s\n",
													$num_seq, $ori_cluster_num, $keys[$x], $tem3{$keys[$x]}, $tem{$keys[$x]}, $tem4{$keys[$x]});
								}
								return($indup_count);
	   }
	}
		close(CLU); ## this is a bug fix

	if($max_size == $ori_cluster_size){   $good_bad=1;
	}else{	                              $good_bad=0;	}

    print "\n# Sarah, Do you think the subclusterings are O.K.?" if $verbose;
    print "\n#   Tell me, if you feel suspicious, jong\@salts.med.harvard.edu\n\n" if $verbose;
    return($good_bad, $indup_count, $ori_cluster_size, \@sub_clustering_out_files);
}






#__________________________________________________________________________
# Title     : exchange_query_with_match_in_mspa
# Usage     : @exchanged_mspa=@{&exchange_query_with_match_in_mspa(\@file)};
# Function  :
# Example   :
# Keywords  : swap_query_with_match_in_mspa, invert_query_with_match_in_mspa,
#             swap_query_seq_with_match_seq_in_mspa,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub exchange_query_with_match_in_mspa{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my(%exchanged_mspa, @sorted_by_query_seq_names, @new_mspa_lines);
		 $open_mspa_files_x_opt = 'x';
		 if($char_opt=~/n/){ $names_only='n' }
		 %exchanged_mspa=%{&open_mspa_files(@file, $open_mspa_files_x_opt, $names_only )};

		 @new_mspa_lines=values %exchanged_mspa;
		 @sorted_by_query_seq_names=
				map{ $_->[0] } sort {$a->[1] cmp $b->[1]} map {/^\d+\s+\S+\s+\d+\s+\d+\s+(\S+)/ && [$_, $1] } @new_mspa_lines;
		 return(\@sorted_by_query_seq_names);
}

#______________________________________________________________________________
# Title     : swap_array_elements
# Usage     :
# Function  :
# Example   :
# Keywords  : swap_array_elem_positions, swap_positions_in_array
# Options   :
# Author    : jong@biosophy.org,
# Category  : Array-handling, Action=Swap
# Version   : 1.0
#------------------------------------------------------------------------------
sub swap_array_elements{
		my($pos1, $pos2, $array_ref)=@_;
		if($pos1 >= @{$array_ref} ){ $pos1=$#{$array_ref}; }
		if($pos2 >= @{$array_ref}){ $pos2 = $#{$array_ref};
			 print "\n# (i) \$pos2 is larger than last elem position";
		}

		@{$array_ref}[$pos2, $pos1]=@{$array_ref}[$pos1, $pos2];
		return($array_ref);
}


#______________________________________________________________
# Title     : get_internal_dup_in_a_cluster
# Usage     :
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub get_internal_dup_in_a_cluster{
	$cluster_line=$_[0] || ${$_[0]};
	my($i, $j, @seq, %out, $seq_name);
	my $overlap_factor=40;
	my $min_inside_dom_size=40;
	@seq=split(/\s+/, $cluster_line);  ## These sequence are single seq with different regions
	@seq= map{$_->[0]} sort{$a->[1] cmp $b->[1] or $a->[2] <=> $b->[2] }
			             map {/^((\S+)_(\d+)\-(\d+)\s*.*)$/ && [$1, $2, $3, $4]} @seq;

	F1:for($i=0; $i< @seq; $i++){
	   $seq1=$seq[$i];
	   if($seq1=~/^(\S+)_(\d+)\-(\d+)/){
		  $seq_name=$1;
		  $start1=$2;
		  $end1=$3;
	   }
	   F:for($j=1; $j< @seq; $j++){
		  $seq2=$seq[$j];
		  if($seq1 eq $seq2){ next } ### Skip IDENTICAL ones (xxxx_1-10, xxxx_1-10)
		  if($seq2=~/^(\S+)_(\d+)\-(\d+)/){
			 $start2=$2;
			 $end2=$3;
		  }
		  $leng2=$end2-$start2;
		  $margin=$leng2/12;   ## 8% overlap is regarded as not overlapping

		  if(( ($start1+$margin) > $end2)||
		    ( ($start2+$margin) > $end1)){ # skips non overlapping seqlets

			$out{"$start1\-$end1"}.="$start2\-$end2 ";

			splice(@seq, $j, 1);
			$j--;
		  }
	   }
	}
	#@out=sort (@out);
	#@out=@{&remove_dup_in_array(\@out)};
	#@out=@{&remove_similar_seqlets(\@temp, "f=2")};
	return(\%out);
}

#______________________________________________________________
# Title     : get_domain_inside_domain
# Usage     :
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : find_dindoms, domain_inside_domain, domain_in_domain
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub get_domain_inside_domain{
	$cluster_line=$_[0] || ${$_[0]};
	my($i, $j, @seq, @out);
	my $overlap_factor=40;
	my $min_inside_dom_size=40;
	@seq=split(/\s+/, $cluster_line);
	F1:for($i=0; $i< @seq; $i++){
	   $seq1=$seq[$i];
	   if($seq1=~/^(\S+)_(\d+)\-(\d+)/){
		  $seq_name=$1;
		  $start1=$2;
		  $end1=$3;
	   }
	   F:for($j=0; $j< @seq; $j++){
		  $seq2=$seq[$j];
		  if($seq1 eq $seq2){ next } ### Skip IDENTICAL ones (xxxx_1-10, xxxx_1-10)
		  if($seq2=~/^(\S+)_(\d+)\-(\d+)/){
			 $start2=$2;
			 $end2=$3;
		  }
		  if(($start1 > $end2)||($start2 > $end1)){ # skips non overlapping seqlets
			 next;
		  }
		  if(($start1 > $start2)&&($end1 < $end2)){  #   -----
			 $leng_seq1=$end1-$start1;               # ----------
			 $leng_seq2=$end2-$start2;
			 if(( ($leng_seq2/2) >= $leng_seq1 )&&
			    ($leng_seq1 > $min_inside_dom_size) ){   # if seq1 is less than 60% of seq2, it is a hidden domain
				push(@out, "$seq2\($seq1\)");
			 }
		  }elsif(($start1 < $start2)&&($end1 > $end2)){  # -----------
			 $leng_seq1=$end1-$start1;                   #   ------
			 $leng_seq2=$end2-$start2;
			 if(( ($leng_seq1/2) >= $leng_seq2)&&
			    ($leng_seq2 > $min_inside_dom_size) ){   # if seq1 is less than 60% of seq2, it is a hidden domain
				push(@out, "$seq1\($seq2\)");
			 }
		  }
	   }
	}
	return(\@out);
}



#______________________________________________________________
# Title     : scale_for_horizontal_histogram
# Usage     :
# Function  : used to make things like:
#
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub scale_for_horizontal_histogram{
	my @query=@{$_[0]};
	if(@query > 2400){
	$condense_factor=20;
	}elsif(@query > 2200){
	$condense_factor=18;
	}elsif(@query > 1900){
	$condense_factor=16;
	}elsif(@query > 1600){
	$condense_factor=15;
	}elsif(@query > 1400){
	$condense_factor=14;
	}elsif(@query > 1200){
	$condense_factor=12;
	}elsif(@query > 1000){
	$condense_factor=10;
	}elsif(@query > 800){
	$condense_factor=9;
	}elsif(@query > 630){
	$condense_factor=8;
	}elsif(@query > 440){
	$condense_factor=6;
	}elsif(@query> 220){
	$condense_factor=4;
	}elsif(@query > 120){
	$condense_factor=3;
	}else{
	$condense_factor=2;
	}
	return(\$condense_factor);
}



#______________________________________________________________
# Title     : get_added_matched_regions_in_mspa
# Usage     :
# Function  : This reads MSP file regions matched for a target seq
#             and adds things up to plot horizontally.
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub get_added_matched_regions_in_mspa{
	 my @lines=@{$_[0]};
	 for($i=0; $i< @lines; $i++){
	  #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	  #                   $1                 $2     $3    $4      $5     $6    $7     $8
	  #                   171     41.18      6      73  HI1690    9      76  HI0736 sodium...
	  #,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
	  if($lines[$i]=~/^\s*(\d+)\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s*(.*)/){
		 if($4 eq $7){
			$query_name=$4;
			$query_leng=$3;
			for($j=0; $j<$query_leng; $j++){ $query[$j]=0; }
			next;
		 }else{
			if($match_name ne $7){ push(@matched_members, $7); }
			$query_start=$2;
			$query_end  =$3;
			$query_seq  =$4;
			$match_start=$5;
			$match_end  =$6;
			$desc       =$8;
			$match_name =$7;
			for($k= $query_start; $k<$query_end; $k++){
			   $query[$k]++;
			}
		 }
	  }
	 }
	 return(\@query);
}




#______________________________________________________________
# Title     : cluster_merged_seqlet_sets
# Usage     : @out=@{&cluster_merged_seqlet_sets(\@lines)};
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
#  $short_region=  S by S -S  # taking shorter region overlapped in removing similar regions
#  $large_region=  L by L -L  # taking larger  region overlapped in removing similar regions
#  $average_region=A by A -A # taking average region overlapped in removing similar regions
#
# Version   : 1.8
#--------------------------------------------------------------
sub cluster_merged_seqlet_sets{
	 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	 if($debug==1){print "\n\t\@hash=\"@hash\"
	 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my ($optimize, @splited1, @splited2, $verbose, $link_or_not);
	 my @seq_names_in_clu=@{$array[0]};
	 $link_or_not=0;
	 my $factor=7; # 7 means 70% now

	 if($vars{'f'}=~/(\S+)$/){ $factor=$1 }
	 if($char_opt=~/o/){ $optimize=1 }
	 if($char_opt=~/S/){ $short_region='S'; }
	 if($char_opt=~/L/){ $large_region='L';   }
	 if($char_opt=~/A/){ $average_region='A'; }
	 if($char_opt=~/v/){ $verbose=1 }

	 if($verbose){ print "\n# (1) cluster_merged_seqlet_sets: Checking linkage and merging <<<<<>>>>>\n@seq_names_in_clu\n";   }

	 F1: for($i=0; $i< @seq_names_in_clu; $i++){
			@splited1=split(/\s+/, $seq_names_in_clu[$i]);
			for($j=0; $j< @seq_names_in_clu; $j++){
				if($seq_names_in_clu[$i] eq $seq_names_in_clu[$j]){ next  }
				@splited2=split(/\s+/, $seq_names_in_clu[$j]);

				$link_or_not=${&check_linkage_of_2_similar_seqlet_sets(\@splited1, \@splited2, "f=$factor")};
				print "\n +++++ \$link_or_not is  $link_or_not +++" if $verbose;
				if($link_or_not==1){
						 if($verbose){
								 print "\n# (2) cluster_merged_seqlet_sets: \n $seq_names_in_clu[$i]  \n and $seq_names_in_clu[$j] \n are linked \n";
						 }

						 if($optimize){ ##---- This will also remove similar seqlets, not only identical ones
								$seq_names_in_clu[$i]=join(' ', sort @{&remove_similar_seqlets( [@splited1, @splited2],
																						$short_region, $large_region, $average_region)} );
						 }else{
								$seq_names_in_clu[$i]=join(' ', sort @{&remove_dup_in_array( [@splited1, @splited2])} );
						 }
						 splice(@seq_names_in_clu, $j,1);
						 $j--; $i--;
						 next F1;
		 }
	  }
	 }
	 return(\@seq_names_in_clu);
}

#______________________________________________________________________________
# Title     : check_mailcap_file_in_user_home_dir
# Usage     :
# Function  : checks rasmol setting in .mailcap file
# Example   :
# Keywords  : check_rasmol_setting mailcap
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub check_mailcap_file_in_user_home_dir{
    my($mailcap_file_correctly_set, $mailcap_file);
    $mailcap_file="$ENV{\"HOME\"}\/.mailcap";
    unless(-s "$mailcap_file"){
       print "\n$0:  To view molecules with Rasmol, you have to set $mailcap_file file correctly\n";
       die;
    }else{
       open(MAIL_CAP_FILE, "$mailcap_file") || die "$0: can not open $ENV{HOME}\/.mailcap file\n";
       while(<MAIL_CAP_FILE>){
          if(/rasmol/){
              $mailcap_file_correctly_set=1;
          }
       }
       close(MAIL_CAP_FILE);
    }
    return(\$mailcap_file_correctly_set);
}




#______________________________________________________________________________
# Title     : check_homology_of_seq_pair
# Usage     :
# Function  :
# Example   : $homology_info=${&check_homology_of_seq_pair(\$pairs[$i], \%pdbg_hash_table)};
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_homology_of_seq_pair{
		my($i, %pdbg_hash_table,%input_hash, $seq_name1, $seq_name2,
			 $classification1, $classification2);
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Argument handling
		#___________________________________
		for($i=0; $i< @_; $i++){
			 if(ref($_[$i]) eq 'SCALAR' and ${$_[$i]}=~/^(\S+)\s+(\S+)$/){
					 ($seq_name1, $seq_name2)=($1,$2);
					 splice(@_, $i, 1); $i--;
			 }elsif(ref($_[$i]) eq 'ARRAY' and @{$_[$i]} eq 2){
					 ($seq_name1, $seq_name2)=@{$_[$i]}; splice(@_, $i, 1); $i--;
			 }elsif(ref($_[$i]) eq 'HASH'){
					 %input_hash=%{$_[$i]};
					 my @keys=keys %input_hash;
					 if($keys[0]=~/\S+/ and $input_hash{$keys[0]}=~/(\d+\.\d+\.\d+)/){
							 %pdbg_hash_table=%input_hash; splice(@_, $i, 1); $i--;
					 }
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # When seq pair name is given in HASH=(seq1, seq2)
					 #___________________________________________________
					 elsif($keys[0]=~/^\S+$/ and $input_hash{$keys[0]}=~/^\S+$/){
							 ($seq_name1, $seq_name2)= ($keys[0], $input_hash{$keys[0]});
							 splice(@_, $i, 1); $i--;
					 }elsif($keys[0]=~/^(\S+)\s(\S+)$/){
							 ($seq_name1, $seq_name2)= ($1, $2); splice(@_, $i, 1); $i--;
					 }
			 }
		}

		if($pdbg_hash_table{$seq_name1}=~/^(\d+\.\d+\.\d+)/){
			 $classification1=$1;
		}else{
			 print "\n\t# (W) \'$pdbg_hash_table{$seq_name1}\' is NOT FOUND in \%pdbg_hash_table, One member group??";
		}
		if($pdbg_hash_table{$seq_name2}=~/^(\d+\.\d+\.\d+)/){
			 $classification2=$1;
		}else{
			 print "\n\t# (W) \"$pdbg_hash_table{$seq_name2}\" is NOT FOUND in \%pdbg_hash_table, One member group??";
		}
		if($classification1 and $classification1 eq $classification2){
			 print "\n\t# (i) $seq_name1 $classification1 == $seq_name2 $classification2";
			 return(\'Homolog');
		}else{
			 print "\n\t# (i) $seq_name1 $classification1 =X= $seq_name2 $classification2";
			 return(\'Nomolog');
		}
}



#______________________________________________________________
# Title     : check_linkage_of_2_similar_seqlet_sets
# Usage     :
# Function  : connects two clusters of seqlets if they share
#              identical or near identical seqlets
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#  $factor = by f=  # eg)  "f=$factor" in the higher level sub
#
# Returns   :
# Argument  :
# Version   : 2.0
#--------------------------------------------------------------
sub check_linkage_of_2_similar_seqlet_sets{
	 my ($seq1, $name1, $start1, $end1, $seq2, $leng1, $leng2,
	    $name2, $start2, $end2, $diff_start,  $diff_end, @splited1,
	    @splited2, $link_or_not, $factor, $s, $t, $final_factor);
	 @splited1=@{$_[0]};
	 @splited2=@{$_[1]};

	 $link_or_not=0;
	 $factor=7;  # this means 70% sequence region overlap of the intermediate is chosen

	 if($_[2]=~/f=(\S+)/i){	  $factor=$1;	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # Breaks the splited1 and splited2 strings to words to compare
	 #_________________________________________________________________
	 F1: for($s=0; $s<@splited1; $s++){
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# Checks if the input has :  XXXXX_10-400 format or simple name like XXXXXX
			#______________________________________________________________________________
			if($splited1[$s]=~/^ *((\S+)_(\d+)\-(\d+))/){ $seq1=$1;	$name1=$2; $start1=$3; $end1=$4;
			}else{   $seq1=$splited1[$s]; $name1=$start1=$end1='';    }
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# Breaks the splited2
			#_____________________________________________________________________
			F2: for($t=0; $t< @splited2; $t++){
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # If splited1 has XXXX_10-100 format(def($name1)), then compare regions
				 #_________________________________________________________________________
                 if($name1 and $splited2[$t]=~/^ *((\S+)_(\d+)\-(\d+))/){ $seq2=$1; $name2=$2; $start2=$3; $end2=$4;
					 if($seq1 eq $seq2){ $link_or_not=1; return(\$link_or_not) }
					 if($name1 ne $name2){
						 next F2;
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                     # The most impoartant part is here. $final_factor=$smaller_leng - $smaller_leng*($factor/10);
					 #____________________________________________
                     }elsif($name1 eq $name2){
						 $leng1=$end1-$start1; $leng2=$end2-$start2;
						 if($leng1 >= $leng2){ $smaller_leng=$leng2; }else{ $smaller_leng=$leng1; }
						 $diff_start=abs($start1-$start2);
						 $diff_end  =abs($end1  -$end2  );
                         $final_factor=$smaller_leng - $smaller_leng*($factor/10);
                         $final_diff=($diff_start+$diff_end)/2;
                         if($final_diff <= $final_factor ){
                            $|=1;
                            print "\n$seq1 $seq2: $final_diff ($diff_start, $diff_end): $smaller_leng, $final_factor, ";
							$link_or_not=1; return(\$link_or_not);
    					 }else{  print "\n$seq1 $seq2: $final_diff ($diff_start, $diff_end): $smaller_leng, $final_factor 0\n"; }
					 }## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 }else{
				     $seq2=$splited2[$t];
					 if($seq1 eq $seq2){ $link_or_not=1; }
				 }
			}
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # If $link_or_not has become 1 in any of the above part, 1 is returned
	 #________________________________________________________________________
	 return(\$link_or_not);
}



#__________________________________________________________________________
# Title     : merge_arrays_by_common_elements
# Usage     :  @out=@{&merge_arrays_by_common_elements(\@ref_of_arrays)}
# Function  : merges arrays if there are common array elements.
#             if @A has (1,2,3) and @B has (2, 4, 5), they share 2, so
#             they are merged to be (1,2,3,4,5)
# Example   :
# Keywords  : cluster_arrays_by_common_elements, merge_arrays_if_common_elements
#             merge_array_if_common_elements, merge_arrays_when_common_elements_occur
#             merge_arrays
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub merge_arrays_by_common_elements{
	my ($i, @mother_array);

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Handling input array
	#______________________________________
	if( @_==1 and ref($_[0]) eq 'ARRAY'){  @mother_array=@{$_[0]};
	}elsif(@_ > 1){   @mother_array=@_;
	}else{
	   print "\n# The input for merge_arrays_by_common_elements needs one ref of array or multiple refs of array\n";
	}

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Main algo
	#______________________________________
	for($i=0; $i< @mother_array; $i++){
	   my @merged=(@{$mother_array[$i]}, @{$mother_array[$i+1]});
	   my ($common_or_not, %merged_hash, $j);

	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	   #  Checks if there is a common element
	   #______________________________________
	   for($j=0; $j< @merged; $j++){
		  $merged_hash{$merged[$j]}++;
		  if($merged_hash{$merged[$j]} > 1){ $common_or_not=1 }
	   }
	   my @non_redundant=keys %merged_hash;

	   if($common_or_not==1){
		   $mother_array[$i]=\@non_redundant;
		   splice(@mother_array, ($i+1), 1);
		   $i--;
	   }
	}
	return(\@mother_array);
}


#________________________________________________________________________________
# Title     : check_parf_files
# Usage     : $number_of_parf=${&check_parf_files(@input)};
# Function  : checks if given file(s) is a parf file and returns the number of
#              identified parf file. If you check 2 files and both are parf, you
#               will get (\$num_of_parf_file) value of 2.
# Example   :
#    PARF file looks like this>
#   d1nsca_   d3nn9__   Homolog -664.92 2.43.1.1.3  2.43.1.1.2
#   d1dppa_   d2olba_   Homolog -617.41 3.68.1.1.6  3.68.1.1.1
#   d2ach.1a1 d9api.1a1 Homolog -556.38 5.2.1.1.3   5.2.1.1.4
# Keywords  :
# Options   :
# Author    :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub check_parf_files{
		 my(@parf_file, $i, $j, @array, $counter, $num_of_parf_file);

		 for($i=0; $i< @_; $i++){
					if(ref($_[$i]) eq 'SCALAR' and -f ${$_[$i]}){
							 push(@parf_file, ${$_[$i]})
					}elsif(-f $_[$i]){
							 push(@parf_file, $_[$i])
					}elsif(ref($_[$i]) eq 'ARRAY'){
							 @array=@{$_[$i]};
							 for($j=0; $j< @array; $j++){
									 if(-f $array[$j]){
											 push(@parf_file, $array[$j]);
									 }
							 }
					}
		 }
		 print "\n# There were: @parf_file\n" if $verbose;
		 for($i=0; $i< @parf_file; $i++){ ## usually @parf_file has only one element!
					#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					# Check if it is parf file inside the file
					#__________________________________________________________
					open(INPUT_FILE, "<$parf_file[$i]");
					while(<INPUT_FILE>){
							 $counter++;
							 if(/^\s*\S+\s+\S+\s+[HN]omolog\s+\S+\s+\S+\s+\S+/){
									 $num_of_parf_file++;
									 print "\n# $parf_file[$i] is a PARF file\n" if $verbose;
									 last;
							 }else{
									 if($counter > 100){  ## giving up, it is not PARF file!
											 print "\n# $0 needs to have PARF files, others are ignored" if $verbose;
											 last;
									 }else{
											 next;
									 }
							 }
					}
					close(INPUT_FILE);
		 }
		 return(\$num_of_parf_file);
}



#__________________________________________________________________________
# Title     : check_common_elements_in_array
# Usage     : &check_common_elements_in_array($mother_array[$i], $mother_array[$i+1]));
# Function  : accepts 1 or 2 refs of arrays and checks if there is any
#             common(repeating) elements between the two (or inside one)
#             The result is either ref of 1, or 0
# Example   :
# Keywords  : is_there_common_element, if_common_elements
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub check_common_elements_in_array{
	my(@merged_array, %common_elemnts_count, $m);
	if(@_ > 1){
	   @merged_array=(@{$_[0]}, @{$_[1]});
	}else{
	   @merged_array=(@{$_[0]});
	}
	for $m (@merged_array){
	   $common_elemnts_count{$m}++;
	   if($common_elemnts_count{$m} > 1){
		  print "\n# $common_elemnts_count{$m}     $m common!\n";
		  return(\1);
	   }
	}
	return(\0);
}

#______________________________________________________________________________
# Title     : list_small_files
# Usage     : @files_listed=@{&list_small_files(@ARGV)};
# Function  :
# Example   :
# Keywords  : show_small_files
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub list_small_files{
    my($file_size_cut_line, $creation_time, $size, @files_listed, $i, @files);

    $file_size_cut_line=${$_[0]} || $_[0];
    $file_size_cut_line_bigger_than=$ARGV[1];

	 @files=@{&read_file_names_only('.')};

	 for($i=0; $i< @files; $i++){
        $size= -s $files[$i];
        $creation_time= localtime( (stat($files[$i]))[9] );
		if($size <= $file_size_cut_line and $size >= $file_size_cut_line_bigger_than){
			push(@files_listed, $files[$i]);
			print "\n# (i) $files[$i] is smaller than  $file_size_cut_line, size= $size byte, $creation_time";
		}
	 }
	 return(\@files_listed);
}


#______________________________________________________________________________
# Title     : link_prot_superfam_class_to_SCOP_web_site
# Usage     :
# Function  :
# Example   :
# Keywords  : attach_scop_URL_to_superfamily_classification
#             link_protein_superfam_class_to_SCOP_web_site
#             link_SCOP, link_scop, attach_URL_, attach_url
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub link_prot_superfam_class_to_SCOP_web_site{
    my($line, @classi, $i, $class, $fold, $superfam, $class_URL, $first_num,
       $sec_num, $third_num, $final_line, @line_frags, @classi_URL);
    $line=${$_[0]} || $_[0];
    if($line=~/\/scop.\d+.\d+.\d+.\d+\.\d+\.\d+\.html\"\>\d+\.\d+\.\d+/){
        return(\$line)
    }

    if(@classi=$line=~/(\d+\.\d+\.\d+)/g){
        for($i=0; $i<@classi; $i++){
            if($classi[$i]=~/(\d+)\.(\d+)\.(\d+)/){
              ($class, $fold, $superfam)=($1, $2, $3);
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
               #______________________________________________________________________________________
               if(length($class) ==1){      $first_num="00$class";
               }elsif(length($class) ==2){  $first_num="0$class";
               }else{                       $first_num="$class"; }
               if(length($fold) ==1){       $sec_num="00$fold";
               }elsif(length($fold) ==2){   $sec_num="0$fold";
               }else{                       $sec_num="$fold"; }
               if(length($superfam) ==1){      $third_num="00$superfam";
               }elsif(length($superfam) ==2){  $third_num="0$superfam";
               }else{                          $third_num="$superfam"; }
               $class_URL="$first_num\.$sec_num\.$third_num";
               push(@classi_URL, $class_URL);
            }else{
               die "\nlink_prot_superfam_class_to_SCOP_web_site: Something is wrong \n";
            }
        }
    }else{
        return(\$line);
    }
    @line_frags=split(/\d+\.\d+\.\d+/, $line);
    for($i=0; $i<@line_frags; $i++){
        $final_line .="$line_frags[$i]<A href=\"http://scop.mrc-lmb.cam.ac.uk/scop/data/scop.1.$classi_URL[$i].000.000.html\"\>$classi[$i]<\/A>";
    }
    return(\$final_line);
}

#__________________________________________________________________________
# Title     : link_ranges
# Usage     : @all_ranges = @{&link_ranges(@all_ranges)};
# Function  : merges ranges(10-20, 11-21 etc) when there is any overlap
#              is present
#             If you put a reverse range like '2000-20', it will
#              complain and reverse the order and do the job after correction.
#
# Example   : INPUT:
#
#   @input=( '1-30 1-40 1-50',
#            '2-49 4-40 2-99'....)
#
# Keywords  : connect_ranges, link_overlapping_ranges, connect_overlapping_ranges
# Options   : _  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------
sub link_ranges{
	 my (@all_ranges, $new_start, $new_end, @output, $i, $seq1, $start1,
	   $end1, $seq2,
	   $smaller_leng, $start2, $end2, @split, @split1, @split2);
	 my $leng_thresh=30;
	 my $optimize=0;
	 for($i=0; $i< @_; $i++){
	  if(ref($_[$i]) eq 'ARRAY'){
		  @all_ranges=@{$_[$i]};
			}
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  Sorting the ranges by the starting range number.(essential)
	 #______________________________________________________________
	 @all_ranges=map {$_->[0]} sort { $a->[1] <=> $b->[1] }
			   map { $_=~/(\d+)\-/ and [$_, $1] } @all_ranges;

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  iterating merger
	 #_________________________________________________________
	 for($i=0; $i< @all_ranges; $i++){
	   if($all_ranges[$i] =~/(\d+)\-(\d+)/){
		   ($start1, $end1)=($1, $2);
		   if($start1 > $end1){
			  print "\n# link_ranges: Error, \$start1 :$start1 is larger than \$end1: $end1\n";
			  print "\n# Exchanging the start and end, and starting it all over again";
			  $all_ranges[$i]="$2\-$1";
			  @all_ranges=map {$_->[0]} sort { $a->[1] <=> $b->[1] }
			              map { $_=~/(\d+)\-/ and [$_, $1] } @all_ranges;
			  $i= -1;
			  next;
		   }
	   }
	   if($all_ranges[$i+1] =~/(\d+)\-(\d+)/){
		   ($start2, $end2)=($1, $2);
		   if($start2 > $end2){
			  print "\n# link_ranges: Error, \$start2 :$start2 is larger than \$end2: $end2\n";
			  print "\n# Exchanging the start and end, and starting it all over again";
			  $all_ranges[$i+1]="$2\-$1";
			  @all_ranges=map {$_->[0]} sort { $a->[1] <=> $b->[1] }
			              map { $_=~/(\d+)\-/ and [$_, $1] } @all_ranges;
			  $i= -1;
			  next;
		   }

		   if($start1 <= $start2      and $end1 >= $end2){    ## -----------------
			   $new_start=$start1;                             #      --------
			   $new_end =$end1;
			   splice(@all_ranges, $i, 2, "$new_start\-$new_end");
			   $i--;
			   next;
		   }
		   if( $start2 <= $start1     and $end2 >= $end1){      ##    -------
			   $new_start=$start2;                              #  ----------------
			   $new_end =$end2;
			   splice(@all_ranges, $i, 2, "$new_start\-$new_end");
			   $i--;
			   next;
		   }
		   if($start1 <= $start2      and $start2 <= $end1){     #  -----------
			   $new_start=$start1;                               #     -----------
			   $new_end =$end2;
			   splice(@all_ranges, $i, 2, "$new_start\-$new_end");
			   $i--;
			   next;
		   }
		   if($start2 <= $start1      and $start1 <= $end2){    #       -----------
			   $new_start=$start2;                              #  ---------
			   $new_end =$end1;
			   splice(@all_ranges, $i, 2, "$new_start\-$new_end");
			   $i--;
			   next;
		   }
	   }
	 }
	 return(\@all_ranges);
}



#__________________________________________________________________________
# Title     : merge_similar_ranges
# Usage     : @all_ranges = @{&merge_similar_seqlets(@all_ranges)};
# Function  : merges ranges(10-20, 11-21 etc) when there is any overlap
#              is present (resulting in average start and end at each level)
#             If you put a reverse range like '2000-20', it will
#              complain and reverse the order and do the job after correction.
#
# Example   : INPUT:
#
#   @input=( '1-30 1-40 1-50',
#            '2-49 4-40 2-99'....)
#
# Keywords  : merge_similar_regions, merge_ranges, merge_regions,
#              merge_sequence_ranges, merge_overlap_ranges, connect_ranges
#              connect_overlapping_ranges, connect_similar_ranges,
#              remove_similar_ranges
# Options   : f=   for setting factor (0.7 for 70% overlap minimum)
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------------
sub merge_similar_ranges{
	 my (@all_ranges, $new_start, $new_end, @output, $i, $seq1, $start1,
	   $end1, $seq2, $average_leng,
	   $smaller_leng, $start2, $end2, @split, @split1, @split2);
	 my $factor=0.9;     #  0.8 means 80% overlap
	 my $leng_thresh=30;
	 my $optimize=0;
	 for($i=0; $i< @_; $i++){
	  if(ref($_[$i]) eq 'ARRAY'){
		  @all_ranges=@{$_[$i]};
	  }elsif($_[$i]=~/f=(\S+)/){
					$factor=$factor_ori=$1;
	      #print "\n# merge_similar_ranges: Factor used will be $factor\n\n";
	  }elsif($_[$i]=~/z/i){
	      $optimize=1 }
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  Sorting the ranges by the starting range number.(essential)
	 #______________________________________________________________
	 @all_ranges=map {$_->[0]} sort { $a->[1] <=> $b->[1] }
			   map { $_=~/(\d+)\-\d+\s*$/ and [$_, $1] } @all_ranges;

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  iterating merger
	 #_________________________________________________________
	 for($i=0; $i< @all_ranges; $i++){
			 $factor=$factor_ori;

	   if($all_ranges[$i] =~/(\d+)\-(\d+)\s*$/){  ## ranges are at the end
		   ($start1, $end1)=($1, $2);
		   if($start1 > $end1){
			  print "\n# merge_similar_ranges: Error, \$start1 :$start1 is larger than \$end1: $end1\n";
			  print "\n# Exchanging the start and end, and starting it all over again";
			  $all_ranges[$i]="$2\-$1";
			  @all_ranges=map {$_->[0]} sort { $a->[1] <=> $b->[1] }
			              map { $_=~/(\d+)\-\d+\s*$/ and [$_, $1] } @all_ranges;
			  $i= -1;
			  next;
		   }
	   }
			 if($all_ranges[$i+1] =~/(\d+)\-(\d+)\s*$/){ ## ranges are at the end
		   ($start2, $end2)=($1, $2);
		   if($start2 > $end2){
			  print "\n# merge_similar_ranges: Error, \$start2 :$start2 is larger than \$end2: $end2\n";
			  print "\n# Exchanging the start and end, and starting it all over again";
			  $all_ranges[$i+1]="$2\-$1";
			  @all_ranges=map {$_->[0]} sort { $a->[1] <=> $b->[1] }
			              map { $_=~/(\d+)\-\d+\s*$/ and [$_, $1] } @all_ranges;
			  $i= -1;
			  next;
		   }

					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 $average_leng=(($end2+$end1)/2)-(($start1+$start2)/2);   ## this is protein seq ranges
					 $factor-=$average_leng/5000; ## adjusting $factor according to the size of range.
					 #_____________________________________________________________

					 if($start1 <= $start2      and $end1 >= $end2){        ## -----------------

							 if(($end1-$start1)*$factor  <= ($end2-$start2) ){    #      --------
									$new_start=(($start1+$start2)/2);
			      $new_end  =(($end1+$end2)/2);
			      splice(@all_ranges, $i, 2, "$new_start\-$new_end");
			      $i--;			      next;
			   }
		   }
		   if( $start2 <= $start1     and $end2 >= $end1){       ##    -------
							 if(($end2-$start2)*$factor  <= ($end1-$start1) ){  #  ----------------
									 $new_start=(($start2+$start1)/2);
									 $new_end  =(($end1+$end2)/2);
									 splice(@all_ranges, $i, 2, "$new_start\-$new_end");
									 $i--;              next;
							 }
		   }
		   if($start1 <= $start2      and $start2 <= $end1){     #  -----------
							 if(($end1-$start2) >=  ($end2-$start1)*$factor ){ #      -----------
									$new_start=(($start2+$start1)/2);
									$new_end  =(($end1+$end2)/2);
									splice(@all_ranges, $i, 2, "$new_start\-$new_end");
									$i--;               next;
							 }
		   }
		   if($start2 <= $start1      and $start1 <= $end2){     #       -----------
							 if(($end2-$start1) >=  ($end1-$start2)*$factor ){ #    -----------
									 $new_start=(($start2+$start1)/2);
									 $new_end  =(($end1+$end2)/2);
									 splice(@all_ranges, $i, 2, "$new_start\-$new_end");
									 $i--;              next;
							 }
		   }
	   }
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  making everything integer at the last minute to save CPU
	 #___________________________________________________________
	 @all_ranges = map{ /(\S+)\-(\S+)\s*$/ and int($1).'-'.int($2)  } @all_ranges;
	 return(\@all_ranges);
}



#_________________________________________________________________________
# Title     : merge_similar_seqlets
# Usage     : @all_seqlets = @{&merge_similar_seqlets(@all_seqlets)};
# Function  : merges seqlet sets which have identical
#             sequences and share similar regions by connection factor of 30%
#             This means, if any two seqlets from the same sequences which
#             share more than 70% seqlet regions overlapping are merged
#             This only sees the very first sequence in the seqlets line!!!
#             (so, PARTIAL MERGE !!)
# Example   : INPUT:
#
#   @input=( 'seq1_1-30 seq2_1-40 seq3_1-50',
#            'seq1_2-49 seq3_4-40 seq4_2-99'....)
#
#   @output=('seq1_1-30 seq2_1-45 seq3_2-45 seq4_2-99');
#
# Keywords  : merge_similar_sequences, merge_sequence_names, merge_sequences,
#              merge_sequence_ranges, merge_similar_sequences_with_ranges,
#              merge_seqlets, merge_duplication_modules
# Options   :
#
#   f=<digit>   for determing the factor in filtering out non-homologous
#                  regions, 7 = 70% now!!
#   l=<digit>   for seqlet(duplication module) length threshold
#   z           for activating remove_similar_sequences, rather than remove_dup....
#   S  $short_region=  S by S -S  # taking shorter region overlap in removing similar reg
#   L  $large_region=  L by L -L  # taking larger  region overlap in removing similar reg
#   A  $average_region=A by A -A  # taking average region overlap in removing similar reg
#
# Version   : 2.2
#-------------------------------------------------------------------------------
sub merge_similar_seqlets{
	 my (@all_seqlets, @result_all_seqlets, $i, $j, $k, $seq1, $start1, $end1, $seq2,
	   $smaller_leng, $start2, $end2, @split, @split1, @split2, $factor, $leng_thresh, $optimize,
			 $short_region, $large_region, $average_region, $overlapping_seq_match_size);
	 $factor=7;     #  30% sequence mismatch region is allowed(3)
	 $leng_thresh=30;
	 $optimize=1;
	 $average_region='A'; # default

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 # Sorting (parsing) input to get options and input array
	 #_________________________________________________________
	 for($i=0; $i< @_; $i++){
	     if(ref($_[$i]) eq 'ARRAY'){
             @all_seqlets=@{$_[$i]}; #<------------ @all_seqlets is a very very big array with all the mspa chunks altogether
			 }elsif($_[$i]=~/f=(\S+)/){  $factor=$1;
			 }elsif($_[$i]=~/z/i){       $optimize=1;
			 }elsif($_[$i]=~/l=(\d+)/i){ $leng_thresh=$1;
			 }elsif($_[$i]=~/^S/){       $short_region='S';   $large_region=$average_region='';
			 }elsif($_[$i]=~/^L/){       $large_region='L';   $short_region=$average_region='';
			 }elsif($_[$i]=~/^A/){       $average_region='A'; $short_region=$large_region  =''; }
	 }
	 if(@all_seqlets==1){
         return(\@all_seqlets);
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # This is to remove which are identical in @all_seqlets;
	 #_________________________________________________________
	 F1: for($i=0; $i< @all_seqlets; $i++){
		my $merged_two_seqlet_lines;

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        # The following is correct. Don't touch again
        #__________________________________________________
        if($all_seqlets[$i] eq $all_seqlets[$i+1]){
			splice(@all_seqlets, $i+1, 1);
			$i-- if $i >0;    next F1;
	    }else{
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # @split1 and 2 are arrays from different string entry in @all_seqlets
            #______________________________________________________________________
            @split1=sort split(/\s+/, $all_seqlets[$i]);
            @split2=sort split(/\s+/, $all_seqlets[$i+1]);
		}

	    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    #   (3) If the first elements of @split1 and 2 are identical, lets merge the two arrays. For example,
	    #    aa_EC1427_1-390 aa_EC388_1-374 ap_EC143_23-399 dr_6457710_11-405 ec_1787201_9-360 mj_MJ1649_5-387 mj_MJ1653_4-383 pa_5459109_1-394 ph_PH1915_1-394 tm_4982274_20-385
        #    aa_EC1427_1-390 aa_EC388_1-372 ap_EC143_40-399 dr_6457710_11-407 dr_6459463_3-373 ec_1787201_4-367 mj_MJ1649_5-385 mj_MJ1653_39-382 pa_5459109_21-392 ph_PH1915_21-392 tm_4982274_12-382
	    #__________________________________________________________________________________________________
		if($split1[0] eq $split2[0] or $split1[0] eq $split2[1] or $split1[1] eq $split2[0]){
              @split=(@split1, @split2);
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # This step is proven to be fine. optimize option removes similar seqlets
              #___________________________________________________
              if(1){
                 $all_seqlets[$i]= join(' ', sort @{&remove_similar_seqlets(\@split,
		                              $short_region, $large_region, $average_region)} );
		      }else{
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # Only removes exactly identical ones
				 #__________________________________________________________
				 $all_seqlets[$i]=  join(' ', @{&remove_dup_in_array(\@split, 's')} );
		      }
		      splice(@all_seqlets, $i+1, 1);     $i-- if $i >0;     next F1;
	    }

	    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# (4) If the first elements of @split1 and 2 are NOT identical, lets check the sequence ranges
	    #_____________________________________________________________________________________________
		F2: for($j=0; $j < @split1; $j++){
			if($split1[$j] =~/^\s*(\S+)_(\d+)\-(\d+)/){
				 my ($seq1, $start1, $end1)=($1, $2, $3);

				 F3: for($k=0; $k<@split2; $k++){
					 if($split2[$k] =~/(\S+)_(\d+)\-(\d+)/){
						 my($seq2, $start2, $end2)=($1, $2, $3);

						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
						 # Check if the seqs are identicl (from the two arrays), no point to merge which are not identical from the first
						 #__________________________________________________________________________________________
						 if($seq1 eq $seq2){
                             $diff_start=abs($start1-$start2); $diff_end  =abs($end1  -$end2  );
                             $leng1=$end1-$start1; $leng2=$end2-$start2;
                             if($leng1 >= $leng2){  $smaller_leng=$leng2; $larger_leng =$leng1
                             }else{  $smaller_leng=$leng1;  $larger_leng =$leng2       }

                             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                             # Checking the minimal seq region leng here
                             #______________________________________________________
                             if($smaller_leng < $leng_thresh){ next }

                             $overlapping_seq_match_size=${&get_overlapping_seq_match_size($start1, $end1, $start2, $end2)};
                             $averge_seq_leng_of_2_seqs=($leng1+$leng2)/2;

                             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                             # This is the critically important part
                             #_______________________________________________________________
                             if($average_region){      $finally_adjusted_seq_leng=$averge_seq_leng_of_2_seqs*($factor/10);
                             }elsif($short_region){    $finally_adjusted_seq_leng=$smaller_leng*($factor/10);
                             }elsif($large_region){    $finally_adjusted_seq_leng=$larger_leng*($factor/10);     }

                             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                             # Now let's check if we regard them homologous or not\
                             #_______________________________________________________
                             if( $overlapping_seq_match_size >=  $finally_adjusted_seq_leng){
                                 @split= (@split1, @split2);
                                 if($optimize){ #~~~~~ $optimize option removes similar seqlets
                                     $all_seqlets[$i]= join(' ', sort @{&remove_similar_seqlets(\@split,
                                                         $short_region, $large_region, $average_region)} );
                                 }else{
                                       $all_seqlets[$i]= join(' ', @{&remove_dup_in_array(\@split, 's')} );
                                 }
                                 $merged_two_seqlet_lines=1;
                                 splice(@all_seqlets, $i+1, 1);
                                 $i-- if $i >0;  next F1;
                             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                             # We believe they are not homologous
                             #____________________________________________
                             }else{  next F3;  }
                          }
                       }
                       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                       # If there is no range (region) in seq naem, let's skip, as there is no way to check
                       #__________________________________________________________________________________
                       else{ # when split2 does not match xxx_10-20 format
                               next;
                       }
                  }
            }else{  next; } # when split1 does not match xxx_10-20 format
        }
        unless($merged_two_seqlet_lines){   }
	 }
	 return(\@all_seqlets);
}






#______________________________________________________________
# Title     : sort_by_digits_in_string
# Usage     :
# Function  : sorts arrays of strings like
#
#   MJ0228_314-573 MJ1197_348-601
#   MJ0228_451-576 sll0078_502-594 sll1425_489-611
#   MJ0228_479-572 sll0078_502-594
#
#   According to the digits after seq names _314-, _451-, _479-
#    in the above
#   This only looks at the very first sequence in the string
#
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.4
#--------------------------------------------------------------
sub sort_by_digits_in_string{
	 my (@out, $i,  @temp1, @temp2, $old, @T);
	 my @array_of_string=sort @{$_[0]};

	 for($i=0; $i<= @array_of_string; $i++){
	  if($array_of_string[$i]=~/^((\S+)_(\d+)\-(\d+)\s*.*)$/){
		 unless(defined($old)){
			$old=$2;
			push(@temp1, $1);
			push(@temp2, $3);
		    next;
		 }elsif($2 eq $old){
			push(@temp1, $1);
			push(@temp2, $3);
			next;
		 }elsif( ($2 ne $old)||($i==$#array_of_string) ){
		    &sort_and_put_strings_to_out;
		    push(@temp1, $1);
		    push(@temp2, $3);
			$old  =$2;

			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			sub sort_and_put_strings_to_out{
			   my ($j, $k, $num);
			   @temp2=sort { $a<=>$b } @temp2; ## sort numerically
			   F1: for($j=0; $j< @temp2; $j++){
				  $num=$temp2[$j];
				  for($k=0; $k< @temp1; $k++){
					 if($temp1[$k]=~/^(\S+)_$num\-/){
						push(@out, $temp1[$k]);
						splice(@temp1, $k, 1);
						$k--;
						splice(@temp2, $j, 1);
						$j--;
						next F1;
					 }
				  }
			   }
			   @temp1=@temp2=();

			}#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	     }
	  }elsif($i > 0){ ## for the very last sort
		  &sort_and_put_strings_to_out;
	  }
	 }
	 return(\@out);
}



#______________________________________________________________
# Title     : sort_words_in_string
# Usage     :
# Function  : sort words in strings sperated by ' ' or "\n"
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : sort_words_in_sequences, sort_sequences_in_string,
#             sort_strings_in_string, sort_string_by_words, sort_elements_in_string
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub sort_words_in_string{
		my @in=@{$_[0]} || @_;
		my @OUT;
		for (@_){
		 push(@OUT, join(' ', sort split(/\s+|\n/) ));
		}
		return(\@OUT);
}



#__________________________________________________________________________
# Title     : convert_hmmls_to_mspa_files
# Usage     : @out=@{&convert_hmmls_to_mspa_files(\@file)};
# Function  :
# Example   :
# Keywords  : convert_hmmls_to_mspa
# Options   :
#   S=$single_out_file_name   for producing single mspa file with all the hmmls contents
#   E=Enguiry_name    for specifying enquiry seq name rather than 'HMM', the default
#   $bit_score_threshold= by t=
# Returns   :
# Argument  :
# Version   : 1.4
#----------------------------------------------------------------------------
sub convert_hmmls_to_mspa_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my (@all_the_files_written, $written_file, $base,
						$bit_score_threshold, $out_mspa_file_name, $input_hmmls_file,
	    %out);
	$bit_score_threshold=10;

				if($vars{'S'}=~/\S/){ $single_out_file_name=$vars{'S'} };
				if($vars{'t'}=~/\S/){ $bit_score_threshold =$vars{'t'} };
	if($vars{'E'}=~/\S/){ $enquiry_name        =$vars{'E'}   # default $enquiry_name is input file base
	}else{ $enquiry_name='HMM' }

	for($i=0; $i< @file; $i++){

							if($vars{'E'}=~/\S/){ $base=$enquiry_name;   # When $enquiry_name is given, it uses for output name
							}else{
									$base=${&get_base_names($file[$i])};
							}
							$out_mspa_file_name="$base\.mspa";
							$input_hmmls_file=$file[$i];
							if($vars{'S'}=~/\S/){
											%out=(%out, %{&open_hmmls_files($input_hmmls_file,
																			 'm', "E=$enquiry_name",
																			 "t=$bit_score_threshold"
																			 )} );
							}else{
											%out=%{&open_hmmls_files($input_hmmls_file,
														 "t=$bit_score_threshold", 'm')};  # m for mspa out
											$written_file=${&write_mspa_files(\%out, $out_mspa_file_name)};
											push(@all_the_files_written, $written_file);
							}
	}

	if($vars{'S'}=~/\S/){
		$written_file=${&write_mspa_files(\%out, $single_out_file_name)};
		push(@all_the_files_written, $written_file);
	}
	if(@all_the_files_written > 1){
		return(\@all_the_files_written);
	}else{
		return(\$all_the_files_written[0]);
	}
}


#______________________________________________________________
# Title     : convert_mmp_to_mrg
# Usage     :
# Function  :
# Example   :
#  Example OUT as string
#
#   slr1950 sll1920 sll0672 sll1076 sll1614 slr0797 slr0798 slr0822 slr1729
#   slr1729 sll1076 sll0672 sll1614 sll1920 slr0797 slr0798 slr0822 slr1950
#
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub convert_mmp_to_mrg{
	 my @mmp=@{$_[0]};
	 my($i, $long, $out, @out, $leading_seq);
	 for($i=0; $i< @mmp; $i++){
	 if(($mmp[$i]=~/^\s*\d+\s+\d+\.?[e\-\d]*\s+\d+\s+\d+\s+(\S+)\s+\d+\s+\d+\s+(\S+)\s*$/)&&($1 eq $2)){
		next;
	 }elsif($mmp[$i]=~/^\s*\d+\s+\d+\.?[e\-\d]*\s+\d+\s+\d+\s+(\S+)\s+\d+\s+\d+\s+(\S+)\s*$/){
		$leading_seq=$1;
		$long=$2;
		$long=~s/\,/ /g;
		$out="$leading_seq $long";
		push(@out, $out);
	 }
	 }
	 return(\@out);
}


#______________________________________________________________________________
# Title     : add_revcomp_sequences
# Usage     : %out=%{&add_revcomp_sequences(\@input_string_or_seq)};
#              or %out=%{&add_revcomp_sequences(\%input_string_or_seq)};
# Function  :
# Example   :
# Keywords  : add_revcomp_string, add_revcomp_string_array, insert_revcomp_string_array
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub add_revcomp_sequences{
		my(@revcomp_patterns, @patterns, $pattern, $i, %patterns, @names, $arbit_name);
		if(ref($_[0]) eq 'ARRAY'){
				@patterns=@{$_[0]};
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# Making a hash out of array
				#_________________________________________________
		    for($i=0; $i< @patterns; $i++){
					 $arbit_name="PAT\_$i";
					 $patterns{$arbit_name}=$patterns[$i];
		    }
		}elsif(ref($_[0]) eq 'HASH'){ %patterns=%{$_[0]};
		}else{  print "\n# (Error) add_revcomp_sequences get either HASH or ARRAY only \n"; die }
		@names=sort keys %patterns;
		for($i=0; $i< @names; $i++){
			 $pattern =$patterns{$names[$i]};
		   $pattern =~ tr/\[\]acgtrymkswhbvdnACGTRYMKSWHBVDN/\]\[tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
			 $pattern = reverse $pattern; # reversing it to add complimentary to the original
			 $patterns{"$names[$i]\_rc"}=$pattern;
		}
		return(\%patterns);
}



#_______________________________________________________________________________
# Title     : add_ranges_in_mspa_line
# Usage     :
# Function  : this adds ranges to the seqnames of mspa files
#             mmp line is mspa line with additional sequences at the end
# Example   :
# Keywords  : convert_mspa_to_mmp, convert_mspa, convert_mspa_2_mmp
#             change_mspa_to_mmp, add_range_in_mspa, convert_mspa_line_to_mmp_line
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.5
#-------------------------------------------------------------------------------
sub add_ranges_in_mspa_line{
	 my $input_mspa=${$_[0]} || $_[0];
	 my($score, $evalue, $long_1, $new_seq1, $new_seq2, $middle,
	  $start1, $end1, $start2, $end2, $seq1, $seq2, $new);

	 if($input_mspa=~/^\s*(\d+)\s+(\S+)\s*\S*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
	  ($score, $evalue, $start1, $end1, $start2, $end2)=($1, $2, $3, $4, $6, $7);
	  ($seq1, $seq2)=($5, $8);
	  if($seq1=~/(\S+)\_\d+\-\d+/){
		 $new_seq1="$1\_$start1\-$end1";
	  }else{
		 $new_seq1="$seq1\_$start1\-$end1";
	  }
	  if($seq2=~/(\S+)\_\d+\-\d+/){
		 $new_seq2="$1\_$start2\-$end2";
	  }else{
		 $new_seq2="$seq2\_$start2\-$end2";
	  }
	  $new=sprintf("%-6s %-9s %-5s %-5s %-32s %-5s %-5s %-32s",
			$score, $evalue, $start1, $end1, $new_seq1, $start2, $end2, $new_seq2);
	 }
	 return(\$new);
}



#______________________________________________________________________________
# Title     : align_herta_inputs_with_adjustments
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.6
#------------------------------------------------------------------------------
sub align_herta_inputs_with_adjustments{
    my($i, %align_position_seq1_seq2, %MRC_search_alignment,
       @scores, @align_info, $herta_align_score, $min_score,
       @align_info, @seq1_aligned, @seq2_aligned, @residues1, @residues2,
       @positions1, @positions2, $align_info, $REF_seq1_start_final, $query_seq, $DB_seq,
       $REF_seq2_start_final, $REF_scores_gap, @seq1_start_final, @seq2_start_final, @scores_gap,
       $seq1_len, $seq2_len, @herta_align_score, $last_residue_posi_1, $last_residue_posi_2,
       @residues1_suffix, @residues2_suffix, @complete_seq1_aligned, @complete_seq2_aligned,
       $NO_screen_print, $Mutual_Seq_Id_aligned, $Mutual_Seq_Id, $non_idential,
       $ALIGNMENT_LENG, $query_seq_align_range, $DB_seq_align_range);
    @residues1       =@{$_[0]};
    @residues2       =@{$_[1]};
    @positions1      =@{$_[2]};
    @positions2      =@{$_[3]};
    %align_position_seq1_seq2=%{$_[4]};
    $query_seq       =${$_[5]} || $_[5];
    $DB_seq          =${$_[6]} || $_[6];
    $NO_screen_print =${$_[7]} || $_[7];

    $seq1_len=@residues1;
    $seq2_len=@residues2;

    $query_seq_align_range="$positions1[0]-$positions1[$#positions1]";
    $DB_seq_align_range   ="$positions2[0]-$positions2[$#positions2]";

    $query_seq="$query_seq\_$query_seq_align_range";
    $DB_seq="$DB_seq\_$DB_seq_align_range";

    ($REF_seq1_start_final, $REF_seq2_start_final, $REF_scores_gap)
               =&get_prefix_arrays_for_seqlet_alignment(\@residues1, \@residues2,
                                                        \@positions1, \@positions2);

    @seq1_start_final=@{$REF_seq1_start_final};
    @seq2_start_final=@{$REF_seq2_start_final};
    @scores_gap      =@{$REF_scores_gap};

    # ALIGNMENT 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, -8, 0, 0, 0, 0, 0, 0, 10, 0,
    @align_info      =@{$align_position_seq1_seq2{'ALIGNMENT'}};
    #print "\n", @align_info, "\n";
    $herta_align_score=$align_position_seq1_seq2{'RAW_ALIGN_SCORE'};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # min_score from herta (around -5 to +7 range). -3 is reasonable
    #________________________________________________
    $min_score=-3.0;  # arbitrary

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # This is affected when the first residue was indel (such as -5, or 5)
    #________________________________________________________________________
    if(abs($align_info[0])){  #<-- Yet another adjustment
        $align_info[0]= ($align_info[0] + @seq1_start_final);
        for($i=0; $i< @seq1_start_final; $i++){
           push(@scores, -3);
        }
    }
    #print "\n@positions2\n";
    #print "\n@seq1_start_final\n@seq2_start_final\n@align_info\n";
    for($i=0; $i < @align_info; $i++){
       $align_info=$align_info[$i];
       if($align_info < 0){
           $align_info=abs($align_info);
           $last_residue_posi_1=$i+$align_info-1;
           push(@seq2_aligned, split(//, "."x$align_info));
           push(@seq1_aligned, @residues1[$i .. $last_residue_posi_1]);
           for(1..$align_info){  push(@scores, $min_score);  }
       }elsif($align_info > 0){
           $last_residue_posi_2=$i+$align_info-1;
           push(@seq1_aligned, split(//, "."x$align_info));
           push(@seq2_aligned, @residues2[$i .. $last_residue_posi_2]);
           for(1..$align_info){  push(@scores, $min_score); }
       }elsif($align_info == 0){
           $posi1=shift(@positions1);
           $posi2=shift(@positions2);
           #print "\n$posi1";
           $score=$align_position_seq1_seq2{$seq_name2}{$posi2};
           push(@scores, $score);
           if($score < $min_score){ $min_score=$score }
           push(@seq1_aligned, $residues1[$posi1-1]);
           push(@seq2_aligned, $residues2[$posi2-1]);
           $last_residue_posi_1=$posi1-1;
           $last_residue_posi_2=$posi2-1;
           #print "\t $residues1[$posi1-1] $last_residue_posi_1 $last_residue_posi_2";
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Get mutual seq. identity of aligned region
           #_________________________________________________________
           if($residues1[$last_residue_posi_1] eq $residues2[$last_residue_posi_2]){
               $Mutual_Seq_Id++;
           }else{
               $non_idential++;
           }

       }
    }
    $ALIGNMENT_LENG       =$Mutual_Seq_Id + $non_idential;
    if($ALIGNMENT_LENG < 1){ $Mutual_Seq_Id_aligned=0.000;
    }else{ $Mutual_Seq_Id_aligned=$Mutual_Seq_Id/$ALIGNMENT_LENG; }

    $Mutual_Seq_Id_aligned  = sprintf("%-.3f", $Mutual_Seq_Id_aligned);
    unshift(@seq1_aligned, @seq1_start_final) if @seq1_start_final;
    unshift(@seq2_aligned, @seq2_start_final) if @seq2_start_final;
    @scores=(@scores_gap, @{&normalize_numbers_in_array(\@scores, '-3 5')});
    #print "SEQ1\n", @seq1_aligned, "\nSEQ2\n", @seq2_aligned, "\nSCO\n", @scores, "\n\n";
    $herta_align_score  = sprintf("%-.4f", $herta_align_score);
    @herta_align_score=($herta_align_score);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # handlign residues suffices
    #_________________________________________________________________
    $last_residue_posi_1++;  ## need to increment by 1 as I want SUFFIX, not the last residue
    $last_residue_posi_2++;
    @residues1_suffix=@residues1[$last_residue_posi_1 .. $#residues1];
    @residues2_suffix=@residues2[$last_residue_posi_2 .. $#residues2];

    push(@scores, split(//, "."x(@residues1_suffix + @residues2_suffix)) );
    if(@residues1_suffix > @residues2_suffix){
         $residues1_arr_size=@residues1_suffix;
         unshift(@residues1_suffix, split(//, "."x@residues2_suffix));
         push(@residues2_suffix, split(//, "."x$residues1_arr_size));
    }else{
         $residues2_arr_size=@residues2_suffix;
         unshift(@residues2_suffix, split(//, "."x@residues1_suffix));
         push(@residues1_suffix, split(//, "."x$residues2_arr_size));
    }
    $suffix_size_diff=abs(@residues1_suffix-@residues2_suffix);

    @complete_seq1_aligned=(@seq1_aligned, @residues1_suffix);
    @complete_seq2_aligned=(@seq2_aligned, @residues2_suffix);
    if($query_seq eq $DB_seq){ $DB_seq='SELF'; }
    %MRC_search_alignment=("$query_seq", [@complete_seq1_aligned],
                              "$DB_seq", [@complete_seq2_aligned],
                      'RAW_ALIGN_SCORE', [@scores],
                      'SUM_HERTA_SCORE', \@herta_align_score,
                      'SEQ_IDENTITY'   , \$Mutual_Seq_Id_aligned,
                      'ALIGNMENT_LENG' , \$ALIGNMENT_LENG);

    unless($NO_screen_print){
       print "\n# Seqlet Matrix Profile search result. Using Forward-Backward Herta algorithm\n";
       print "# SEQ1: $query_seq ($seq1_len), SEQ2: $DB_seq($seq2_len)\n";
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # returning ForBack score, forward score, backward score
    #________________________________________________________________
    return(\%MRC_search_alignment);

}



#______________________________________________________________
# Title     : convert_mspa_line_to_mmp_line
# Usage     :
# Function  : this adds ranges to the seqnames of mspa files
#             mmp line is mspa line with additional sequences at the end
# Example   :
# Keywords  : convert_mspa_to_mmp, convert_mspa, convert_mspa_2_mmp
#             change_mspa_to_mmp, add_range_in_mspa
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.5
#--------------------------------------------------------------
sub convert_mspa_line_to_mmp_line{
	 my $input_mspa=${$_[0]} || $_[0];
	 my($score, $evalue, $long_1, $new_seq1, $new_seq2, $middle,
	  $start1, $end1, $start2, $end2, $seq1, $seq2, $new);

	 if($input_mspa=~/^\s*(\d+)\s+(\S+)\s*\S*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
	  ($score, $evalue, $start1, $end1, $start2, $end2)=($1, $2, $3, $4, $6, $7);
	  ($seq1, $seq2)=($5, $8);
	  if($seq1=~/(\S+)\_\d+\-\d+/){
		 $new_seq1="$1\_$start1\-$end1";
	  }else{
		 $new_seq1="$seq1\_$start1\-$end1";
	  }
	  if($seq2=~/(\S+)\_\d+\-\d+/){
		 $new_seq2="$1\_$start2\-$end2";
	  }else{
		 $new_seq2="$seq2\_$start2\-$end2";
	  }
	  $new=sprintf("%-6s %-9s %-5s %-5s %-32s %-5s %-5s %-32s",
			$score, $evalue, $start1, $end1, $new_seq1, $start2, $end2, $new_seq2);
	 }
	 return(\$new);
}



#______________________________________________________________________________
# Title     : combine_forward_backward_sec_str_prediction
# Usage     :%av_of_forw_backw_pred=%{&combine_forward_backward_sec_str_prediction(
#                                  \$output_pred_file_name, \$output_pred_file_name_rv)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub combine_forward_backward_sec_str_prediction{
		my($input_predator_file_name, $reverse_order_of_one_hash,
			 $input_predator_file_name_rv, $ignore_non_matching_residues,
			 $ignore_non_matching_residues);
		if(ref($_[0]) eq 'SCALAR'){ $input_predator_file_name=${$_[0]};
		}else{    $input_predator_file_name=$_[0]; }
		if(ref($_[1]) eq 'SCALAR'){ $input_predator_file_name_rv=${$_[1]};
		}else{    $input_predator_file_name=$_[1]; }
		if($_[2]=~/i/){    $ignore_non_matching_residues='i' }
		$reverse_order_of_one_hash='r';
		my $input_predator_file_name_rv=$_[1] or $_[1];
		print "\n# (i) $input_predator_file_name \n";
		my %sec1=%{&open_predator_files($input_predator_file_name)};
		my %sec1_rv=%{&open_predator_files($input_predator_file_name_rv)};
		my %av_of_forw_backw_pred=%{&get_averaged_prediction(\%sec1, \%sec1_rv,
							 "w=$weight_factor",
							 $give_weight_with_good_match,
							 "$reverse_order_of_one_hash")};
		return(\%av_of_forw_backw_pred);
}



#________________________________________________________________________________
# Title     : merge_sequence_alignments
# Usage     : &merge_sequence_alignments(@seq);  while @seq has
#              @seq=(\%hash1, \%hash2);  while %hash1 and %hash2 have
#    %hash1=qw(seq1 ANN-NTMQQRRQQQRKRRRQQQSSSSTTST seq2 --NNN--QQ--QQQ--RRRR--SSSS--);
#    %hash2=qw(seq2 NN-QQQQQ--RRRR----SS--SS---    seq3 -NNXQQQXQRTRRRXTTSTSSMMSSTTT);
#
# Function  :
# Example   :
# Keywords  : combine_sequence_alignment, merge_sequence_alignment_pairs
#             merge_seq_alignment, make_interm_alignment, make_3_way_alignment
#             merge_alignment, combine_alignment
# Options   :
#    l=  for sequence block length by print_seq_in_block subroutine
#    t=  for specifying the length of seq names shown.
#    t   for truncating the seq names in printing out.
#    s   for sorting the final output lines (default anyway for print_seq_in_block)
#
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------------------
sub merge_sequence_alignments{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my (@splited1_common, @splited2_common, @splited1_non_common, @splited2_non_common,
			 @gap_pos1, @gap_pos2, $block_length, $sort_seq_names,
			 $truncate_name_to_10_char, $trunc_name_to, $block_range,
			 $common_seq_entry, $non_common_seq_entry1, $non_common_seq_entry2,
			 %temp1, %temp2, %out_hash_issa, @homology_line2, @homology_line1,
			 @temp );
		$block_length=60;
		$sort_seq_names='s'; ## this is for &print_seq_in_block

		if($vars{'l'}=~/\d+/){  $block_length=$vars{'l'}; }
		if($char_opt=~/t/){    $truncate_name_to_10_char='t' }
		if($vars{'t'}=~/\d+/){ $trunc_name_to=$vars{'t'}; }
		if($char_opt=~/s/){    $sort_seq_names='s' }
		if($vars{'r'}=~/(\d+\-\d+)/){ $block_range= $1 };

		for($i=0; $i< @hash; $i+=2){
				 my(%hash1, %hash2, @aligned_alignments);

 		     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     # Running the MAIN intermediate alignments
		     #__________________________________________________________________________

				 @aligned_alignments=@{&align_intermediate_alignments($hash[$i], $hash[$i+1])};

				 %hash1=%{$aligned_alignments[0]};
				 %hash2=%{$aligned_alignments[1]};

				 $common_seq_entry     =${$aligned_alignments[2]};
				 $non_common_seq_entry1=${$aligned_alignments[3]};
				 $non_common_seq_entry2=${$aligned_alignments[4]};

				 #~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # Aligning the start of common sequences
				 #  i.e. putting pre gap part to a sequence which does not have it.
				 #
				 #  NKNWKLRAHLC-KHTGEKP---FPCKEEGCDKGFTSLHHLTRHS---ITHTGEKN--FKCDSDKCDLTFTTKANMKKHFNRFH splited1_common
				 #  --------------NKNWKLRAHLCKHTGEKPFPCKEEGCDKGFTSLHHLTRHSITHTGEKNFKCDSDKCDLTFTTKANMKKHFNRFH-- splited2_common
				 #  becomes->
				 #
				 #  --------------NKNWKLRAHLC-KHTGEKP---FPCKEEGCDKGFTSLHHLTRHS---ITHTGEKN--FKCDSDKCDLTFTTKANMKKHFNRFH splited1_common
				 #  --------------NKNWKLRAHLCKHTGEKPFPCKEEGCDKGFTSLHHLTRHSITHTGEKNFKCDSDKCDLTFTTKANMKKHFNRFH-- splited2_common
				 #_______________________________________________________________________________________________________________

				 #@gap_pos1=@{&get_gap_positions(\$hash1{$common_seq_entry}, 'p' )}; # p means all positive positions wanted
				 #@gap_pos2=@{&get_gap_positions(\$hash2{$common_seq_entry}, 'p' )};

				 @splited1_common    =split(//, $hash1{$common_seq_entry} );
				 @splited2_common    =split(//, $hash2{$common_seq_entry} );
				 if( $hash1{$non_common_seq_entry1} ){
						@splited1_non_common=split(//, $hash1{$non_common_seq_entry1} );
						@splited2_non_common=split(//, $hash2{$non_common_seq_entry2} );
				 }else{
						@splited1_non_common=split(//, $hash2{$non_common_seq_entry1} );
						@splited2_non_common=split(//, $hash1{$non_common_seq_entry2} );
						@temp=@splited1_common; @splited1_common=@splited2_common; @splited2_common=@temp;
				 }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 #  Core algorithm (For MSF files)
				 #__________________________________________
				 for($j=0; $j< @splited1_common; $j++){
						 if($splited1_common[$j] ne $splited2_common[$j]){
								 if($splited1_common[$j]=~/(\W)/){
										 splice(@splited2_common, $j, 0, $1);
										 splice(@splited2_non_common, $j, 0, $1); # unless($splited2_non_common[j]=~/\W/);
								 }
								 elsif($splited2_common[$j]=~/(\W)/){
										 splice(@splited1_common, $j, 0, $1);
										 splice(@splited1_non_common, $j, 0, $1);# unless($splited1_non_common[j]=~/\W/);
										 if($splited1_common[$j] eq $splited1_non_common[$j]){
												 $homology_line2[$j]=':';
										 }else{
												 $homology_line2[$j]=' ';
										 }
								 }
						 }
				 }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # Making Homology line
				 #_____________________________________________
				 for($j=0; $j< @splited1_non_common; $j++){
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# The first SEQ1  with Interm HOMOLOGY
							#______________________________________________________________
							if($splited1_non_common[$j]=~/\W/){ $homology_line1[$j]=' '; goto HOMOL_2 }

							if($splited1_non_common[$j] eq $splited1_common[$j] and $splited1_non_common[$j] eq $splited2_non_common[$j] ){
									$homology_line1[$j]= $splited1_non_common[$j];
							}elsif($splited1_non_common[$j] eq $splited1_common[$j] ){
									$homology_line1[$j]=$splited1_non_common[$j] ;
							}elsif($splited2_non_common[$j] eq $splited1_non_common[$j]){
									if($splited2_non_common[$j]=~/\W/){ $homology_line1[$j]=' '
							    }else{  $homology_line1[$j]=':' }
							}elsif( ${&amino_acid_homology_matrix($splited2_non_common[$j], $splited1_non_common[$j])} ){
									$homology_line1[$j]='.';
							}
							else{ $homology_line1[$j]=' '; }

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# The Second SEQ2  with Interm HOMOLOGY
							#______________________________________________________________
							HOMOL_2:
							if($splited2_non_common[$j]=~/\W/){ $homology_line2[$j]=' '; next }

							if($splited2_non_common[$j] eq $splited2_common[$j] and $splited2_non_common[$j] eq $splited1_non_common[$j] ){
									$homology_line2[$j]=$splited2_non_common[$j] ;
							}elsif($splited2_non_common[$j] eq $splited2_common[$j]){
									$homology_line2[$j]=$splited2_non_common[$j] ;
							}elsif($splited2_non_common[$j] eq $splited1_non_common[$j]){
									if($splited2_non_common[$j]=~/\W/){ $homology_line2[$j]=' ';
									}else{  $homology_line2[$j]=':'; }
							}elsif( ${&amino_acid_homology_matrix($splited2_non_common[$j], $splited1_non_common[$j])} ){
									$homology_line2[$j]='.';
							}else{ $homology_line2[$j]=' '; }

				 }
				 $out_hash_issa{"1 $non_common_seq_entry1 "}=join('', @splited1_non_common);
				 $out_hash_issa{"3 $common_seq_entry"}=join('', @splited2_common);
				 $out_hash_issa{'2 homol_line1'}=join('', @homology_line1);
				 $out_hash_issa{'4 homol_line2'}=join('', @homology_line2);
				 $out_hash_issa{"5 $non_common_seq_entry2"}=join('', @splited2_non_common);
				 &print_seq_in_block(\%out_hash_issa, $sort_seq_names,  "t=$trunc_name_to", "f=defaul_result\.issa",
															 $truncate_name_to_10_char, "l=$block_length", "r=$block_range");
		}
}


#________________________________________________________________________________________
# Title     : merge_sequence_in_mspa_file
# Usage     :
# Function  :
# Example   : INPUT: (MSPA file) ===>
#  59     2.6        47    64     d2pia_3        10    30     d1erd___10-30
#  161    1.1e-07    24    91     d2pia_3        16    85     d1frd___16-85
#
#  722    0          1     106    d1put__        1     106    d1put___1-106
#  66     4.9        2     68     d1put__        43    106    d2lbp___43-106
#  69     1.3        12    49     d1put__        81    120    d1cgo___81-120
#
#  60     3.3        13    38     d1frd__        32    57     d1orda1_32-57
#  65     1.7        21    58     d1frd__        40    69     d2mtac__40-69
#
#   ==== OUTPUT ===>
#    d1frd___1-98 d1frd___1-98_1-98 d1frd___16-85 d2pia_3_24-91_24-91
#    d1frd___16-85_16-85 d2pia_3_24-91
#    d1put___1-106 d1put___1-106_1-106
#    d2pia_3_1-98 d2pia_3_1-98_1-98
#
# Keywords  : mergr_seq_in_mspa_file, merge_sequence_in_mspa, merge_sequences_in_mspa_file
# Options   :
#  $dynamic_factor =  y by y -y   # adjusting factor value dynamically(more seq higher factor)
#  $short_region   =  S by S -S  # taking shorter region overlapped in removing similar regions
#  $large_region   =  L by L -L  # taking larger  region overlapped in removing similar regions
#  $average_region =  A by A -A # taking average region overlapped in removing similar regions
#
# Thanks    : Alexey Eroshkin <alexey@axyspharm.com>
# Version   : 3.5
#----------------------------------------------------------------------------------------
sub merge_sequence_in_mspa_file{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my ($mspa_value, @all_seqlets, %temp_hash, @mspa_chunks, $clu_out, $size_of_all_seqlets,
		    $ragne, $base, $optimize, $mrg_out, @arr, $sat_out, %final_hash_out, @final_pre_hash,
				$length_thresh, $merge, $factor, $Evalue_thresh, $score, $dynamic_factor, $score_match,
				$eval_match, $query_seq, $query_start, $query_stop, $match_seq, $match_start,
				$short_region, $large_region, $average_region, $original_clu_size, $match_stop,
				$total_mspa_line_count);
		$factor=$default_factor=7; #~~~~ default connection factor U, 7 means 70% now!
		$length_thresh=30;
		$Evalue_thresh=1;
		$score =75;
		$range='r';
		if(@file < 1){ print "\n# (E) merge_sequence_in_mspa_file needs at least 1 MSPA file\n"; die }

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Following changes the defaults with given parameters
		#_____________________________________________________________
		if($char_opt=~/z/i){       $optimize='z';    ## This will cause using remove_similar_seqlets than remove_dup_in_array !
		}if($char_opt=~/m/){       $merge='m';
		}if($char_opt=~/y/){       $dynamic_factor='y';
        }if($char_opt=~/r/){       $verbose='r';
        }if($char_opt=~/v/){       $verbose='v';
		}if($char_opt=~/S/){       $short_region='S';
		}if($char_opt=~/L/){       $large_region='L';
		}if($char_opt=~/A/){       $average_region='A';
		}if($vars{'T'}=~/\d+/){    $length_thresh=$vars{'T'};
		}if($vars{'f'}=~/\S+/){    $factor=$vars{'f'};  ## Here I give a generous $factor !
		}if($vars{'s'}=~/\d+/){    $score = $vars{'s'};
        }if($vars{'e'}=~/\S+/){    $Evalue_thresh= $vars{'e'};
        }if($vars{'E'}=~/\S+/){    $Evalue_thresh= $vars{'E'}; }

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  Just to inform what parameters have been chosen
		#_____________________________________________________________
        print "\n# (1) merge_sequence_in_mspa_file : default \$score      : $score";
        print "\n#                                 : default \$Evalue_thresh     : $Evalue_thresh";
        print "\n#                                 : used \$length_thresh : $length_thresh";
        print "\n#                                 : default \$factor     : $default_factor";
        print "\n#                                 : used    \$factor     : $factor";
        print "\n#                                 : \$dynamic_factor     : $dynamic_factor\n";

		for($c=0; $c< @file; $c++){
             open(MSPA, "$file[$c]") || die "Can not open $file[$c] \n";
			 $base=${&get_base_names($file[$c])};
			 $clu_out="$base\_F${factor}.clu"; # <-- This is the most important output. Sarah's program will process this
			 $sat_out="$base\_F${factor}.sat";
             my $total_mspa_lines=@mspa1=<MSPA>;
             print "\n $file[$c] is opened successfully \$total_mspa_lines : $total_mspa_lines\n";

			 for($i=0; $i< @mspa1; $i++){
					#~~~~~~~~~~ Include range or NOT in the seq name ~~~~~~~~~~~~~~~~~~~~~~~~~~`
					# %temp_hash is just to get the chunk of MSPA block. As mspa file uses empty line as a delimiter
					#____________________________________________________________________________
					if($char_opt=~/r/){
						 if($mspa1[$i]=~/^\s*(\S+)\s+(\S+)\s*\S*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
                              $total_mspa_line_count++;
									$score_match=$1;	$eval_match=$2;
                                    $query_seq=$5;      $query_start=$3;
									$query_stop=$4;		$match_seq=$8;
									$match_start=$6;	$match_stop=$7;
                                    if($score_match < $score or $eval_match > $Evalue_thresh){next};
									if($query_seq=~/\S+_\d+\-\d+$/){ $new_seq1=$query_seq }else{ $new_seq1="$query_seq\_$query_start\-$query_stop"; }
									if($match_seq=~/\S+_\d+\-\d+$/){ $new_seq2=$match_seq }else{ $new_seq2="$match_seq\_$match_start\-$match_stop"; }

									if($new_seq1 eq $new_seq2){ next};

									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# Modifying $mspa1[$i] line !!!
									#______________________________
									$mspa1[$i]=sprintf("%s %-3s %s %s %s %s %s %s",
													$score_match, $eval_match, $query_start,
													$query_stop, $new_seq1, $match_start,
													$match_stop, $new_seq2);
									$temp_hash{$query_seq}.="$mspa1[$i]\n";
						 }
					}else{
						 if($mspa1[$i]=~/^\s*(\S+)\s+(\S+)\s*\S*\s+\d+\s+\d+\s+(\S+)[_\d+\-\d+]?\s+\d+\s+\d+\s+\S+/){
									if($1 < $score or $2 > $Evalue_thresh){	next };
									$temp_hash{$3}.="$mspa1[$i]\n";
						 }
					}#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			}
            close(MSPA);
		}
        $original_clu_size=@mspa_chunks= values(%temp_hash); ## Using temp hash is more than 2 times faster than push

        print "\n The total seq to divclus is : $original_clu_size \$total_mspa_line_count: $total_mspa_line_count\n";
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Determining the dynamic factor here (when 'd' opt is set)
		#____________________________________________________________
		if($dynamic_factor){
				#--> 100 => 10, 1000 => 15, 10000 => 20
				print "\n# ### \$factor: $factor\n";
				$factor += (log($original_clu_size)*5)/10 - 1; ## This is a simplistic.
				if($factor > 9.5){ $factor=9.5 } # this is the very upper limit for any factor.
				print "\n# ### \$factor: $factor\n";
		}

		for($i=0; $i< @mspa_chunks; $i++){
            @arr=@{&merge_sequence_in_mspa_chunk($mspa_chunks[$i], $verbose, $optimize,
								"$merge", "E=$Evalue_thresh", "s=$score",
								"f=$factor", "T=$length_thresh",
								$short_region, $large_region, $average_region)};
			push(@all_seqlets,  @arr);
		}

		#~~~~~~~~~ sorting inner sequences in strings ~~~~~~~~~
		#______________________________________________________
		@all_seqlets=@{&sort_words_in_string(@all_seqlets)}; ## This speeds up about 2 times !!!

		#~~~~~~~ Sort by the _digit-  in seqlet names ~~~~~~~~~
		@all_seqlets= map{$_->[0]} sort{$a->[1] cmp $b->[1] or $a->[2] <=> $b->[2]  }
									map {/^\s*((\S+)_(\d+)\-(\d+).*)/ && [$1, $2, $3, $4]} @all_seqlets;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# merge sequences in a simple way until there is no change in the array
		#  This is an incomplete merge(merges first seqlets of string ...
		#______________________________________________________________________
		for($i=0; $i< @mspa_chunks; $i ++){
             ITERATION_RETURN_POINT:
             $size_of_all_seqlets=@all_seqlets;
             @all_seqlets = @{&merge_similar_seqlets(\@all_seqlets, $optimize,
                                                      $short_region, $large_region,
                                                      $average_region, "f=$factor")};
             if($size_of_all_seqlets > @all_seqlets){
                 @all_seqlets = @{&merge_similar_seqlets(\@all_seqlets, $optimize,
                                                $short_region, $large_region, $average_region, "f=$factor")};
                 print "\n $size_of_all_seqlets Iterating merge_similar_seqlets \n";
                 goto ITERATION_RETURN_POINT;
             }else{
                 last;
             }
		}

		if($optimize){
             @all_seqlets=@{&remove_similar_seqlets(\@all_seqlets,
                                             $short_region, $large_region, $average_region)};
             #@all_seqlets=@{&remove_dup_in_array(\@all_seqlets)};

		}else{
             @all_seqlets=@{&remove_dup_in_array(\@all_seqlets)};
		}
		return(\@all_seqlets);
}




#__________________________________________________________________________
# Title     : merge_sequence_in_mspa_chunk
# Usage     :
# Function  : merges sequences which are linked by common regions
#             This filters the sequences by evalue and ssearch score
#             This is the main algorithm of merging similar sequences.
#             MSPA lines become pairs of seq_regions
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : connect_sequence_in_mspa, link_sequence_in_mspa_chunk
#             connect_sequence_in_mspa_chunk, link_sequence_in_mspa
#             merge_sequence, link_sequence, connect_sequence
# Options   : _  for debugging.
#             #  for debugging.
#             m  for merge file output format (.mrg)
#             t= for threshold of seqlet length eg)  "t=30"
#             f= for overlap factor (usually between 2 to 7 )
#                 2 means, if the two regions are not overlapped
#                  by more than HALF of of the smaller region
#                  it will not regard as common seqlet block
#             s= for ssearch score minimum
#             e= for ssearch e value maximum
#             S  for S -S  # taking shorter region overlapped in removing similar regions
#             L  for L -L  # taking larger  region overlapped in removing similar regions
#             A  for A -A # taking average region overlapped in removing similar regions
#
# Returns   :
# Argument  :
# Thanks    : Alexey Eroshkin <alexey@axyspharm.com>
# Version   : 2.9
#--------------------------------------------------------------
sub merge_sequence_in_mspa_chunk{
	 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	 if($debug==1){print "\n\t\@hash=\"@hash\"
	 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my ($ssearch_score2, $evalue_found2, $evalue_found1, $ssearch_score1, $optimize );
	 my ($L, %out_hash, @out, $LL, @Final_out, $verbose, $final_factor, $R_diff, @seqlets,
			 $short_region, $large_region, $average_region, $factor, $score, $evalue, $length_thresh);
	 $factor =7; # default factor for around 30% sequence mis-overlap is the threshold for common block
	 #~~~~~~~~~~~~~~ The lower the factor the larger clustering will occur ~~~~~~~~~~~~
	 $score  =75; # default ssearch score. seq below this will be chucked out
	 $evalue =10; # default maximum e value used. Seq higher than this will be thrown out
	 $length_thresh =30; # sequence length threshold. overlap less than this will be ignored

	 if($char_opt=~/v/){     $verbose = 'v'
	 }if($char_opt=~/z/){    $optimize = 'z'
	 }if($char_opt=~/S/){    $short_region='S';
	 }if($char_opt=~/L/){	   $large_region='L';
	 }if($char_opt=~/A/){	   $average_region='A'; }

	 if($vars{'T'}=~/\d+/){   $length_thresh=$vars{'T'};
	 }if($vars{'f'}=~/\S+/){  $factor=$vars{'f'};
	 }if($vars{'s'}=~/\d+/){  $score = $vars{'s'};
     }if($vars{'e'}=~/\d+/){  $evalue= $vars{'e'};
     }if($vars{'E'}=~/\d+/){  $evalue= $vars{'E'};
	 }

     @seqlets=split(/\n+/, (${$_[0]} || $_[0]) );

	 F1: for($i=0; $i < @seqlets; $i ++){
			if($seqlets[$i]=~/^\s*((\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+))\s+(\S+)\s*(.*)/){
		     if($6 eq $9){ splice(@seqlets, $i, 1); $i--; next };
				 ($long_match1, $enq_seq1, $mat_seq1, $R_start1, $R_end1 )=($1, $6, $9, $4, $5);
                 $Region_leng1=$R_end1-$R_start1;  $ssearch_score1= $2;  $evalue_found1 = $3;
	       }
	       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	       # Following lines are disabled as I believe seqlets have been checked in previous sub
		   #________________________________________________________________________________________________
	       if( ($Region_leng1 < $length_thresh) || ($ssearch_score1 < $score) ){ splice(@seqlets, $i, 1); $i--; next; }
	       if( $evalue_found1 > $evalue){ splice(@seqlets, $i, 1); $i--; next; }

		   F2: for($j=0; $j < @seqlets; $j ++){
		     if($seqlets[$i] eq $seqlets[$j]){ next };
		     if($seqlets[$j]=~/^\s*((\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+))\s+(\S+)\s*(.*)/){
			      ($long_match2, $enq_seq2, $mat_seq2, $R_start2, $R_end2)=($1, $6, $9, $4, $5);
			      $Region_leng2=$R_end2-$R_start2;	$ssearch_score2=$2;	$evalue_found2= $3;
	         }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # Following lines are disabled as I believe seqlets have been checked in previous sub
			 #________________________________________________________________________________________________
		     #if( ($Region_leng2 < $length_thresh)||($ssearch_score2 < $score) ){ splice(@seqlets, $j, 1); $j--; next; }
		     #if( $evalue_found2 > $evalue){ splice(@seqlets, $j, 1); $j--; next; }

             $R_diff=abs($Region_leng1-$Region_leng2);   ## <<<---- Note it is div by 2

		     if($Region_leng2 < $Region_leng1){ $smaller_leng=$Region_leng2; }else{ $smaller_leng=$Region_leng1; }

             $Start_diff=abs($R_start1-$R_start2); ## <<<---- Note it is div by 2
             $final_factor=$smaller_leng - $smaller_leng*($factor/10);

			 #~~~~~~~~~~ If average R_diff and average Start_diff are less then 1/7 of the smaller seqlet
			 #~~~~~~~~~~ we regard they are same selqets
             if( $R_diff <= $final_factor ){  ### if diff is less than around 30% of the smaller length
					  if($Region_leng2 >= $Region_leng1){
							 #~~~~~ $mat_seq1 or $mat_seq2 can increase to 'slr1453,sll0238', so you need ',' in the middle only
                             $extended_name="$mat_seq2|-|$mat_seq1";
							 $L=length($extended_name);
							 $LL=length($long_match2)+2;
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # This makes "368   2.3e-06  0.352  4    189   af_AF2051  20   208   hi_HI1334,hi_34343"
							 #_________________________________________________________________________________________
							 $seqlets[$i]= sprintf("%-${LL}s %-${L}s", $long_match2, $extended_name);
							 splice(@seqlets, $j, 1);
							 $i-- unless($i==0);
							 $j--;
							 next F1;
					  }elsif( $Region_leng1 >= $Region_leng2){  ## chooses the bigger range seq
							 $extended_name="$mat_seq1|-|$mat_seq2"; # must be ',' not ' '
							 $L=length($extended_name);
							 $LL=length($long_match1)+2;
							 $seqlets[$i]=sprintf("%-${LL}s %-${L}s", $long_match1, $extended_name);
							 splice(@seqlets, $j, 1);
							 $i-- unless($i <= 0);
							 $j--;
							 next F1;
					  }
	       }else{
			      next F2;
		   }
	    }
	 }
	 #print "\n @seqlets \n";
	 if($char_opt=~/m/){ # #             m  for merge file output format (.mrg)
            for($i=0; $i< @seqlets; $i++){
				 if($seqlets[$i]=~/^\s*\S+\s+\S+\s+\d+\s+\d+\s+(\S+)\s+\d+\s+\d+\s+(\S+)/){
						if($1 eq $2){ next }
						$leading_seq=$1; $long=$2; $long=~s/\|\-\|/ /g;
						push(@Final_out, "$leading_seq $long" );
				 }
			}
	 }
	 @Final_out=sort @Final_out;
     #print "\n========># \@Final_out: @Final_out ";
	 return(\@Final_out);
}




#______________________________________________________________
# Title     : get_overlapping_range
# Usage     : @n1=@{&get_overlapping_range(\@ranges1, \@ranges2)};
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : get_overlapping_range_in_mspa, get_overlapping_range_in_mspa_file,
#             get_overlapping_seq_match_range, get_overlap_seq_match_range
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub get_overlapping_range{
	 my (@new_range, $R_start1, $R_start2);
	 ($R_start1, $R_end1)=@{$_[0]}[0..1];
	 ($R_start2, $R_end2)=@{$_[1]}[0..1];

	 if(($R_start1 <= $R_start2)&&        # ------------
	 ( $R_end1 >= $R_end2) ){           #   -------
	   @new_range= ($R_start2, $R_end2);
	 }elsif(($R_start1 <= $R_start2)&&    # -----------
	 ( $R_end1 <= $R_end2) &&           #    -----------
	 ( $R_end1 >  $R_start2) ){
	   @new_range= ($R_start2, $R_end1);
	 }elsif(($R_start1 >= $R_start2)&&    #    -----------
	 ( $R_end1 >= $R_end2  ) &&         # -----------
	 ( $R_end2 >  $R_start1) ){
	   @new_range= ($R_start1, $R_end2);
	 }elsif(($R_start1 >= $R_start2)&&    #   ------
	 ( $R_end1 <= $R_end2) ){           # -----------
	   @new_range= ($R_start1, $R_end1);
	 }else{                                #  ----
	  @new_range=(0,0);                  #        --------
	 }
	 return(\@new_range);
}


#______________________________________________________________________________
# Title     : find_small_files
# Usage     : @files_found_to_be_small=@{&find_small_files(@ARGV)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub find_small_files{
    my($file_size_cut_line, $size, @files_removed, $i, @files);
     $file_size_cut_line=$_[0];
     $file_size_cut_line_bigger_than=$ARGV[1];

     @files=@{&read_file_names_only('.')};

     for($i=0; $i< @files; $i++){
         $size= -s $files[$i];
         if($size <= $file_size_cut_line and $size >= $file_size_cut_line_bigger_than){
             push(@files_removed, $files[$i]);
             print "\n# (i) $files[$i] is smaller than $file_size_cut_line, size= $size byte";
         }
     }
     return(\@files_removed);
}

#______________________________________________________________________________
# Title     : find_missing_files_of_certain_extension
# Usage     : @files=@{&find_missing_files_of_certain_extension(".", "e=fa,mspa,pbla.gz")};
#
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub find_missing_files_of_certain_extension{
	my($in_dir, $i, $j, $x, $k, $dir, @final_files, @possible_dirs, $sort_opt, $ext, @extensions,
		 $path_include, @in, $glob_given, @files_globed, @in_dir, $pwd, $extension_given,
		 %target_file_names, @target_file_names, @read_files, %ext_hash, $input_dir,
		 %found_files, %missing_files, @files_created);
	$pwd=`pwd`; chomp($pwd);
	$in_dir=$pwd;
	@in=@_;

    $input_dir=${$_[0]} || $_[0];
    push(@in_dir, $input_dir);
    $extensions=${$_[1]} || $_[1];
    if($extensions=~/e=(\S+[\, ]\S+)/){ push( @extensions, split(/\,/, $1) );
    }elsif($extensions=~/e=(\S+)/){ push(@extensions, $extensions) }
    print "\@extensions :  @extensions\n";

    for $ext(@extensions){ $extensions{$ext}=$ext }

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Main READING PART. I have @in_dir and @extensions now
	#_________________________________________________________________
    for($k=0; $k< @in_dir; $k++){
		 chdir($in_dir[$k]) or die "\n# read_file_names_only: could not get into $in_dir[$k]\n";
	     opendir(DIR1, ".");
		 @read_files = readdir(DIR1);
	     if(@read_files < 1){ print "\n# read_file_names_only: ERROR??, \@read_files is empty\n\n\n"; }
	     for($i=0; $i < @read_files; $i ++){
              if( $read_files[$i] =~ /^([^\.]+)\.(\S+)$/){
                  $base=$1;
                  $ext=$2;
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # There must be at least one matching extension for one base name
                  #___________________________________________________________________
                  unless($extensions{$ext}){ print "\n Excluded : $base"; next
                  }else{
                      for($j=0; $j< @extensions; $j++){
                          $target_file="$base\.$extensions[$j]";
                          if(-s "$target_file"){
                             push(@{$found_files{$extensions[$j]}}, $base);
                          }else{
                             push(@{$missing_files{$extensions[$j]}}, $base);
                          }
                      }
                  }
              }
	     }
	     chdir($pwd);
   }

   for($i=0; $i< @extensions; $i++){
      $missing_file_list_file="missing_$extensions[$i]\_files\.list";
      $found_file_list_file="found_$extensions[$i]\_files\.list";
      push(@files_created, $missing_file_list_file, $found_file_list_file);
      open(MISS_LIST, ">$missing_file_list_file") || die "\n Can not create $missing_file_list_file \n";
      open(FOUND_LIST, ">$found_file_list_file") || die "\n Can not create $found_file_list_file \n";
      @missing_files=@{$missing_files{$extensions[$i]}};
      @found_files  =@{$found_files{$extensions[$i]}};
      for($j=0; $j<@missing_files; $j++){
         print MISS_LIST "$missing_files[$j]\n";
      }
      for($j=0; $j<@found_files; $j++){
         print  FOUND_LIST "$found_files[$j]\n";
      }
      close(MISS_LIST);
      close(FOUND_LIST);
   }
   print "\n @files_created are created \n\n";
   return(\@files_created);
}



#______________________________________________________________________________
# Title     : find_missing_mspa_files_for_pbla_gz
# Usage     :
#             @files=@{&find_missing_mspa_files_for_pbla_gz("e=$input_extensions")};
#             @files=@{&find_missing_mspa_files_for_pbla_gz(\@input_extensions)};
#
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub find_missing_mspa_files_for_pbla_gz{
	my($in_dir, $i, $j, $x, $k, $dir, @final_files, @possible_dirs, $sort_opt, $ext, @extensions,
		 $path_include, @in, $glob_given, @files_globed, @in_dir, $pwd, $extension_given,
		 %target_file_names, @target_file_names, @read_files, %ext_hash);
	$pwd=`pwd`; chomp($pwd);
	$in_dir=$pwd;
	@in=@_;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Directory entry and opts detection
	#_________________________________________
	for($k=0; $k < @in; $k++){
 	    if   ( $in[$k] eq '.'){ push(@in_dir,$pwd); splice(@in, $k, 1);  $k--; next }
		if( !(ref($in[$k]))){
	        print "\n# read_file_names_only: $in[$k] is not a reference";
			if($in[$k]=~/D=(\S+)/i){
					print "\n# read_file_names_only : $1 is used as input dir ";
					push(@in_dir, $1); splice(@in, $k, 1);    $k--; next;  }
			if( -d "$in[$k]" ){
				print "\n# read_file_names_only: $in[$k] is a dir";
				if($in[$k]=~/\/\S+$/){
							$path_include=1;  ## If the input dir has '/', I assume path should be added to out file names
							print "\n# read_file_names_only: \$path_include is set to 1";
			    }
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# Removes the last slash '/' of input dir name
			#________________________________________________
			if($in[$k]=~/\/$/){   chop($in[$k]);  }
						push(@in_dir, $in[$k]);
						splice(@in, $k, 1);    $k--; next;
		}
		if(!(-f $in[$k]) and $in[$k] =~ /^\-p *$/ ){ ## somehow, ' *' is essential
			$path_include=1;
			splice(@in, $k, 1); $k--;
								}elsif(!(-f $in[$k]) and $in[$k] =~ /^\-s *$/   ){$sort_opt=1; splice(@in, $k, 1); $k--;
								}else{
										 print "\n# (W) read_file_names_only: $in[$k] not a file, nor dir, a file extnsion?\n";
								}
	 }elsif(ref($in[$k])){
				if(ref($in[$k]) eq 'SCALAR'){
					 if( -d ${$in[$k]}){
							 if(${$in[$k]}=~/\/$/){ chop(${$in[$k]}) }
							 push(@in_dir,${$in[$k]});
							 splice(@in, $k, 1);
							 $k--;
					 }elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-p$/ ){$path_include=1; splice(@in, $k, 1); $k--;
					 }elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-s$/ ){$sort_opt=1; splice(@in, $k, 1); $k--;}
				}elsif(ref($in[$k]) eq 'ARRAY'){
					 @target_file_names=@{$in[$k]}; splice(@in, $k, 1); $k--;
					 for($x=0; $x < @target_file_names; $x++){  # making a hash out of @array
							 $target_file_names{$target_file_names[$x]}=$target_file_names[$x];
					 }
				}
	 }
	}
	if(@in_dir < 1){ push(@in_dir, $pwd) }

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Main READING PART. I have @in_dir and @extensions now
	#_________________________________________________________________

	for($k=0; $k< @in_dir; $k++){
		 chdir($in_dir[$k]) or die "\n# read_file_names_only: could not get into $in_dir[$k]\n";
	     opendir(DIR1, ".");
		 @read_files = readdir(DIR1);
	     print "\n# read_file_names_only: content of \@read_files in $in_dir[$k] : @read_files\n" if $verbose;
	     if(@read_files < 1){ print "\n# read_file_names_only: ERROR??, \@read_files is empty\n\n\n"; }
	     for($i=0; $i < @read_files; $i ++){
               if( -f "$read_files[$i]" ){
                   if( $read_files[$i] =~ /(\S+)\.pbla\.gz$/){
                       if(-s "$1\.mspa"){
                       }else{
                            push(@final_files, "$read_files[$i]" );
                       }
                   }
               }

	     }
	     chdir($pwd);
   }
   @final_files=sort @final_files if $sort_opt == 1;
   return(\@final_files);
}



#______________________________________________________________________________
# Title     : find_fssp_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub find_fssp_DALI {
        local($string)=@_;

        $hit=0;
        $heading=`grep PDBid $TABLE2`;
        if($string) { &grep_string_in_PDB_file($string, $hit); }
        print "<HR>\n";
        if($hit>=0) {print "Click on a hyperlink to view the structural alignments.\n";}
        else {
print<<"EOT";
No matches were found in the simple search.
EOT
        }
}



#______________________________________________________________________________
# Title     : find_boundaries_in_arrays
# Usage     :
# Function  :
# Example   :
# Keywords  : convert_array_to_ranges, translate_array_to_ranges
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub find_boundaries_in_arrays{
    my($i, @array_with_numbers, @boundaris_as_ranges, $range_start);
    @array_with_numbers=@{$_[0]};
    $range_start=$array_with_numbers[$i];
    push(@boundaris_as_ranges, $range_start);
    for($i=0; $i< @array_with_numbers; $i++){
       if($array_with_numbers[$i] + 1 != $array_with_numbers[$i+1]){
           push(@boundaris_as_ranges, $array_with_numbers[$i], $array_with_numbers[$i+1]);
       }

    }
    if(!$boundaris_as_ranges[$#boundaris_as_ranges]){ pop(@boundaris_as_ranges) }
    return(\@boundaris_as_ranges);
}



#______________________________________________________________________________
# Title     : find_common_seq_names
# Usage     :($INT_sq1, $INT_sq2, $sq1, $sq2)=@{&find_common_seq_names(\@seq_names)};
# Function  : returns the common sequence names(usually Intermediates in search)
#             The sequence names can be XXXX or XXXX_30-66
#             Accepts 4 strings in an array.
# Example   :
# Keywords  : get_common_seq_names, get_identical_seq_names,
#             get_2_most_similar_strings_in_array
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub find_common_seq_names{
		my @seq_names=sort @{$_[0]};
		my ($i, $previous_seq_name, @seq_names_out, $previous_seq_name_orig,
		    $highest_iden, @name_chars2, @name_chars1);
		for($i=0; $i< @seq_names; $i++){
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If seq names have RANGE information XXX_10-30
			 #______________________________________________
			 if($seq_names[$i]=~/(\S+)_(\d+)\-\d+/){
					if($1 eq $previous_seq_name){
					    if($i == 1){
					       if($previous_seq_name_start > $2){
										 @seq_names_out=($seq_names[$i], $previous_seq_name_orig, $seq_names[$i+1], $seq_names[$i+2]);
					       }else{
										 @seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i+1], $seq_names[$i+2]);
								 }
							}elsif($i > 1){
								 @seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i-2], $seq_names[$i+1]);
							}
					}
					$previous_seq_name=$1;
					$previous_seq_name_start=$2;
					$previous_seq_name_orig=$seq_names[$i];
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If seq names DO NOT have range info  XXXXXX
			 #______________________________________________
			 }elsif($seq_names[$i] eq $seq_names[$i+1]){
					if($i == 0){
							@seq_names_out=($seq_names[$i], $seq_names[$i+1], $seq_names[$i-1], $seq_names[$i+2]);
					}elsif($i == 1){
							@seq_names_out=($seq_names[$i], $seq_names[$i+1], $seq_names[$i-2], $seq_names[$i-1]);
					}elsif($i == 2){
							@seq_names_out=($seq_names[$i], $seq_names[$i+1], $seq_names[$i-3], $seq_names[$i-2]);
					}
					return(\@seq_names_out)
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # If seq names DO NOT have range info and there is not identical seq pairs
			 #__________________________________________________________________________________
			 }else{
			    my ($counter, $j, $non_char_count);
					$counter=1;
					@name_chars1=split(//, $previous_seq_name);
					@name_chars2=split(//, $seq_names[$i]);
					for($j=0; $j < @name_chars1; $j++){
							if($name_chars1[$j] eq $name_chars2[$j]){
									$counter++;
									if($counter > $highest_iden){
											$highest_iden=$counter;
											if($i == 1){
													@seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i+1], $seq_names[$i+2]);
											}elsif($i == 2){
													@seq_names_out=($previous_seq_name_orig, $seq_names[$i], $seq_names[$i-2], $seq_names[$i+1]);
											}elsif($i == 3){
													@seq_names_out=($seq_names[$i-1], $seq_names[$i], $seq_names[$i-3], $seq_names[$i-2]);
													return(\@seq_names_out);
											}
									}
							}else{ ## When there is non-identical char comes, skip it.
									#$non_char_count++;
									next;
							}
					}
					$previous_seq_name=$seq_names[$i];
					$previous_seq_name_orig=$seq_names[$i];
			 }
		}
		return(\@seq_names_out);
}



#______________________________________________________________________________
# Title     : find_source_perl_library
# Usage     : $source_library=${&find_source_perl_library};
# Function  : gets the default perl sub source library from ENV setenv
# Example   :
# Keywords  :
# Options   :
# Author    : jong@ebi.ac.uk
# Version   : 1.2
#------------------------------------------------------------------------------
sub find_source_perl_library{
     my($source_library);
     print "\n# $0: You did not use \"s=\" option for \$source_library\n";
     print "\n#     I am trying to retrieve your default source lib. \n";

     if( defined( $ENV{'MY_PERL_LIB'} ) ){
            $source_library=$ENV{'MY_PERL_LIB'};
     }elsif( defined( $ENV{'BIO_PERL'} ) ){
            $bioperl_lib=$ENV{'BIO_PERL'};
     }elsif(-e "/Bio/Perl/Bioinf.pl"){
            $source_library="/Bio/Perl/Bioinf.pl";
     }elsif(-e "/perl/Bioinf.pl"){
            $source_library="/perl/Bioinf.pl";
     }elsif(-e "$ENV{HOME}\/Perl/Bioinf.pl"){
            $source_library="$ENV{HOME}\/Perl/Bioinf.pl";
     }elsif(-e "/gn0/jong/Perl/B.pl"){
            $source_library="/gn0/jong/Perl/B.pl";
     }elsif(-e "/home/jong/Perl/B.pl"){
            $source_library="/home/jong/Perl/B.pl";
     }elsif(-e "/Perl/Bioinf.pl"){
            $source_library="/Perl/Bioinf.pl";
     }elsif(-e "/Perl/B.pl"){
            $source_library="/Perl/B.pl";
     }elsif(-e "B.pl"){
            $source_library="B.pl";
     }elsif(-e "/usr/Perl/B.pl"){
            $source_library="/usr/Perl/B.pl";
     }elsif(-e "/ss0/sat/Script/B.pl"){
            $source_library="/ss0/sat/Script/B.pl";
     }elsif(-e "/ss0/agb/Script/B.pl"){
            $source_library="/ss0/agb/Script/B.pl";
     }else{
            print "\n $0 can not find source library, please set BIO_PERL env\n";
     }
     return(\$source_library);
}

#______________________________________________________________
# Title     : find_central_seq_mspa_chunk
# Usage     : This finds the correct mspa chunk with given seq name
#             and big original or any mspa chunk
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub find_central_seq_mspa_chunk{
	 my $central_seq=${$_[0]};
	 my @MSP=@{$_[1]};
	 my ($j, $range, @MSP_1);
	 for($j=0; $j<@MSP; $j++){
	  #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	  #                   $1                 $2     $3    $4      $5     $6    $7     $8
	  #                   171     41.18      6      73  HI1690    9      76  HI0736 sodium...
	  #,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
	  if($MSP[$j]=~/^\s*(\d+)\s+\d+\.*\d*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(.+)/i){
		 if( ($4 eq $central_seq) && ($4 ne $7) ){
			$range="$2 \- $3";
			push(@MSP_1,  $range);
		 }
	  }
	 }
	 return(\@MSP_1);
}



#______________________________________________________________
# Title     : find_central_sequence
# Usage     :
# Function  : accepts mspa file and finds the central sequence.
#             central sequence is in the centre of all the member
#             sequences in a group or cluster
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub find_central_sequence{
	#"""""""""""""""""< handle_arguments{ head Ver 3.9 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	 my (%score, $out, @Keys);
	 for($i=0; $i< @file; $i++){
	  my($input_file) = ${$file[$i]} || $file[$i];

	  if($debug eq 1){ print "\n inputfile is $input_file\n" };
	  unless (-e $input_file){
		  print chr(7);
		  print "\n\n\t This is sub open_mspa_files in $0  \n\n";
		  print "\t Fatal: The input file $input_file is not in the directory \n";
	  }
	  open(FILE_1,"$input_file");
	  @MSP=<FILE_1>;

	  for($j=0; $j<@MSP; $j++){
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 #                   $1                 $2     $3    $4      $5     $6    $7     $8
		 #                   171     41.18      6      73  HI1690    9      76  HI0736 sodium...
		 #,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
		 if($MSP[$j]=~/^\s*(\d+)\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(.+)/){
			if($4 eq $7){
			   $seq_name=$7;
			}elsif( ($4 ne $7) && ( defined($seq_name) ) ){
			   $score{$seq_name}+= $1;
			}
		 }
	  }
	 }
	 @Keys=keys %score;
	 for($i=0; $i< @Keys; $i++){
	  if($score{$Keys[$i]} > $largest){
		 $largest=$score{$Keys[$i]};
		 $out=$Keys[$i];
	  }
	 }
	 return(\$out);
}



#______________________________________________________________________________
# Title     : ftp_put_files_given_from_a_list
# Usage     : &ftp_put_files_given_from_a_list(\$file_list, $ftp_server_name, $target_directory,
#                                  $username='jong', $passwd='asdfjik');
#
# Function  : transfer file over ftp (file names are given as a list)
# Example   :
#             &ftp_put_files_given_from_a_list(\$file_list,
#                                               $ftp_server_name,
#                                               $target_directory,
#                                               $username='jong',
#                                               $passwd='9890ukk',
#                                              );
# Keywords  : transfer_files_with_ftp
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub ftp_put_files_given_from_a_list{
    my($i, $ftp_server_name, $ftp, $target_directory, $username, $passwd,
       $file_list, @files, $type);
    use Net::FTP;
    $file_list=${$_[0]} || $_[0];
    $ftp_server_name=${$_[1]} || $_[1];
    $target_directory=${$_[2]} || $_[2];
    $username=${$_[3]} || $_[3];
    $passwd  =${$_[4]} || $_[4];
    if($_[5]){        $type =${$_[5]} || $_[5];
    }else{            $type = 'I' ;     }

    $ftp=Net::FTP->new("$ftp_server_name") || die "Cant connect to $ftp_server_name\n";
    $ftp->login($username, $passwd) || die "Cant login as $username with $passwd\n\n";
    $ftp->cwd($target_directory);
    unless(-s $file_list){
       print "\n I need a list file for files: \$file_list has \"$file_list\"\n"; die;
    }
    $num_of_files=@files=@{&open_list_file_ARRAY(\$file_list)};
    for($i=0; $i < @files; $i++){
       $ftp->put($files[$i]);
       print "$i/$num_of_files Putting $files[$i] to $ftp_server_name as $username using ftp_put_files_given_from_a_list\n";
    }
    $ftp->quit();
}


#______________________________________________________________________________
# Title     : ftp_get_files_given_from_a_list
# Usage     : &ftp_put_files_given_from_a_list(\$file_list, $ftp_server_name, $server_directory,
#                                  $username='jong', $passwd='asdfjik', $client_directory);
#
# Function  : transfer file over ftp (file names are given as a list)
# Example   :
#             &ftp_get_files_given_from_a_list(\@files,
#                                               $ftp_server_name,
#                                               $server_directory,
#                                               $username='jong',
#                                               $passwd='9890ukk',
#                                               $client_directory
#                                              );
# Keywords  : transfer_files_with_ftp
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.3
#------------------------------------------------------------------------------
sub ftp_get_files_given_from_a_list{
    my($i, $ftp_server_name, $ftp, $server_directory, $username, $passwd,
       @files, $type, $client_directory);
    use Net::FTP;
    @files=@{$_[0]};
    $ftp_server_name =${$_[1]} || $_[1];
    $server_directory=${$_[2]} || $_[2];
    $username=${$_[3]} || $_[3];
    $passwd  =${$_[4]} || $_[4];
    $client_directory=${$_[5]} || $_[5];

    if($_[6]){        $type =${$_[6]} || $_[6];
    }else{            $type = 'I' ;     }

    $ftp=Net::FTP->new("$ftp_server_name") || die "Cant connect to $ftp_server_name\n";
    $ftp->login($username, $passwd) || die "Cant login as $username with $passwd\n\n";
    $ftp->cwd($server_directory);
    unless(@files){
       print "\n I need a file list: \@files\n"; die;
    }
    for($i=0; $i < @files; $i++){
       $local_file="$client_directory\/$files[$i]";
       $ftp->get($files[$i], $local_file);
       print "($i) getting $files[$i] from $ftp_server_name as $username. $local_file\n";
    }
    $ftp->quit();
}



#______________________________________________________________
# Title     : write_dof_files
# Usage     : &write_dof_files(\@mspas);
#             while @mspas means mspa file names
# Function  : write Alex's domfam file. it prints out tilde lines
#             if the seqlet matched are below threshold defined.
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
#             v  for verbose STDOUT
#             n  for NO seq start and end number display
#             t= for teshold (eg, t=40  for Blastp(or ssearch) score 40 threshold)
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------
sub write_dof_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my $thresh = 0;
	 my @mspas=@file;
	 my (@mspa_name, $mspa_file, @list, $leng, $scale);
	 $thresh=$vars{'t'} if defined( $vars{'t'} ) ;
	 $scale =$vars{'s'};

	 for($i=0; $i < @mspas; $i++){ ### @mspas should have mspa file names
	  my($x, $leng, $line_size, $o, $I_len, $SC, %count);
	  my @mspa_name=split(/\./, $mspas[$i]);
	  my $base=$mspa_name[0];
	  my $out_dof_file="$base\_$thresh\.dof";
	  open(DOF, ">$out_dof_file");
	  open(MSP, "$mspas[$i]");
	  my @output=<MSP>;

	  ###### Getting automatic $scale ~~~~~~~~~~~~~~~~~~~~~~~
	  unless($scale=~/\d+/){
		 for($j=0; $j< @output; $j++){
			if($output[$j]=~/^\s*\S+\s+\S+\s+1\s+(\d+)\s+\S+/){
			   $leng=$1 if ($1 > $leng);
			}
		 }
		 if($leng > 1300){ $scale = 20;
		 }else{
		    $scale=int($leng / (log($leng)*10) );
		 }
		 if($scale < 5){
			$scale=5;
		 }
	  }

	  if($output[0]=~/^$/){ splice(@output, 0, 1); }
	  if($remove=~/r/){ shift(@output); }  ## removing the first line

	  #######======  Drawing the top line ###########
	  $line_size=int($leng/$scale);

	  #######======  SCALE writing =======###########
	  print DOF "\n NAME       LENG  FROM- TO  ";
	  print     "\n NAME       LENG  FROM- TO  "  if ($char_opt=~/v/);
	  my $div=int($leng/$scale);
	  my $Scaled=int($div/$scale);
	  for($x=1; $x< $leng; $x+=$div){
		 $I_len=length($x);
		 $SC=$Scaled-$I_len;
		 print DOF $x."."x$SC;
		 print     $x."."x$SC if ($char_opt=~/v/);
	  }
	  #####~~~~ Processing MSP file lines ~~~~~~~~
	  for ($o=0; $o< @output; $o++){
		 my $each_mspa_line=$output[$o];
		 my ($line,$score, $start1, $end1, $query, $start2, $end2,
		     $put_blank_line, $no_num, $target_seq,$first_time,
		     $S2L, $E2L, $L);
		 if($each_mspa_line =~/^$/){
			print DOF "\n";
			print "\n"  if ($char_opt=~/v/);
			$first_time=1;
			next;
		 }elsif($each_mspa_line =~/^\s*(\d+)\s+\S+\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
			$score=$1;
		    #if($score < $thresh){
		    #   print "\n>$4 score too low"; next;
		    #}
			$start1    =$2;
			$end1      =$3;
			$query     =$4;
			$start2    =$5;
			$end2      =$6;
			$target_seq=$7;
			$target_leng=length($fasta{$target_seq});
			if($count{$target_seq} >= 1){
			   $first_time=0;
			   $put_blank_line=0;
			}elsif($count{$target_seq} < 1){
			   $first_time=1;
			}
			$count{$target_seq}++;
		 }
		 my $S=int($start1/$scale);
		 my $E=int($end1/$scale);
		 $L=$E-$S+1;
		 if($char_opt=~/n/i){
			  if($score < $thresh){
				 $line=" "x$S."\~"x$L;
			  }else{
				 $line=" "x$S."\-"x$L;
			  }
		 }else{
			  $S2L=length($start2);
			  $E2L=length($end2);
			  $L=$L-$S2L-$E2L;
			  if($L < 1){ $L=1 }
			  if($score < $thresh){
				 $line=" "x$S.$start2."\~"x$L.$end2;
			  }else{
				 $line=" "x$S.$start2."\-"x$L.$end2;
			  }
		 }

		 ### Actual writing ####
		 if($first_time==1){
			$first_time=0;
				#    Name leng strt-end   |---------------------------------------------------------
			  printf DOF "\n\>%-11s %-4d %-4d\-%4d %-${line_size}s", $target_seq, $target_leng, $start1, $end1, $line;
			  printf  ("\n\>%-11s %-4d %-4d\-%4d %-${line_size}s",
			   $target_seq, $target_leng, $start1, $end1, $line)  if ($char_opt=~/v/);
		 }elsif($first_time !=1){
			if($put_blank_line==1){
			  print DOF "\n";
			  printf DOF "\n %-11s %-4d %-4d\-%4d %-${line_size}s", $target_seq, $target_leng, $start1, $end1,$line;
			  print  "\n"  if ($char_opt=~/v/);
			  printf  ("\n %-11s %-4d %-4d\-%4d %-${line_size}s",
				 $target_seq, $target_leng, $start1, $end1,$line)  if ($char_opt=~/v/);
		   }else{
			  printf DOF "\n %-11s %-4d %-4d\-%4d %-${line_size}s", $target_seq, $target_leng, $start1, $end1,$line;
			  printf ( "\n %-11s %-4d %-4d\-%4d %-${line_size}s",
				$target_seq, $target_leng, $start1, $end1,$line)  if ($char_opt=~/v/);
		   }
		 }

	  }
	  print DOF "\n\n";
	  print "\n"  if ($char_opt=~/v/);
	  print "\n# ~~~~~ lines mean match regions with below threshold ($thresh)" if $thresh > $score;
	  print "\n# $out_dof_file   is created \n";
	 }

}



#______________________________________________________________
# Title     : make_filtered_list
# Usage     :
# Function  : this is the core of check_genome_cluster.pl
#             finds good linkage seqlets in mspa files
# Example   :
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub make_filtered_list{ #####################################33
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 $|=1;
	 my ($result, @mspa,%temp_mspa, @num_of_all_links,$link_counter,$diff1, $diff2);
	 my $num_seq=0;
	 my @sizes_of_seqlets;
	 open(MSP, "$file[0]");
	 FIRST_FOR:for($c=0; $c< @file; $c++){
	 my %temp_mspa;
	 #print "\nFirst\(${c}\)th INPUT file processing\n";
	 my @mspa1=<MSP>;
	 my (@mspa, $MSP);
	 for($i=0; $i< @mspa1; $i++){
	   if($mspa1[$i]=~/^\s*(\d+)\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\w+)\s+(\d+)\s+(\d+)\s+(\w+)/i){
		  if($1 > $mspa_value){
		    $temp_mspa{$4} .= $mspa1[$i];
		  }
	   }
	 }
	 close(MSP);
	 #print "\n", %temp_mspa, "\n";

	 @mspa=values %temp_mspa;
	 $num_seq=@mspa;
	 print "\nTOP Number of seq is: $num_seq \n";

	 #""""""  Real algorithm starts HERE##''''''''''''''''''''''''''''''''''''''''

	 # optimization: I found no need to go through all mspa chunk. One is enough by experience
	 #MSP1: for($i=0; $i< @mspa; $i++){ # @mspa has (mspachunk1, mspachunk2...)
	 if($fast==1){ $mspa_chunk_num=1
	 }else{ $mspa_chunk_num=@mspa }

	 MSP1: for($i=0; $i< $mspa_chunk_num; $i++){ # @mspa has (mspachunk1, mspachunk2...)
 	    my $pos=$i+1;
	    my @seqlets1=split(/\n+/,  $mspa[$i]);
	    print "   MSP1 ${i}th  MSP chunk is handled #######","\n";
	    my $temp=@seqlets1-1;
	    SEQLET1: for($j=1; $j < @seqlets1; $j++){
		   my @OUTPUT=&follow_seqlet_link($seqlets1[$j], @mspa);
		   my $depth_of_linking=${$OUTPUT[0]};
		   my $size_of_common_seqlet=${$OUTPUT[1]};
		   if(($depth_of_linking==@mspa)&&($size_of_common_seqlet > $threshold)){
		      $result=1;
		      if($fast == 1){
				 last FIRST_FOR;
		         #goto EXIT_1;
		      }
		   }
		   #push(@num_of_all_links, $depth_of_linking);
		   #push(@sizes_of_seqlets, $size_of_common_seqlet);
	    }
	 }
	 }
	 #print "\n All searched links: \n", "@num_of_all_links", "\n";
	 #print "\n Sizes of common seqlet\n", "@sizes_of_seqlets\n";
	 EXIT_1:
	 return(\$result, \$num_seq);
}


#______________________________________________________________
# Title     : follow_seqlet_link
# Usage     :
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub follow_seqlet_link{
	 my $seqlet_line=shift;
	 my @mspa=@_;
	 my ($i, $j, $link_counter, @common_range,$seqlet_very_ori, @ranges_very_ori,
	  @new_ranges, $seqlet_ori, $matched_ori, @ranges1, @ranges2);
	 if($seqlet_line=~/^\s*\d+\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\w+)\s+(\d+)\s+(\d+)\s+(\w+)/i){
	  $seqlet_ori =$3;
	  $seqlet_very_ori=$3;
	  $matched_ori=$6;
	  @ranges1=($1, $2, $4, $5);
	  @ranges_very_ori=@ranges1;
	 }
	 my $visited .= "$seqlet_ori ";
	 #print "\n\=======$seqlet_ori \@ranges1 is @ranges1 =================================\n";

	 MSP: for($i=0; $i<@mspa; $i++){
	  my @seqlets1=split(/\n+/,  $mspa[$i]);
	  #my @common_range;
	  SEQLET1: for($j=1; $j < @seqlets1; $j++){
	     my $seqlet_num=$j;
	     my @temp= &get_mspa_range($seqlets1[$j]) if $seqlets1[$j]=~/\S/;
	     my @ranges2=@{$temp[0]}; # has (1 2 3 4);
	     my $seq2        = $temp[1];
	     my $matched_seq2= $temp[2];
	     #splice(@seqlets1, $j, 1);
	     #$j--;
		 if($seq2 eq $seqlet_ori){
		    next MSP; # to the next MSP chunk
		 }elsif(($seq2 eq $matched_ori)&&($visited !~ /$matched_seq2/)){
			if($verbose=~/v$/i){
	          print "\n    SEQLET1_________________________________________\(${pos}th MSP chunk\)\n";
	          print "    SEQLET1 $temp number of seqlets  for the ${pos}th mspa file\n";
			  print "    SEQLET1_________________________________________\(${seqlet_num}th seqlet )\n";
			  print "    QUERY seqlet is $temp[1]: ", "@ranges2[0..1]  MATCH seqlet is $temp[2]: ", "@ranges2[2..3]","\n";
			  print "    Target seqlet is $seq2 : @ranges2\n";
			}
			if(($ranges1[2] >= $ranges2[0])&&    ##     =======
			   ($ranges1[3] <= $ranges2[1]) ){   ##  ==============
			   $link_counter++;
			   #push(@common_range, @ranges1, @ranges2);
			   #print "\n      MSP2      \@ranges1 is ", "@ranges1" if($verbose=~/v/i);
			   #print "\n                \@ranges2 is ", "@ranges2" if($verbose=~/v/i);
			   $diff1=$ranges1[2] - $ranges2[0];
			   $diff2=$ranges2[1] - $ranges1[3];
			   @new_ranges =($ranges1[2], $ranges1[3], ($ranges2[2]+$diff1), ($ranges2[3]-$diff2) );
			   @ranges1=(@new_ranges); #, $ranges2[2], $ranges2[3]);
			   $seqlet_ori=$seq2;
			   $matched_ori=$matched_seq2;
			   $visited .= "$seqlet_ori ";
			   if($verbose=~/v/i){
			      print "\n      FIRST elsif    Finalout @new_ranges \$link_counter=$link_counter", "\n";
			      print "                                         \$num_seq = $num_seq\n";
			   }
			   if( ($link_counter+2) >= @mspa){
				  #print  "\n   All link found \$link_counter = $link_counter, \$num_seq=$num_seq\n";
				  $result=1;
				  #$link_counter=0;
				  #print "\n     Common range: ", "@common_range", "\n";
				  $visited .= "$matched_seq2 ";
				  #print "     Sequence visited: $visited \n";
				  @common_range=();
				  $not_visited_mspa_chunk=0;
				  goto EXIT;
			   }
			   $i=0;
			   next MSP;
			}elsif(($ranges1[2] <= $ranges2[0])&& ##    --------------
				   ($ranges1[3] >= $ranges2[1]) ){ ##       --------
			   $link_counter++;
			   #push(@common_range, @ranges1, @ranges2);
			   #print "\n         \@ranges1 is ", "@ranges1";
			   #print "\n         \@ranges2 is ", "@ranges2";
			   @new_ranges =($ranges2[0], $ranges2[1], $ranges2[2], $ranges2[3],);
			   #print "\n      Second elsif  Finalout ", @new_ranges, " \$link_counter=$link_counter\n";
			   #print "                                         \$num_seq = $num_seq\n";
			   @ranges1=(@new_ranges);
			   $seqlet_ori=$seq2;
			   $matched_ori=$matched_seq2;
			   $visited .= "$seqlet_ori ";

			   if( ($link_counter+2) >= @mspa){
				  #print  "\n     All link found \$link_counter = $link_counter, \$num_seq=$num_seq\n";
				  $result=1;
				  #$link_counter=0;
				  #print "\n     ", "@common_range", "\n";
				  $visited .= "$matched_seq2 ";
				  #print "     Sequence visited: $visited \n";
				  @common_range=();
				  $not_visited_mspa_chunk=0;
				  goto EXIT;
			   }
			   $i=0;
			   next MSP;
			}elsif(($ranges1[2] <= $ranges2[0])&&   #    ======
				   ($ranges1[3] <= $ranges2[1]) &&   ##      =======
				   ($ranges1[3] >= $ranges2[0]) ){
			   $link_counter++;
			   #push(@common_range, @ranges1, @ranges2);
			   #print "\n         \@ranges1 is ", "@ranges1";
			   #print "\n         \@ranges2 is ", "@ranges2";
			   #print "                                         \$num_seq = $num_seq\n";
			   $diff2=$ranges2[1] - $ranges1[3];
			   @new_ranges=($ranges2[0], $ranges1[3],  $ranges2[2], ($ranges2[3]-$diff2));
			   @ranges1=(@new_ranges);
			   $seqlet_ori=$seq2;
			   $matched_ori=$matched_seq2;
			   $visited .= "$seqlet_ori ";
			   #print "\n      Third elsif  Finalout ", @new_ranges, " \$link_counter=$link_counter\n";
			   if( ($link_counter+2) >= @mspa){
				  #print  "\n     All link found \$link_counter = $link_counter, \$num_seq=$num_seq\n";
				  $result=1;
				  #$link_counter=0;
				  #print "\n     ", "@common_range", "\n";
				  $visited .= "$matched_seq2 ";
				  #print "     Sequence visited: $visited \n";
				  @common_range=();
				  $not_visited_mspa_chunk=0;
				  goto EXIT;
			   }
			   $i=0;
			   next MSP;
			}elsif(($ranges1[2] >= $ranges2[0])&&  #        ======
				  ($ranges1[3] >= $ranges2[1])&&   ##  =======
				  ($ranges1[2] <= $ranges2[1]) ){
			   $link_counter++;
			   #push(@common_range, @ranges1, @ranges2);
			   #print "\n         \@ranges1 is ", "@ranges1";
			   #print "\n         \@ranges2 is ", "@ranges2";
			   $diff1=$ranges1[2] - $ranges2[0];
			   @new_ranges=($ranges1[2], $ranges2[1], ($ranges2[0]+$diff1), $ranges2[1]);
			   @ranges1=(@new_ranges);
			   $seqlet_ori=$seq2;
			   $matched_ori=$matched_seq2;
			   $visited .= "$seqlet_ori ";
			   #print "\n      Fourth elsif  Finalout ", @new_ranges, " \$link_counter=$link_counter\n";
			   #print "                                         \$num_seq = $num_seq\n";
			   if( ($link_counter+2) >= @mspa){
				  #print  "\n     All link found \$link_counter = $link_counter, \$num_seq=$num_seq\n";
				  $result=1;
				  #$link_counter=0;
				  #print "\n     ", "@common_range", "\n";
				  $visited .= "$matched_seq2 ";
				  #print "     Sequence visited: $visited \n";
				  @common_range=();
				  $not_visited_mspa_chunk=0;
				  goto EXIT;
			   }
			   $i=0;
			   next MSP;
			}else{
			   if($verbose=~/v/i){
			      print "\nX X X X X   Link broken ", @new_ranges, " \$link_counter=$link_counter\n";
			   }
			   next SEQLET1;
			}
		 }
	  }
	 }
	 EXIT:
	 $final_num_of_seq_linked=$link_counter+2;
	 if($final_num_of_seq_linked==@mspa){
	  $seqlet_leng=$new_ranges[$#common_range]-$new_ranges[$#common_range-1]+1;
	  #print "\n Common Seqlet size:  $seqlet_leng \n";
	 }else{
	  $seqlet_leng=0;
	 }
	 #print "\nLINKING seq num for seqlet $seqlet_very_ori \(","@ranges_very_ori","\) is $final_num_of_seq_linked \n";
	 return(\$final_num_of_seq_linked, \$seqlet_leng);
}


#________________________________________________________________________________
# Title     : convert_clu_to_mspa
# Usage     : @written_mspa_files=@{&convert_clu_to_mspa(\$single_linkage_file)};
# Function  : reads in a big single linkage cluster file(or normal cluster file)
#              and creates a big mspa file which contains all the entries in the
#              cluster file (usually with the extension of sclu or clu)
#             This normally reads in xxxx.mso, xxxx.sso like files, but if the
#              corresponding  xxx.mspa file already exists, it concatenates them to
#              make a bigger one.
# Example   :
# Keywords  : clu_2_sso_2_mspa, cluster_to_mspa, cluster_to_sso_to_mspa
#              clu_to_sso_to_mspa
# Options   :
# Category  :
# Version   : 2.7
#--------------------------------------------------------------------------------
sub convert_clu_to_mspa{
    my($i, $j, $k, $s, $u, $v, $p, $m, $n, $y, @possible_extensions, $single_file_name,
           @seq_names, @final_files, @U_L_case, $file, @file, @name_types,
           @poss_sub_dir_heads, @written_mspa_files, $Lean_output, $subdir_char_size,
           $no_of_ext_to_be_checked, $extension_type_found);

    $subdir_char_size=2; # default
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Opening cluster file (xx.clu)
    # %clus looks like this:  2-507     YGR041W YLR353W
    #                         3-308     YDR222W YDR346C YLR225C
    #                         2-184     YCL066W YCR040W
    #______________________________________________________________
    my $clu=${$_[0]} || $_[0];
    $Lean_output=${$_[1]} || $_[1];

    if($verbose){   print "\n# convert_clu_to_mspa : \"$clu\" is given and I am processing it with clu_to_sso_to_mspa\n" if defined $clu;     }
    my %clus=%{&open_clu_files(\$clu)};
    my @clusters= keys %clus;
    my $num_of_cluster=@clusters=@{&sort_by_cluster_size(\@clusters)};

    print "# (i) $0: convert_clu_to_mspa: No. of cluster=$num_of_cluster after open_clu_files \n" if $verbose;

    #&show_array(\@clusters) if $verbose;
    #&show_hash(\%clus) if $verbose;
    @possible_extensions=('mspa', 'mspa.gz', 'msso', 'msso.gz','fsso', 'pbla', 'pbla.gz',
                                                               'ssso', 'fso', 'out', 'prot.sso', 'prot.ts');
    @U_L_case=('\U', '\L', ' ');  ## !! the ' ' is necessary

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Making each SINGLE linkage clu to MSP file format to be ready for divclus
    #______________________________________________________________________________
    for($i=0; $i< @clusters; $i++){
	   my (@seq_names, @final_files, $clus_name, $big_out_mspa, @mspa_hashes);
	   $clus_name=$clusters[$i];
	   unless($single_file_name=~/\S/){
						 $big_out_mspa="$clus_name\_cluster\.mspa"; #<<<----- final output name
	   }else{
						 $big_out_mspa=$single_file_name;
	   }
	   push(@written_mspa_files, $big_out_mspa); ## This is the output of this sub

	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	   #  If $clus_name.mspa is already there, skip
	   #_____________________________________________
	   if( (-s $big_out_mspa) > 100  and !$over_write ){
               print "\n# (i) convert_clu_to_mspa : $big_out_mspa MSP file already exists, skipping\n";
               print "#    Use  \$over_write option \'o\' to start all over again or \n";
               print "#    delete clustering files like XX-XX_cluster.clu to go on\n";
               next ;
       }
       $num_of_seq_member=@seq_names=split(/\s+/, $clus{$clusters[$i]}); # @seq_names has (HIU001, HI002, HI333, MJ111, etc)
       print "# $0: convert_clu_to_mspa: No. of seq member=$num_of_seq_member after split \n" if $verbose;

       $no_of_ext_to_be_checked=@possible_extensions;
       $extension_type_found=0;

       FOR0: for($j=0; $j < @seq_names; $j++){
							 my($sub_dir_head, $file_name_low, $file_name_up, $file_name_prot_low,
									$file_name_prot_up, $file_name_low_gz, $file_name_up_gz,
									$file_name_prot_low_gz, $file_name_prot_up_gz);
									$each_seq_name=$seq_names[$j];
							 my @poss_sub_dir_heads=('.'); ## <<<<------- This is critically important, when 'D' opt is not used!

							 if($each_seq_name=~/(\S+)_\d+\-\d+$/){
									 $each_seq_name_range=$each_seq_name;
									 $each_seq_name=$1;
									 @name_types=($each_seq_name, $each_seq_name_range);
							 }else{
									 @name_types=($each_seq_name);
							 }
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 #  Here I take chars from the sequ names, as dirs have fragments of chars
							 #_______________________________________________________________________________
							 for($s=1; $s <= $subdir_char_size ; $s++){  ## here, number 2 indicates, I check single or 2 char sub dir names
									 $sub_dir_head= substr($seq_names[$j], 0, $s);
									 unshift(@poss_sub_dir_heads, "\L$sub_dir_head") if (-d "\L$sub_dir_head" );
									 unshift(@poss_sub_dir_heads, "\U$sub_dir_head") if (-d "\U$sub_dir_head" );
							 }
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 #  Checking all the possible subdirectories to crop all the sso files
							 #_______________________________________________________________________________

							 FOR1: for($p=0; $p <= @poss_sub_dir_heads; $p++){ ## Default has '.' will make things like '././fam_8_8.pbla.gz'

										$subd=$poss_sub_dir_heads[$p];               ## Also, the '<=' not '<' cures the same problem.
										#print "# (i) Checking sub dir $subd\n";
										FOR2 : for($e=$extension_type_found; $e < $no_of_ext_to_be_checked; $e++){
												 $ext=$possible_extensions[$e];
												 #print "      (i) \$ext at $subd is  $ext\n";
												 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
												 #  This makes all the possible lower upper case names
												 #______________________________________________________
												 for( $u=0; $u < @U_L_case; $u++){
														for($v=0; $v <@name_types; $v++){
															 $each_seq_name=$name_types[$v];
															 if($U_L_case[$u]=~/U/){  $each_seq_name="\U$each_seq_name";
															 }elsif($U_L_case[$u]=~/L/){ $each_seq_name="\L$each_seq_name";
															 }else{ $each_seq_name=$each_seq_name }

															 if(-s "$each_seq_name\.$ext"){
																		push(@final_files, "$each_seq_name\.$ext" ) ;
																		$extension_type_found=$e; $no_of_ext_to_be_checked=$e+1;
																		$found_search_prog_exention_used=$ext;
																		$found_real_subdir_name=$subd; ## This is to report the name of the actual subd found
																		$found_search_prog_exention_used=$ext;
																		next FOR0
															 }elsif(-s "$each_seq_name\.$ext\.gz"){
																		push(@final_files, "$each_seq_name\.$ext\.gz" ) ;
																		$extension_type_found=$e; $no_of_ext_to_be_checked=$e+1;
																		$found_search_prog_exention_used=$ext;
																		$found_real_subdir_name=$subd; ## This is to report the name of the actual subd found
																		$found_search_prog_exention_used=$ext;
																		next FOR0
															 }else{
                                                                  $file_wanted="\.\/$subd\/$each_seq_name\.$ext";
                                                                  if(-s $file_wanted){
                                                                          push( @final_files, $file_wanted);
                                                                          $extension_type_found=$e; $no_of_ext_to_be_checked=$e+1;
                                                                          $found_real_subdir_name=$subd; ## This is to report the name of the actual subd found
                                                                          $found_search_prog_exention_used=$ext;
                                                                          last FOR1;
                                                                  }elsif(-s "$file_wanted\.gz"){
                                                                          push( @final_files, "$file_wanted\.gz");
                                                                          $extension_type_found=$e; $no_of_ext_to_be_checked=$e+1;
                                                                          $found_search_prog_exention_used=$ext;
                                                                          $found_real_subdir_name=$subd; ## This is to report the name of the actual subd found
                                                                          next FOR0;
                                                                  }
															 }
														}
												 }
										} # FOR2
							 } # FOR1
				 } # FOR0

                 if(@final_files < 1){
					print "\n# (E) convert_clu_to_mspa :LINE no.: ", __LINE__, " ERROR: \@final_files is empty. Serious error\n";
					print "\n If you have sub dir which have more than 2 chars as names, you may increase the default 2 to 3 in the above\n";
					next;
				 }
				 $write_each_mspa_to_disk='';
                 #@final_files=sort(@final_files); ## this is not really necessary

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 #  Check if small mspa files have already made in previous steps
				 #________________________________________________________________
				 if($final_files[0]=~/(\S+)\.mspa/){ ##  concatenate mspa into big_mspa
						 $search_file_base=$1;
                         open(BIG_MSP_FILE_C, ">$big_out_mspa");
                         print BIG_MSP_FILE_C "# Latest write by convert_clu_to_mspa in $0\n";
                         for($y=0; $y< @final_files; $y++){

                             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                             # Opens single MSP file. Check if they were gzipped or not before open
                             #________________________________________________________________________
                             if($final_files[$y]=~/(\S+)\.gz$/){
                                 system("gzip -d $final_files[$y]");
                                 open(SINGLE_MSP, "$1") || warn "\n\n Can not open SINGLE_MSP $final_files[$y]";
                             }else{                          open(SINGLE_MSP, "<$final_files[$y]") || warn "\n\n Can not open SINGLE_MSP $final_files[$y]";
                             }
                             while(<SINGLE_MSP>){
							      print BIG_MSP_FILE_C $_;
							 }
						 }
						 close(BIG_MSP_FILE_C);
						 close(SINGLE_MSP);
						 push(@written_mspa_files, $big_out_mspa);

						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
						 # Doing something for L option ($Lean_output)
						 #___________________________________________________
						 if($Lean_output and -d $found_real_subdir_name and $found_search_prog_exention_used){
                             for($y=0; $y< @seq_names; $y++){
                                     unlink("$found_real_subdir_name\/$seq_names[$y]\.$found_search_prog_exention_used");
                                     unlink("$found_real_subdir_name\/$seq_names[$y]\.$found_search_prog_exention_used\.gz");
                             }
						 }elsif($Lean_output){
                             for($y=0; $y< @seq_names; $y++){
                                     unlink("$seq_names[$y]\.$found_search_prog_exention_used");
                                     unlink("$seq_names[$y]\.$found_search_prog_exention_used\.gz");
                             }
						 }
				 }else{
                      if($write_each_mspa_to_disk){
                           print "\# $0 : going to run open_sso_files with $write_each_mspa_to_disk opt\n";
                           $big_out_mspa=${&open_sso_files(\@final_files, $uppercase_seq_name, $write_each_mspa_to_disk,
                                                                                                                                           "u=$upper_expect_limit", $new_format, $add_range, $add_range2, $big_out_mspa, $over_write)};
                           if(-s $big_out_mspa > 200){  print "\n# $0: SUCCESS to create $big_out_mspa :) :) :-) :-) ?\n"; }
                      }else{
                           print "\n# convert_clu_to_mspa: I am running open_sso_files. \n";
                           @mspa_hashes=@{&open_sso_files(\@final_files, $uppercase_seq_name, $write_each_mspa_to_disk,
                                                         "u=$upper_expect_limit", $new_format, $add_range,
                                                         $add_range2, $big_out_mspa, $over_write)};
                           &write_mspa_files(@mspa_hashes, $big_out_mspa); ## concatenates all the hash ref to one
                      }
				 }
		 }## end of  for($i=0; $i< @clusters; $i++){
		 return(\@written_mspa_files);
}# end of






#________________________________________________________________________________
# Title     : clu_to_sso_to_mspa
# Usage     : &clu_to_sso_to_mspa(\$clu);
# Function  : reads in a big single linkage cluster file(or normal cluster file)
#              and creates a big mspa file which contains all the entries in the
#              cluster file (usually with the extension of sclu or clu)
#             This normally reads in xxxx.mso, xxxx.sso like files, but if the
#              corresponding  xxx.mspa file already exists, it concatenates them to
#              make a bigger one.
# Example   :
# Keywords  : convert_clu_to_sso_to_mspa, clu_2_sso_2_mspa, cluster_to_mspa, cluster_to_sso_to_mspa
# Options   :
# Version   : 1.8
#--------------------------------------------------------------------------------
sub clu_to_sso_to_mspa{
		 my($i, $j, $k, $s, $u, $p, $m, $n, $y, @possible_extensions, @seq_names,
				@final_files, @U_L_case, $file, @file, @written_mspa_files);

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 # Opening cluster file (xx.clu)
		 # %clus looks like this:  2-507     YGR041W YLR353W
		 #                         3-308     YDR222W YDR346C YLR225C
		 #                         2-184     YCL066W YCR040W
		 #______________________________________________________________
		 my $clu=${$_[0]} || $_[0];
		 if($verbose){
				 print "\n# clu_to_sso_to_mspa : \"$clu\" is given
						 and I am processing it with clu_to_sso_to_mspa\n" if defined $clu;
		 }
		 my %clus=%{&open_clu_files(\$clu)};
		 my @keys= keys %clus;
		 my $num_of_cluster=@keys=@{&sort_by_cluster_size(\@keys)};

		 print "# $0: clu_to_sso_to_mspa: No. of cluster=$num_of_cluster after open_clu_files \n";

		 &show_array(\@keys) if $verbose;
		 &show_hash(\%clus) if $verbose;
		 @possible_extensions=('mspa', 'sso', 'msso', 'msso.gz',
							'pbla.gz', 'pbla', 'fsso', 'ssso', 'fso', 'out', 'prot.sso', 'prot.ts');
		 @U_L_case=('\U', '\L');

		 for($i=0; $i< @keys; $i++){
				my (@seq_names, @final_files, $clus_name, $big_out_mspa, @mspa_hashes);
				$clus_name=$keys[$i];
				unless($single_file_name=~/\S/){
						$big_out_mspa="$clus_name\_cluster\.mspa"; #<<<----- final output name
				}else{
						$big_out_mspa=$single_file_name;
				}
				push(@written_mspa_files, $big_out_mspa); ## This is the output of this sub

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  If $clus_name.mspa is already there, skip
				#_____________________________________________
				if( (-s $big_out_mspa) > 100  and !$over_write ){
						print "\n# clu_to_sso_to_mspa : $big_out_mspa MSP file already exists, skipping\n";
						print "#    Use  \$over_write option \'o\' to start all over again or \n";
						print "#    delete clustering files like XX-XX_cluster.clu to go on\n";
						next ;
				}
				$num_of_seq_member=@seq_names=split(/\s+/, $clus{$keys[$i]}); # @seq_names has (HIU001, HI002, HI333, MJ111, etc)
				print "# $0: clu_to_sso_to_mspa: No. of seq member=$num_of_seq_member after split \n" if $verbose;

				FOR0: for($j=0; $j < @seq_names; $j++){
					 my($sub_dir_head, $file_name_low, $file_name_up, $file_name_prot_low, @sub_dir_heads,
							 $file_name_prot_up, $file_name_low_gz, $file_name_up_gz,
							 $file_name_prot_low_gz, $file_name_prot_up_gz);

					 $each_seq_name=$seq_names[$j];
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 #  Here I take chars from the sequ names, as dirs have fragments of chars
					 #_______________________________________________________________________________
					 for($s=1; $s <=2 ; $s++){  ## here, number 2 indicates, I check single or 2 char sub dir names
							 $sub_dir_head= substr($seq_names[$j], 0, $s);
							 push(@sub_dir_heads, "\L$sub_dir_head") if (-d "\L$sub_dir_head" );
							 push(@sub_dir_heads, "\U$sub_dir_head") if (-d "\U$sub_dir_head" );
					 }
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 #  Checking all the possible subdirectories to crop all the sso files
					 #_______________________________________________________________________________
					 FOR1: for($p=0; $p < @sub_dir_heads; $p++){
							 $subd=$sub_dir_heads[$p];
							 FOR2 : for($e=0; $e < @possible_extensions; $e++){
										$ext=$possible_extensions[$e];
										#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
										#  This makes all the possible lower upper case names
										#______________________________________________________
										for( $u=0; $u < @U_L_case; $u++){
												if($U_L_case[$u]=~/U/){  $each_seq_name="\U$each_seq_name";
												}else{                   $each_seq_name="\L$each_seq_name"; }

												if(-s "$each_seq_name\.$ext"){   push(@final_files, "$each_seq_name\.$ext" ) ; next FOR0 }
												elsif(-s "$each_seq_name\.$ext\.gz"){ push(@final_files, "$each_seq_name\.$ext\.gz" ) ; next FOR0 }
												else{
														$file_wanted="\.\/$subd\/$each_seq_name\.$ext";
														if(-s $file_wanted){
																push( @final_files, $file_wanted); next FOR0 }
														elsif(-s "$file_wanted\.gz"){
																push( @final_files, "$file_wanted\.gz");
																next FOR0
														}
												}
										}
							 } # FOR2
					 } # FOR1

				} # FOR0

				print "\n# @final_files \n=============> $big_out_mspa  \n\n" if $verbose;

				if(@final_files < 1){
					 print "\n# clu_to_sso_to_mspa :LINE no.: ", __LINE__, " ERROR: \@final_files is empty. Serious error\n";
					 print "\n If you have sub dir which have more than 2 chars as names, you may increase the default 2 to 3 in the above\n";
					 next;
				}
				$write_each_mspa_to_disk='w';

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  Check if small mspa files have already made in previous steps
				#________________________________________________________________
				if($final_files[0]=~/\.mspa\s*$/){ ##  concatenate mspa into big_mspa
						 open(BIG_MSP_FILE, ">$big_out_mspa");
						 for($y=0; $y< @final_files; $y++){
                             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                             # Opens single MSP file. Check if they were gzipped or not before open
                             #________________________________________________________________________
                             if($final_files[$y]=~/\.gz$/){  open(SINGLE_MSP, "|gunzip -d $final_files[$y]") || warn "\n\n Can not open SINGLE_MSP $final_files[$y]";
                             }else{                          open(SINGLE_MSP, "<$final_files[$y]") || warn "\n\n Can not open SINGLE_MSP $final_files[$y]";
                             }
                             while(<SINGLE_MSP>){
							      print BIG_MSP_FILE_C $_;
							 }
						 }
						 close(BIG_MSP_FILE);
						 close(SINGLE_MSP);
						 push(@written_mspa_files, $big_out_mspa);

				}else{
						if($write_each_mspa_to_disk){
								 print "\# $0 : going to run open_sso_files with $write_each_mspa_to_disk opt\n";
								 $big_out_mspa=${&open_sso_files(\@final_files, $uppercase_seq_name, $write_each_mspa_to_disk,
															 "u=$upper_expect_limit", $new_format, $add_range, $add_range2, $big_out_mspa, $over_write)};
								 if(-s $big_out_mspa > 200){  print "\n# $0: SUCCESS to create $big_out_mspa :) :) :-) :-) ?\n"; }
						}else{
								 print "\n# clu_to_sso_to_mspa: I am running open_sso_files. \n";
								 @mspa_hashes=@{&open_sso_files(\@final_files, $uppercase_seq_name, $write_each_mspa_to_disk,
															 "u=$upper_expect_limit", $new_format, $add_range, $add_range2, $big_out_mspa, $over_write)};

								 &write_mspa_files(@mspa_hashes, $big_out_mspa); ## concatenates all the hash ref to one
						}
				}
		 }
		 return(\@written_mspa_files);
}# end of


#________________________________________________________________________________
# Title     : convert_clu_to_sso_to_mspa
# Usage     : &clu_to_sso_to_mspa(\$clu);
# Function  : reads in a big single linkage cluster file(or normal cluster file)
#              and creates a big mspa file which contains all the entries in the
#              cluster file (usually with the extension of sclu or clu)
#             This normally reads in xxxx.mso, xxxx.sso like files, but if the
#              corresponding  xxx.mspa file already exists, it concatenates them to
#              make a bigger one.
# Example   :
# Keywords  : clu_2_sso_2_mspa, cluster_to_mspa, cluster_to_sso_to_mspa
#              clu_to_sso_to_mspa
# Options   :
# Category  :
# Version   : 1.8
#--------------------------------------------------------------------------------
sub convert_clu_to_sso_to_mspa{
		 my($i, $j, $k, $s, $u, $p, $m, $n, $y, @possible_extensions, @list,
					@final_files, @U_L_case, $file, @file, @written_mspa_files);

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 # Opening cluster file (xx.clu)
		 # %clus looks like this:  2-507     YGR041W YLR353W
		 #                         3-308     YDR222W YDR346C YLR225C
		 #                         2-184     YCL066W YCR040W
		 #______________________________________________________________
		 my $clu=${$_[0]} || $_[0];
		 if($verbose){
					 print "\n# clu_to_sso_to_mspa : \"$clu\" is given
													 and I am processing it with clu_to_sso_to_mspa\n" if defined $clu;
		 }
		 my %clus=%{&open_clu_files(\$clu)};
		 my @keys= keys %clus;
		 my $num_of_cluster=@keys=@{&sort_by_cluster_size(\@keys)};

		 print "# $0: clu_to_sso_to_mspa: No. of cluster=$num_of_cluster after open_clu_files \n" if $verbose;

		 &show_array(\@keys) if $verbose;
		 &show_hash(\%clus) if $verbose;
		 @possible_extensions=('mspa', 'sso', 'msso', 'msso.gz','fsso', 'ssso', 'fso', 'out', 'prot.sso', 'prot.ts');
		 @U_L_case=('\U', '\L');

		 for($i=0; $i< @keys; $i++){
				 my (@list, @final_files, $clus_name, $big_out_mspa, @mspa_hashes);
				 $clus_name=$keys[$i];
				 unless($single_file_name=~/\S/){
							$big_out_mspa="$clus_name\_cluster\.mspa"; #<<<----- final output name
				 }else{
							$big_out_mspa=$single_file_name;
				 }
				 push(@written_mspa_files, $big_out_mspa); ## This is the output of this sub

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 #  If $clus_name.mspa is already there, skip
				 #_____________________________________________
				 if( (-s $big_out_mspa) > 100  and !$over_write ){
						 print "\n# clu_to_sso_to_mspa : $big_out_mspa MSP file already exists, skipping\n";
						 print "#    Use  \$over_write option \'o\' to start all over again or \n";
						 print "#    delete clustering files like XX-XX_cluster.clu to go on\n";
						 next ;
				 }
				 $num_of_seq_member=@list=split(/\s+/, $clus{$keys[$i]}); # @list has (HIU001, HI002, HI333, MJ111, etc)
				 print "# $0: clu_to_sso_to_mspa: No. of seq member=$num_of_seq_member after split \n" if $verbose;

				 FOR0: for($j=0; $j < @list; $j++){
									my($sub_dir_head, $file_name_low, $file_name_up, $file_name_prot_low, @sub_dir_heads,
										 $file_name_prot_up, $file_name_low_gz, $file_name_up_gz,
										 $file_name_prot_low_gz, $file_name_prot_up_gz);

									$each_seq_name=$list[$j];
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									#  Here I take chars from the sequ names, as dirs have fragments of chars
									#_______________________________________________________________________________
									for($s=1; $s <=2 ; $s++){  ## here, number 2 indicates, I check single or 2 char sub dir names
											 $sub_dir_head= substr($list[$j], 0, $s);
											 push(@sub_dir_heads, "\L$sub_dir_head") if (-d "\L$sub_dir_head" );
											 push(@sub_dir_heads, "\U$sub_dir_head") if (-d "\U$sub_dir_head" );
									}
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									#  Checking all the possible subdirectories to crop all the sso files
									#_______________________________________________________________________________
									FOR1: for($p=0; $p < @sub_dir_heads; $p++){
											 $subd=$sub_dir_heads[$p];
											 FOR2 : for($e=0; $e < @possible_extensions; $e++){
														$ext=$possible_extensions[$e];
														#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
														#  This makes all the possible lower upper case names
														#______________________________________________________
														for( $u=0; $u < @U_L_case; $u++){
																	if($U_L_case[$u]=~/U/){  $each_seq_name="\U$each_seq_name";
																	}else{                   $each_seq_name="\L$each_seq_name"; }

																	if(-s "$each_seq_name\.$ext"){   push(@final_files, "$each_seq_name\.$ext" ) ; next FOR0 }
																	elsif(-s "$each_seq_name\.$ext\.gz"){ push(@final_files, "$each_seq_name\.$ext\.gz" ) ; next FOR0 }
																	else{
																			 $file_wanted="\.\/$subd\/$each_seq_name\.$ext";
																			 if(-s $file_wanted){
																											 push( @final_files, $file_wanted); next FOR0 }
																			 elsif(-s "$file_wanted\.gz"){
																											 push( @final_files, "$file_wanted\.gz");
																											 next FOR0
																			 }
																	}
														}
											 } # FOR2
									} # FOR1

				 } # FOR0

				 print "\n# @final_files \n=============> $big_out_mspa  \n\n" if $verbose;

				 if(@final_files < 1){
							print "\n# clu_to_sso_to_mspa :LINE no.: ", __LINE__, " ERROR: \@final_files is empty. Serious error\n";
							print "\n If you have sub dir which have more than 2 chars as names, you may increase the default 2 to 3 in the above\n";
							next;
				 }
				 # $write_each_mspa_to_disk='w';

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 #  Check if small mspa files have already made in previous steps
				 #________________________________________________________________
				 if($final_files[0]=~/\.mspa\s*$/){ ##  concatenate mspa into big_mspa
						 open(BIG_MSP_FILE, ">$big_out_mspa");
						 print "\n # Written by  convert_clu_to_sso_to_mspa in $0\n";
						 for($y=0; $y< @final_files; $y++){
								 open(SINGLE_MSP, "$final_files[$y]");
								 while(<SINGLE_MSP>){
										 print BIG_MSP_FILE $_;
								 }
						 }
						 close(BIG_MSP_FILE);
						 close(SINGLE_MSP);
						 push(@written_mspa_files, $big_out_mspa);

				 }else{
						 if($write_each_mspa_to_disk){
									print "\# $0 : going to run open_sso_files with $write_each_mspa_to_disk opt\n";
									$big_out_mspa=${&open_sso_files(\@final_files, $uppercase_seq_name, $write_each_mspa_to_disk,
																																					"u=$upper_expect_limit", $new_format, $add_range, $add_range2, $big_out_mspa, $over_write)};
									if(-s $big_out_mspa > 200){  print "\n# $0: SUCCESS to create $big_out_mspa :) :) :-) :-) ?\n"; }
						 }else{
									print "\n# clu_to_sso_to_mspa: I am running open_sso_files. \n";
									@mspa_hashes=@{&open_sso_files(\@final_files, $uppercase_seq_name, $write_each_mspa_to_disk,
																																					"u=$upper_expect_limit", $new_format, $add_range, $add_range2, $big_out_mspa, $over_write)};

									&write_mspa_files(@mspa_hashes, $big_out_mspa); ## concatenates all the hash ref to one
						 }
				 }
		 }
		 return(\@written_mspa_files);
}# end of


#______________________________________________________________________________
# Title     : sso_to_mspa
# Usage     : &sso_to_mspa(@ARGV, $single_out_opt);
# Function  : This takes sso file(s) and produces MSP file. It
#             concatenate sso file contents when more than one
#             sso file is given.
# Example   : &sso_to_mspa(@ARGV, 'OUT.mspa', $single_out_opt);
# Warning   : This capitalize all the input file names when
#              producing xxxxx.mspa. xxxxx.sso -> XXXX.sso
# Keywords  : sso_file_to_mspa_file, convert_sso_to_mspa,
# Options   : _  for debugging.
#             #  for debugging.
#             v  for showing the MSP result to screen
#             s  for making single MSP file for each sso file
#                    as well as big MSP file which has all sso
#             u= for upper expectation value limit
#             l= for lower expect val limit
#             s= for single file name input eg. "s=xxxxx.mspa"
#             n  for new format (mspa2 format)
#             r  for adding range
#             r2 for adding ranges in all sequence names
#
# Returns   : the file names created (xxxx.mspa, yyyy.mspa,,,,)
# Argument  :
# Category  :
# Version   : 2.6
#-----------------------------------------------------------------------------
sub sso_to_mspa{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my ($upper_expect_limit, $lower_expect_limit)=(50, 0);
	 my (%sso, @sso, @SSO, $big_out_mspa1,  @final_out, $big_out_mspa2,
	   $create_sso, $single_out_opt, $add_range, $add_range2, $big_out_mspa,
	   $Evalue_thresh, $new_format, $Score_thresh, $margin, $single_file_name);
	if($vars{'u'}=~/([\.\d]+)/){ $upper_expect_limit = $vars{'u'} };
	if($vars{'l'}=~/([\.\d]+)/){ $lower_expect_limit = $vars{'l'} };
	if($vars{'t'}=~/(\d+)/){ $Score_thresh  = $vars{'t'} };
	if($vars{'m'}=~/(\d+)/){ $margin  = $vars{'m'} };
	if($vars{'s'}=~/\S/){ $single_file_name  = $vars{'s'} };
	if($char_opt=~/r2/){  $add_range='r'; $add_range2='r2' }
	if($char_opt=~/r/){   $add_range = 'r' }
	if($char_opt=~/c/){   $create_sso = 'c' }
	if($char_opt=~/s/){   $single_out_opt='s' }
	if($char_opt=~/n/){   $new_format='n' }
	 print "\n# File given to sso_to_mspa is \"@file\", Normally xxx.sso file names\n";

	 if($single_file_name=~/\S/){
	   $big_out_mspa=$single_file_name;
	 }else{
	   for($i=0; $i < @file; $i++){
		   if($file[$i]=~/\.mspa$/){ ## when output file name is given
			   $big_out_mspa=$file[$i];
			   splice(@file, $i, 1);
			   $i--;
		   }elsif($file[$i]=~/^(\d+\-\d+)([_\d]*)\.[mfs]?sso/){  ## creates xxxx.mspa file name from xxxx.sso
			   $big_out_mspa1="\U$1"."$2"."\.mspa";
			   $big_out_mspa2="\U$1".".mspa";
		   }elsif($file[$i]=~/^(\S+)\.[mfs]?sso$/){
			   $big_out_mspa1="\U$1"."\.mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
			   print "\n# sso_to_mspa: File matched  xxxx.sso  format \n";
		   }elsif($file[$i]=~/^(\S+)\.out$/){
			   $big_out_mspa1="\U$1"."\.mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
			   print "\n# sso_to_mspa: File matched  xxxx.out  format \n";
		   }elsif($file[$i]=~/^(\S+)\.p[rot\,]*\.ts\.gz/){
			   $big_out_mspa1="\U$1".".mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
		   }elsif($file[$i]=~/^(\S+)\.ts\.gz/){
			   $big_out_mspa1="\U$1".".mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
		   }elsif($file[$i]=~/^(\S+)\.out\.gz/ or $file[$i]=~/^(\S+)\.[mfs]?sso\.gz/){
			   $big_out_mspa1="\U$1".".mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
		   }
	   }
	 }
	 if(defined($big_out_mspa)){
	   $big_out_mspa1=$big_out_mspa2=$big_out_mspa;
	   print "\n# \$big_out_mspa is defined as \'$big_out_mspa\'\n";
	 }else{
	   print "\n# sso_to_mspa: You did not define the big MSP file out format, so $big_out_mspa1 \n";
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  (1) When File was given to this sub routine
	 #__________________________________________
	 if(@file == 1){   ## ONE single file input??
	  print "# one file @file is given, OUT will be: $big_out_mspa1 \n";
	  @sso=@{&open_sso_files(@file, $add_range, $add_range2,
	          "u=$upper_expect_limit",
			  "l=$lower_expect_limit",
			  "m=$margin",
			  $new_format,
			  "s=$big_out_mspa")};
	  push(@final_out, &write_mspa_files(@sso, $big_out_mspa1,
	        $single_out_opt, $add_range) );

	 }elsif(@file > 1){ ## MOre than 1 file input??
	  @sso=@{&open_sso_files(@file, $add_range, $add_range2,
	        "l=$lower_expect_limit",
	        "u=$upper_expect_limit",
	        "m=$margin",
	        $new_format)};
	  push(@final_out, @{&write_mspa_files(@sso, $big_out_mspa2,
			$single_out_opt, $add_range)} ); ## concatenates all the hash ref to one
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  (2) When NO File but ARRAY is given
	 #      Here, you can have SSO files created
	 #__________________________________________
	 elsif(@array >=1){
	  print "\n# In sso_to_mspa, \@array is given rather than \@file";
	  @sso=@{&open_sso_files(@array, "u=$upper_expect_limit", $add_range2,
			  "l=$lower_expect_limit", $add_range, $create_sso,
			  "m=$margin", $new_format)};
	  push(@final_out, @{&write_mspa_files(@sso, $big_out_mspa,
						  $single_out_opt, $add_range)} );
	 }
	 return(\@final_out);
}



#______________________________________________________________________________
# Title     : convert_sso_to_mspa
# Usage     : &convert_sso_to_mspa(@ARGV, $single_out_opt);
# Function  : This takes sso file(s) and produces MSP file. It
#             concatenate sso file contents when more than one
#             sso file is given.
# Example   : &convert_sso_to_mspa(@ARGV, 'OUT.mspa', $single_out_opt);
# Warning   : This capitalize all the input file names when
#              producing xxxxx.mspa. xxxxx.sso -> XXXX.sso
# Keywords  : sso_file_to_mspa_file, convert_sso_to_mspa,
# Options   : _  for debugging.
#             #  for debugging.
#             v  for showing the MSP result to screen
#             s  for making single MSP file for each sso file
#                    as well as big MSP file which has all sso
#             u= for upper expectation value limit
#             l= for lower expect val limit
#             s= for single file name input eg. "s=xxxxx.mspa"
#             n  for new format (mspa2 format)
#             r  for adding range
#             r2 for adding ranges in all sequence names
#
# Returns   : the file names created (xxxx.mspa, yyyy.mspa,,,,)
# Argument  :
# Category  :
# Version   : 2.6
#-----------------------------------------------------------------------------
sub convert_sso_to_mspa{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my ($upper_expect_limit, $lower_expect_limit)=(50, 0);
	 my (%sso, @sso, @SSO, $big_out_mspa1,  @final_out, $big_out_mspa2,
	   $create_sso, $single_out_opt, $add_range, $add_range2, $big_out_mspa,
	   $Evalue_thresh, $new_format, $Score_thresh, $margin, $single_file_name);
	if($vars{'u'}=~/([\.\d]+)/){ $upper_expect_limit = $vars{'u'} };
	if($vars{'l'}=~/([\.\d]+)/){ $lower_expect_limit = $vars{'l'} };
	if($vars{'t'}=~/(\d+)/){ $Score_thresh  = $vars{'t'} };
	if($vars{'m'}=~/(\d+)/){ $margin  = $vars{'m'} };
	if($vars{'s'}=~/\S/){ $single_file_name  = $vars{'s'} };
	if($char_opt=~/r2/){  $add_range='r'; $add_range2='r2' }
	if($char_opt=~/r/){   $add_range = 'r' }
	if($char_opt=~/c/){   $create_sso = 'c' }
	if($char_opt=~/s/){   $single_out_opt='s' }
	if($char_opt=~/n/){   $new_format='n' }
	 print "\n# File given to convert_sso_to_mspa is \"@file\", Normally xxx.sso file names\n";

	 if($single_file_name=~/\S/){
	   $big_out_mspa=$single_file_name;
	 }else{
	   for($i=0; $i < @file; $i++){
		   if($file[$i]=~/\.mspa$/){ ## when output file name is given
			   $big_out_mspa=$file[$i];
			   splice(@file, $i, 1);
			   $i--;
		   }elsif($file[$i]=~/^(\d+\-\d+)([_\d]*)\.[mfs]?sso/){  ## creates xxxx.mspa file name from xxxx.sso
			   $big_out_mspa1="\U$1"."$2"."\.mspa";
			   $big_out_mspa2="\U$1".".mspa";
		   }elsif($file[$i]=~/^(\S+)\.[mfs]?sso$/){
			   $big_out_mspa1="\U$1"."\.mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
			   print "\n# convert_sso_to_mspa: File matched  xxxx.sso  format \n";
		   }elsif($file[$i]=~/^(\S+)\.out$/){
			   $big_out_mspa1="\U$1"."\.mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
			   print "\n# convert_sso_to_mspa: File matched  xxxx.out  format \n";
		   }elsif($file[$i]=~/^(\S+)\.p[rot\,]*\.ts\.gz/){
			   $big_out_mspa1="\U$1".".mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
		   }elsif($file[$i]=~/^(\S+)\.ts\.gz/){
			   $big_out_mspa1="\U$1".".mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
		   }elsif($file[$i]=~/^(\S+)\.out\.gz/ or $file[$i]=~/^(\S+)\.[mfs]?sso\.gz/){
			   $big_out_mspa1="\U$1".".mspa";
			   $big_out_mspa2="\U$1"."_all".".mspa";
		   }
	   }
	 }
	 if(defined($big_out_mspa)){
	   $big_out_mspa1=$big_out_mspa2=$big_out_mspa;
	   print "\n# \$big_out_mspa is defined as \'$big_out_mspa\'\n";
	 }else{
	   print "\n# convert_sso_to_mspa: You did not define the big MSP file out format, so $big_out_mspa1 \n";
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  (1) When File was given to this sub routine
	 #__________________________________________
	 if(@file == 1){   ## ONE single file input??
	  print "# one file @file is given, OUT will be: $big_out_mspa1 \n";
	  @sso=@{&open_sso_files(@file, $add_range, $add_range2,
	          "u=$upper_expect_limit",
			  "l=$lower_expect_limit",
			  "m=$margin",
			  $new_format,
			  "s=$big_out_mspa")};
	  push(@final_out, &write_mspa_files(@sso, $big_out_mspa1,
	        $single_out_opt, $add_range) );

	 }elsif(@file > 1){ ## MOre than 1 file input??
	  @sso=@{&open_sso_files(@file, $add_range, $add_range2,
	        "l=$lower_expect_limit",
	        "u=$upper_expect_limit",
	        "m=$margin",
	        $new_format)};
	  push(@final_out, @{&write_mspa_files(@sso, $big_out_mspa2,
			$single_out_opt, $add_range)} ); ## concatenates all the hash ref to one
	 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  (2) When NO File but ARRAY is given
	 #      Here, you can have SSO files created
	 #__________________________________________
	 elsif(@array >=1){
	  print "\n# In convert_sso_to_mspa, \@array is given rather than \@file";
	  @sso=@{&open_sso_files(@array, "u=$upper_expect_limit", $add_range2,
			  "l=$lower_expect_limit", $add_range, $create_sso,
			  "m=$margin", $new_format)};
	  push(@final_out, @{&write_mspa_files(@sso, $big_out_mspa,
						  $single_out_opt, $add_range)} );
	 }
	 return(\@final_out);
}


#______________________________________________________________________________
# Title     : backup_config_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub backup_config_files{
    my($HOME_dir, $backup_directory, $date, @target_files, $file, $file_name,
       $destination, @backedup_files);
    $HOME_dir="$ENV{'HOME'}";
    $backup_directory=${$_[0]};
    unless($backup_directory){ $backup_directory= "$HOME_dir/Backup/Conf"; }
    $date=${&get_date_text};
    $backup_directory="$HOME_dir".'/Backup/Conf';
    @target_files=("/etc/hosts", "/etc/fstab", "/etc/passwd",
                   "/etc/httpd/conf/access.conf",
                   "/etc/httpd/conf/srm.conf",
                   "/etc/httpd/conf/httpd.conf",
                   "/etc/group", "$HOME_dir/.bashrc",
                   "$HOME_dir/.fvwm2rc", "$HOME_dir/.profile",
                   "$HOME_dir/.Ted/tedrc", "$HOME_dir/.xinitrc",
                   );
    for $file (@target_files){
      $file_name=${&extract_file_name(\$file)};
      $destination="$backup_directory\/$file_name\_$date";
      &copy_files($file, $destination);
      if(-s $destination){
         print "\n# $destination\t has been made ";
         push(@backedup_files, $destination);
      }
    }
    print "\n";
    return(\@backedup_files);
}



#________________________________________________________________________________
# Title     : bla_to_msf  (this is not used. Use convert_bla_to_msf)
# Usage     : @msf_file_made=@{&bla_to_msf(\@bla_file)};
# Function  : matched each query seq name and if the E value is lower than
#             my arbitrary threshold, I put the subject and target pair
#             alignment into a hash.
#             In later iterations, the latest is replaced
# Example   :
# Keywords  : convert_bla_to_msf
# Options   :
# Author    :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub bla_to_msf{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my ($e_val_threshold)=0.0005;
		my(@template_query_seq, @keys, %alignment_hash, %alignment_hash_query,
			 %alignment_hash_subject);
		$choose_iteration=1;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Opening file
		#______________________________________________
		for($i=0; $i< @file; $i++){
				$file_base_name=${&get_base_names($file[$i])};
				open(BLAST_OUTPUT, $file[$i]);
				while(<BLAST_OUTPUT>){
						if(/^Query=(\S+)/){
								$query_seq=$1;   last;
						}
				}
				close(BLAST_OUTPUT);

				open(BLAST_OUTPUT, $file[$i]);
				while(<BLAST_OUTPUT>){

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						#  Finds the query sequence, resets $start_point and next line
						#____________________________________________
						if(/^Searching\.\.\.\.\.\.\.\.\.\.\./){
																										 $present_iteration++;
																										 if($present_iteration > $choose_iteration){
																													last
																										 }else{
																													%alignment_hash_subject=%alignment_hash_query=();
																										 }
						}elsif(/^\>\s*(\S+)/){
																										 $subject_seq=$1;
																										 $start_point='';
																										 if($alignment_hash_subject{$subject_seq}){
																												 $seq_already_in=1;
																												 $subject_seq='';
																												 next;
																										 }
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# If $subject_seq defined, match the line to get expectation value
						#________________________________________________________________
						elsif($subject_seq
							and /^\s*Score\s*\=\s*(\S+)\s*bits.+\,\s*Expect\s*=\s*(\S+)/i){
								$expect_value=$2;
								unless($alignment_hash_subject{$subject_seq} or $expect_value > $e_val_threshold){
										$alignment_hash_subject{"$subject_seq"}="$expect_value ";
										$alignment_hash_query{"$subject_seq"}="$expect_value ";
								}
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# If $subject_seq defined, and expectation val is less than thresh, match Query seq line,
						#   0.0005 = $e_val_threshold
						#_____________________________________________________________________________________
						elsif($subject_seq and $expect_value < $e_val_threshold and /Query\s+(\d+)\s+(\S+)\s+\d+/){
								if($start_point){
										$alignment_hash_query{"$subject_seq"}.=$2;
								}else{ # If this is the first match of 'query', put dashes according to the start point
										$start_point=$1;
										$alignment_hash_query{"$subject_seq"}.="_"x($start_point-1).$2;
										$alignment_hash_subject{"$subject_seq"}.="_"x($start_point-1);
								}

						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# If $subject_seq defined, and expectation val is less than thresh, match Sbjct seq line
						#_____________________________________________________________________________________
						elsif($subject_seq and $expect_value < $e_val_threshold and /Sbjct\s+\d+\s+(\S+)\s+\d+/){
								$alignment_hash_subject{"$subject_seq"}.=$1;
						}
				}
				close(BLAST_OUTPUT);

				# now in %alignment_hash, I have many pairs like:
				# --------VAVCQNMGIGK--DGNLPWPPLRNEYKYFQR
				# --------WARKNKLGWGFELKGSMPSAPLITEQTYFKD
				# -----------------------KTWFSIPEKNRPLK
				# -----------------------KTWEEIPALDKELK

				$output_msf="$file_base_name\.msf";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
				# sorting the keys and then the first column of hash value(which is evals) and then
				# keys by keys names when the E vals are equal
				# This way, I get:
				# 0 : d8dfr__ query 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				# 1 : d8dfr__ sbjct 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				# 2 : nr_DYR_CHICK query 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				# 3 : nr_DYR_CHICK sbjct 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				#    ...
				#___________________________________________________________________
				@keys= map{ $_->[1] }
							 sort { $a->[0] <=> $b->[0] }
							 map{ $alignment_hash_subject{$_}=~/^(\S+)/ or $_=~/^(\S+)/ ; [$1, $_] }
							 sort keys %alignment_hash_subject;

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
				# Making the final alignments by adjusting gaps in every pairwise step comparison
				# keys   are 'd8dfr__ query',          'd8dfr__ sbjct',,,
				# values are '7e-92 VRSLNSIVAVCQ....', '7e-92 VRSLNSIVAVCQN....'
				#________________________________________________
				$template_query=$alignment_hash_query{$keys[0]};

				if($alignment_hash_query{$keys[0]}=~/^\S+\s+(\S+)/){   @template_query_seq=split(//, $1);       }

				print "\n", @template_query_seq, "\n" if $verbose;


				for($j=0; $j < @keys; $j++){
						my($k, $evalue, @gapped_position, $query_seq, $g);

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# matching query entry and inserting gaps
						#__________________________________________________
						$query_name=$keys[$j];
						if($alignment_hash_query{$query_name}=~/^(\S+)\s+(\S+)$/){
								$evalue=$1;
								$query_seq=$2;       }
						if($query_seq !~/\-/){  next   }

						my @splited_query_seq=split(//, $query_seq);

						$longest_query_seq=@splited_query_seq if @splited_query_seq > $longest_query_seq;

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# skip gaps at the beginning
						#_____________________________________________________
						if($splited_query_seq[0] eq '_'){
								for($k=0; $k < @splited_query_seq; $k++){
										if($splited_query_seq[$k] ne '_' and $splited_query_seq[$k] ne '-'){
												last;
										}
								}
						}

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# Finding all the gapped position and saving them
						#___________________________________________________
						for( $s=$k-1; $s < @splited_query_seq; $s++){
								if($splited_query_seq[$s] eq '-'){
										push(@gapped_position, $s);
								}
						}

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# (1) TEMPLATE: matching sbjct entry and inserting gaps
						#__________________________________________________
						if(@gapped_position < 1){ next }
						for($g=0; $g< @gapped_position; $g++){
								$char_posi=$template_query_seq[$gapped_position[$g]] ;
								if($char_posi ne '-'){
										splice(@template_query_seq, $gapped_position[$g], 0, '-');
								}
						}
						print "\n# gaps are @gapped_position \n" if $verbose;
						@gapped_position=();
						next;
				}

				#print "\n      ", @template_query_seq, "\n The raw subject lines are:\n";

				if($verbose){
						for($k=0; $k< @keys; $k++){
								print $alignment_hash_subject{$keys[$k]}, "\n";
						}
						print "\n The raw QUERY lines\n";
						for($k=0; $k< @keys; $k++){
								print $alignment_hash_query{$keys[$k]}, "\n";
						}
				}

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				# Fixing subject sequences according to template and query seqs
				#____________________________________________________________________
				for($g=0; $g < @keys; $g++){
						 $subject_name=$keys[$g];

						 my($evalue, @splited_subject_seq, @splited_query_seq);

						 $alignment_hash_query{  $subject_name}=~/^(\S+)\s+(\S+)/;
						 @splited_query_seq  =split(//, $2);
						 $alignment_hash_subject{$subject_name}=~/^(\S+)\s+(\S+)/;
						 @splited_subject_seq=split(//, $2);
						 $evalue=$1;

						 for($t=0; $t< @template_query_seq; $t++){
								 if($template_query_seq[$t] ne '-' ){
										 next
								 }elsif($template_query_seq[$t] eq '-'){

										 $char_of_the_position=$splited_query_seq[$t];
										 if($char_of_the_position ne '-' and $char_of_the_position ne '_'){

												 #print "\n# \$t is $t";
												 #print "\n# \$evalue is $evalue\n ==>";
												 #print @splited_query_seq, "\n ==>";
												 #print @splited_subject_seq, "\n ==>";
												 splice(@splited_subject_seq, $t, 0, '-');
												 splice(@splited_query_seq, $t, 0, '-');
												 #print @splited_query_seq, "\n ==>";
												 #print @splited_subject_seq, "\n";
												 next;
										 }elsif($char_of_the_position eq '_'){
												 splice(@splited_subject_seq, 0, 0, '_');
												 splice(@splited_query_seq, 0, 0, '_');

										 }elsif($char_of_the_position eq '-'){
												 next;
										 }
								 }
						 }
						 $new_subject_seq=join('', @splited_subject_seq);
						 $new_query_seq  =join('', @splited_query_seq);
						 #$alignment_hash{$keys[$g]}="$evalue $new_subject_seq";
						 #$alignment_hash{$keys[$g-1]}="$evalue $new_query_seq";
						 $alignment_hash_subject{$subject_name}="$evalue $new_subject_seq";
						 $alignment_hash_query{$subject_name}  ="$evalue $new_query_seq";
				}


				print "\n";print @template_query_seq, "\n" if $verbose;

				for($h=0; $h< @keys; $h++){
						 $subject_name=$keys[$h];
						 $alignment_hash_subject{$subject_name}=~/^(\S+)\s+(\S+)/;
						 #print "\n $alignment_hash_query{$subject_name}";
						 print "\n $alignment_hash_subject{$subject_name}";
						 $final_seq_out{$subject_name}=$2;
				}
				&write_msf(\%final_seq_out, \$output_msf);
				push(@final_out, $output_msf);
		}
		return(\@final_out);
}

#________________________________________________________________________________
# Title     : convert_bla_to_msf
# Usage     : @msf_file_made=@{&convert_bla_to_msf(\@bla_file)};
# Function  : matched each query seq name and if the E value is lower than
#             my arbitrary threshold, I put the subject and target pair
#             alignment into a hash.
#             In later iterations, the latest is replaced
# Example   :
# Keywords  : convert_bla_to_msf
# Options   :
# Author    :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub convert_bla_to_msf{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my ($e_val_threshold)=0.0005;
		my(@template_query_seq, @keys, %alignment_hash, %alignment_hash_query,
			 %alignment_hash_subject);
		$choose_iteration=1;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Opening file
		#______________________________________________
		for($i=0; $i< @file; $i++){
				$file_base_name=${&get_base_names($file[$i])};
				open(BLAST_OUTPUT, $file[$i]);
				while(<BLAST_OUTPUT>){
						if(/^Query=(\S+)/){
								$query_seq=$1;   last;
						}
				}
				close(BLAST_OUTPUT);

				open(BLAST_OUTPUT, $file[$i]);
				while(<BLAST_OUTPUT>){

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						#  Finds the query sequence, resets $start_point and next line
						#____________________________________________
						if(/^Searching\.\.\.\.\.\.\.\.\.\.\./){
								$present_iteration++;
								if($present_iteration > $choose_iteration){
										last
								}else{
										%alignment_hash_subject=%alignment_hash_query=();
								}
						}elsif(/^\>\s*(\S+)/){
								$subject_seq=$1;
								$start_point='';
								if($alignment_hash_subject{$subject_seq}){
										$seq_already_in=1;
										$subject_seq='';
										next;
								}
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# If $subject_seq defined, match the line to get expectation value
						#________________________________________________________________
						elsif($subject_seq
							and /^\s*Score\s*\=\s*(\S+)\s*bits.+\,\s*Expect\s*=\s*(\S+)/i){
								$expect_value=$2;
								unless($alignment_hash_subject{$subject_seq} or $expect_value > $e_val_threshold){
										$alignment_hash_subject{"$subject_seq"}="$expect_value ";
										$alignment_hash_query{"$subject_seq"}="$expect_value ";
								}
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# If $subject_seq defined, and expectation val is less than thresh, match Query seq line,
						#   0.0005 = $e_val_threshold
						#_____________________________________________________________________________________
						elsif($subject_seq and $expect_value < $e_val_threshold and /Query\s+(\d+)\s+(\S+)\s+\d+/){
								if($start_point){
										$alignment_hash_query{"$subject_seq"}.=$2;
								}else{ # If this is the first match of 'query', put dashes according to the start point
										$start_point=$1;
										$alignment_hash_query{"$subject_seq"}.="_"x($start_point-1).$2;
										$alignment_hash_subject{"$subject_seq"}.="_"x($start_point-1);
								}

						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# If $subject_seq defined, and expectation val is less than thresh, match Sbjct seq line
						#_____________________________________________________________________________________
						elsif($subject_seq and $expect_value < $e_val_threshold and /Sbjct\s+\d+\s+(\S+)\s+\d+/){
								$alignment_hash_subject{"$subject_seq"}.=$1;
						}
				}
				close(BLAST_OUTPUT);

				# now in %alignment_hash, I have many pairs like:
				# --------VAVCQNMGIGK--DGNLPWPPLRNEYKYFQR
				# --------WARKNKLGWGFELKGSMPSAPLITEQTYFKD
				# -----------------------KTWFSIPEKNRPLK
				# -----------------------KTWEEIPALDKELK

				$output_msf="$file_base_name\.msf";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
				# sorting the keys and then the first column of hash value(which is evals) and then
				# keys by keys names when the E vals are equal
				# This way, I get:
				# 0 : d8dfr__ query 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				# 1 : d8dfr__ sbjct 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				# 2 : nr_DYR_CHICK query 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				# 3 : nr_DYR_CHICK sbjct 7e-92 VRSLNSIVAVCQNMGIGKDGNLPWPPLRNEYKYFQRMTSTSHVEGKQNAVIM
				#    ...
				#___________________________________________________________________
				@keys= map{ $_->[1] }
							 sort { $a->[0] <=> $b->[0] }
							 map{ $alignment_hash_subject{$_}=~/^(\S+)/ or $_=~/^(\S+)/ ; [$1, $_] }
							 sort keys %alignment_hash_subject;

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
				# Making the final alignments by adjusting gaps in every pairwise step comparison
				# keys   are 'd8dfr__ query',          'd8dfr__ sbjct',,,
				# values are '7e-92 VRSLNSIVAVCQ....', '7e-92 VRSLNSIVAVCQN....'
				#________________________________________________
				$template_query=$alignment_hash_query{$keys[0]};

				if($alignment_hash_query{$keys[0]}=~/^\S+\s+(\S+)/){   @template_query_seq=split(//, $1);       }

				print "\n", @template_query_seq, "\n" if $verbose;


				for($j=0; $j < @keys; $j++){
						my($k, $evalue, @gapped_position, $query_seq, $g);

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# matching query entry and inserting gaps
						#__________________________________________________
						$query_name=$keys[$j];
						if($alignment_hash_query{$query_name}=~/^(\S+)\s+(\S+)$/){
								$evalue=$1;
								$query_seq=$2;       }
						if($query_seq !~/\-/){  next   }

						my @splited_query_seq=split(//, $query_seq);

						$longest_query_seq=@splited_query_seq if @splited_query_seq > $longest_query_seq;

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# skip gaps at the beginning
						#_____________________________________________________
						if($splited_query_seq[0] eq '_'){
								for($k=0; $k < @splited_query_seq; $k++){
										if($splited_query_seq[$k] ne '_' and $splited_query_seq[$k] ne '-'){
												last;
										}
								}
						}

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# Finding all the gapped position and saving them
						#___________________________________________________
						for( $s=$k-1; $s < @splited_query_seq; $s++){
								if($splited_query_seq[$s] eq '-'){
										push(@gapped_position, $s);
								}
						}

						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# (1) TEMPLATE: matching sbjct entry and inserting gaps
						#__________________________________________________
						if(@gapped_position < 1){ next }
						for($g=0; $g< @gapped_position; $g++){
								$char_posi=$template_query_seq[$gapped_position[$g]] ;
								if($char_posi ne '-'){
										splice(@template_query_seq, $gapped_position[$g], 0, '-');
								}
						}
						print "\n# gaps are @gapped_position \n" if $verbose;
						@gapped_position=();
						next;
				}

				#print "\n      ", @template_query_seq, "\n The raw subject lines are:\n";

				if($verbose){
						for($k=0; $k< @keys; $k++){
								print $alignment_hash_subject{$keys[$k]}, "\n";
						}
						print "\n The raw QUERY lines\n";
						for($k=0; $k< @keys; $k++){
								print $alignment_hash_query{$keys[$k]}, "\n";
						}
				}

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				# Fixing subject sequences according to template and query seqs
				#____________________________________________________________________
				for($g=0; $g < @keys; $g++){
						 $subject_name=$keys[$g];

						 my($evalue, @splited_subject_seq, @splited_query_seq);

						 $alignment_hash_query{  $subject_name}=~/^(\S+)\s+(\S+)/;
						 @splited_query_seq  =split(//, $2);
						 $alignment_hash_subject{$subject_name}=~/^(\S+)\s+(\S+)/;
						 @splited_subject_seq=split(//, $2);
						 $evalue=$1;

						 for($t=0; $t< @template_query_seq; $t++){
								 if($template_query_seq[$t] ne '-' ){
										 next
								 }elsif($template_query_seq[$t] eq '-'){

										 $char_of_the_position=$splited_query_seq[$t];
										 if($char_of_the_position ne '-' and $char_of_the_position ne '_'){

												 #print "\n# \$t is $t";
												 #print "\n# \$evalue is $evalue\n ==>";
												 #print @splited_query_seq, "\n ==>";
												 #print @splited_subject_seq, "\n ==>";
												 splice(@splited_subject_seq, $t, 0, '-');
												 splice(@splited_query_seq, $t, 0, '-');
												 #print @splited_query_seq, "\n ==>";
												 #print @splited_subject_seq, "\n";
												 next;
										 }elsif($char_of_the_position eq '_'){
												 splice(@splited_subject_seq, 0, 0, '_');
												 splice(@splited_query_seq, 0, 0, '_');

										 }elsif($char_of_the_position eq '-'){
												 next;
										 }
								 }
						 }
						 $new_subject_seq=join('', @splited_subject_seq);
						 $new_query_seq  =join('', @splited_query_seq);
						 #$alignment_hash{$keys[$g]}="$evalue $new_subject_seq";
						 #$alignment_hash{$keys[$g-1]}="$evalue $new_query_seq";
						 $alignment_hash_subject{$subject_name}="$evalue $new_subject_seq";
						 $alignment_hash_query{$subject_name}  ="$evalue $new_query_seq";
				}


				print "\n";print @template_query_seq, "\n" if $verbose;

				for($h=0; $h< @keys; $h++){
						 $subject_name=$keys[$h];
						 $alignment_hash_subject{$subject_name}=~/^(\S+)\s+(\S+)/;
						 #print "\n $alignment_hash_query{$subject_name}";
						 print "\n $alignment_hash_subject{$subject_name}";
						 $final_seq_out{$subject_name}=$2;
				}
				&write_msf(\%final_seq_out, \$output_msf);
				push(@final_out, $output_msf);
		}
		return(\@final_out);
}



#________________________________________________________________________________
# Title     : convert_html_bla_to_mspa
# Usage     : %hash_out_final=%{&convert_html_bla_to_mspa(\$file, [$Lean_output])};
# Function  : reads in PSI blast output and produces MSP file format.
#             Takes all the good hits below certain threshold in multiple iteration
#             Reports the best evalue with a given sequence name
# Example   : %hash_out=%{&convert_html_bla_to_mspa(\$file)};
# Keywords  : pbla_to_mspa, blast_to_mspa, bla_2_mspa, blastp_to_mspa_format,
#             blast_to_mspa_format, convert_html_bla_to_mspa, convert_html_bla_to_mspa_files
#             bla_to_mspa
# Options   :
#   $pdbd_seq_only  d   for getting dxxxx_ like seq names only(pdb40d names for examp)
#   $all_seq  a         for forcing all seq conversion
#   $which_iteration= by i=    # choose which iteration result you want to take
#   $which_iteration   as just a digit
#   $report_only_the_best=b by b -b
#   $take_only_the_last_iteration=l by l
#   $accumulative_hits_eval_thresh= by e=
#   $genome_seq_only=g      by g
#   $nrdb_seq_only=n        by n
#   $evalue_thresh=         by E=
#   $Accumulate_matches=A   by A -A
#   $Lean_output=L          by L -L  # to remove search output to unclutter
#
# Author    : Sarah Teichmann and Jong Park, jong@biosophy.org
# Version   : 4.2
#--------------------------------------------------------------------------------
sub convert_html_bla_to_mspa{
	 my($i, $j, $k, @lines, $match_string_count,  $line_count, $query_string_count,
			$match_length, $Lean_output,
			$lines, $duplicated_match_count, $new_sorted_name, $sorted_name, $verbose,
			$pdbd_seq_only, $entry_found, $which_iteration, $report_only_the_best,
			$genome_seq_only, $all_seq, $header_found, $accumulative_hits_eval_thresh,
			$take_only_the_last_iteration, $original_query, $nrdb_seq_only,
			$get_the_final_iteration, $read_entry_lines, $verbose, $Accumulate_matches);
	 my $match_leng_thresh=10;
	 ### This localization is critial NOT my, as I use a sub which relies on this
	 local(%hash_out, %accumulative_hits, $file, $score, $score_ori, $evalue,
				 $evalue_ori, $seq_id, $query_range_start, $query_range_stop,
				 $query, $match_string_start, $match_string_stop, $matched,
				 $read_point_found);
	 $duplicated_match_count=0;

	 my $evalue_thresh=$accumulative_hits_eval_thresh=1; ## default eval threshes
	 $query='query_seq'; ## default query seq name, to avoid blank name

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # Processing the input arguments to get file and options etc
	 #_____________________________________________________________
	 for (@_){
			 if(ref $_ eq 'ARRAY'){ @lines =@{$_};
			 }elsif( ref $_ eq 'SCALAR' and -s ${$_} ){ $file=${$_};
			 }elsif( -s $_ ){            $file=$_;
			 }elsif(/^\s*d\s*$/){          $pdbd_seq_only='d'; $all_seq=''; $genome_seq_only='';
					 print "\n $0: convert_html_bla_to_mspa,  You set \$pdbd_seq_only option, I will skip others.\n";
			 }elsif(/^\s*[i=]*(\d+)\s*$/){ $which_iteration=$1;
			 }elsif(/^\s*b\s*$/){          $report_only_the_best='b';
			 }elsif(/^\s*a\s*$/){          $all_seq='a'; $genome_seq_only=''; $pdbd_seq_only=''; $nrdb_seq_only='';
			 }elsif(/^\s*g\s*$/){          $genome_seq_only='g'; $all_seq=''; $pdbd_seq_only='';$nrdb_seq_only='';
			 }elsif(/^\s*n\s*$/){          $nrdb_seq_only='n'; $all_seq=''; $pdbd_seq_only=''; $genome_seq_only='';
			 }elsif(/^\s*l\s*$/){          $take_only_the_last_iteration='l'; }
			 if(/^\s*v\s*$/){          $verbose='v'; }
			 if(/^\s*L\s*$/){          $Lean_output='L'; }
			 if(/e=(\S+)/){          $accumulative_hits_eval_thresh=$1; }
			 if(/E=(\S+)/){          $evalue_thresh=$1;			 }
			 if(/SEQ_NAME=(\S+)/){   $query=$original_query=$SEQ_NAME=$1;  }
			 if(/A$/){               $Accumulate_matches='A';  }
	 }
	 unless($which_iteration){  $get_the_final_iteration=1 }

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
	 # If the input file is gzipped, uncompress it to text file and then open
	 #__________________________________________________________________
	 if($file=~/\.gz\s*$/){
			 open(BLA_FILE, "gunzip -c $file|") || die "\n# $0: Failed to open $file\n";
			 if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;			 }
	 }else{
			 open(BLA_FILE, "$file") || die "\n# $0: convert_html_bla_to_mspa : Failed to open $file\n";
			 if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;			 }
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # UP to NOW is frivalous option handling stuff
	 #_______________________________________________________

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # (1) Main reading in .pbla file (or any extension)
	 #____________________________________________________________________________
	 while(<BLA_FILE>){
			$line_count++;      $lines=$_;  ## putting $_ to $lines var
			if($lines=~/^\s*$/ or $lines=~/^ \s+Length\s+\=\s+\d+\s*$/){      next     }  ## skipping some junk lines

			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (1.1) If I reach the end of the opened file, I use &put_mspa_lines_to_hash_from_bla sub to write the final mspa line and finish
			#________________________________________________________________________________________________________________
			if( eof ){
					 if( $read_point_found <= $which_iteration  or  $get_the_final_iteration){
							 #print "     # (i) <<<< The end of file reached, writing $sorted_name \n\n";
							 @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																				$sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																				$match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																				$take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
							 %hash_out=         %{$out_from_put_mspa_lines[0]};
							 %accumulative_hits=%{$out_from_put_mspa_lines[1]};
							 $read_point_found= $out_from_put_mspa_lines[2];
							 last;
					 }
			}

			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (2) Extracting query seq name(this is the only place to get it)
			#____________________________________________________________
			if($lines=~/^\s*Query=\s+(\S+)/){ $query=$original_query=$1;    next    }
			# Following is to handle the HTML version of PSI output
			if($lines=~/\<\S\>\s*Query=\<\S\>/i){ $query=$original_query=$SEQ_NAME;  next } # <b>Query=</b>
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~
			# (3) 'Searching......done'  line indicates new search step(iteration)
			#_________________________________________________________________________
			if( $lines=~/^\s*Searching\.\.\.+[done]?/i ){
					$read_point_found++;
					#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
					#  (3.3) Following is the KEY part for controlling iteration
					#__________________________________________________________
					if( $which_iteration and $read_point_found < $which_iteration){
							 #print "\n# (INFO) skipped, \$which_iteration: ($which_iteration), \$read_point_found: ($read_point_found)" if $verbose;
							 $match_string_count=$query_string_count=$score=$evalue=$seq_id=$score_ori=$evalue_ori='';
							 $query_range_stop=$query_range_start=$match_string_stop=$mspa_line=$new_sorted_name='';
							 $entry_found=$duplicated_match_count=0;

							 if( !$Accumulate_matches){
									 %hash_out=(); ## this is to remove any discarded pairs in the iteration
							 }
							 #print "\n# (INFO) ===> New iteration ====\$read_point_found: $read_point_found, \$which_iteration:$which_iteration\n";
							 next;
					}elsif( $which_iteration and $read_point_found == $which_iteration){
							 $read_entry_lines=1;  next;
					}elsif( $which_iteration and $read_point_found >  $which_iteration){
							 @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																				$sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																				$match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																				$take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
							 %hash_out=         %{$out_from_put_mspa_lines[0]};
							 %accumulative_hits=%{$out_from_put_mspa_lines[1]};
							 $read_point_found= $out_from_put_mspa_lines[2];
							 last;
					}elsif(!$which_iteration){
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
							 # (3.4) Default situation
							 #____________________________________________________________
							 #print "\n# (WARN) You did not set \$which_iteration option \n\n" if $verbose;
							 if($read_point_found > 1){
											 #print "\n (3.3) Writing the last entry $sorted_name BEFORE next Searching........ line\n";
											 @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																								$sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																								$match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																								$take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
											 %hash_out=         %{$out_from_put_mspa_lines[0]};
											 %accumulative_hits=%{$out_from_put_mspa_lines[1]};
											 $read_point_found= $out_from_put_mspa_lines[2];
							 }
							 $match_string_count=$query_string_count=$score=$evalue=$seq_id=$score_ori=$evalue_ori='';
							 $query_range_stop=$query_range_start=$match_string_stop=$mspa_line=$new_sorted_name='';
							 $entry_found=$duplicated_match_count=0;
							 if( !$Accumulate_matches){  %hash_out=(); $entry_found=0; $duplicated_match_count=0;     }
							 $read_entry_lines=1; ## this is set by 'Searching......' line
							 next;
					}
			}
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (4) '> xxxx '  New sequence entry, '>' starts
			#__________________________________________________________
			elsif($read_entry_lines and $lines=~/uid\=\d+\"\>.+\|([^\|]+)[\|]?\<\/a\>/i){
					$temp_match=$1;
					#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					# (4.0) To get the pdbd seq names only 'dxxx__' sort of thing
					#________________________________________________________
					if($pdbd_seq_only and ($temp_match !~/^pdb_\S+/ and $temp_match !~/^[cde]\d\S+/)  ){
							$entry_found=0; print "\n# NOT pdb seq\n";    next;
					}elsif($genome_seq_only and $temp_match !~/^gn_\S+/){
							$entry_found=0; print "\n# NOT genome seq\n"; next
					}elsif($nrdb_seq_only and $temp_match !~/^nr_\S+/){
							$entry_found=0; print "\n# NOT nrdb\n";      next
					#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
					# (4.1) This is the DEFAULT
					#_____________________________________________________________
					}else{ ## This is default and equivalent to have the $all_seq option on.
							$entry_found=1;
							if($match_string_count){ ## $match_string_count is incremented only by 'Sbjct' line
										@out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																						 $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																						 $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																						 $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
										%hash_out=         %{$out_from_put_mspa_lines[0]};
										%accumulative_hits=%{$out_from_put_mspa_lines[1]};
										$read_point_found= $out_from_put_mspa_lines[2];
										$match_string_count=0;
										$duplicated_match_count=0;
							}

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							#  Only with new seq entry, I count the pair occurrances
							#__________________________________________________________________
							$query=$original_query; $query_string_count='';
							$matched=$temp_match; ## this should be here, after if
							$sorted_name=join(' ', sort($query, $matched) );
					}
					$match_string_count=0;
			}
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (5) Matching  Score =  325 bits (824), Expect = 6e-89           << 2 >>
			#_________________________________________________________________
			elsif( ($entry_found and $lines=~/^\s*Score\s*\=\s*(\S+)\s*bits\s+\(\S+\)\,\s*Expect\s*=\s*(\S+)/i)
					or ($entry_found and $lines=~/^\s*Score\s*\=\s*(\S+)\s*bits.+\,\s*Expect\s*=\s*(\S+)/i)){

					$score_ori=$1;
					$evalue_ori=$2;
					if($evalue_ori=~/^e\-\d\d\d/){ $evalue_ori="1".$evalue_ori; } ## bug fix for short eval in blast distribution

					if($match_string_count){ # $match_string_count is increased when Sbjct word is found
							if($evalue > $evalue_thresh){ $evalue=$evalue_ori; $score=$score_ori; next }
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
							# When Only the first match(best evalue) is required, write mspa line and reset $entry_found var
							#_________________________________________________________________________________________________
							if($report_only_the_best){
									#print "      (5)  \$report_only_the_best is set\n" if $verbose;
									@out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																					 $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																					 $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																					 $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
									%hash_out=         %{$out_from_put_mspa_lines[0]};
									%accumulative_hits=%{$out_from_put_mspa_lines[1]};
									$read_point_found= $out_from_put_mspa_lines[2];
									$entry_found=0; next;
							}else{
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~`
									# duplicated match count means, query matched more than one region of a match seq
									#__________________________________________________________________________________
									$duplicated_match_count++;
									$sorted_name="$sorted_name $duplicated_match_count";
									#print " ====(5) Multiple region for \"$new_sorted_name\" is found =========== e= $evalue\n" if $verbose;
									@out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																					 $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																					 $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																					 $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
									%hash_out=         %{$out_from_put_mspa_lines[0]};
									%accumulative_hits=%{$out_from_put_mspa_lines[1]};
									$read_point_found= $out_from_put_mspa_lines[2];
							}
							$score=$score_ori; $evalue=$evalue_ori;
					}else{
							#print "     (5) \$match_string_count is not set NO write \$evalue_ori $evalue_ori\n" if $verbose;
							$evalue=$evalue_ori; $score=$score_ori;
					} ## to next line

					sub reset_all_the_vars{
						 #print "            !!!!  Reseting all the vars !!!!\n" if $verbose;
						 $query_string_count=$score=$evalue=$seq_id=$query_range_stop=$query_range_start='';
						 $match_string_stop=$mspa_line=$new_sorted_name=$match_string_count='';
					}
			}

			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			# (6) Matching   Identities = 158/158 (100%), Positives = 158/158 (100%)    ,
			#____________________________________________________________________________________
			elsif( $entry_found and $lines=~/^\s*Identities\s+=\s+\S+\/(\S+)\s+\(\s*(\S+)\s*\%\)/i){
					$query_string_count=$match_string_count=0;
					$seq_id=$2/100;
					$match_length=$1;
					if($match_length < $match_leng_thresh){
							#print "     (6) \$match_leng_thresh $match_leng_thresh > \$match_length $match_length" if $verbose;
							$entry_found=0;
							$match_string_count=1;
							next;
					}else{
							#print "     (6) $sorted_name : ABOVE leng thresh. \$seq_id= $seq_id, \$match_length= $match_length\n" if $verbose;
					}
			}
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (7) Matching 'Query: 2 GIRAATSQEINELT..' line    ,
			#_________________________________________________________________
			elsif($entry_found and $lines=~/^\s*Query\:?\s+(\d+)\s+\D+\s+(\d+)/){
					$query_string_count++;
					$query_line_found=1;
					if($query_string_count==1){      $query_range_start=$1;   $query_range_stop =$2;
					}elsif($query_string_count > 1){ $query_range_stop=$2;     }
					#print "        (7) Query: line found: $query\_$query_range_start\-$query_range_stop\n" if $verbose;
			}
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (8) Matching 'Sbjct: 2 GIRAATSQEINELT..' line
			#_________________________________________________________________
			elsif($entry_found and $query_line_found and $lines=~/^\s*Sbjct\:?\s+(\d+)\s+[\w\-]+\s+(\d+)/i){
					$match_string_count++;
					$subject_line_found=1;
					if($match_string_count==1){      $match_string_start=$1;
																					 $match_string_stop =$2;
					}elsif($match_string_count > 1){ $match_string_stop=$2;      }
					#print "        (8) Sbjct: line found: $temp_match\_$match_string_start\-$match_string_stop\n" if $verbose;
			}
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# (9) Matching '   Database: ' line    ,                << END >>
			#_________________________________________________________________
			elsif( ($entry_found and  $lines=~/^\s+Database:\s+\S+/) or eof){ # the very last write
					if($evalue > $evalue_thresh){ last
					}else{
							#print "        <<<< The end of file reached, writing $sorted_name\n" if $verbose;
							@out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
																			 $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
																			 $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
																			 $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
							%hash_out=         %{$out_from_put_mspa_lines[0]};
							%accumulative_hits=%{$out_from_put_mspa_lines[1]};
							$read_point_found= $out_from_put_mspa_lines[2];
							last;
					}
			}
	 }
	 close(BLA_FILE);
	 unless( $take_only_the_last_iteration){
			 print "\n# >> ACCUMULATIVE HITS are reported as you did not set \$take_only_the_last_iteration opt!!\n";
			 %hash_out=(%hash_out, %accumulative_hits);
	 }
	 #&show_hash(\%hash_out) if $verbose;
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
	 # CLeaning up the BLA file if $Lean_output is set
	 #_____________________________________________________
	 $gzipped_search_file="$file\.gz";
	 if($Lean_output ){ ## If Lean_out opt is set and $file exists and %hash_out is not empty, remove $file
			 if(-s $file){
					 unlink($file);  ## removes fam_8_8.pbla etc,
			 }elsif(-s $gzipped_search_file){
					 unlink($gzipped_search_file); ## removes fam_8_8.pbla.gz etc,
			 }else{
					 print "\n# (E) convert_html_bla_to_mspa: tried to remove search out file for \$Lean_output opt,
							 but failed. Something is wrong. Think! or report to jong\@salt2.med.harvard.edu,
							 jong\@mrc-lmb.cam.ac.uk, sat\@mrc-lmb.cam.ac.uk, jong_p\@hotmail.com\n";
							 die;
			 }

	 }
	 return(\%hash_out);
}


#________________________________________________________________________________
# Title     : convert_bla_HTML_to_mspa
# Usage     : %hash_out_final=%{&convert_bla_HTML_to_mspa(\$file, [$Lean_output])};
# Function  : reads in PSI blast output and produces MSP file format.
#             Takes all the good hits below certain threshold in multiple iteration
#             Reports the best evalue with a given sequence name
# Example   : %hash_out=%{&convert_bla_HTML_to_mspa(\$file)};
# Keywords  : pbla_to_mspa, blast_to_mspa, bla_2_mspa, blastp_to_mspa_format,
#             blast_to_mspa_format, convert_bla_HTML_to_mspa, convert_bla_HTML_to_mspa_files
#             bla_to_mspa, convert_bla_to_mspa
# Options   :
#   $pdbd_seq_only  d   for getting dxxxx_ like seq names only(pdb40d names for examp)
#   $all_seq  a         for forcing all seq conversion
#   $which_iteration= by i=    # choose which iteration result you want to take
#   $which_iteration   as just a digit
#   $report_only_the_best=b by b -b
#   $take_only_the_last_iteration=l by l
#   $accumulative_hits_eval_thresh= by e=
#   $genome_seq_only=g      by g
#   $nrdb_seq_only=n        by n
#   $evalue_thresh=         by E=
#   $Accumulate_matches=A   by A -A
#   $Lean_output=L          by L -L  # to remove search output to unclutter
#
# Author    : Sarah Teichmann and Jong Park, jong@salt2.med.harvard.edu
# Version   : 4.7
#--------------------------------------------------------------------------------
sub convert_bla_HTML_to_mspa{
    my($i, $j, $k, @lines, $match_string_count,  $line_count, $query_string_count,
       $match_length, $Lean_output,
       $lines, $duplicated_match_count, $new_sorted_name, $sorted_name, $verbose,
       $pdbd_seq_only, $entry_found, $which_iteration, $report_only_the_best,
       $genome_seq_only, $all_seq, $header_found, $accumulative_hits_eval_thresh,
       $take_only_the_last_iteration, $original_query, $nrdb_seq_only,
       $get_the_final_iteration, $read_entry_lines, $verbose, $Accumulate_matches,
       %good_matches_list, $matched_seq_name, $true_seq_name_found);
    my $match_leng_thresh=10;
    ### This localization is critial NOT my, as I use a sub which relies on this
    local(%hash_out, %accumulative_hits, $file, $score, $score_ori, $evalue,
          $evalue_ori, $seq_id, $query_range_start, $query_range_stop,
          $query, $match_string_start, $match_string_stop, $matched,
          $read_point_found);
    $duplicated_match_count=0;

    my $evalue_thresh=$accumulative_hits_eval_thresh=1; ## default eval threshes
    $query=$original_query='query_seq'; ## default query seq name, to avoid blank name

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Processing the input arguments to get file and options etc
    #_____________________________________________________________
    for (@_){
        if(ref $_ eq 'ARRAY'){ @lines =@{$_};
        }elsif( ref $_ eq 'SCALAR' and -s ${$_} ){ $file=${$_};
        }elsif( -s $_ ){            $file=$_;
        }elsif(/^\s*d\s*$/){          $pdbd_seq_only='d'; $all_seq=''; $genome_seq_only='';
            print "\n $0: convert_bla_HTML_to_mspa,  You set \$pdbd_seq_only option, I will skip others.\n";
        }elsif(/^\s*b\s*$/){          $report_only_the_best='b';
        }elsif(/^\s*a\s*$/){          $all_seq='a'; $genome_seq_only=''; $pdbd_seq_only=''; $nrdb_seq_only='';
        }elsif(/^\s*g\s*$/){          $genome_seq_only='g'; $all_seq=''; $pdbd_seq_only='';$nrdb_seq_only='';
        }elsif(/^\s*n\s*$/){          $nrdb_seq_only='n'; $all_seq=''; $pdbd_seq_only=''; $genome_seq_only=''; }
        if(/^\s*l\s*$/){          $take_only_the_last_iteration='l'; }
        if(/^\s*v\s*$/){          $verbose='v'; }
        if(/^\s*L\s*$/){          $Lean_output='L'; }
        if(/e=(\S+)/){          $accumulative_hits_eval_thresh=$1; }
        if(/E=(\S+)/){          $evalue_thresh=$1;          }
        if(/SEQ_NAME=(\S+)/i){   $query=$original_query=$SEQ_NAME=$1;  }
        if(/A$/){               $Accumulate_matches='A';  }
        if(/^\s*i=\s*(\d+)\s*$/){ $which_iteration=$1; }
     }
     unless($which_iteration){  $get_the_final_iteration=1 }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
     # If the input file is gzipped, uncompress it to text file and then open
     #__________________________________________________________________
     if($file=~/\.gz\s*$/){
         open(BLA_FILE, "gunzip -c $file|") || die "\n# $0: Failed to open $file\n";
         if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;
         }elsif($query eq 'query_seq' and $file=~/(\S+)\.\S+\.gz/){    $query=$original_query=$1;      }
     }else{
         open(BLA_FILE, "$file") || die "\n# $0: convert_bla_HTML_to_mspa : Failed to open $file\n";
         if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;
         }elsif($query eq 'query_seq' and $file=~/(\S+)\.\S+$/){     $query=$original_query=$1;       }
     }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # UP to NOW is frivalous option handling stuff
     #_______________________________________________________

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # (1) Main reading in .pbla file (or any extension)
     #____________________________________________________________________________
     while(<BLA_FILE>){
            $line_count++;      $lines=$_;  ## putting $_ to $lines var
            if($lines=~/^\s*$/ or $lines=~/^ \s+Length\s+\=\s+\d+\s*$/){      next     }  ## skipping some junk lines


            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # (1.1) If I reach the end of the opened file, I use &put_mspa_lines_to_hash_from_bla sub to write the final mspa line and finish
            #________________________________________________________________________________________________________________
            if( eof ){
                 if( $read_point_found <= $which_iteration  or  $get_the_final_iteration){
                      #print "     # (i) <<<< The end of file reached, writing $sorted_name \n\n";
                      @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                                         $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                                         $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                                         $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                      %hash_out=         %{$out_from_put_mspa_lines[0]};
                      %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                      $read_point_found= $out_from_put_mspa_lines[2];
                      last;
                 }
            }

            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # (2) Extracting query seq name(this is the only place to get it)
            #__________________________________________________________________
            if($lines=~/^\s*Query=\s*(\S+)/){ $query=$original_query=$1; $true_seq_name_found=1; next    }
            # Following is to handle the HTML version of PSI output
            if(!$true_seq_name_found and $lines=~/Query=\<\S\>/i){
                  $query=$original_query=$SEQ_NAME;  next } # <b>Query=</b>

            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~
            # (3) 'Searching......done'  line indicates new search step(iteration)
            #_________________________________________________________________________
            if( $lines=~/^\s*Searching\.\.\.\.+[done]?/i ){
                 %good_matches_list=();
                 $read_point_found++;

                 $entry_found=0;
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 #  (3.3) Following is the KEY part for controlling iteration. HTML format result is irrelevant to this
                 #________________________________________________________________________________________________________
                 if( $which_iteration and $read_point_found < $which_iteration){
                      #print "\n# (INFO) skipped, \$which_iteration: ($which_iteration), \$read_point_found: ($read_point_found)" if $verbose;
                      $match_string_count=$query_string_count=$score=$evalue=$seq_id=$score_ori=$evalue_ori='';
                      $query_range_stop=$query_range_start=$match_string_stop=$mspa_line=$new_sorted_name='';
                      $entry_found=$duplicated_match_count=0;

                      if( !$Accumulate_matches){
                              %hash_out=(); ## this is to remove any discarded pairs in the iteration
                      }
                      #print "\n# (INFO) ===> New iteration ====\$read_point_found: $read_point_found, \$which_iteration:$which_iteration\n";
                      next;
                 }elsif( $which_iteration and $read_point_found == $which_iteration){
                      $read_entry_lines=$summary_lines_found=1;
                      next;
                 }elsif( $which_iteration and $read_point_found >  $which_iteration){
                      @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                           $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                           $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                           $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                      %hash_out=         %{$out_from_put_mspa_lines[0]};
                      %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                      $read_point_found= $out_from_put_mspa_lines[2];
                      last;

                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # If you did not set the which iteration option
                 #_________________________________________________________
                 }elsif(!$which_iteration){
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                      # (3.4) Default situation
                      #____________________________________________________________
                      #print "\n# (WARN) You did not set \$which_iteration option \n\n" if $verbose;
                      if($read_point_found > 1){
                            #print "\n (3.3) Writing the last entry $sorted_name BEFORE next Searching........ line\n";
                            @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                                               $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                                               $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                                               $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                            %hash_out=         %{$out_from_put_mspa_lines[0]};
                            %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                            $read_point_found= $out_from_put_mspa_lines[2];
                      }
                      $match_string_count=$query_string_count=$score=$evalue=$seq_id=$score_ori=$evalue_ori='';
                      $query_range_stop=$query_range_start=$match_string_stop=$mspa_line=$new_sorted_name='';
                      $entry_found=$duplicated_match_count=0;
                      if( !$Accumulate_matches){  %hash_out=(); $entry_found=0; $duplicated_match_count=0;     }
                      $read_entry_lines=$summary_lines_found=1; ## this is set by 'Searching......' line
                      next;
                 }
            # $summary_lines_found is set by Searching............ line
            }elsif($summary_lines_found and $lines=~/good_GI\" VALUE = \S+>(\S+)<\/a> .+\d+\s*<\/a>\s+([\d\-e]+)\s*$/){
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
            # reading the search summary lines. Save time by selecting which match to parse
            # VALUE = "350102">prf||0409309A</a>  hemoglobin alpha [Loris tardigradus]                   <a href = #350102> 92</a>  4e-19
            #_________________________________________________________________________________________
                 $matched_seq_name=$1;
                 $match_E_value=$2;
                 if($matched_seq_name=~/pdb\|(\S+)\|(\S+)$/i){ $matched_seq_name="$1$2"
                 }elsif($matched_seq_name=~/^gi\|\S*?\|?([^\|]+)$/i
                    or  $matched_seq_name=~/^\S+\|\S*\|([^\|]+)$/){ $matched_seq_name=$1 }

                 if($match_E_value <= $evalue_thresh){
                     if($pdbd_seq_only and ($matched_seq_name=~/^pdb_/
                        or $matched_seq_name=~/^[cde]\d\w{3,6}/)
                        or $matched_seq_name=~/^ds[\d\_]+$/){
                         $good_matches_list{$matched_seq_name}=$matched_seq_name;
                     }elsif(!$pdbd_seq_only){
                         $good_matches_list{$matched_seq_name}=$matched_seq_name;
                     }
                 }else{
                     next;
                 }
            }elsif($read_entry_lines and $lines=~/\&.+uid=\d+\">(\S+)<\/a> .+/){
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # (4) &uid=00350102">prf||0409309A</a> hemoglobin alpha [Loris tardigradus]
            #__________________________________________________________
                    $temp_match=$1;
                    if($temp_match=~/pdb\|(\S+)\|(\S+)$/i){ $temp_match="$1$2"
                    }elsif($temp_match=~/^gi\|\S*?\|?([^\|]+)$/i
                       or  $temp_match=~/^\S+\|\S*\|([^\|]+)$/){ $temp_match=$1 }
                    $summary_lines_found=0;
                    unless($good_matches_list{$temp_match}){ $entry_found=0; next }

                    $entry_found=1;
                    if($match_string_count){ ## $match_string_count is incremented only by 'Sbjct' line
                          @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                                           $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                                           $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                                           $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                          %hash_out=         %{$out_from_put_mspa_lines[0]};
                          %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                          $read_point_found= $out_from_put_mspa_lines[2];
                          $match_string_count=0;
                          $duplicated_match_count=0;
                    }

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    #  Only with new seq entry, I count the pair occurrances
                    #__________________________________________________________________
                    $query=$original_query; $query_string_count='';
                    $matched=$temp_match; ## this should be here, after if
                    $sorted_name=join(' ', sort($query, $matched) );
                    $match_string_count=0;
            }elsif($entry_found){
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # (5) Matching  Score =  325 bits (824), Expect = 6e-89           << 2 >>
                #________________________________________________________________________________
                if( $lines=~/^\s*Score\s*\=\s*(\S+)\s*bits\s+\(\S+\)\,\s*Expect\s*=\s*(\S+)/i
                    or $lines=~/^\s*Score\s*\=\s*(\S+)\s*bits.+\,\s*Expect\s*=\s*(\S+)/i){

                    $score_ori=$1;
                    $evalue_ori=$2;
                    if($evalue_ori=~/^e\-\d\d\d/){ $evalue_ori="1".$evalue_ori; } ## bug fix for short eval in blast distribution

                    if($match_string_count){ # $match_string_count is increased when Sbjct word is found
                            if($evalue > $evalue_thresh){ $evalue=$evalue_ori; $score=$score_ori; next }
                            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                            # When Only the first match(best evalue) is required, write mspa line and reset $entry_found var
                            #_________________________________________________________________________________________________
                            if($report_only_the_best){
                                    #print "      (5)  \$report_only_the_best is set\n" if $verbose;
                                    @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                                                     $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                                                     $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                                                     $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                                    %hash_out=         %{$out_from_put_mspa_lines[0]};
                                    %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                                    $read_point_found= $out_from_put_mspa_lines[2];
                                    $entry_found=0; next;
                            }else{
                                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~`
                                    # duplicated match count means, query matched more than one region of a match seq
                                    #__________________________________________________________________________________
                                    $duplicated_match_count++;
                                    $sorted_name="$sorted_name $duplicated_match_count";
                                    #print " ====(5) Multiple region for \"$new_sorted_name\" is found =========== e= $evalue\n" if $verbose;
                                    @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                                                     $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                                                     $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                                                     $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                                    %hash_out=         %{$out_from_put_mspa_lines[0]};
                                    %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                                    $read_point_found= $out_from_put_mspa_lines[2];
                            }
                            $score=$score_ori; $evalue=$evalue_ori;
                    }else{
                            #print "     (5) \$match_string_count is not set NO write \$evalue_ori $evalue_ori\n" if $verbose;
                            $evalue=$evalue_ori; $score=$score_ori;
                    } ## to next line

                    sub reset_all_the_vars{
                         #print "            !!!!  Reseting all the vars !!!!\n" if $verbose;
                         $query_string_count=$score=$evalue=$seq_id=$query_range_stop=$query_range_start='';
                         $match_string_stop=$mspa_line=$new_sorted_name=$match_string_count='';
                    }
            }
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
            # (6) Matching   Identities = 158/158 (100%), Positives = 158/158 (100%)    ,
            #____________________________________________________________________________________
            elsif( $lines=~/^\s*Identities\s+=\s+\S+\/(\S+)\s+\(\s*(\S+)\s*\%\)/i){
                 $query_string_count=$match_string_count=0;
                 $seq_id=$2/100;
                 $match_length=$1;
                 if($match_length < $match_leng_thresh){
                         #print "     (6) \$match_leng_thresh $match_leng_thresh > \$match_length $match_length" if $verbose;
                         $entry_found=0;
                         $match_string_count=1;
                         next;
                 }else{
                         #print "     (6) $sorted_name : ABOVE leng thresh. \$seq_id= $seq_id, \$match_length= $match_length\n" if $verbose;
                 }
            }
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # (7) Matching 'Query: 2 GIRAATSQEINELT..' line    ,
            #_________________________________________________________________
            elsif($lines=~/^\s*Query\:?\s+(\d+)\s+\D+\s+(\d+)/){
                 $query_string_count++;
                 $query_line_found=1;
                 if($query_string_count==1){      $query_range_start=$1;   $query_range_stop =$2;
                 }elsif($query_string_count > 1){ $query_range_stop=$2;     }
                 #print "        (7) Query: line found: $query\_$query_range_start\-$query_range_stop\n" if $verbose;
            }
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # (8) Matching 'Sbjct: 2 GIRAATSQEINELT..' line
            #_________________________________________________________________
            elsif($query_line_found and $lines=~/^\s*Sbjct\:?\s+(\d+)\s+[\w\-]+\s+(\d+)/i){
                 $match_string_count++;
                 $subject_line_found=1;
                 if($match_string_count==1){      $match_string_start=$1;
                                                                                  $match_string_stop =$2;
                 }elsif($match_string_count > 1){ $match_string_stop=$2;      }
                 #print "        (8) Sbjct: line found: $temp_match\_$match_string_start\-$match_string_stop\n" if $verbose;
            }
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # (9) Matching '   Database: ' line    ,                << END >>
            #_________________________________________________________________
            elsif( $lines=~/CPU time:/ or $lines=~/^\s+Database:\s+\S+/ or eof){ # the very last write
                 if($evalue > $evalue_thresh){ last
                 }else{
                      #print "        <<<< The end of file reached, writing $sorted_name\n" if $verbose;
                      @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out, \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                                                       $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                                                       $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                                                                       $take_only_the_last_iteration, $accumulative_hits_eval_thresh, $evalue_thresh)};
                      %hash_out=         %{$out_from_put_mspa_lines[0]};
                      %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                      $read_point_found= $out_from_put_mspa_lines[2];
                      last;
                 }
            }elsif($lines=~/^\s+\*+\s+No hits found\s+\*+/i){
                 print "\n $lines \n";
                 last;
            }
         }
     }
     close(BLA_FILE);
     unless( $take_only_the_last_iteration){
             print "\n# >> ACCUMULATIVE HITS are reported as you did not set \$take_only_the_last_iteration opt!!\n";
             %hash_out=(%hash_out, %accumulative_hits);
     }
     #&show_hash(\%hash_out) if $verbose;
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
     # CLeaning up the BLA file if $Lean_output is set
     #_____________________________________________________
     $gzipped_search_file="$file\.gz";
     if($Lean_output ){ ## If Lean_out opt is set and $file exists and %hash_out is not empty, remove $file
          if(-s $file){
                  unlink($file);  ## removes fam_8_8.pbla etc,
          }elsif(-s $gzipped_search_file){
                  unlink($gzipped_search_file); ## removes fam_8_8.pbla.gz etc,
          }else{
                  print "\n# (E) convert_bla_HTML_to_mspa: tried to remove search out file for \$Lean_output opt,
                          but failed. Something is wrong. Think! or report to jong\@salt2.med.harvard.edu,
                          jong\@mrc-lmb.cam.ac.uk, sat\@mrc-lmb.cam.ac.uk, jong_p\@hotmail.com\n";
                          die;
          }
     }
     return(\%hash_out);
}


#________________________________________________________________________________
# Title     : convert_bla_to_MSPA_file_format
# Usage     : %hash_out_final=%{&convert_bla_to_MSPA_file_format(\$file, [$Lean_output])};
# Function  : reads in PSI blast output and produces MSPA file format.
#             Takes all the good hits below certain threshold in multiple iteration
#             Reports the best evalue with a given sequence name
# Example   : %hash_out=%{&convert_bla_to_MSPA_file_format(\$file)};
# Keywords  : pbla_to_mspaa, blast_to_mspaa, bla_2_mspaa, blastp_to_mspaa_format,
#             blast_to_mspaa_format, convert_bla_to_MSPA_file_format, convert_bla_to_MSPA_file_format_files
#             bla_to_mspaa
# Options   :
#   $pdbd_seq_only  d   for getting dxxxx_ like seq names only(pdb40d names for examp)
#   $all_seq  a         for forcing all seq conversion
#   $which_iteration= by i=    # choose which iteration result you want to take
#   $which_iteration   as just a digit
#   $report_only_the_best=b by b -b
#   $take_last_iter_PSI_BLA=l by l
#   $PSI_BLA_ACCUMU_hits_eval_thresh= by e=
#   $genome_seq_only=g      by g
#   $nrdb_seq_only=n        by n
#   $Evalue_thresh=         by E=
#   $Accumulate_matches=A   by A -A
#   $Lean_output=L          by L -L  # to remove search output to unclutter
#
# Author    : Sarah Teichmann and Jong Park, jong@salt2.med.harvard.edu
# Version   : 5.5
#--------------------------------------------------------------------------------
sub convert_bla_to_MSPA_file_format{
    my($i, $j, $k, @lines, $match_string_count,  $line_count, $query_string_count,
       $match_length, $Lean_output, $SEQ_NAME, $original_query,
       $duplicated_match_count, $new_sorted_name, $sorted_name, $verbose,
       $pdbd_seq_only, $which_iteration, $report_only_the_best,
       $genome_seq_only, $all_seq, $header_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
       $take_last_iter_PSI_BLA, $nrdb_seq_only, $system_mem_size,
       $get_the_final_iteration, $read_entry_lines, $verbose, $Accumulate_matches,
       $CONVERGED_sign_found, $Evalue_limit, $entry_and_alignment_found, $query,
       );
    my $match_leng_thresh=10;
    ### This localization is critial NOT my, as I use a sub which relies on this
    local(%hash_out, %accumulative_hits, $file, $score, $score_ori, $evalue,
          $evalue_ori, $seq_id, $query_range_start, $query_range_stop,
          $match_string_start, $match_string_stop, $matched, $matched_seq_name,
          $read_point_found, $summary_lines_found, $entry_found, %good_matches_list);
    $duplicated_match_count=0;
    $Evalue_thresh=40;
    $Evalue_limit=5;
    $PSI_BLA_ACCUMU_hits_eval_thresh=0.0001; ## default eval threshes
    $query=$original_query='query_seq'; ## default query seq name, to avoid blank name
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Processing the input arguments to get file and options etc
    #_____________________________________________________________
    for (@_){
        if(ref $_ eq 'ARRAY'){ @lines =@{$_};
        }elsif( ref $_ eq 'SCALAR' and -s ${$_} ){ $file=${$_};
        }elsif( -s $_ ){            $file=$_;
        }elsif(/^ *d *$/){          $pdbd_seq_only='d'; $all_seq=''; $genome_seq_only='';
            print "\n $0: convert_bla_to_MSPA_file_format,  You set \$pdbd_seq_only option, I will skip others.\n";
        }elsif(/^ *b *$/){          $report_only_the_best='b';
        }elsif(/^ *a *$/){          $all_seq='a'; $genome_seq_only=''; $pdbd_seq_only=''; $nrdb_seq_only='';
        }elsif(/^ *g *$/){          $genome_seq_only='g'; $all_seq=''; $pdbd_seq_only='';$nrdb_seq_only='';
        }elsif(/^ *n *$/){          $nrdb_seq_only='n'; $all_seq=''; $pdbd_seq_only=''; $genome_seq_only=''; }
        if(/^ *l *$/){          $take_last_iter_PSI_BLA='l'; $Accumulate_matches='' }
        if(/^ *v *$/){          $verbose='v'; }
        if(/^ *L *$/){          $Lean_output='L'; }
        if(/^\s*e=(\S+)/){          $evalue_thresh=$1; }
        if(/^\s*SEQ_NAME=(\S+)/i){  $query=$original_query=$SEQ_NAME=$1;  }
        if(/^\s*E=(\S+)\s*/){       $Evalue_limit=$1;          }
        if(/^\s*A$/){           $Accumulate_matches='A'; $take_last_iter_PSI_BLA=''; }
        if(/^ *i= *(\d+) *$/){ $which_iteration=$1; }
     }
     unless($which_iteration){  $get_the_final_iteration=1 }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
     # If the input file is gzipped, uncompress it to text file and then open
     #__________________________________________________________________
     if($file=~/\.gz *$/){
         open(BLA_FILE, "gunzip -c $file|") || die "\n# $0: Failed to open $file\n\n\n";
         if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;          }
     }else{
         open(BLA_FILE, "$file") || die "\n# !! $0: convert_bla_to_MSPA_file_format : Failed to open \"$file\"\n\n\n";
         if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;          }
     }

     ###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~###
     ###                                                                           ###
     ###  (1) Main reading in .pbla file (or any extension)                        ###
     ###   by putting pattern matches which occur most, I can save comparisons     ###
     ###___________________________________________________________________________###
     while(<BLA_FILE>){
         unless(/^(\S+) .{30,} +\d+ +([\d\.e\-]+)\s*$/ or /^\s*$/){ ## remove summary and NEW lines to reduce memory takeup
            push(@lines, $_);
         }
     }
     close(BLA_FILE);
     BLA2: for ($i=0; $i< @lines; $i++){
         if($lines[$i]=~/^Query=\s+(\S+)/){  $query=$original_query=$1; $i++;
         }elsif($lines[$i]=~/\<\S\>\s{,4}Query=\<\S\>/i){  $query=$original_query=$SEQ_NAME; $i++;  }
         if($lines[$i]=~/^Database:\s+(\S+)/){         $source_DB=$1;  $i++;       }
         if($lines[$i]=~/^Searching\.\..+[done]?/i){   $which_iteration++;
            splice(@lines, 0, $i); $i=0;
         }

         MATCH_FOUND:
         if($lines[$i]=~/^\>(\S+)/){
              $matched=$1;
              if($matched !~/\|/){
              }elsif($matched=~/pdb\|(\S+)\|(\S+)$/i){ $matched="$1$2"
              }elsif($matched=~/^gi\|\S*?\|?([^\|]+)$/i
                 or  $matched=~/^\S+\|\S*\|([^\|]+)$/){ $matched=$1 }

              $i+=2;
              until( $lines[$i]=~/^\s+Score/){  $i++;  }
              if( $lines[$i]=~/^\s+Score\s+=\s+(\S+)\s+bits\s+\(\S+\)\,\s+Expect\s+=\s+(\S+)/i
                  or /^\s+Score\s+=\s+(\S+)\s+bits.+\,\s+Expect\s+=\s+(\S+)/i ){
                  ($score, $evalue)=($1, $2);
              }

              if($evalue=~/^e\-\d\d\d/){ $evalue="1".$evalue; } ## bug fix for short eval in blast distribution
              $i++;
              if( $lines[$i]=~/^\s+Identities\s+=\s+\S+\/(\S+)\s+\(\s*(\S+)\s*\%\)/i){
                  $match_length=$1;
                  if($match_length < $match_leng_thresh){  $matched=''; $i+=2; goto MATCH_FOUND;
                  }else{   $seq_id=$2/100;  }
              }
              $i++;

              MATCH_CONTINUED:
              if($lines[$i]=~/^Query\:\s+(\d+)\s+(\D+)\s+(\d+)/){
                   $query_string_count++;
                   $aligned_seq_query .= $2;
                   if($query_string_count==1){  ($query_range_start, $query_range_stop)=($1, $3);
                   }elsif($query_string_count > 1){ $query_range_stop=$3;     }
                   $i+=2;
                   if($lines[$i]=~/^Sbjct\:\s+(\d+)\s+(\D+)\s+(\d+)/i){
                        $match_string_count++;
                        $aligned_seq_match .= $2;
                        if($match_string_count==1){ ($match_string_start, $match_string_stop)=($1, $3);
                        }elsif($match_string_count > 1){ $match_string_stop=$3;      }
                   }
                   $i++;
                   goto MATCH_CONTINUED;
              }
              $sorted_name=join(' ', sort("$query\_$query_range_start\-$query_range_stop",
                                          "$matched\_$match_string_start\-$match_string_stop"));
              if($Evalue_thresh >= $evalue){
                  $read_point_found=$which_iteration;
                  if($hash_out{$sorted_name}=~/^\S+\s+(\S+)\s+\S+/){
                      if($1 > $evalue){
                          $hash_out{$sorted_name}=sprintf("%-s\t%-5s\t%-4s\t%-4s %-s %-s %-3s %-s\t%-8s\t%s %s<=>%s\n",
                                     $score, $evalue, $seq_id, $query_range_start, $query_range_stop,
                                     $query, $match_string_start, $match_string_stop, $matched,
                                     $read_point_found, $aligned_seq_query, $aligned_seq_match);
                      }
                  }else{
                      $hash_out{$sorted_name}=sprintf("%-s\t%-5s\t%-4s\t%-4s %-s %-s %-3s %-s\t%-8s\t%s %s<=>%s\n",
                                 $score, $evalue, $seq_id, $query_range_start, $query_range_stop,
                                 $query, $match_string_start, $match_string_stop, $matched,
                                 $read_point_found, $aligned_seq_query, $aligned_seq_match);
                  }
                  #print ALIGNMENT ">$sorted_name\n$aligned_seq_query\n$aligned_seq_match\n";
              }
              $query_string_count=$score=$evalue=$seq_id=$query_range_stop=$query_range_start=
              $match_string_stop=$mspaa_line=$new_sorted_name=$match_string_count=$aligned_seq_query=$aligned_seq_match='';
              goto MATCH_FOUND;
         }
     }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
     # CLeaning up the BLA file if $Lean_output is set
     #_____________________________________________________
     $gzipped_search_file="$file\.gz";
     if($Lean_output ){ ## If Lean_out opt is set and $file exists and %hash_out is not empty, remove $file
          if(-s $file){
                  unlink($file);  ## removes fam_8_8.pbla etc,
          }elsif(-s $gzipped_search_file){
                  unlink($gzipped_search_file); ## removes fam_8_8.pbla.gz etc,
          }else{
             print "\n# (E) convert_bla_to_MSPA_file_format: tried to remove search out file for \$Lean_output opt,
                   but failed. Something is wrong. Think! or report to jong\@salt2.med.harvard.edu,
                   jong\@mrc-lmb.cam.ac.uk, sat\@mrc-lmb.cam.ac.uk, jong_p\@hotmail.com\n";
                   exit;
          }
     }
     return(\%hash_out);
}





#________________________________________________________________________________
# Title     : convert_bla_to_mspa
# Usage     : %hash_out_final=%{&convert_bla_to_mspa(\$file, [$Lean_output])};
# Function  : reads in PSI blast output and produces MSP file format.
#             Takes all the good hits below certain threshold in multiple iteration
#             Reports the best evalue with a given sequence name
# Example   : %hash_out=%{&convert_bla_to_mspa(\$file)};
# Keywords  : pbla_to_mspa, blast_to_mspa, bla_2_mspa, blastp_to_mspa_format,
#             blast_to_mspa_format, convert_bla_to_mspa, convert_bla_to_mspa_files
#             bla_to_mspa
# Options   :
#   $pdbd_seq_only  d   for getting dxxxx_ like seq names only(pdb40d names for examp)
#   $all_seq  a         for forcing all seq conversion
#   $which_iteration= by i=    # choose which iteration result you want to take
#   $which_iteration   as just a digit
#   $report_only_the_best=b by b -b
#   $take_last_iter_PSI_BLA=l by l
#   $PSI_BLA_ACCUMU_hits_eval_thresh= by e=
#   $genome_seq_only=g      by g
#   $nrdb_seq_only=n        by n
#   $evalue_thresh=         by E=
#   $Accumulate_matches=A   by A -A
#   $Lean_output=L          by L -L  # to remove search output to unclutter
#
# Author    : Sarah Teichmann and Jong Park, jong@salt2.med.harvard.edu
# Version   : 5.2
#--------------------------------------------------------------------------------
sub convert_bla_to_mspa{
    my($i, $j, $k, @lines, $match_string_count,  $line_count, $query_string_count,
       $match_length, $Lean_output, $SEQ_NAME, $original_query,
       $duplicated_match_count, $new_sorted_name, $sorted_name, $verbose,
       $pdbd_seq_only, $which_iteration, $report_only_the_best,
       $genome_seq_only, $all_seq, $header_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
       $take_last_iter_PSI_BLA, $nrdb_seq_only,
       $get_the_final_iteration, $read_entry_lines, $verbose, $Accumulate_matches,
       $CONVERGED_sign_found, $Evalue_limit, $entry_and_alignment_found, $query);
    my $match_leng_thresh=10;
    ### This localization is critial NOT my, as I use a sub which relies on this
    local(%hash_out, %accumulative_hits, $file, $score, $score_ori, $evalue,
          $evalue_ori, $seq_id, $query_range_start, $query_range_stop,
          $match_string_start, $match_string_stop, $matched, $matched_seq_name,
          $read_point_found, $summary_lines_found, $entry_found, %good_matches_list);
    $duplicated_match_count=0;

    $Evalue_limit=5;
    $PSI_BLA_ACCUMU_hits_eval_thresh=0.0001; ## default eval threshes
    $query=$original_query='query_seq'; ## default query seq name, to avoid blank name
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Processing the input arguments to get file and options etc
    #_____________________________________________________________
    for (@_){
        if(ref $_ eq 'ARRAY'){ @lines =@{$_};
        }elsif( ref $_ eq 'SCALAR' and -s ${$_} ){ $file=${$_};
        }elsif( -s $_ ){            $file=$_;
        }elsif(/^\s*d\s*$/){          $pdbd_seq_only='d'; $all_seq=''; $genome_seq_only='';
            print "\n $0: convert_bla_to_mspa,  You set \$pdbd_seq_only option, I will skip others.\n";
        }elsif(/^\s*b\s*$/){          $report_only_the_best='b';
        }elsif(/^\s*a\s*$/){          $all_seq='a'; $genome_seq_only=''; $pdbd_seq_only=''; $nrdb_seq_only='';
        }elsif(/^\s*g\s*$/){          $genome_seq_only='g'; $all_seq=''; $pdbd_seq_only='';$nrdb_seq_only='';
        }elsif(/^\s*n\s*$/){          $nrdb_seq_only='n'; $all_seq=''; $pdbd_seq_only=''; $genome_seq_only=''; }
        if(/^\s*l\s*$/){          $take_last_iter_PSI_BLA='l'; $Accumulate_matches='' }
        if(/^\s*v\s*$/){          $verbose='v'; }
        if(/^\s*L\s*$/){          $Lean_output='L'; }
        if(/^\s*e=(\S+)/){          $PSI_BLA_ACCUMU_hits_eval_thresh=$1; }
        if(/^\s*SEQ_NAME=(\S+)/i){  $query=$original_query=$SEQ_NAME=$1;  }
        if(/^\s*E=(\S+)\s*/){       $Evalue_limit=$1;          }
        if(/^\s*A$/){           $Accumulate_matches='A'; $take_last_iter_PSI_BLA=''; }
        if(/^\s*i=\s*(\d+)\s*$/){ $which_iteration=$1; }
     }
     unless($which_iteration){  $get_the_final_iteration=1 }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
     # If the input file is gzipped, uncompress it to text file and then open
     #__________________________________________________________________
     if($file=~/\.gz\s*$/){
         open(BLA_FILE, "gunzip -c $file|") || die "\n# $0: Failed to open $file\n\n\n";
         if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;          }
     }else{
         open(BLA_FILE, "$file") || die "\n# !! $0: convert_bla_to_mspa : Failed to open \"$file\"\n\n\n";
         if($file=~/^([de]*\d\d*\w\w\w\w\w)\./){         $query=$1;          }
     }
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # UP to NOW is frivalous option handling stuff
     #_______________________________________________________

     ###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~###
     ###                                                                           ###
     ###  (1) Main reading in .pbla file (or any extension)                        ###
     ###   by putting pattern matches which occur most, I can save comparisons     ###
     ###___________________________________________________________________________###
     BLA: while(<BLA_FILE>){

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
         # This is just to skip garbage lines
         #_______________________________________________________
         if(/^\s*$/ or /^ \s+Length\s+\=\s+\d+\s*$/){      next     }  ## skipping some junk lines

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (1) The most important READING HERE!
         #___________________________________________
         if($entry_and_alignment_found or ($summary_lines_found and /^\>\S/)){
              ($matched, $entry_and_alignment_found)
                  =&match_seq_entry_and_alignment_block_in_BLAST_output($original_query);
              $summary_lines_found=0;
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (3) '> xxxx '  New sequence entry, '>' starts
         #__________________________________________________________
         }elsif(/^(\S+)\s.{29,}\s\d+\s+(\S{3,8})\s*$/){   ## mind the size of space!!
              $name_matched=$1;
              $evalue=$2;
              &match_summary_head_lines_in_BLAST_output($name_matched, $evalue);
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~
         # (4) 'Searching......done'  line indicates new search step(iteration)
         #_________________________________________________________________________
         }elsif( /^\s{0,4}Searching\.\.\.+[done]?/i ){
             $which_iteration=&match_Searching_dot_line_in_BLAST_output($which_iteration);
             $summary_lines_found=1;
             next BLA;
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (5) Check if it converged before the given -j value
         #________________________________________________________
         }elsif(/^\s*CONVERGED/){
             $CONVERGED_sign_found=1;
             $which_iteration=$read_point_found;
             $entry_and_alignment_found=1;
             next BLA;
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (6) Extracting query seq name(this is the only place to get it)
         #__________________________________________________________________
         }elsif(/^\s{0,4}Query=\s+(\S+)/){
              $query=$original_query=$1;
              next BLA;
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (6-1) Following is to handle the HTML version of PSI output
         #___________________________________________________________________
         }elsif(/\<\S\>\s*Query=\<\S\>/i){ $query=$original_query=$SEQ_NAME;
             next BLA;  # <b>Query=</b>
         }elsif(eof){
              @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                    \%accumulative_hits, $SEQ_NAME,$matched,$evalue, $score, $seq_id,
                    $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                    $match_string_stop, $read_point_found, $accumulative_hits_eval_thresh,
                    $take_last_iter_PSI_BLA, $accumulative_hits_eval_thresh, $Evalue_limit)};
              %hash_out=         %{$out_from_put_mspa_lines[0]};
              %accumulative_hits=%{$out_from_put_mspa_lines[1]};
              $read_point_found= $out_from_put_mspa_lines[2];
              last;
         }elsif(/^\s+\*+\s+No hits found\s+\*+/i){
              print "\n $_ \n";
              last;
         }
     }
     close(BLA_FILE);

     unless( $take_last_iter_PSI_BLA){
         print "\n# >> ACCUMULATIVE HITS are reported as you did not set \$take_last_iter_PSI_BLA opt!!\n";
         %hash_out=(%hash_out, %accumulative_hits);
     }
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
     # CLeaning up the BLA file if $Lean_output is set
     #_____________________________________________________
     $gzipped_search_file="$file\.gz";
     if($Lean_output ){ ## If Lean_out opt is set and $file exists and %hash_out is not empty, remove $file
          if(-s $file){
                  unlink($file);  ## removes fam_8_8.pbla etc,
          }elsif(-s $gzipped_search_file){
                  unlink($gzipped_search_file); ## removes fam_8_8.pbla.gz etc,
          }else{
             print "\n# (E) convert_bla_to_mspa: tried to remove search out file for \$Lean_output opt,
                   but failed. Something is wrong. Think! or report to jong\@salt2.med.harvard.edu,
                   jong\@mrc-lmb.cam.ac.uk, sat\@mrc-lmb.cam.ac.uk, jong_p\@hotmail.com\n";
                   die;
          }
     }
     return(\%hash_out);

            sub match_summary_head_lines_in_BLAST_output{
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                 # reading the search summary lines. Save time by selecting which match to parse
                 # "d2sga__ 2.35.1.1.3 Protease A [(Streptomyces griseus), strain k1]    273  7e-74"
                 #_________________________________________________________________________________________
                 $matched_seq_name=$_[0];
                 $evalue=$_[1];

                 if($matched_seq_name=~/pdb\|(\S+)\|(\S+)$/i){ $matched_seq_name="$1$2"
                 }elsif($matched_seq_name=~/^gi\|\S*?\|?([^\|]+)$/i
                    or  $matched_seq_name=~/^\S+\|\S*\|([^\|]+)$/){ $matched_seq_name=$1
                 }
                 if($evalue <= $Evalue_limit){
                     if($pdbd_seq_only and ($matched_seq_name=~/^pdb_/
                        or $matched_seq_name=~/^[cde]\d\w{3,6}/)
                        or $matched_seq_name=~/^ds[\d\_]+$/){
                         $good_matches_list{$matched_seq_name}=$matched_seq_name;
                     }elsif(!$pdbd_seq_only){
                         $good_matches_list{$matched_seq_name}=$matched_seq_name;
                     }
                 }
                 return($matched_seq_name, $evalue);
            }

            sub match_seq_entry_and_alignment_block_in_BLAST_output{
                $entry_and_alignment_found=1;
                $original_query=$_[0];

                if(/^\> {0,4}(\S+)/){
                     $temp_match=$1;
                     if($temp_match=~/pdb\|(\S+)\|(\S+)$/i){ $temp_match="$1$2"
                     }elsif($temp_match=~/^gi\|\S*?\|?([^\|]+)$/i
                        or  $temp_match=~/^\S+\|\S*\|([^\|]+)$/){ $temp_match=$1 }

                     unless($good_matches_list{$temp_match}){  next }
                     if($match_string_count){ ## $match_string_count is incremented only by 'Sbjct' line
                           @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                                  \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                  $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                  $match_string_stop, $read_point_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
                                  $take_last_iter_PSI_BLA, $PSI_BLA_ACCUMU_hits_eval_thresh, $Evalue_limit)};
                           %hash_out=         %{$out_from_put_mspa_lines[0]};
                           %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                           $read_point_found= $out_from_put_mspa_lines[2];
                           $match_string_count=0;
                           $duplicated_match_count=0;
                     }

                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     #  Only with new seq entry, I count the pair occurrances
                     #__________________________________________________________________
                     $query=$original_query;
                     $query_string_count='';
                     $matched=$temp_match; ## this should be here, after if
                     $sorted_name=join(' ', sort($query, $matched) );
                     $match_string_count=0;
                }
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # (1) Matching  Score =  325 bits (824), Expect = 6e-89           << 2 >>
                #________________________________________________________________________________
                elsif( /^\s*Score\s*\=\s*(\S+)\s*bits\s+\(\S+\)\,\s*Expect\s*=\s*(\S+)/i
                    or /^\s*Score\s*\=\s*(\S+)\s*bits.+\,\s*Expect\s*=\s*(\S+)/i){
                    $score_ori=$1;  $evalue_ori=$2;
                    if($evalue_ori=~/^e\-\d\d\d/){ $evalue_ori="1".$evalue_ori; } ## bug fix for short eval in blast distribution

                    if($match_string_count){ # $match_string_count is increased when Sbjct word is found
                         if($evalue > $Evalue_limit){ $evalue=$evalue_ori; $score=$score_ori; }
                         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                         # When Only the first match(best evalue) is required, write mspa line and reset $entry_found var
                         #_________________________________________________________________________________________________
                         if($report_only_the_best){
                              #print "      (5)  \$report_only_the_best is set\n" if $verbose;
                              @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                                      \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                      $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                      $match_string_stop, $read_point_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
                                      $take_last_iter_PSI_BLA, $PSI_BLA_ACCUMU_hits_eval_thresh, $Evalue_limit)};
                              %hash_out=         %{$out_from_put_mspa_lines[0]};
                              %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                              $read_point_found= $out_from_put_mspa_lines[2];
                              #$entry_found=0;
                         }else{
                              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~`
                              # duplicated match count means, query matched more than one region of a match seq
                              #__________________________________________________________________________________
                              $duplicated_match_count++;
                              $sorted_name="$sorted_name $duplicated_match_count";
                              @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                                      \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                      $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                      $match_string_stop, $read_point_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
                                      $take_last_iter_PSI_BLA, $PSI_BLA_ACCUMU_hits_eval_thresh, $Evalue_limit)};
                              %hash_out=         %{$out_from_put_mspa_lines[0]};
                              %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                              $read_point_found= $out_from_put_mspa_lines[2];
                         }
                         $score=$score_ori; $evalue=$evalue_ori;
                    }else{
                         $evalue=$evalue_ori; $score=$score_ori;
                    } ## to next line

                    sub reset_all_the_vars{
                         #print "            !!!!  Reseting all the vars !!!!\n" if $verbose;
                         $query_string_count=$score=$evalue=$seq_id=$query_range_stop=$query_range_start='';
                         $match_string_stop=$mspa_line=$new_sorted_name=$match_string_count='';
                     }
                }
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                # (2) Matching   Identities = 158/158 (100%), Positives = 158/158 (100%)    ,
                #____________________________________________________________________________________
                elsif( /^ {0,4}Identities\s+=\s+\S+\/(\S+)\s+\(\s*(\S+)\s*\%\)/i){
                     $query_string_count=$match_string_count=0;
                     $seq_id=$2/100;
                     $match_length=$1;
                     if($match_length < $match_leng_thresh){  $match_string_count=1; }
                }
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # (3) Matching 'Query: 2 GIRAATSQEINELT..' line    ,
                #_________________________________________________________________
                elsif(/^ {0,4}Query\:?\s+(\d+)\s+\D+\s+(\d+)/){
                     $query_string_count++;
                     $query_line_found=1;
                     if($query_string_count==1){      $query_range_start=$1;   $query_range_stop =$2;
                     }elsif($query_string_count > 1){ $query_range_stop=$2;     }
                }
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # (4) Matching 'Sbjct: 2 GIRAATSQEINELT..' line
                #_________________________________________________________________
                elsif($query_line_found and /^ {0,4}Sbjct\:?\s+(\d+)\s+[\w\-]+\s+(\d+)/i){
                     $match_string_count++;
                     $subject_line_found=1;
                     if($match_string_count==1){      $match_string_start=$1;
                                                      $match_string_stop =$2;
                     }elsif($match_string_count > 1){ $match_string_stop=$2;      }
                }
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # (5) Matching '   Database: ' line    ,                << END >>
                #_________________________________________________________________
                elsif(/^\s+Database:\s+\S+/ or eof){ # the very last write
                     if($evalue > $Evalue_limit){
                     }else{
                          @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                                \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                $match_string_stop, $read_point_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
                                $take_last_iter_PSI_BLA, $PSI_BLA_ACCUMU_hits_eval_thresh, $Evalue_limit)};
                          %hash_out=         %{$out_from_put_mspa_lines[0]};
                          %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                          $read_point_found= $out_from_put_mspa_lines[2];
                     }
                }
                return($matched, $entry_and_alignment_found);
             }

             sub match_Searching_dot_line_in_BLAST_output{
                  $which_iteration=$_[0];
                  %good_matches_list=();
                  $read_point_found++;
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                  #  (3.3) Following is the KEY part for controlling iteration
                  #__________________________________________________________
                  if( $read_point_found < $which_iteration){
                       $match_string_count=$query_string_count=$score=$evalue=$seq_id=$score_ori=$evalue_ori='';
                       $query_range_stop=$query_range_start=$match_string_stop=$mspa_line=$new_sorted_name='';
                       $duplicated_match_count=0;
                       if( !$Accumulate_matches){  %hash_out=(); } ## this is to remove any discarded pairs in the iteration
                  }elsif( $read_point_found == $which_iteration){

                  }elsif( $which_iteration and $read_point_found >  $which_iteration){
                       @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                                  \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                  $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                  $match_string_stop, $read_point_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
                                  $take_last_iter_PSI_BLA, $PSI_BLA_ACCUMU_hits_eval_thresh, $Evalue_limit)};
                       %hash_out=         %{$out_from_put_mspa_lines[0]};
                       %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                       $read_point_found= $out_from_put_mspa_lines[2];
                       last;
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # If you did not set the which iteration option
                  #_________________________________________________________
                  }elsif(!$which_iteration){
                       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                       # (3.4) Default situation
                       #____________________________________________________________
                       print "\n# (WARN) You did not set \$which_iteration option \n\n" if $verbose;
                       if($read_point_found > 1){
                             @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
                                    \%accumulative_hits, $query,$matched,$evalue, $score, $seq_id,
                                    $sorted_name, $query_range_start, $query_range_stop,$match_string_start,
                                    $match_string_stop, $read_point_found, $PSI_BLA_ACCUMU_hits_eval_thresh,
                                    $take_last_iter_PSI_BLA, $PSI_BLA_ACCUMU_hits_eval_thresh, $Evalue_limit)};
                             %hash_out=         %{$out_from_put_mspa_lines[0]};
                             %accumulative_hits=%{$out_from_put_mspa_lines[1]};
                             $read_point_found= $out_from_put_mspa_lines[2];
                       }
                       $match_string_count=$query_string_count=$score=$evalue=$seq_id=$score_ori=$evalue_ori='';
                       $query_range_stop=$query_range_start=$match_string_stop=$mspa_line=$new_sorted_name='';
                       $entry_found=$duplicated_match_count=0;
                       if( !$Accumulate_matches){  %hash_out=(); $entry_found=0; $duplicated_match_count=0;     }
                  }
                  return($which_iteration);
             }


}


#______________________________________________________________________________
# Title     : put_commas_in_number
# Usage     :
# Function  :
# Example   :
# Keywords  : commify
# Options   :
# Author    :
# Category  :
# Returns   :
# Version   : 1
#------------------------------------------------------------------------------
sub put_commas_in_number{
    my($input_num, $input_num_rv);
    $input_num=reverse(${$_[0]}) || reverse($_[0]);
    $input_num=~s/(\d\d\d)(?=\d)(?!\d*\.)/$1\,/g;
    $input_num_rv=reverse($input_num);
    return(\$input_num_rv);
}



#______________________________________________________________________________
# Title     : put_numbers_in_bins
# Usage     : @num=@{&put_numbers_in_bins(\@num, <binsize>, <max_num>)};
# Function  : bin numbers
# Example   : @num=@{&put_numbers_in_bins(\@num, 20, 1000)};
# Keywords  : make_bar_charts_with_numbers, bin_numbers
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub put_numbers_in_bins{
    my($i, @numbers, @binned_numbers, $bin_number, $max_number, $final_cal_res);
    @numbers=@{$_[0]};
    $bin_number=$max_number=@numbers;
    if(ref($_[1]) eq 'SCALAR'){
         $bin_number=${$_[1]};
    }else{
       $bin_number=$_[1];
       print "\n# (W) put_numbers_in_bins needs bin number ref as 2nd arg";
    }
    if(ref($_[2]) eq 'SCALAR'){
         $max_number=${$_[2]};
    }else{
       $max_number=$_[2];
       print "\n# (W) put_numbers_in_bins needs bin number ref as 2nd arg\n";
    }
    for($i=0; $i< @numbers; $i++){
       $final_cal_res=($max_number/$bin_number)*int($numbers[$i]*($bin_number/$max_number)+1);
       push(@binned_numbers, $final_cal_res);
    }
    return(\@binned_numbers);
}

#______________________________________________________________________________
# Title     : put_this_process_in_the_background
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub put_this_process_in_the_background{
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Putting the editor into background from nik@tiuk.ti.com
    #__________________________________________________________
    die 0 if fork;         # basic background
    use POSIX qw(setsid);
    setsid();               # disassociate from terminal etc.
}



#______________________________________________________________________________
# Title     : put_mspa_lines_to_hash_from_bla
# Usage     : @out_from_put_mspa_lines=@{&put_mspa_lines_to_hash_from_bla(\%hash_out,
#                                        $query,$matched,$evalue, $score, $seq_id,
#                                        $sorted_name, $query_range_start,
#                                        $query_range_stop,$match_string_start,
#                                        $match_string_stop, $read_point_found,
#                                        $PSI_BLA_ACCUMU_hits_eval_thresh,
#                                        $take_last_iter_PSI_BLA)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.5
#------------------------------------------------------------------------------
sub put_mspa_lines_to_hash_from_bla{
    my (@finale_out, $sorted_name, $mspa_line, $evalue, $score, $matched,
        $seq_id, $query_range_start,$PSI_BLA_ACCUMU_hits_eval_thresh,
        $query_range_stop, $query, $match_string_start, $match_string_stop,
        $read_point_found, %hash_out, %accumulative_hits, $Evalue_thresh);
    $Evalue_thresh=10;
    %hash_out=%{$_[0]};         %accumulative_hits=%{$_[1]};
    $query=$_[2];               $matched=$_[3];
    $evalue=$_[4];              $score=$_[5];
    $seq_id=$_[6];              $sorted_name=$_[7];
    $query_range_start=$_[8];   $query_range_stop =$_[9];
    $match_string_start=$_[10]; $match_string_stop=$_[11];
    $read_point_found=$_[12];   $PSI_BLA_ACCUMU_hits_eval_thresh=$_[13];
    $take_last_iter_PSI_BLA=$_[14];
    $PSI_BLA_ACCUMU_hits_eval_thresh=$_[15];
    $Evalue_thresh=$_[16];
    $query  ="$query\_$query_range_start\-$query_range_stop";

    if($matched !~/^\S+\_\d+\-\d+\s*$/){         $matched="$matched\_$match_string_start\-$match_string_stop";
    }elsif($matched =~/^(\S+)\_\d+\-\d+\s*$/){   $matched="$1\_$match_string_start\-$match_string_stop"; }

    if($score=~/\S/ and $evalue=~/\S/ and $match_string_start=~/\S/ and $Evalue_thresh > $evalue){
        $mspa_line=sprintf("%-6s %-8s %-5s %-5s %-5s %-32s %-5s %-s\t%-s\t%-s\n",
                           $score, $evalue, $seq_id, $query_range_start, $query_range_stop,
                           $query, $match_string_start, $match_string_stop, $matched, $read_point_found);
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # This is where I really put the matches !!!
        #_____________________________________________________
        if($hash_out{$sorted_name}=~/^\S+\s+(\S+)\s+/){
            if($1 >= $evalue){
                $hash_out{$sorted_name}=$mspa_line;
            }
        }else{
            $hash_out{$sorted_name}=$mspa_line;
        }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # This part is to rescue the hits dropped by matrix migration
        #_________________________________________________________________
        if(!$take_last_iter_PSI_BLA and $evalue <= $PSI_BLA_ACCUMU_hits_eval_thresh ){
            if($accumulative_hits{$sorted_name}){
                if($accumulative_hits{$sorted_name}=~/^[\t ]*\S+[\t ]+(\S+)[\t ]/){
                     if($evalue < $1){
                             $accumulative_hits{$sorted_name}=$mspa_line;   }   }
            }else{ $accumulative_hits{$sorted_name}=$mspa_line;     }
        }
    }else{
    }
    @finale_out=(\%hash_out, \%accumulative_hits, $read_point_found, $query,
                 $matched, $evalue, $score, $seq_id, $sorted_name,
                 $query_range_start, $query_range_stop, $match_string_start, $match_string_stop  );
    return(\@finale_out);
}







#________________________________________________________________________________
# Title     : convert_bla_multaln_to_msf
# Usage     : @msf_file_made=@{&convert_bla_multaln_to_msf(\@bla_file, [i=2])};
# Function  : matched each query seq name and if the E value is lower than
#             my arbitrary threshold, I put the subject and target pair
#             alignment into a hash.
#             In later iterations, the latest is replaced,
#              when you use m6 option for PSI blast
#             this adds '00x' extensions to the repeatedly occurring seq names
#
# Example   : @msf_file_made=@{&convert_bla_multaln_to_msf(\@bla_file,
#                                              $verbose, "i=$iteration")};
# Keywords  : psi_blast_to_msf, psi_blast_multaln_to_msf
# Options   :
#   i=$iteration
#   v  for verbose
# Author    :
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------------------
sub convert_bla_multaln_to_msf{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my ($e_val_threshold)=0.0005;
		my(@template_query_seq, @keys, $present_iteration, $blank_line_counter,
			 %alignment_hash_subject, $seq_order, $choose_iteration, %final_output_hash,
			 $seq_name, %seq_names_in_block, $put_alphabet_to_number_only_name);
		$choose_iteration=1;
		if($vars{'i'}=~/(\d+)/){
			 $choose_iteration=$1;
		}
		if($char_opt=~/v/){ $verbose='v' }
		if($char_opt=~/a/){ $put_alphabet_to_number_only_name='a' }

		print "\n# $0: bla_multaln_to_msf, \$choose_iteration is $choose_iteration\n";

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Opening file
		#______________________________________________
		for($i=0; $i< @file; $i++){
				$file_base_name=${&get_base_names($file[$i])};
				print "\n# bla_multaln_to_msf: processing $file[$i]\n";
				my($present_iteration, %seq_names_in_block, $seq_name_ori, $sequence);
				open(BLAST_OUTPUT, $file[$i]);
				while(<BLAST_OUTPUT>){
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						#  Finds the query sequence, resets $start_point and next line
						#____________________________________________
						if(/^Query=\s*(\S+)/){
								$query_seq=$1;
								print "\n# The query sequence is: $query_seq\n";
						}elsif(/^Searching\.\.\.\.\.\.\.\./ or eof){ ### to make sure it gets the last one
								$present_iteration++;
								if($present_iteration > $choose_iteration){
										%final_output_hash=%alignment_hash_subject;
										last;
								}else{
										%final_output_hash=%alignment_hash_subject;
										%alignment_hash_subject=();
										%seq_names_in_block=();
										$seq_order='';
								}
						}elsif(/^(QUERY)\s+\d*\s*(\S\S+)\s*\d*$/){
								%seq_names_in_block=();
								$seq_name=$1;
								$seq_order=$seq_name;
								$seq_names_in_block{$seq_name}++;
								$alignment_hash_subject{$seq_name} .= $2; ## bug fix '.'
						}elsif(/^(\S+)\s+\d+\s+(\S+)\s+\d+\s*$/){
								$seq_name=$seq_name_ori=$1;
								$sequence=$2;

								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
								# This is to replace number only seq names to alphabetical ones
								#_____________________________________________________________
								if($put_alphabet_to_number_only_name and $seq_name=~/^\d+$/){
										$seq_name='T'.$seq_name;
										$seq_name_ori='T'.$seq_name_ori;
								}

								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								# This is to handle multiple identical seq name entry
								#_____________________________________________________
								if($seq_names_in_block{$seq_name} > 0){
									 $seq_name=$seq_name."00$seq_names_in_block{$seq_name}";
								}
								$seq_order.=" $seq_name";
								$alignment_hash_subject{$seq_name}.=$sequence;
								$seq_names_in_block{$seq_name_ori}++; ## NOTE that it is $seq_name_ori not  $seq_name
						}elsif(/^(\S+)\s+(\-+)\s*$/){
								$seq_name=$seq_name_ori=$1;
								$sequence=$2;

								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
								# This is to replace number only seq names to alphabetical ones
								#_____________________________________________________________
								if($put_alphabet_to_number_only_name and $seq_name=~/^\d+$/){
										$seq_name='T'.$seq_name;
										$seq_name_ori='T'.$seq_name_ori;
								}

								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								# This is to handle multiple identical seq name entry
								#_____________________________________________________
								if($seq_names_in_block{$seq_name} > 0){
									 $seq_name=$seq_name."00$seq_names_in_block{$seq_name}";
								}
								$seq_order.=" $seq_name";
								$alignment_hash_subject{$seq_name}.=$sequence;
								$seq_names_in_block{$seq_name_ori}++;  ## NOTE that it is $seq_name_ori not  $seq_name
						}

				}
				close(BLAST_OUTPUT);
				print "\n# finished reading in BLAST output(@file) \n";

				# now in %alignment_hash, I have many pairs like:
				# --------VAVCQNMGIGK--DGNLPWPPLRNEYKYFQR
				# --------WARKNKLGWGFELKGSMPSAPLITEQTYFKD
				# -----------------------KTWFSIPEKNRPLK
				# -----------------------KTWEEIPALDKELK
				print "\n# the seq order is: $seq_order\n" if $verbose;

				$output_msf="$file_base_name\.msf";
				print "\n# $0: running write_msf subroutine\n";
				&write_msf(\%final_output_hash, \$output_msf, "o=$seq_order");
				print "\n# $0: $output_msf is created\n";
				push(@final_out, $output_msf);
		}
		return(\@final_out);
}








#______________________________________________________________
# Title     : get_sub_hash
# Usage     : %sub_hash=%{&get_sub_hash(\%FASTA, \@list)};
# Function  : fetches hash keys and values by giving keys to
#             a hash
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : subhash, sub_hash, get_hash_elements, fetch_sub_hash
#             take_sub_hash, get_hash_by_keys, get_sub_hash_by_keys
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub get_sub_hash{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my (%out_hash, @out_hash_all_ref);
	for($i=0; $i < @hash; $i++){
	   my %hash=%{$hash[$i]};
	   my @keys = keys %hash;
	   for($j=0; $j < @raw_string; $j++){
		  for($l=0; $l < @keys; $l++){
			if($keys[$l] eq $raw_string[$j]){
				$out_hash{$keys[$l]}=$hash{$keys[$l]};
			}
		  }
	   }
	   push(@out_hash_all_ref, \%out_hash);
	}
	if(@out_hash_all_ref > 1){
	   return(@out_hash_all_ref);
	}else{
	   return($out_hash_all_ref[0]);
	}
}



#______________________________________________________________
# Title     : get_smallest_file
# Usage     : $smallest_file_name=${&get_largest_file(@ARGV)};
# Function  : checks the size of files and returns the smallest
#             one's name. If a file is not present in pwd or
#             specified absolute path, it ignores it.
# Example   :
# Keywords  : choose_smallest_file, smallest_file, find_smallest_file
#             get_the_smallest_file, choose_the_smallest_file,
#             fetch_smallest_file, take_smallest_file, get_smaller_file,
# Options   : _  for debugging.
#             #  for debugging.
#             e  for extract the smallest from the input array
#                       leaving it one element less, in this case
#                       there will be two returning refs.
# Category  :
# Version   : 1.3
#--------------------------------------------------------------
sub get_smallest_file{
		my @in;
		if(ref $_[0] eq 'ARRAY'){
	 @in = @{$_[0]};
		}else{
	 @in = @_;
		}
		my $smallest=10000000000;
		my ($smallest_file, $i, $extract_opt);

		for($i=0; $i< @in; $i++){
	if(($in[$i]=~/^\-?e$/i)&&(!(-f $in[$i])) ){
	   $extract_opt=1;
	   splice(@in, $i, 1);
	   $i--;
	}
		}
		for($i=0; $i< @in; $i++){
	my $size=(-s $in[$i]);
	if($size < $smallest){
	   $smallest=$size;
	   if($extract_opt ==1){
		  print "\$extract_opt is $extract_opt \n";
		  push(@in, $smallest_file) if defined($smallest_file);
		  $smallest_file = splice(@in, $i, 1);
		  print "\n $smallest_file \n";
		  $i--;
	   }else{
		  $smallest_file=$in[$i];
	   }
	}
		}
		if($extract_opt==1){
				 return(\$smallest_file, \@in);
		}else{ return(\$smallest_file); }
}

#______________________________________________________________
# Title     : get_largest_file
# Usage     : $largest_file_name=${&get_largest_file(@ARGV)};
# Function  : checks the size of files and returns the largest
#             one's name. If a file is not present in pwd or
#             specified absolute path, it ignores it.
# Example   :
# Keywords  : choose_largest_file, largest_file, find_largest_file
#             get_the_largest_file, choose_the_largest_file, get_biggest_file
#             fetch_largest_file, take_largest_file, get_bigger_file, get_larger_file
# Options   : _  for debugging.
#             #  for debugging.
#             e  for extract the largest from the input array
#                       leaving it one element less, in this case
#                       there will be two returning refs.
# Category  :
# Version   : 1.4
#--------------------------------------------------------------
sub get_largest_file{
		my @in;
		if(ref $_[0] eq 'ARRAY'){
	 @in = @{$_[0]};
		}else{
	 @in = @_;
		}

		my ($largest_file, $largest, $i, $extract_opt);
		for($i=0; $i< @in; $i++){
	if(($in[$i]=~/^\-?e$/i)&&(!(-f $in[$i])) ){
	   $extract_opt=1;
	   splice(@in, $i, 1);
	   $i--;
	}
		}
		for($i=0; $i< @in; $i++){
	my $size=(-s $in[$i]);
	if($size > $largest){
						 $largest=$size;
						 if($extract_opt ==1){
										print "\$extract_opt is $extract_opt \n";
										push(@in, $largest_file) if defined($largest_file);
										$largest_file = splice(@in, $i, 1);
										print "\n $largest_file \n";
										$i--;
						 }else{
										$largest_file=$in[$i];
						 }
				}
		}
		if($extract_opt==1){
	 return(\$largest_file, \@in);
		}else{ return(\$largest_file); }
}



#______________________________________________________________
# Title     : get_sequence_complexity
# Usage     : print "\n", ${&get_sequence_complexity(\$seq)};
# Function  : caculates the single sequence's sequence complexity
#             If the seq given is larger than 20, it divides it into
#             frags of 20 aa and gets the average of it.
# Example   :  ${&get_sequence_complexity(\$seq)};
#             while $seq='TTTTTACDEFGHIKLMNPQRSTVWYAAAAACCCADFADFA'
# Warning   :
# Keywords  : sequence_complexity, calc_sequence_complexity,
#             calc_seq_complexity, get_seq_complexity, seg, get_sequence_entropy
# Options   : _  for debugging.
#             #  for debugging.
#             'w=' for window size as the first arg
# Returns   : Ref. for a scalar digit.
# Argument  : ref. of string.
# Category  :
# Version   : 1.3
#--------------------------------------------------------------
sub get_sequence_complexity{
	 my ($complexity, @seq,$i, $j, @frag);
	 my $win=20;
	 if(ref($_[0]) eq 'ARRAY'){
	  @seq=@{$_[0]};
	 }else{
	  $seq=${$_[0]} || $_[0];
	  @seq=split(//, $seq);
	 }
	 if(defined($_[1])){  $win=${$_[1]} || $_[1]; }

	 if(@seq <= $win){
	 my (%seq, @keys);
	 for($i=0; $i< @seq; $i++){
		$seq{$seq[$i]}++;
	 }
	 @keys= keys %seq;
	 $complexity=@keys/@seq;
	 }else{
	 my @frag=@{&divide_array(\@seq, "s=$win")};
	 my @complexity=();
	 for($i=0; $i < @frag; $i++){
		my (%seq, @keys);
		my @arr=@{$frag[$i]};
		for($j=0; $j< @arr; $j++){
		   $seq{$arr[$j]}++;
		}
		@keys=keys %seq;
		push(@complexity, @keys/$win);
	 }
	 $complexity=${&array_average(\@complexity)};
	 }
	 return(\$complexity);
}


#______________________________________________________________________________
# Title     : calculate_sequence_composition_identity
# Usage     : $ID=${&calculate_sequence_composition_identity(\%hash1, \%hash2)};
# Function  :
# Example   :
#             %hash1=qw(H 1 E 3 C 6);
#             %hash2=qw(H 5 E 2 C 3);
# Keywords  : calculate_composition_identiry, get_composition_identity_of_secture
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub calculate_sequence_composition_identity{
    my(%input_hash1, %input_hash2, %duplicate, $composi_ID,
       $rate_diff_sum, %ratio1, %ratio2, $sum_hash1_occur,
       $sum_hash2_occur, $i, @residue_keys, $final_rate_diff_sum);
    %input_hash1=%{$_[0]};
    %input_hash2=%{$_[1]};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # getting all the residue types (such as H, E, C....).
    #______________________________________________________
    @residue_keys= (keys %input_hash1, keys %input_hash2);
    @residue_keys = grep { ! $duplicate{$_}++ } @residue_keys;

    for($i=0; $i<@residue_keys; $i++){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Calculating the composition similarity (dot product of 2 vectors to get a scalar) %secture_composition_hash
       #_____________________________________________________________________________________________________________
       $sum_hash1_occur+=$input_hash1{$residue_keys[$i]};
       $sum_hash2_occur+=$input_hash2{$residue_keys[$i]};
    }
    if($sum_hash1_occur and $sum_hash2_occur){
       for($i=0; $i<@residue_keys; $i++){
          $ratio1{$residue_keys[$i]}=$input_hash1{$residue_keys[$i]}/$sum_hash1_occur;
          $ratio2{$residue_keys[$i]}=$input_hash2{$residue_keys[$i]}/$sum_hash2_occur;
          $rate_diff_sum += abs($ratio1{$residue_keys[$i]} - $ratio2{$residue_keys[$i]});
       }
       $final_rate_diff_sum=$rate_diff_sum/2;
       $composi_ID = 1 - $final_rate_diff_sum;
    }else{
       die "\n Something is wrong with \%hash1 and \%hash2 \n\n";
    }
    #print "==       $composi_ID ", %input_hash1, " " , %input_hash2, "\n";
    $composi_ID  = sprintf("%-.2f", $composi_ID);
    return(\$composi_ID);
}


#______________________________________________________________________________
# Title     : calculate_protein_structural_domain_interactibility_from_Y2H
# Usage     : $0 pdb100d_1_48.pdbg or pdb100d_1_48.mpfa
# Function  : This takes SCOP domain def file (such as SFINP or MPFA file: pdb100d_1_48.mpfa
#              and calculates the interactibility of superfamilies.
# Example   :
# Keywords  : calculate_SCOP_structural_domain_interactibility
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub calculate_protein_structural_domain_interactibility_from_Y2H{
    my($i, $j, $SFINP_file, @superfam, @sorted, %superfam, $num_member,
       $matched_line, @matched, %duplicate);
    $SFINP_file=$_[0];
    open(SFINP, "<$SFINP_file") || die;
    while(<SFINP>){
        if(/^(\d\S+)\s+(\d\S+)/){
            $superfam1=$1;
            $superfam2=$2;
            $superfam1=~s/_/\./g;
            $superfam2=~s/_/\./g;
            if($superfam1=~/\S/ and $superfam2=~/\S/){
                push(@{$superfam{$superfam1}}, $superfam2);
                push(@{$superfam{$superfam2}}, $superfam1);
            }
        }
    }

    $num_superfam=@superfam=sort keys %superfam;
    for($i=0; $i< @superfam; $i++){
        %duplicate=();
        $num_matches=@matched=grep { ! $duplicate{$_}++ } @{$superfam{$superfam[$i]}};
        $matched_line=join(',', @matched);
        #push(@protein_inter_versatility, "$superfam[$i]\t$num_matches\t@matched");
        push(@protein_inter_versatility, "$superfam[$i]\,$num_matches\,$matched_line");
    }
    @sorted=map {$_->[0]} sort { $b->[1]<=>$a->[1] } map {[$_, /^\d+.\d+.\d+\s+(\d+)/]} @protein_inter_versatility;
    for(@sorted){
       print "$_\n";
    }
    print "\n# number of total superfam: $num_superfam\n";
}



#______________________________________________________________________________
# Title     : calculate_protein_structural_domain_interactibility
# Usage     : $0 pdb100d_1_48.pdbg or pdb100d_1_48.mpfa
# Function  : This takes SCOP domain def file (such as PDBG or MPFA file: pdb100d_1_48.mpfa
#              and calculates the interactibility of superfamilies.
# Example   :
# Keywords  : calculate_SCOP_structural_domain_interactibility
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub calculate_protein_structural_domain_interactibility{
    my($i, $j, $PDBG_file, @superfam, %superfam, $num_member);
    $PDBG_file=$_[0];
    open(PDBG, "<$PDBG_file") || die;
    while(<PDBG>){  if(/>(\S+)\s(\d+\.\d+\.\d+)/){   push(@{$superfam{$2}}, $1);  }   }

    @superfam=sort keys %superfam;

    for($i=0; $i< @superfam; $i++){
       my($whole_protein, $domain_protein, @members, $interactibility);
       $num_member=@members=@{$superfam{$superfam[$i]}};
       #print "\n@members";
       for($j=0; $j< @members; $j++){
          if($members[$j]=~/__$/){
             $whole_protein++;
          }elsif($members[$j]=~/_$/){
             $domain_protein++;
          }elsif($members[$j]=~/[\._]\d$/){ ## >e1avo.7n 1.2
             #$domain_protein++;
             $whole_protein++;
          }elsif($members[$j]=~/[a-z]\d$/i){
             $domain_protein++;
          }
       }
       if($domain_protein < 1){
          $interactibility='All whole chain protein';
          $whole_chain_protein_num++;
          $whole_chain_protein_num_Mem+=$num_member;
       }else{
          $interactibility=sprintf("%-3.2f", $whole_protein/$domain_protein);
          if($interactibility == 0){
             $domainonly_protein_num++;
             $domainonly_protein_num_Mem+=$num_member;
          }else{
             $interactible_protein_domain++;
             $interactible_protein_domain_Mem+=$num_member;
          }
       }
       print "\n$superfam[$i] -> $interactibility ($whole_protein/$domain_protein)";
    }

    $non_interactible_protein=$domainonly_protein_num + $whole_chain_protein_num;
    $non_interactible_protein_Mem=$domainonly_protein_num_Mem + $whole_chain_protein_num_Mem;
    print "\n\n \$domainonly_protein_num is $domainonly_protein_num";
    print "\n \$interactible_protein_domain $interactible_protein_domain (\$non_interactible_protein: $non_interactible_protein)";
    print "\n \$whole_chain_protein_num is $whole_chain_protein_num\n\n";

    $total_Mem_interact =($domainonly_protein_num_Mem+$interactible_protein_domain_Mem+$whole_chain_protein_num_Mem);
    print "\n\n \$domainonly_protein_num_Mem is $domainonly_protein_num_Mem";
    print "\n \$interactible_protein_domain_Mem $interactible_protein_domain_Mem ($non_interactible_protein)";
    print "\n \$whole_chain_protein_num_Mem is $whole_chain_protein_num_Mem (total: $total_Mem_interact)\n\n";

}


#______________________________________________________________________________
# Title     : calculate_versatility_of_domain_interaction
# Usage     : &calculate_versatility_of_domain_interaction($PSDIP_file, $PDBG_file);
# Function  : generates various analysis files
# Example   :
#   PSDIP file is like:
#   PROTEIN_NONINTERACT     d168lb_ d168lc_ 168l  4.0 0 b: c:
#   PROTEIN_NONINTERACT     d168lc_ d168ld_ 168l  4.7 0 c: d:
#   PROTEIN_INTERACT        d168ld_ d168le_ 168l  4.2 5 d: e:
#   PROTEIN_INTERACT        d175la_ d175lb_ 175l a: b:
#   PROTEIN_INTERACT        d176la_ d176lb_ 176l a: b:
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub calculate_versatility_of_domain_interaction{
    my($PSDIP_file,  $PDBG_file, %pdbg, @sorted_pair, %superfam, %superfams,
       $i, %psdip, $superfam1, $superfam2, %superfam_pair_interact, $file1, $file2,
       $total_self_self_inter_pair, %self_nelf_inter, %self_self_inter,
       %superfam_count, @superfams, %superfam_versatility, $num_self_self_inter,
       $ratio_self_inter, $total_r_nelf_inter, $total_r_self_inter,
       @SF_mem_no_vs_Interact_PAIR_no1, @SF_mem_no_vs_Interact_PAIR_no2,
       @SF_mem_no_vs_Interact_PAIR_no3, $member_no, $match_SF_num,$PDBG_type,
       %non_redun_superfam_match, @superfam_matched, %superfam_pair_interact,
       %pdbg_desc, %total_superfam_number, $total_non_interaction_pair, $total_pairing,
       $total_interact_superfam_num);
    $file1=${$_[0]} || $_[0];   $file2 =${$_[1]} || $_[1];
    if($file1=~/\.[pdbg|mpfa]/ and $file2=~/\.psdip/){ $PDBG_file=$file1; $PSDIP_file=$file2
    }elsif($file1=~/\.psdip/ and $file2=~/\.[pdbg|mpfa]/){ $PDBG_file=$file2; $PSDIP_file=$file1 }
    unless(-s $PSDIP_file and -s $PDBG_file){ die "\n I need PSDIP and PDBG file <- calculate_versatility_of_domain_interaction\n";}

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Check what PDBG file(%) was used to add in output file names
    #_________________________________________________________________
    if($PDBG_file=~/pd\w+?(\d+)\w*_/){    $PDBG_type=$1;    }
    open(PDBG, "<$PDBG_file") || die;
    while(<PDBG>){
        if(/\>(\S+)\s(\d+\.\d+\.\d+)\S+\s+(.+)/){
           $pdbg{$1}=$2; $pdbg_desc{$2}.="\t$3\n";
           push(@{$superfam{$2}}, $1);
           $total_superfam_number{$2}++;
        }
    }
    close(PDBG);
    $total_superfam_number=keys %total_superfam_number;

    open(PSDIP, "<$PSDIP_file") || die;
    while(<PSDIP>){
       if(/PROTEIN_INTERACT\s+(\S+)\s+(\S+)/){
           $pdbd1=$1; $pdbd2=$2;
           @sorted_pair=sort($pdbd1, $pdbd2);
           $superfam1=$pdbg{$pdbd1};
           $superfam2=$pdbg{$pdbd2};
           if($superfam1 and $superfam2){
              push(@{$superfam_versatility{$superfam1}}, $superfam2);
              push(@{$superfam_versatility{$superfam2}}, $superfam1);
              if($pdbd1=~/__$/ and $pdbd2=~/__$/){
                  $whole_protein_domain_interact_pair++;
              }elsif($pdbd1=~/[a-z]_$/ and $pdbd2=~/[a-z]_$/){
                  $whole_chain_domain_interact_pair++;
              }else{
                  $whole_domain_domain_interact_pair++;
              }
           }else{ next }
           $psdip{"@sorted_pair"}="@sorted_pair";
           @sorted_superfam=sort ($superfam1, $superfam2);
           $superfam_pair_interact{"@sorted_superfam"}++;
           if($superfam1 eq $superfam2){
              $self_self_inter{$superfam1}=$superfam1;  $total_self_self_inter_pair++;
           }else{
              $self_nelf_inter{$superfam1}=$superfam2;  $total_self_nelf_inter_pair++;
           }
           $superfam_count{$superfam1}++;  $superfam_count{$superfam2}++;
       }elsif(/PROTEIN_NONINTERACT\s+(\S+)\s+(\S+)/){ $total_non_interaction_pair++ }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Creating various files
    #__________________________________________________________________________
    open(SF_mem_no_vs_Interact_PAIR_no, ">SF_mem_no_vs_Interact_PAIR_no\_$PDBG_type\.txt") || die;
    open(SF_member_num_vs_Interact_SF_num, ">SF_member_num_vs_Interact_num\_$PDBG_type\.txt") || die;
    open(ALL_PAIR_vs_SUPERFAM_pair, ">ALL_PAIR_vs_SUPERFAM_pair\_$PDBG_type\.txt") || die;
    open(SUMMARY_FILE, ">versatility_summary_$PDBG_type\.piver") || die ; ## protein interaction versitility
    print SUMMARY_FILE "# made by: calculate_versatility_of_domain_interaction to make piver file\n";
    print SUMMARY_FILE "# Total superfam number: $total_superfam_number in $PDBG_file\n";

    $total_interact_superfam_num=@superfams=sort keys %superfam_versatility;
    for($i=0; $i< @superfams; $i++){
       my(%non_redun_superfam_match);
       unless($superfams[$i]=~/\S+/){ next; }
       $total_pair_inter_for_1_SF=@superfam_matched=@{$superfam_versatility{$superfams[$i]}};
       for($j=0; $j< @superfam_matched; $j++){
           $non_redun_superfam_match{$superfam_matched[$j]}=$superfam_matched[$j];
       }
       $match_SF_num=@non_redun_superfam_match=sort keys %non_redun_superfam_match;
       print SUMMARY_FILE "$superfams[$i] ($superfam_count{$superfams[$i]}) \t$match_SF_num \t@non_redun_superfam_match\n";
       print SUMMARY_FILE "$pdbg_desc{$superfams[$i]}\n";
       $member_no=@{$superfam{$superfams[$i]}};
       print "$superfams[$i]\t$member_no\t$match_SF_num\t$total_pair_inter_for_1_SF\n";
       print ALL_PAIR_vs_SUPERFAM_pair "$match_SF_num\t$total_pair_inter_for_1_SF\n";
       push(@SF_mem_no_vs_Interact_PAIR_no1, $member_no);
       push(@SF_mem_no_vs_Interact_PAIR_no2, $total_pair_inter_for_1_SF);
       push(@SF_mem_no_vs_Interact_PAIR_no3, $superfams[$i]);
       #print SF_mem_no_vs_Interact_PAIR_no "$total_pair_inter_for_1_SF \t$superfam_count{$superfams[$i]}\n";
       $SF_num_vs_INTER_num{$superfam_count{$superfams[$i]}}=$match_SF_num;
    }
    @SF_num_vs_INTER_num=sort {$a<=>$b} keys %SF_num_vs_INTER_num;
    for($i=0; $i< @SF_num_vs_INTER_num; $i++){
       print SF_member_num_vs_Interact_SF_num "$SF_num_vs_INTER_num[$i]\t$SF_num_vs_INTER_num{$SF_num_vs_INTER_num[$i]}\n";
    }
    close(SF_member_num_vs_Interact_num);

    @SF_mem_no_vs_Interact_PAIR_no1= @SF_mem_no_vs_Interact_PAIR_no1;
    for($i=0; $i< @SF_mem_no_vs_Interact_PAIR_no1; $i++){
       print SF_mem_no_vs_Interact_PAIR_no "$SF_mem_no_vs_Interact_PAIR_no1[$i]\t$SF_mem_no_vs_Interact_PAIR_no2[$i]\n";
    }
    close(SF_member_num_vs_Interact_num);
    $num_self_self_inter=@self_self_inter_superfam=sort keys %self_self_inter;
    $num_self_nelf_inter=@self_nelf_inter_superfam=sort keys %self_nelf_inter;
    $ratio_self_inter=$num_self_self_inter/($num_self_self_inter+$num_self_nelf_inter);
    $ratio_nelf_inter=$num_self_nelf_inter/($num_self_self_inter+$num_self_nelf_inter);
    $total_pairing=$total_self_self_inter_pair+$total_self_nelf_inter_pair;
    $total_possible_pairing = $total_pairing + $total_non_interaction_pair;
    $total_r_self_inter  =$total_self_self_inter_pair/$total_pairing;
    $total_r_nelf_inter  =$total_self_nelf_inter_pair/$total_pairing;
    $average_interaction =$total_self_self_inter_pair/$total_possible_pairing;
    $average_interaction_SF=$total_pairing/$total_interact_superfam_num;

    print "\n\$num_self_self_inter : $ratio_self_inter (\$total_self_self_inter_pair: $total_self_self_inter_pair)";
    print "\n\$num_self_nelf_inter : $ratio_nelf_inter (\$total_self_nelf_inter_pair: $total_self_nelf_inter_pair)";
    print "\n\$total_r_self_inter: $total_r_self_inter";
    print "\n\$total_r_nelf_inter: $total_r_nelf_inter\n";
    print "\nSF_mem_no_vs_Interact_PAIR_no\_$PDBG_type.txt ";
    print "\nSF_member_num_vs_Interact_num\_$PDBG_type.txt ";
    print "\nversatility_summary_$PDBG_type\.piver";
    print "\nALL_PAIR_vs_SUPERFAM_pair\_$PDBG_type.txt";
    print "\n# Total superfam number: $total_superfam_number in $PDBG_file";
    print "\n# Total interaction pair number: $total_pairing";
    print "\n# Average interaction all the possible pairs: $average_interaction";
    print "\n# Average interaction for all interacting superfam: $average_interaction_SF ($total_pairing/$total_interact_superfam_num)";
    print "\n# \$total_possible_pairing : $total_possible_pairing";
    print "\n# \$whole_chain_domain_interact_pair : $whole_chain_domain_interact_pair";
    print "\n# \$whole_domain_domain_interact_pair : $whole_domain_domain_interact_pair";
    print "\n\n";

    print SUMMARY_FILE "\n# Total pairing superfam number: $total_superfam_number in $PDBG_file";
    print SUMMARY_FILE "\n# Average interaction for all the possible pairs: $average_interaction";
    print SUMMARY_FILE "\n# Average interaction for all interacting superfam: $average_interaction_SF";
    print SUMMARY_FILE "\n# Total interaction pair number: $total_pairing";
    print SUMMARY_FILE "\n# \$total_possible_pairing : $total_possible_pairing\n";
    print SUMMARY_FILE "\n# \$whole_chain_domain_interact_pair : $whole_chain_domain_interact_pair";
    print SUMMARY_FILE "\n# \$whole_domain_domain_interact_pair : $whole_domain_domain_interact_pair";
    close(SUMMARY_FILE);
}




#______________________________________________________________________________
# Title     : calculate_distance_for_2_points_in_3D
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub calculate_distance_for_2_points_in_3D{
    my(@xyz_coord1, @xyz_coord2, $distance, $diff_x, $diff_y, $diff_z);
    @xyz_coord1=@{$_[0]};
    @xyz_coord2=@{$_[1]};
    $diff_x=abs($xyz_coord1[0] - $xyz_coord2[0]);
    $diff_y=abs($xyz_coord1[1] - $xyz_coord2[1]);
    $diff_z=abs($xyz_coord1[2] - $xyz_coord2[2]);
    $distance=sqrt($diff_x*$diff_x + $diff_y*$diff_y +  $diff_z*$diff_z);
    return(\$distance);
}


#______________________________________________________________________________
# Title     : calculate_ATGC_bases_ratio_window_scan
# Usage     :
# Function  :
# Example   :
# Keywords  : scan_DNA_to_calculate_ATGC_ratio
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.4  Aug. 1999
#------------------------------------------------------------------------------
sub calculate_ATGC_bases_ratio_window_scan{
    my($input_FASTA_file, $base, $strand, %strand, $window_size, $orig_seq,
        $seq_count, $i, $sample_interval, $ratio_deviation, $Final_ratio_file,
        $AT_ratio_atgcr_file, %sum_ATGC, $GC_ratio_atgcr_file, $name, $na_prv,
        $seq_counter);
    $sample_interval =10;
    $input_FASTA_file=${$_[0]} || $_[0];
    $window_size     =${$_[1]} || $_[1];
    $sample_interval =${$_[2]} || $_[2];
    $base=${&get_base_names($input_FASTA_file)};

    print "\n INPUT: $input_FASTA_file, Winsize: $window_size, Sample_Int: $sample_interval \n";
    open(INPUT_FASTA, "<$input_FASTA_file") || die "\n can not open $input_FASTA_file \n\n";
    while(<INPUT_FASTA>){
      if(/\>\s*(\S+)/){ ## eof is for single sequence FASTA input
         if(/\>\s*(\S+(\S)[\-\S]*)/){
            $name=$1;  $strand=$2;
            unless($strand =~/[WC]/){ $strand='_';  }
            $name=~s/\W/\_/g;
            $strand{$strand}=$strand;
         }
         $seq_counter++;
         if($seq_counter == 1){ $na_prv=$name; print "\n>$name Strand $strand. Seq. is processed. Wait!!! \n"; next
         }elsif($seq_counter > 1){
            unless($orig_seq){  $orig_seq=$_;   }
            $na_prv=&write_AT_GC_ratio_and_contents_ratio_files($base, $na_prv,
                                                                $sample_interval,
                                                                $window_size, $orig_seq,
                                                                \%strand);
            $orig_seq='';
         }

      }elsif($name and /^\s*[ATGC]+/i){
         $orig_seq .= $_;
         $na_prv=$name;
      }
    }
    print "\n Doing the last calculation\n";
    $na_prv=&write_AT_GC_ratio_and_contents_ratio_files($base, $na_prv,
                                                           $sample_interval,
                                                           $window_size, $orig_seq,
                                                           \%strand);
    return($seq_counter);
}


#______________________________________________________________________________
# Title     : calculate_composition_profix
# Usage     :
# Function  :
# Example   :
# Keywords  : calculate_composition_identity
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub calculate_composition_prosix{
    local($seqlet_match, $num_of_secture_type);
    $num_of_secture_type=3;
    #$running_av_compos_simil=${$_[0]} || $_[0];
    $seqlet_match=${$_[1]} || $_[1];

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Calculating the composition similarity (dot product of 2 vectors to get a scalar) %secture_composition_hash
    #_____________________________________________________________________________________________________________
    $sum_query_occur=$secture_compos_hash_query{'H'}+
                     $secture_compos_hash_query{'E'}+
                     $secture_compos_hash_query{'C'};
    $sum_match_occur=$secture_compos_hash_match{'H'}+
                     $secture_compos_hash_match{'E'}+
                     $secture_compos_hash_match{'C'};
    $Total_sum_match_occur += $sum_match_occur;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # This if check is necessary as I take only the self-self reverse sectures
    #_____________________________________________________________________________
    if($sum_query_occur and $sum_match_occur){
       print "      (5) Q=", %secture_compos_hash_query, "  M=", %secture_compos_hash_match , "\n";
       print "\n       (6) $Total_sum_match_occur \$seqlet_query_prev : $seqlet_query_prev $sum_query_occur,  \$seqlet_match : $seqlet_match $sum_match_occur\n";
       $ratio_query_H=$secture_compos_hash_query{'H'}/$sum_query_occur;
       $ratio_query_E=$secture_compos_hash_query{'E'}/$sum_query_occur;
       $ratio_query_C=$secture_compos_hash_query{'C'}/$sum_query_occur;
       $ratio_match_H=$secture_compos_hash_match{'H'}/$sum_match_occur;
       $ratio_match_E=$secture_compos_hash_match{'E'}/$sum_match_occur;
       $ratio_match_C=$secture_compos_hash_match{'C'}/$sum_match_occur;

       $rate_diff_H   =abs($ratio_query_H - $ratio_match_H);
       $rate_diff_E   =abs($ratio_query_E - $ratio_match_E);
       $rate_diff_C   =abs($ratio_query_C - $ratio_match_C);
       $rate_diff_sum +=($rate_diff_H + $rate_diff_E + $rate_diff_C)/2;
       $counter++;
       $composition_similarity= ($counter - ($rate_diff_sum))/$counter;
       $running_av_compos_simil=$composition_similarity;
       print "\n, $composition_similarity $running_av_compos_simil \n";
    }
    %secture_compos_hash_query=%secture_compos_hash_match=();
}


#______________________________________________________________________________
# Title     : calculate_scop_domain_alignment_ratios
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub calculate_scop_domain_alignment_ratios{
    my($i, @pdb40d, $pdb40d_file_count, $total_pair_count, $line_count,
       @alignment_ratio, @sorted_ratios, $pdb40d_fasta_file);
    $pdb40d_fasta_file=${$_[0]} || $_[0];

    open(PDB40D, "<$pdb40d_fasta_file") || die "\n Can not open $pdb40d_fasta_file \n";
    while(<PDB40D>){
      if(/\>(\S+)/){
         push(@pdb40d, $1);
      }
    }
    close(PDB40D);
    $pdb40d_entry_num=@pdb40d;
    for($i=0; $i<@pdb40d; $i++){
       if(-s "$pdb40d[$i]\.mspa"){
          $pdb40d_file_count++;
          $total_pair_count += $line_count;
          my($line_count, $query_domain_size, $align_ratio, $alignment_size);
          open(MSP, "<$pdb40d[$i]\.mspa") || die "\n Can not open $pdb40d[$i]\.mspa \n";
          print "\n $i/$pdb40d_entry_num: parsing $pdb40d[$i]\.mspa";
          LOOP: while(<MSP>){
             if(/^\S+\s+(\S+)\s+\S+\s+(\d+)\s+(\d+)/){
                $line_count++;
                if($line_count == 1){
                   if($1 > 0.00005){ print "\n Strange, $1 is too high\n"; next LOOP; }
                   $query_domain_size=$3-$2+1;
                   push(@alignment_ratio, 1);
                }elsif($1 <= 0.0005){
                   $alignment_size=$3-$2+1;
                   $align_ratio=$alignment_size/$query_domain_size;
                   $align_ratio=${&trim_number(\$align_ratio, 2)};
                   if($align_ratio > 1){
                      print "\n$align_ratio: $pdb40d[$i]\.mspa \$alignment_size $alignment_size, \$query_domain_size $query_domain_size\n";
                      $align_ratio=1;
                   }
                   push(@alignment_ratio, $align_ratio);
                }
             }
          }
       }
    }
    print "\n Parsing finished, Writing now\n";
    @sorted_ratios=sort {$a<=>$b} @alignment_ratio;

    open(RATIO, ">domain_seq_alignment_ratio.list") || die "\n Can not create domain_seq_alignment_ratio.list \n";
    for($i=0; $i < @sorted_ratios; $i++){
       print RATIO "$sorted_ratios[$i]\n";
    }
    close(RATIO);
    print "\n \$pdb40d_file_count : $pdb40d_file_count, \$total_pair_count : $total_pair_count\n\n";
    return(\@sorted_ratios);
}


#________________________________________________________________________________
# Title     : calculate_single_linkage_match_with_parf_files
# Usage     :
# Function  : 43 => 1/100,000, 433=> 1/10,000 error rate (RFP) from 432680 possible
#              matches.
# Example   :
#    PARF file looks like this>
#   d1nsca_   d3nn9__   Homolog -664.92 2.43.1.1.3  2.43.1.1.2
#   d1dppa_   d2olba_   Homolog -617.41 3.68.1.1.6  3.68.1.1.1
#   d2ach.1a1 d9api.1a1 Homolog -556.38 5.2.1.1.3   5.2.1.1.4
#
# Keywords  : single_linkage
# Options   :
#       $number_of_Nomologs_to_read= by N=
# Author    :
# Returns   :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub calculate_single_linkage_match_with_parf_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (@parf_file, $number_of_lines_read,  %all_parf_file_hash,
        %parf_hash_homology_info, %parf_hash_score, $possible_combination,
        %parf_hash_classification_column_1, %parf_hash_classification_column_2,
        %parf_hash_Homologous_rank,  %parf_hash_Nomologous_rank, $homolog_counter, $nomolog_counter);

    my $number_of_lines_to_read   = 50000;
    my $number_of_Homologs_to_read= 7000; # 699 is for 1% error in 935 PDB40D
    my $number_of_Nomologs_to_read= 86; # 9 is for 1% error in 935 PDB40D

    if($vars{'l'}=~/\S+/){ $number_of_lines_to_read=$vars{'l'} }
    if($vars{'N'}=~/\S+/){ $number_of_Nomologs_to_read=$vars{'N'} }

    for($i=0; $i< @file; $i++){
        my ($counter);
        if($file[$i]=~/\.parf/i){
            push(@parf_file, $file[$i]);
        }else{
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # Check if it is parf file inside the file
            #__________________________________________________________
            open(INPUT_FILE, "<$file[$i]");
            while(<INPUT_FILE>){
                 $counter++;
                 if(/^\s*\S+\s+\S+\s+[NFUH]omolog\s*\S*\s*\S*\s*\S*/){
                     push(@parf_file, $file[$i]);
                     last;
                 }else{
                     if($counter > 10){  ## giving up, it is not PARF file!
                         print "\n# $0 needs to have PARF files, others are ignored";
                         last;
                     }else{
                         next;
                     }
                 }
            }
            close(INPUT_FILE);
        }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Processing the parf file contents
    #__________________________________________________________
    for($i=0; $i< @parf_file; $i++){
        my(@hash_index_array, $single_linkage_made_with_linkage_hash, $sorted_pair, @sorted_seq_name_pairs);
        open(PARF_FILE, "<$parf_file[$i]");
        while(<PARF_FILE>){
             if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s*(\S*)\s*(\S*)\s*(\S*)/){
                  $number_of_lines_read++;
                  $seq_name1=$1;
                  $seq_name2=$2;
                  $sorted_pair=join('', sort($1, $2));
                  $homology_info=$3;
                  $score=$4;
                  $classification_column_1=$5;
                  $classification_column_2=$6;
                  if($classification_column_1 =~/^(\d+\.\d+\.\d+)\.*\d*\.*\d*/){
                       $superfamily_class=$1;
                  }

                  $single_linkage_made_with_linkage_hash=0; ## this should be reset

                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # Count the NO-HOmology
                  #____________________________________
                  if($homology_info =~/Nomolog/i){
                      $nomolog_counter++;
                  }elsif($homology_info =~/Homolog/i){

                      $homolog_counter++;       #<----- number hash key is crucial !!!

                      #print "$_ $homolog_counter\n";

                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # checks if there were previous entries
                      #_______________________________________________
                      for $j (@hash_index_array){

                          if( $linkage_hash{$j}{$seq_name1} or $linkage_hash{$j}{$seq_name2} ){
                               #print "\n $j : $linkage_hash{$j}{$seq_name1} ";
                               $linkage_hash{$j}{$seq_name1}=$seq_name1;
                               $linkage_hash{$j}{$seq_name2}=$seq_name2;
                               $single_linkage_made_with_linkage_hash=1;
                               last;
                          }
                      }
                      unless($single_linkage_made_with_linkage_hash){
                          $linkage_hash{$homolog_counter}{$seq_name1}=$seq_name1;
                          $linkage_hash{$homolog_counter}{$seq_name2}=$seq_name2;
                          push(@hash_index_array, $homolog_counter);
                      }

                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # Storing matched pairs
                      #__________________________________________
                      $matched_pairs{"$seq_name1 $seq_name2"}="$seq_name1 $seq_name2";
                  }

             }
             if($number_of_lines_read == $number_of_lines_to_read){  last;     }
             if($nomolog_counter == $number_of_Nomologs_to_read){    last;     }
             if($homolog_counter == $number_of_Homologs_to_read){    last;     }
        }
        close(PARF_FILE);

    }
    print "\n";


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # producing result
    #_____________________________________________________
    @keys=sort {$a <=> $b } keys %linkage_hash;

    for($i=0; $i< @keys; $i++){
        $superfamily_member_count =@members=keys %{$linkage_hash{$keys[$i]}};
        $superfamily_member_pairs =$superfamily_member_count*($superfamily_member_count-1)/2;
        $possible_combination += $superfamily_member_pairs;
        %all_pair_hash=%{&get_all_possible_pairs_from_array(\@members)};
        @all_pairs=keys %all_pair_hash;
        print "\n>$keys[$i] $superfamily_member_pairs : @members << $possible_combination";
        for($j=0 ; $j< @all_pairs; $j++){
           if($matched_pairs{$all_pairs[$j]}){
                print "\n      \s*$all_pairs[$j]";
           }else{
                print "\n        $all_pairs[$j]";
           }
        }
        print "\n";
    }
    print "\n";
    print "\n \$homolog_counter : $homolog_counter / $possible_combination\n";


}




#______________________________________________________________________________
# Title     : calc_factorial
# Usage     :
# Function  :
# Example   :
# Keywords  : calculate_factorial, get_factorial
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub calc_factorial{
		my ($number, $factorial, $i);
		$factorial=1;
		if(ref($_[0]) eq 'SCALAR'){
				$number=${$_[0]};
		}else{
				$number=$_[0];
		}
		for($i=1; $i <=$number; $i++){
				$factorial=$factorial*$i;
		}
		return(\$factorial);
}


#______________________________________________________________
# Title     : make_swiss_index
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub make_swiss_index{
	 my ($swiss, %index);
	 if(-e "$ENV{'SWDIR'}seq.dat" ){
	  $swiss="$ENV{'SWDIR'}seq.dat";
	 }elsif( -f "$ENV{'SWISS'}seq.dat" ){
	  $swiss="$ENV{'SWISS'}seq.dat";
	 }elsif( -e 'seq.dat'){
	  $swiss="seq.dat";
	 }elsif( -f "$ENV{'swiss'}seq.dat"){
	  $swiss="$ENV{'swiss'}seq.dat";
	 }else{
	 ASK: print "\n Where is your swissprot seq.dat file?\n";
	  $swiss=<>;
	  chomp($swiss);
	  if(-e "$swiss"){
		 goto OPEN;
	  }else{
		 goto ASK;
	  }
	 }
	 OPEN: open(DB, "$swiss");
	 while(<DB>){

	 if(/^ID\s+(\w+)\s+/){
		$index{$1}=tell(DB);
		print "\n$1 $index{$1}";
	 }
		}
}

#______________________________________________________________________________
# Title     : fetch_seqlet_from_sequence
# Usage     : ($region_substr)=${&fetch_seqlet_from_sequence(\$ori_string, \$range)};
#              $range='10-13 30-33 34-35 36-36';
# Function  :
# Example   :
# Keywords  : get_string_from_string, get_sequence_from_sequence
#             fetch_substring_from_sequence, fetch_substring
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub fetch_seqlet_from_sequence{
    my($original_string, $range, $i, $range, @regions, $temp_orig,
       $start, $stop, $region_size, $fetched_region, $prev_start, $prev_stop);
    $original_string=${$_[0]} || $_[0];

    if(ref($_[1]) eq 'SCALAR'){
       $range=${$_[1]};
       @regions=split(/ +/, $range);
       unless(@regions){ @regions=($range) } ## in the case of ONE single region input
    }elsif(ref($_[1]) eq 'ARRAY'){ @regions=@{$_[1]};
    }else{ $range=$_[1]; @regions=split(/ +/, $range); }

    for($i=0; $i< @regions; $i++){
       $temp_orig=$original_string;
       ($start, $stop)=split(/[\-\_]/, $regions[$i]);
       if($prev_stop >= $start){
          warn "\n Previous region stop is overlaping with new start point @regions\n";
       }
       $region_size=$stop-$start+1;
       $fetched_region .= substr($temp_orig, $start-1,  $region_size);
       ($prev_start, $prev_stop)=($start, $stop);
    }
    return(\$fetched_region);
}




#______________________________________________________________________________
# Title     : fetch_cd2list
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub fetch_cd2list {
        local($cd1,$fsspfile,$stereo)=@_;
                open(IN,$fsspfile) || die "FATAL: bad file name $fsspfile\n";
                while(<IN>) { last if (/^##/); }
                print "<FORM METHOD=\"GET\" ACTION=\"$qz3\">\n\n";
                print $query->h1("Select (check) structural neighbours to display");
                print "<INPUT TYPE=\"submit\" Value=\"3D superimposition\" Name=3D\>";
                print "<INPUT TYPE=\"submit\" Value=\"Multiple alignment (wide)\" Name=1D\>";
                print "<INPUT TYPE=\"submit\" Value=\"Multiple alignment (narrow)\" Name=1Dshort\>";
                 print "<INPUT TYPE=\"submit\" Value=\"Multiple families (wide)\" Name=belvu\>";
                 print "<INPUT TYPE=\"submit\" Value=\"Multiple families (narrow)\" Name=short\>";
                print "<INPUT TYPE=\"reset\" Value=\"Reset selection\">\n";
                # print "<A HREF=$qz3?mode=options&filename=$fsspfile>(Set display options)</A>";
                print "<INPUT TYPE=\"hidden\" NAME=\"filename\" Value=$fsspfile>\n";
                print "<INPUT TYPE=\"hidden\" NAME=\"idecut\" Value=$idecut>\n";
                print "<INPUT TYPE=\"hidden\" NAME=\"stereo\" Value=$stereo>\n";
                $x=<IN>; print "<PRE><B>   ",substr($x,13,33),substr($x,70,50),"</B></PRE>\n";
                print "<PRE>\n";
                undef(@x);
                while(<IN>) {
                        last if(/^\/\//);
                        last if(/^## ALIGNMENTS/);
                        last if(/^## FOOTER/);
                        last if(!/\w/);
                        chop;
                        $long=substr($_,13,6); $cd2=$long; $cd2=~s/-//; $cd2=~s/ //g;
                        ($x,$name)=/ 0\s+0\s+\d+[\sS]+(\d+) [\sS]*(.*)$/;
                        if(!$x) { $domfssp2=$FSSPDIR.$cd2.'.fssp'; }
                        else { $domfssp2=$FSSPDIR.$cd2.'_'.$x.'.fssp'; }
                        if(-e $domfssp2 && $domain) {
#                               ($q,$idom)=/^\s+\d+\: \S+\s+(\S+) .* S \s+(\d+) /; $q.="\:$idom";
                                ($q,$idom)=/^\s+\d+\: \S+\s+(\S+) .* 0\s+0\s+\d+[\sS]+(\d+) /; $q.="\:$idom";
        print "<INPUT TYPE=\"checkbox\" $check Name='cd2list' Value=\"",$q,"\"> ",
"<A HREF=".$qz3."&filename=$domfssp2>$long</A>",substr($_,19,27),$x,' ',$name,"\n";
                        } elsif(-e $domfssp2) {
        print "<INPUT TYPE=\"checkbox\" $check Name='cd2list' Value=\"",$long,"\"> ",
"<A HREF=".$qz3."&filename=$domfssp2>$long</A>",substr($_,19,27),$x,' ',$name,"\n";
                        } else {
        print "<INPUT TYPE=\"checkbox\" $check Name='cd2list' Value=\"",$long,"\"> ",
"$long",substr($_,19,27),$x,' ',$name,"\n";
                        }
                }
                print "</PRE>\n";
                close(IN);
                print "</FORM>\n";
}

#______________________________________________________________________________
# Title     : put_text_page_header
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub put_text_page_header {
        ($header)=@_;
        print<<EOS;
<HEAD><TITLE>EMBL: $header</TITLE></HEAD>
<H1>$header</H1>
<B>Please cite:</B> L. Holm and C. Sander (1996) Science 273(5275):595-60.
EOS
}

#______________________________________________________________________________
# Title     : put_text_page_footer
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub put_text_page_footer {
        print<<EOS;
<HR>
$back
<P>
<P><EM>(C) L. Holm, EMBL-EBI, Hinxton, May 1996</EM>
</BODY>
</HTML>
EOS
}


#_____________________________________________________________________________
# Title     : fetch_sequence_from_db
# Usage     : %sequence=%{&fetch_sequence_from_db($input_file, \@string)};
# Function  : accept seq names (with or without ranges like _10-111 )
#              and produces hash ref.
#             As an option, you can write(xxxx.fasta) the sequences in pwd
#              with the file names with sequence names.
#             The default database used is FASTA format OWL database.
#              You can change this by S (for Swissprot either fasta
#              or full format), P for PDB fasta format data.
#             If you give the path name of DB, it will look for the
#              DB given.
#
#             This automatically checks sequence family number as
#               in >d1bpi___7.6.1
#               and attaches the number in final %sequence output
#
# Example   : %seq=%{&fetch_sequence_from_db(\@input, seq.fasta, seq.fasta.idx)};
#              while @input=qw( 11S3_HELAN_11-31 A1AB_CANFA A1AT_PIG )
# Keywords  : fetch_seq_from_db, fetch_sequence_from_database
# Options   : _  or #  for debugging.
#     w       for write fasta file
#     s=      for putting source DB file name manually
#     d=p100  for PDB100 fasta database from ENV
#     d=p40   for PDB40  fasta database from ENV
#     d=p     for PDB database (usually p100) from ENV
#     d=s     for Swissprot database from ENV
#     d=o     for OWL database from ENV
#     i=      for index filename. If not specified, this looks for it in the same dir as fast     
#     t=      for mspa_threshold
#  mspa_threshold=0.0005  # when MSP file is given as input for getting seq names
#
# Returns   : ref of hash
# Argument  : gets names of sequences
#             eg) \@array, \%hash, \$seq, while @array=(seq1, seq2), $seq='seq1 seq1'
#                                               %hash=(seq1, xxxx, seq2, yyyy);
#
# Version   : 3.8
#------------------------------------------------------------------------------
sub fetch_sequence_from_db{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	my(@DATABASE, @INDEX_FILE, %sequence, %seq_with_index, @input_seq_names,
	   %long_index, @Keys, $R_start, $NAME, $R_leng, $found_seq_count,
	   $eval_blastpgp_thresh, $seq_found1, $sequence, @keys, $index_file,
	   $source_DB_file, $matching_seq, $match_start, $match_stop);

    $eval_blastpgp_thresh=0.001; # default

    if($vars{'mspa_threshold'}=~/(\S+)/ or $vars{'mt'}=~/(\S+)/ or $vars{'t'}=~/(\S+)/ ){
        $eval_blastpgp_thresh=$1;
        print "\n# (INFO) YOU have set the \$eval_blastpgp_thresh $eval_blastpgp_thresh\n\n";
    }
    if($vars{'s'}=~/(\S+)/ or $vars{'DB'}=~/(\S+)/ ){
        $source_DB_file=$1; push(@DATABASE, $source_DB_file);
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# getting input seq names from all sources
	#________________________________________________________
	for(0..@hash){ # from the given hash (keys names)
	     push(@input_seq_names, keys %{$hash[$_]} );
	}
	for(0..@raw_string){  ## from given sequence names
	     push(@input_seq_names, split(/\s+/, $raw_string[$_]) );
	}
    for($i=0; $i<@file; $i++){  ## From MSP file input (get only MATCHED sequences)
        if($file[$i]=~/\.mspa/){
            print "\n# (INFO) MSP file input is detected !\n";
            my ($seq_with_range);
            open(MSP, $file[$i]);
            while(<MSP>){
                 if(/^\s*\S+\s+(\S+)\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(nr_\S+_DROME_\S+)\s+/){
                      push(@input_seq_names, $2) if $1 < $eval_blastpgp_thresh;
                 }elsif(/^\s*\S+\s+(\S+)\s+\S*\s*(\d+)\s+(\d+)\s+\S+\s+(\d+)\s+(\d+)\s+(\S+)\s*/){
                      $matching_seq=$6; $match_start=$4; $match_stop=$5;
                      $evalue=$1;
                      if($matching_seq=~/^(\S+_\d+\-\d+)/){
                          $seq_with_range=$1;
                      }else{
                          $seq_with_range="$matching_seq\_$match_start\-$match_stop";
                      }
                      push(@input_seq_names, $seq_with_range) if $evalue < $eval_blastpgp_thresh;
                      print "\n# (INFO) pushing $seq_with_range" if $verbose;
                 }
            }
            close(MSP);
            splice(@file, $i, 1);
            $i--;
        }
    }

	print "\n# (1) fetch_sequence_from_db: \@raw_string has: ", scalar(@raw_string), " elements";
	print "\n# (2) fetch_sequence_from_db: No. of seq to fetch is:",scalar(@input_seq_names);
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# Choose the DBs and INDEX for fetching sequences. All files input must be DATABAE or INDEXfile
	#___________________________________________
    if(@file > 0){   print "\n# (i) GOOD! Input \@file has \"@file\"";
        for($i=0; $i< @file; $i++){
            if(-T $file[$i] and $file[$i]=~/\.[smp]+fa[sta]?$/){
                push(@DATABASE, $file[$i]);
                if(-T "$file[$i]\.idx"){  push(@INDEX_FILE, "$file[$i]\.idx"); next; }
            }elsif((-T $file[$i]) and ($file[$i]=~/\.seq$/)){    push(@DATABASE, $file[$i]);
            }elsif((-T $file[$i]) and ($file[$i]=~/\.dat$/)){    push(@DATABASE, $file[$i]);
            }elsif(-T $file[$i] and $file[$i]=~/(\S+)\.idx$/){   push(@INDEX_FILE, $file[$i]);
               push(@DATABASE, $1) if -s $1; next;
            }else{
               print "\n#  WARN:  fetch_sequence_from_db:
               You put a file-name-like which is not a fasta DB. Error. I am removing $file[$i]";
               splice(@file, $i, 1);
               $i--;
            }
        }
	}elsif(@file < 1 and !@DATABASE){
	    print "\n# (E)fetch_sequence_from_db: \@file is <= 0, ERROR\n"; die;
	}

	if($vars{'d'}=~/^p[100]*$/){
	   if( -T  $ENV{'PDB_FASTA'} ){             push(@DATABASE,   $ENV{'PDB_FASTA'} );     }
	   elsif(  -T $ENV{'PDB_SEQ_FASTA'} ){      push(@DATABASE,   $ENV{'PDB_SEQ_FASTA'}  ); }
	   elsif(  -T $ENV{'PDB100_FASTA'} ){       push(@DATABASE,   $ENV{'PDB100_FASTA'} ); }
	   if(  -T $ENV{'PDB_FASTA_INDEX'} ){       push(@INDEX_FILE, $ENV{'PDB_FASTA_INDEX'} ); }
	}elsif( $vars{'d'}=~/^p\d+d$/ ){
	   if(  -T $ENV{'PDB100D_FASTA'} ){         push(@DATABASE,   $ENV{'PDB100D_FASTA'});     }
	   elsif(  -T $ENV{'PDBD100_FASTA'}  ){     push(@DATABASE,   $ENV{'PDBD100_FASTA'}); }
	   elsif(  -T $ENV{'PDB100D_SEQ_FASTA'}  ){ push(@DATABASE,   $ENV{'PDB100D_SEQ_FASTA'}); }
	   elsif(  -T $ENV{'PDBD100_SEQ_FASTA'}  ){ push(@DATABASE,   $ENV{'PDBD100_SEQ_FASTA'}); }
	   if(  -T $ENV{'PDB100D_SEQ_FASTA_INDEX'} ){    push(@INDEX_FILE, $ENV{'PDB100D_SEQ_FASTA_INDEX'}); }
	   elsif(  -T $ENV{'PDBD100_SEQ_FASTA_INDEX'} ){    push(@INDEX_FILE, $ENV{'PDBD100_SEQ_FASTA_INDEX'}); }
	}elsif( $vars{'d'}=~/^p40/ ){
	   if(  -T $ENV{'PDB40_FASTA'} ){          push(@DATABASE,   $ENV{'PDB40_FASTA'});     }
	   elsif(  -T $ENV{'PDB40_SEQ_FASTA'}  ){  push(@DATABASE,   $ENV{'PDB40_SEQ_FASTA'}); }
	   if(  -T $ENV{'PDB40_FASTA_INDEX'} ){    push(@INDEX_FILE, $ENV{'PDB40_FASTA_INDEX'}); }
	}elsif( $vars{'d'}=~/^p90/ ){
	   if(  -T $ENV{'PDB90_FASTA'}  ){         push(@DATABASE,   $ENV{'PDB90_FASTA'}    ); }
	   elsif(  -T $ENV{'PDB90_SEQ_FASTA'} ){   push(@DATABASE,   $ENV{'PDB90_SEQ_FASTA'}); }
	   if(  -T $ENV{'PDB90_FASTA_INDEX'} ){    push(@INDEX_FILE, $ENV{'PDB90_FASTA_INDEX'}); }
	}
	if( $vars{'d'}=~/^s\s*$/){
	   if(  -T $ENV{'SWISS_FASTA'} ){          push(@DATABASE,   $ENV{'SWISS_FASTA'});     }
	   elsif(  -T $ENV{'SWISS_SEQ_FASTA'} ){   push(@DATABASE,   $ENV{'SWISS_SEQ_FASTA'}); }
	   elsif(  -T $ENV{"SWISS_DIR\/seq.fasta"} ){ push(@DATABASE,   $ENV{"SWISS_DIR\/seq.fasta"}); }
	   if(  -T $ENV{'SWISS_FASTA_INDEX'} ){    push(@INDEX_FILE, $ENV{'SWISS_FASTA_INDEX'}); }
	   elsif(  -T $ENV{'SWINDEX'} ){           push(@INDEX_FILE, $ENV{'SWINDEX'}); }
	}elsif( $vars{'d'}=~/^o\s*$/){
		if(  -T $ENV{'OWL_FASTA'} ){            push(@DATABASE,   $ENV{'OWL_FASTA'});     }
		elsif(  -T $ENV{'OWL_SEQ_FASTA'} ){     push(@DATABASE,   $ENV{'OWL_SEQ_FASTA'}); }
		elsif(  -T $ENV{"OWL_DIR\/owl.fasta"} ){   push(@DATABASE,   $ENV{"OWL_DIR\/owl.fasta"}); }
		if(  -T $ENV{'OWL_FASTA_INDEX'} ){      push(@INDEX_FILE, $ENV{'OWL_FASTA_INDEX'}); }
		print "\n# Fetching sequences from OWL\n";
	}elsif( $vars{'d'}=~/^n\s*$/){
	   if(  -T $ENV{'NRDB_FASTA'} ){            push(@DATABASE,   $ENV{'NRDB_FASTA'});     }
 	   elsif(  -T $ENV{'NRDB_SEQ_FASTA'} ){     push(@DATABASE,   $ENV{'NRDB_SEQ_FASTA'}); }
			 if(  -T $ENV{'NRDB_FASTA_INDEX'} ){      push(@INDEX_FILE, $ENV{'NRDB_FASTA_INDEX'}); }
			 elsif(  -T $ENV{'NRDB_FASTA_IDX'} ){     push(@INDEX_FILE, $ENV{'NRDB_FASTA_IDX'}); }
	   print "\n# Fetching sequences from OWL\n";
	}elsif( $vars{'d'}=~/^\S+\.\S+$/ and -T $vars{'d'} ){ push(@DATABASE, $vars{'d'} );     }
	if( $vars{'i'}=~/\S+\.\S+$/ and -T $vars{'i'} ){ push(@INDEX_FILE, $vars{'i'} );   }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Each given source DB file has to have INDEX file. Unless, make it here
    #_____________________________________________________________________
    if(@INDEX_FILE < 1 and @DATABASE > 0){
         for($i=0; $i< @DATABASE; $i++){
             if(-s "$DATABASE[$i]\.idx"){ push(@INDEX_FILE, "$DATABASE[$i]\.idx") }
         }
         unless(@INDEX_FILE){
             print "\n# (E) fetch_sequence_from_db: \@INDEX_FILE has less than 1 elem. Trying to make it\n";
             print "     fetch_sequence_from_db called make_seq_index_file to make @INDEX_FILE\n";
             if(${&make_seq_index_file(@DATABASE)}){
                  push(@INDEX_FILE, ${&make_seq_index_file(@DATABASE)});
             }else{ die "\n $0 : make_seq_index_file failed to make INDEX file(.idx) \n\n"; }
         }
	}elsif(@INDEX_FILE > 0 and @DATABASE > 0){
         if( ${&if_file_older_than_x_days("$DATABASE[0]\.idx", 5)} > 0 ){
             print "\n# (i) fetch_sequence_from_db: $DATABASE[0]\.idx is old, rerunning make_seq_index_file\n";
             $index_file=${&make_seq_index_file(\@DATABASE)};
             push(@INDEX_FILE, $index_file);
         }elsif((-s "$DATABASE[0]\.idx") > 20){
             print "\n# (i) fetch_sequence_from_db: $DATABASE[0]\.idx is larger than 20, USING IT";
             push(@INDEX_FILE, "$DATABASE[0]\.idx");
         }else{
             print "\n# (ERROR) fetch_sequence_from_db: Some weird error in pushing \$index_file to \@INDEX_FILE\n"; die;
         }
	}elsif(@DATABASE < 1){
	     print "\n\n# (W) \@INDEX_FILE \"@INDEX_FILE\", and \@DATABASE \"@DATABASE\" are not big enough(0)\n";
	     die;
    }

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
     # To skip a seq name bug (from Sarah)
     #________________________________________________________
     if($input_seq_names[0]=~/\S\-\S+\-\S/){
              print  "\n# (W) NO good having more than 2 dashes in seq. name: $input_seq_names[0], dying \n";
              sleep(2);
     }

     ##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     ##  Now I have @DATABASE, @INDEX_FILE, @input_seq_names
     ##_______________________________________________________________

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	#  Reading in index file to get 'seq' 'seek pos' to make %seq_with_index
	#__________________________________________________________________________
	print "\n#  fetch_sequence_from_db: \@INDEX_FILE @INDEX_FILE, \@DATABASE :@DATABASE\n";
	for($i=0; $i< @INDEX_FILE; $i++){
	   open(INDEX, "$INDEX_FILE[$i]");
	   while(<INDEX>){ if(/(\S+)\s+(\S+)/){  $long_index{$1}=$2;  }  }

	   for($j =0; $j < @input_seq_names; $j++){

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~``
           #  If DATABASE has sequence names with ranges already index the seq with ranges
           #____________________________________________________________________________________
           if($input_seq_names[$j]=~/(\S+\_\d+\-\d+)$/ and $long_index{$1}){
                   $seq_with_index{$1}=$long_index{$1};
           }elsif( ($input_seq_names[$j]=~/pdb_(\S+\_\d+\-\d+)/ or $input_seq_names[$j]=~/nr_(\S+\_\d+\-\d+)/ )
               and $long_index{$1}){
               $seq_with_index{$1}=$long_index{$1};
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~``
           #  If DATABASE has sequence names without ranges index the seq without ranges
           #____________________________________________________________________________________
           }elsif($input_seq_names[$j]=~/^(\S+)\_\d+\-\d+/ and $long_index{$1}){
                   $seq_with_index{$input_seq_names[$j]}=$long_index{$1}; # !!!! <--- This line is critical
           }elsif($input_seq_names[$j]=~/(\S+)\_\d+\-\d+/ and $long_index{"$1\_"}){ # to handle Tim's new pdb100.fasta files
                   $seq_with_index{$input_seq_names[$j]}=$long_index{"$1\_"};
                   print "\n# Warning: $1 (from $input_seq_names[$j]) matched with $1\_ in $INDEX_FILE[$i],
                                               I hope this is correct!!\n";
           }elsif($input_seq_names[$j]=~/nr_(\S+)\_\d+\-\d+/ and $long_index{"$1"}){ # to handle Tim's new pdb100.fasta files
                   print "           (W) $input_seq_names[$j] matched nr_XXXX_ddd-ddd format removing nr_\n";
                   $seq_with_index{$1}=$long_index{$1};
           }elsif($input_seq_names[$j]=~/pdb_(\S+)\_\d+\-\d+/ and $long_index{$1}){
                   print "           (W) $input_seq_names[$j] matched pdb_XXXX_ddd-ddd format removing pdb_\n";
                   $seq_with_index{$1}=$long_index{$1}; # !!!! <--- This line is critical
           }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~``
           #  If input_seq_name has SCOP superfamily numbers
           #____________________________________________________________________________________
           elsif($input_seq_names[$j]=~/^(\S+)\_(\d+\.\d+\.\d+)[\.\d+\.\d+]*/ and $long_index{$1}){
                   $seq_with_index{"$1\_$2"}=$long_index{$1}; # !!!! <--- This line is critical
           }elsif($input_seq_names[$j]=~/\S/ and $long_index{$input_seq_names[$j]}){
                   $seq_with_index{$input_seq_names[$j]}=$long_index{$input_seq_names[$j]}
           }else{
               print chr(7);
               print "\n# (E) Wanted Intermediate, $input_seq_names[$j], has NO corrspndng indx in $INDEX_FILE[$i]";
           }

	   }
	   close INDEX;

	   if ( scalar(keys %seq_with_index) < 1){
			print "\n# fetch_sequence_from_db: \%seq_with_index is too small, ERROR?\n";
	   }
	}

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
	#  Fetching sequences from DATABASE
	#_______________________________________________________________
	print "\n# fetch_sequence_from_db: Fetching seqs from @DATABASE with  @INDEX_FILE ";
	@Keys= sort {$seq_with_index{$a} <=> $seq_with_index{$b} } keys %seq_with_index;        ## <<< NOTE it is @Keys, not @keys
	print "\n# (3) fetch_sequence_from_db: No. of seq indexed is:", scalar(@Keys);

	for($f=0; $f< @DATABASE; $f++){

       open(DB_FASTA, $DATABASE[$f]);

	   F0: for($e=0; $e< @Keys; $e++){
		  my ($seq_found1, $super_fam_class, $NAME, $R_leng, $R_start, $sequence);
		  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		  # When seq name has range attachment, it handles
		  #________________________________________________
		  if($Keys[$e]=~/(\S+)_(\d+)\-(\d+)/){
		      $NAME=$1;
		      $R_start=$2-1;      ## to fit in substr function
              $R_leng =$3-$2+1; ## to fit in substr
		      print "\n# (4) fetch_sequence_from_db: Sequences have ranges ($R_start-$R_leng) only (not superfamily numb.) \n";
		  }
		  elsif($Keys[$e]=~/(\S+)_(\d+)\-(\d+)\_(\d+\.\d+\.\d+)[\.\d+\.\d+]*/){
		      $NAME=$1;
		      $R_start=$2-1;      ## to fit in substr function
		      $R_leng =$3-$2+1; ## to fit in substr
		      $super_fam_class=$4;
		      print "\n# (4) fetch_sequence_from_db: Sequences have ranges and superfamily numb.\n";
		  }
		  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		  # When superfamily (scop) number is attached
		  #___________________________________________________
		  elsif($Keys[$e]=~/(\S+)\_(\d+\.\d+\.\d+)[\.\d+\.\d+]*/){
	          $NAME=$1;
		      $super_fam_class=$2;
		      print "\n# (4) fetch_sequence_from_db: Sequences have SCOP superfamily numbers only \n";
		  }elsif($Keys[$e]=~/^\s*(\S+)[\,]*$/){
		      print "\n# (4) fetch_sequence_from_db: Sequences DON't have ranges or SCOP superfam numb.\n";
							$NAME=$1;
		  }

		  print "\n# BEFORE reading in DB file. \$NAME is  $NAME";

		  if($seq_with_index{$NAME}=~/(\d+)/        # It is importnt having $seq_with_index{$Keys[$e]}
			   or $seq_with_index{$Keys[$e]}=~/(\d+)/
			   or $seq_with_index{"$NAME\,"}=~/(\d+)/    # this is for overcoming '>xxxx,'  entry(the comma)
               or $seq_with_index{"$NAME\_"}=~/(\d+)/    # to handle Tim's  >c1eru_ 3.30.1.1.4
               or $seq_with_index{"pdb\_$NAME"}=~/(\d+)/ # to handle Sarah's pdb_xxxxx
               or $seq_with_index{"nr\_$NAME"}=~/(\d+)/ # to handle Sarah's nr_xxxxx
			   ){
			   my $finding_position= $1-300;
			   if( $finding_position >= 0 ){   seek(DB_FASTA, $1-300, 0);  # -300 is necessary
			   }elsif($finding_position < 0){  seek(DB_FASTA, 0, 0); }      ## This is essential !!!

			   while(<DB_FASTA>){
				  if(!$seq_found1){
					if(/\>\s*$NAME[\,_]?\s*\d*/){
						  $seq_found1=1;
						  print "\n# $NAME  is found in DB, Good ";
					  }
				  }else{
					  if(/^\s*(\w+)\s*$/ ){
                          $sequence .=$1;  ## you should use $1 to avoid including NEW line
						  unless(eof DB_FASTA){ next   ## This is critically important to prevent error.
						  }else{ goto PUT_SEQ }     ## If the last seq has only one single line seq string, it could be a problem
					  }elsif( (/^\s*\>\s*\S+/)  or (eof DB_FASTA) ){
                          #======= When range is defined ==================
                          PUT_SEQ:
                          if($R_start =~/\d+/){
                               $sequence{$Keys[$e]}=substr($sequence, $R_start, $R_leng);                                                                                                                                        $sequence{$Keys[$e]}=substr($sequence, $R_start, $R_leng); next; #
                          }
                          #======= When range is NOT defined ==================
                          else{
                               $sequence{$Keys[$e]}=$sequence;
                          }
                          $R_start=$sequence=$seq_found1='';  ## reset $R_start, $seq_found1,,
                          next F0;
					  }
				  }
			   }

		  }else{
			   print "\n# Error, the sequence pos for $NAME (from $Keys[$e]) in DB doesnt exist in xxxx.idx file?\n";
		  }
	   }
	   close DB_FASTA;
	}
	#print "\n# (6) fetch_sequence_from_db: counted fetched seqs: $found_seq_count, $acquired_seq_count";
	#print "\n# (7) fetch_sequence_from_db: Fetching seq has finished \n";

	return(\%sequence);
}




#______________________________________________________________
# Title     : fetch_seq
# Usage     : &fetch_seq(@ARGV);
# Function  : fetches swissprot entry or fasta format seq with
#             given seq name(like  SAA_HORSE, SA*HORSE, SAA,..)
#             you can give multi files(SAA*, SAU*) at the same
#             time. This uses ENV setting of 'SWDIR'
# Example   : &fetch_swiss_seq(@ARGV);
# Keywords  : fetch_swissprot_sequence, fetch_sequence,
#             find_swiss_sequence, find_sequence
# Options   : _  for debugging.
#             #  for debugging.
#             -f for fasta format file output
#             -a is for ALL matched seq. (same as using glob=> *YEAST)
#             -c is for Creating seq.idx file
#             -h is for HELP!
#             -g is for GDF file format output
#             -l is for list of match entries(in 1 column)
#             -s is for species option (input name mst be species (YEAST, RAT, HUMAN..)
#             n= is for Number of seq you want to get from swissprot
#             s= is for Size limit. Min seq size in swiss, s=10  -> minimum 11 aa seq.
#             S= is for Size limit. Max seq size in swiss, s=1000 -> get less than 1000
#
# Argument  : swissprot seqname
# Category  :
# Version   : 1.7
#--------------------------------------------------------------
sub fetch_seq{
	 my @in=@_;
	 my ($FASTA_index, $FASTA, $where_index, %index, $question, $i,
	    $s,$t,$fasta,$index_file, $all, $species,$target, $matched, $seq, $gdf, $list, $count, $create);
	 my $SEQ_size_max=100000000;

	 if(@_ < 1){	  &HELP_fetch_seq;
	 }else{
	 F: for($t=0; $t<@in; $t++){ #'''''''''''' PROMPT ARGV processing ''''''''''''''''''
		if($in[$t]=~/^\-c$/i){
		   $create=1; splice(@in, $t, 1); $t--;
		   print "\n You should provide database\(e.g, seq.dat\) file with this opt, I guess you did\n";
		   print "\n If you wanted to make an index with any fasta db, you also have to\n";
		   print "  give the file name. e.g:\n     $0 -c /DB/swiss/seq.dat\n";
		   print "  or $0 -c my_db.fasta\n\n";
		   next; }
		if($in[$t]=~/^\-af$/){ $fasta=$all=1; splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-afs$/){ $species=$fasta=$all=1; splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-ag$/){ $gdf=$all=1; splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-g$/){    $gdf=1; splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-f$/i){   $fasta=1; splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-a$/i){   $all=1;   splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-l$/i){   $list=$all=1;   splice(@in, $t, 1); $t--; next; }
		if($in[$t]=~/^\-s$/i){  $species=$all=1; splice(@in, $t, 1); $t--; next; }
		if( ($in[$t]=~/seq\.dat/)&&(-f $in[$t])){ ## if the path for swiss prot is given
		   $DB=$in[$t];  splice(@in, $t, 1); $t--; next;        }
		if( ($in[$t]=~/seq\.idx/)&&(-e $in[$t])){ ## if the path for swiss index is given
		   $index_file=$in[$t];	splice(@in, $t, 1); $t--; next;	}

		#''''''' SWiss prompt input file check ''''''''''''''''''
		if( -f $in[$t]){
		   open(TEMP, "$in[$t]");
		   while(<TEMP>){
			 if(/^ID\s+\w+/){$DB=$in[$t]; splice(@in, $t, 1);$t--;next F;}}
		   close TEMP;
		}

		#'''''''' FASTA prmpt input file check '''''''''''''''''''
		if( (-f $in[$t]) && !(defined($FASTA))){
		   open(TEMP, "$in[$t]");
		   while(<TEMP>){
			 if(/^\> {0,4}\S+/){$FASTA=$in[$t]; $fasta=1;
			 if(-s "$FASTA\.idx"){ $FASTA_index="$FASTA\.idx"; }
		     splice(@in, $t, 1);$t--;next F;}}
		   close TEMP;
		}

		#'''''''' INDEX file automatic check ''''''''''''''''''
		if( -f $in[$t]){
		   open(TEMP2, "$in[$t]");
		   my ($first_pos, $Count, @splited);
		   while(<TEMP2>){
			 $Count++;
			 if( $Count>3 ){
				if(/^ {0,2}\S+\s+(\d+)/){
				   if(defined($first_pos) && ($1-$first_pos ) > 1000 ){
					  $index_file=$in[$t];
					  splice(@in, $t, 1);$t--;next F;
				   }elsif( defined($first_pos) && ($1-$first_pos)<1000 ){
					  $FASTA_index=$in[$t]; $fasta=1;
					  if($FASTA_index=~/^(\S+)\.\w+$/){
					     if(-s $1){ $FASTA= $1; }
					  }
					  splice(@in, $t, 1);$t--;next F;
				   }
				   $first_pos=$1;
				}
			 }
		   }
		   close TEMP2;
		}
		if($in[$t]=~/^\-h$/i){ &HELP_fetch_seq; die;}
		if($in[$t]=~/^n=(\d+)$/i){ $SEQ_num_to_fetch=$1;
		   splice(@in, $t, 1);$t--;next F;}
		if($in[$t]=~/^s=(\d+)$/){ $SEQ_size_min=$1; $fasta=1;
		   splice(@in, $t, 1);$t--;next F;}
		if($in[$t]=~/^S=(\d+)$/){ $SEQ_size_max=$1; $fasta=1;
		   splice(@in, $t, 1);$t--;next F;}
	 }

	 if(($create==1)&&(defined($DB)) ){ goto CREATE; }
	 elsif(($create==1) && (defined($FASTA)) ){ goto CREATE; }
	 elsif($create==1){
	    print "\n You must give db filename (e.g. seq.dat) with path to make an index";
	    print "\n  I can handle fasta db file to make an index\n";
	    die;
	 }
	 }

	 if($SEQ_size_max < $SEQ_size_min){ print "\n Seq size Max is smaller than min\n"; die; }

	 ##""""""""""""""""""""""" DB file if not defined """"""""""""""""""""""""""""""""""""""""""""
	 if (!defined($DB)){
	  if((!defined($FASTA))&&($fasta==1)&&(-T "$ENV{'FASTADB'}")){
		 $FASTA=$ENV{'FASTADB'};
	  }elsif(defined($FASTA) && ($fasta==1) &&($create !=1) ){
		 goto SW_INDEX;
	  }elsif(!defined($FASTA) && (defined($FASTA_index))&& !(-e "$ENV{'FASTADB'}") ){
		 print "\n NO fasta db is defined\n";
		 goto ASK;
	  }elsif(-e "$ENV{'SWDIR'}seq.dat" ){
		 $DB="$ENV{'SWDIR'}seq.dat";
	  }elsif(-e "$ENV{'FETCHSWISS'}seq.dat" ){
		 $DB="$ENV{'FETCHSWISS'}seq.dat";
	  }elsif(-e "$ENV{'FETCHSWISS'}" ){
		 $DB="$ENV{'FETCHSWISS'}";
	  }elsif(-e "$ENV{'SWDIR'}\/seq.dat" ){
		 $DB="$ENV{'SWDIR'}\/seq.dat";
	  }elsif( -f "$ENV{'SWISS'}seq.dat" ){
		 $DB="$ENV{'SWISS'}seq.dat";
	  }elsif( -f "$ENV{'SWISS'}\/seq.dat" ){
		 $DB="$ENV{'SWISS'}\/seq.dat";
	  }elsif( -e 'seq.dat'){
		 $DB="seq.dat";
	  }elsif( -f "$ENV{'swiss'}seq.dat"){
		 $DB="$ENV{'swiss'}seq.dat";
	  }elsif(-f "ENV{'HOME'}seq.dat"){
		 $DB="ENV{'HOME'}seq.dat";
	  }elsif(-f "ENV{'SWDIR'}\/seq.dat"){
		 $DB="ENV{'SWDIR'}\/seq.dat";
	  }else{
		ASK: print "\n Where is your swissprot seq.dat(or fasta db) file?\n";
			 print "  I recommand you to set the path for them in ENV vars\n";
			 print "  e.g. export SWDIR=/DB/Swiss/  to where you put seq.dat\n";
			 print "  e.g. export FASTADB=/DB/Swiss/my_swiss.fasta  for fasta database\n";
		 $swiss=<STDIN>;
		 chomp($swiss);
		 if( -f $swiss){
			open(TEMP, "$swiss");
			while(<TEMP>){
			   if(/^ID\s+\w+/){ $DB=$swiss; goto SW_INDEX; }
			   elsif(/^\> {0,3}\S+/){ $FASTA=$swiss; goto SW_INDEX;}
			}
			close TEMP;
		 }else{
			goto ASK;
		 }
	  }
	 }
	 ##""""""""""""""""""""""""""""" INDEX file """"""""""""""""""""""""""""""""""""""""
	 if( !defined($index_file)){
	  SW_INDEX:
	  if((!defined($FASTA_index))&&($fasta==1)&&(-T "$ENV{'FASTAINDEX'}")){
		 $FASTA_index=$ENV{'FASTAINDEX'};
	  }elsif(!defined($FASTA_index)&&(-T $FASTA)){
		 goto W;
	  }elsif(defined($FASTA_index)&&(-T $FASTA)){
		 goto MAIN_SEARCH;
	  }elsif(-e "$ENV{'FETCHSWISSINDEX'}seq.idx" ){
		 $index_file="$ENV{'FETCHSWISSINDEX'}seq.idx";
	  }elsif(-e "$ENV{'FETCHSWISSINDEX'}\/seq.idx" ){
		 $index_file="$ENV{'FETCHSWISSINDEX'}\/seq.idx";
	  }elsif(-e "$ENV{'SWDIR'}seq.idx" ){
		 $index_file="$ENV{'SWDIR'}seq.idx";
	  }elsif( -f "$ENV{'SWISS'}seq.idx" ){
		 $index_file="$ENV{'SWISS'}seq.idx";
	  }elsif( -f "$ENV{'SWISS'}\/seq.idx" ){
		 $index_file="$ENV{'SWISS'}\/seq.idx";
	  }elsif( -f "$ENV{'SWINDEX'}" ){
		 $index_file="$ENV{'SWINDEX'}";
	  }elsif( -e 'seq.idx'){
		 $index_file="seq.idx";
	  }elsif( -f "$ENV{'swiss'}seq.idx"){
		 $index_file= "$ENV{'swiss'}seq.idx";
	  }elsif( -f "$ENV{'SWINDEX'}seq.idx"){
		 $index_file= "$ENV{'SWINDEX'}seq.idx";
	  }elsif( -f "$ENV{'HOME'}seq.idx"){
		 $index_file= "$ENV{'HOME'}seq.idx";
	  }elsif( -f "$ENV{'SWINDEX'}seq.idx"){
		 $index_file="$ENV{'SWINDEX'}\/seq.idx";
	  }elsif( -f "$ENV{'swindex'}seq.idx"){
		 $index_file="$ENV{'swindex'}seq.idx";
	  }elsif(defined($DB)|| defined($FASTA) ){
		 print "\n Your swissprot is in $DB, but no seq.idx file for it.\n";
		 W: print "\n Where is seq.idx(or fasta idx file eg. $FASTA\.idx), type path and filename?\n";
		    print "  I recommand you to set the path for them in ENV vars later\n";
			print "  e.g. export SWINDEX=/DB/Swiss/  to where you put seq.dat index\n";
			print "  e.g. export FASTAINDEX=/DB/Swiss/my.fasta.idx  for fasta db index\n";
			print "  Asking where 3 times. After, will ask creation of seq.idx or $FASTA.idx\n";
		 $question++;
		 $where_index=<STDIN>;
		 chomp($where_index);
		 if(-f $where_index){
			open(TMP, "$where_index");
		    while(<TMP>){
				if($_=~/^ {0,2}\S+\s+\d+/){
				   $index_file=$where_index;
				   print "\n Your index file seems to be right \($index_file\) \n";
				   goto MAIN_SEARCH;
				}elsif($count > 4){ # read at least 4 lines and see if they are index
				   print "\n $where_index doesn't seem to be index file\n";
				   print "\n Terminate(t) or go on (g) trying\n";
				   $try=getc;
				   if($try=~/t/i){  die; }
				   else{ goto W; }
				}else{
				   $count++;
				}
			}
			close TMP;
		 }else{
			if($question > 2){
			   print "\n I can create the index in pwd for you run $0 and \n";
			   print "\n you can copy seq.idx(or $FASTA\.idx) into your swissprot dir later\n";
			   goto CREATE;
			}
			goto W;
		 }

		 #""""""""""""""" CREATION of INDEX file """""""""""""""""""""""""""""""""""""""""""""
		 CREATE:
		 if(defined($DB)){ print "\n Can I create seq.idx in pwd? (y+return or return)\n" }
		 if(defined($FASTA)){ print "\n Can I create $FASTA\.idx in pwd? (y+return or return)\n" }
		 $yes_no=getc;
		 if($yes_no=~/y/i){
			if(defined($DB)){
			   print "\n seq.idx being created...\(1 min in my Linux\)\n";
			   open(DB, "$DB");
			   open(IDX, ">seq.idx");
			   print IDX "# swiss_index\n";
			   while(<DB>){
				 if(/^ID\s+(\w+)\s+/){
					$index{$1}=tell(DB);
					print IDX "\n$1 $index{$1}";
				 }
			   }
			   close(DB);
			   close(IDX);
			   if(-s "seq.idx"){
				   print "\nGood. seq\.idx is created.";
				   print "\n Copy seq.idx to SWISSPROT dir or you can set\n";
				   print "absolute path ENV var \'SWINDEX\' to your seq.idx path\n";
				   print "e.g. #bash\> export SWINDEX=\/DB\/Swiss\/seq.idx\n\n";
				   if($create==1){ die;  }
			   }else{
				   print "\n Creation of seq.dat seems to have gone wrong";
			   }

			}elsif(defined($FASTA)){
			   $F_idx="$FASTA\.idx";
			   print "\n $F_idx being created...\n";
			   open(FASTADB, "$FASTA");
			   open(FASTAIDX, ">$F_idx");
			   print FASTAIDX "# fasta_index\n";
			   while(<FASTADB>){
				 if(/^\> {0,4}(\S+)\s*/){
					$index{$1}=tell(FASTADB);
					print FASTAIDX "\n$1 $index{$1}";
				 }
			   }
			   close(FASTADB);
			   close(FASTAIDX);
			   if(-s $F_idx){
				   print "\nGood! Copy $F_idx to your DB dir and set two ENV vars\n";
				   print "absolute path ENV var \'FASTADB\' to your fastadb path\n";
				   print "absolute path ENV var \'FASTAINDEX\' to your $F_idx path\n";
				   print "e.g. #bash\> export FASTADB   =\/DB\/mySwiss\/$FASTA\n";
				   print "e.g. #bash\> export FASTAINDEX=\/DB\/mySwiss\/$F_idx\n";
				   print "e.g. #tcsh\> setenv FASTADB    \/DB\/mySwiss\/$FASTA\n";
				   print "e.g. #tcsh\> setenv FASTAINDEX \/DB\/mySwiss\/$F_idx\n";
				   print "Unless, you can specify the database each time at prompt\n\n";
				   if($create==1){ die;  }
			   }else{
				   print "\n Creation of seq.dat or $F_idx seems to have gone wrong";
			   }
			}
		 }else{
			die;
		 }
	  }
	 }

	 #""""""""""""""""""""""""""" MAIN SERACH """""""""""""""""""""""""""""""""""""""""""""""
	 MAIN_SEARCH:
	 for($i=0; $i<@in; $i++){
	  my (@possible, @pos, %possible); my $target=$in[$i];
	  if($target=~/\*/){
		 $target=~s/\*/\\\w\{0,6\}/; # to handle glob input
		 $all=1;
	  }
	  if(defined($index_file)){
		 open(INDEX, "$index_file");
		 if($species==1){
		    while(<INDEX>){
		      if( /(\w*\_$target)\s+(\d+)/ ){ $possible{$1}=$2; }
		    }
		 }else{
		    while(<INDEX>){
		      if( /(\w*$target\w*)\s+(\d+)/ ){ $possible{$1}=$2; }
		    }
		 }
		 close INDEX;
		 goto SWISS;
	  }elsif(($fasta==1) && (defined($FASTA_index)) ){
		 open(INDEX, "$FASTA_index");
		 if($species==1){
		    while(<INDEX>){
		      if( /(\w*\_$target)\s+(\d+)/ ){ $possible{$1}=$2; }
		    }
		 }else{
		    while(<INDEX>){
		      if( /(\w*$target\w*)\s+(\d+)/ ){ $possible{$1}=$2; }
		    }
		 }
		 close INDEX;
		 goto FASTA;
	  }

	  SWISS:
	  @poss = sort keys %possible;

	  if( (@poss >1)&&($all !=1)){
		 print "\n @poss","\n";
		 print chr(7);
		 print "\n There are more than a few seqs for $in[$i]";
		 print "\n be more specific! OR use -a option for all matched\n\n";
		 die;
	  }elsif($all !=1){
		 print "\n";
		 open (DB, "$DB");
		 if(defined($SEQ_num_to_fetch)){
			print "\n# You defined the number of sequence to fetch: $SEQ_num_to_fetch\n";
			$num_sequence=$SEQ_num_to_fetch;
		 }else{ $num_sequence=@poss; }

		 A:for($p=0; $p < $num_sequence; $p++){
		   if($poss[$p]=~/\w*$target\w*/){
			 $matched=$possible{$poss[$p]};   # %possible has the name and index num
			 seek(DB, ($matched-52), 0);
			 while(<DB>){
			   if($gdf==1){
			      if(/ID\s+$poss[$p]\s+\S+\s+\S+\s+(\d+)/){
			         printf ("%-24s %-3d %-7d %-14s %4s\n", "$poss[$p]\/1\-$1", 1, $1, $poss[$p], '0.0');
					 next A;
			      }
			   }
			   elsif(/^ {0,2}\/\// and  $fasta !=1){  # !!! DO NOT put $ in /^ {0,2}\/\// as there is something
				  print "\/\/\n";
				  next A;
			   }elsif(/^ {0,2}\/\//  and  $fasta==1){ # !!! DO NOT put $ in /^ {0,2}\/\// as there is something
				  $seq=~s/ //g;
				  if( ($SEQ_size_min < length($seq))&&(length($seq) < $SEQ_size_max) ){
					 print "\>$poss[$p]\n$seq\n"; $seq=''; next A;
				  }else{  $seq=''; $num_sequence++;  next A; }
			   }elsif( $fasta==1 and /^\s+\w+/){
				  $seq.=$_;
				  next ;
			   }elsif($list==1){
			      if(/ID\s+$poss[$p]\s+\S+\s+\S+\s+(\d+)/){
			         print "$poss[$p]\n";
					 next A;
			      }
			   }elsif($fasta !=1){
				  print ;
			   }
			 }
		   }
		 }
		 close(DB);
	  }elsif($all==1){
		 print "\n";
		 open (DB, "$DB");
		 if(defined($SEQ_num_to_fetch)){ $num_sequence=$SEQ_num_to_fetch;
		 }else{ $num_sequence=@poss; }
		 A:for($p=0; $p < $num_sequence; $p++){
		   if($poss[$p]=~/\w*$target\w*/){
			 $matched=$possible{$poss[$p]};
			 seek(DB, ($matched-51), 0);
			 while(<DB>){
			   if($gdf==1){
			      if(/ID\s+$poss[$p]\s+\S+\s+\S+\s+(\d+)/){
			         printf ("%-24s %-3d %-7d %-14s %4s\n", "$poss[$p]\/1\-$1", 1, $1, $poss[$p], '0.0');
					 next A;
			      }
			   }elsif(/^ {0,2}\/\// and $fasta==1){ # !!! DO NOT put $ in /^ {0,2}\/\// as there is something
				  $seq=~s/ //g;
				  if( ($SEQ_size_min < length($seq))&&(length($seq) < $SEQ_size_max) ){
					 print "\>$poss[$p]\n$seq\n"; $seq='';  next A;
				  }else{  $seq=''; $num_sequence++; next A; }
			   }elsif(/^ {0,2}\/\// and $fasta !=1){  # !!! DO NOT put $ in /^ {0,2}\/\// as there is something
				  print "\/\/\n";
				  next A;
			   }elsif(($fasta==1)&&(/^\s+\w+/)){
				  $seq.=$_;
				  next ;
			   }elsif($list==1){
			      if(/ID\s+$poss[$p]\s+\S+\s+\S+\s+(\d+)/){
			         printf "$poss[$p]\n";
					 next A;
			      }
			   }elsif($fasta !=1){
				  print ;
			   }
			 }
		   }
		 }
		 close(DB);
	  }

	  FASTA:
	  @poss = sort keys %possible;
	  if( (@poss >1)&&($all !=1)){
		 print "\n @poss","\n";
		 print chr(7);
		 print "\n There are more than a few seqs for $in[$i]";
		 print "\n be more specific! OR use -a option for all matched\n\n";
		 die;
	  }elsif($all !=1){
		 print "\n";
		 open (FAS, "$FASTA");
		 B:for($p=0; $p < @poss; $p++){
		 if($poss[$p]=~/\w*$target\w*/){
			 $matched=$possible{$poss[$p]};
			 seek(FAS, ($matched-350), 0);
			 my $seq_found;
			 while(<FAS>){
			if((/^> {0,4}(\S+)/)&&($seq_found==1)){
				   next B;
	 			}elsif(/^> {0,4}($poss[$p])/){
				   print;
				   $seq_found=1;
				}elsif($seq_found==1){
				   print;
				}
			 }
		   }
		 }
		 close(FAS);
	  }elsif($all==1){
		 print "\n";
		 open (FAS, "$FASTA");
		 B2:for($p=0; $p < @poss; $p++){
		   if($poss[$p]=~/\w*$target\w*/){
			 $matched=$possible{$poss[$p]};
			 seek(FAS, ($matched-350), 0);
			 my $seq_found;
			 while(<FAS>){
				if((/^> {0,4}(\S+)/)&&($seq_found==1)){
				   next B2;
				}elsif(/^>\s*($poss[$p])/){
				   print;
				   $seq_found=1;
				}elsif($seq_found==1){
				   print;
				}
			 }
		   }
		 }
		 close(FAS);
	  }
	 }
}



#______________________________________________________________
# Title     : fetch_swiss_seq
# Usage     :
# Function  : fetches swissprot entry or fasta format seq with
#             given seq name(like  SAA_HORSE, SA*HORSE, SAA,..)
#             you can give multi files(SAA*, SAU*) at the same
#             time. This uses ENV setting of 'SWDIR'
# Example   : &fetch_swiss_seq(@ARGV);
# Warning   :
# Keywords  : fetch_swissprot_sequence, fetch_sequence,
#             find_swiss_sequence, find_sequence, fetch
# Options   : _  for debugging.
#             #  for debugging.
#             -f for fasta format file output
# Returns   :
# Argument  : swissprot seqname
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub fetch_swiss_seq{
	 my @in=@_;
	 my ($i, $index_file, $target, $matched, $seq);
	 if(@_ < 1){
	 print "\n Usage: $0 [-f] <any swissprot name entry>\n";
	 print "   -f is for fasta output format only\n";
	 print "\n You have to set ENV var, SWDIR to seq.dat path\n";
	 print chr(7);
	 }
	 for($i=0; $i<@in; $i++){
	  if($in[$i]=~/\-f$/i){
		 $fasta=1;
		 splice(@in, $i, 1);
		 next;
	  }
	 }

	 if(-e "$ENV{'SWDIR'}seq.dat" ){
	  open(DB, "$ENV{'SWDIR'}seq.dat");
	 }elsif( -f "$ENV{'SWISS'}seq.dat" ){
	  open(DB, "$ENV{'SWISS'}seq.dat");
	 }elsif( -e 'seq.dat'){
	  open(DB, "seq.dat");
	 }elsif( -f "$ENV{'swiss'}seq.dat"){
	  open(DB, "$ENV{'swiss'}seq.dat");
	 }

	 if(-e "$ENV{'SWDIR'}seq.idx" ){
	  $index_file="$ENV{'SWDIR'}seq.idx";
	 }elsif( -f "$ENV{'SWISS'}seq.idx" ){
	  $index_file="$ENV{'SWISS'}seq.idx";
	 }elsif( -e 'seq.idx'){
	  $index_file="seq.idx";
	 }elsif( -f "$ENV{'swiss'}seq.idx"){
	  $index_file= "$ENV{'swiss'}seq.idx";
	 }
	 for($i=0; $i<@in; $i++){
	  my @possible;
	  my $target=$in[$i];
	  $target=~s/\*/\\\w\{0,4\}/; # to handle glob input
	  open(INDEX, "$index_file");
	  while(<INDEX>){
		if( /(\w*$target\w*)/ ){
		   push(@possible, $1);
		}
	  }
	  close INDEX;
	  open(INDEX,  "$index_file");
	  if(@possible >1){
		 print "\n@possible", "\n";
		 print chr(7);
		 print "\n There are more than a few seqs for $in[$i], \n be more specific!\n\n";
	  }else{
		 print "\n";
		 A:while(<INDEX>){
		   if(/(\w*$target\w*)\s+(\d+)/){
			 $matched=$1;
			 seek(DB, ($2-51), 0);
			 while(<DB>){
			   if((/^\/\/$/)&&($fasta==1)){
				  $seq=~s/ //g;
				  print "\>$matched\n$seq\n";
				  $seq='';
				  next A;
			   }elsif((/^\/\/$/) && ($fasta !=1)){
				  print "\n";
				  next A;
			   }elsif(($fasta==1)&&(/^\s+\w+/)){
				  $seq.=$_;
				  next ;
			   }elsif($fasta !=1){
				  print ;
			   }
			 }
		   }
		 }
		 print "========= Search for $ARGV[$i] was a success\n" if @in > 1;
	  }
	 }
}



#______________________________________________________________
# Title     : get_sequence_number
# Usage     :
# Function  : reads database and tells how many sequences are there
#             fasta format db is only accepted for now.
# Example   :
# Warning   :
# Keywords  : count_number_of_sequence, get_number_of_sequence
#             get_sequence_number_in_fasta
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------
sub get_sequence_number{
		my @file=@{$_[0]} || @_;
		my %out;
		for($i=0; $i< @file; $i++){
			 my $seq_number_in_db;
			 open(DB, "$file[$i]") || die "\n# (E) Can not open $file[$i]";
			 while(<DB>){
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
					 #  For standard FASTA db
					 #_____________________________________________
					 if(/^\> {0,6}\w+/){
							 $seq_number_in_db++;

					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
					 # Liisa's NRDB90
					 #_____________________________________________
					 }elsif(/^\> {0,6}\/\:/){
							 $seq_number_in_db++;
					 }
			 }
			 close DB;
			 $out{$file[$i]}=$seq_number_in_db;
		}
		return(\%out);
}


#________________________________________________________________________________
# Title     : write_mspa_files
# Usage     : &write_mspa_files(\%in1, \%in2, ['s'], [$filename, o=$output_MSP_file_name],)
# Function  : Writes input which is already in mspa file format to
#              files either the name is given or generated
#              If more than one ref of hash is given, this will
#              concatenate all the hashes to one big one to
#              make one file.
#             When NO output xxx.mspa file name is given, it creates
#              with the query sequence name.
# Example   :  &write_mspa_files(@sso, 's', $out_file);
# Warning   : When NO output xxx.mspa file name is given, it creates
#              with the query sequence name.
# Keywords  : write_mspa, write_MSP, write_MSP_file, write_mspa_file
# Options   : _  for debugging.
#             #  for debugging.
#             s  for each single file output for each hash input
#  filename  for putting output to the specified filename, should be xxx.mspa
#  $output_MSP_file_name= by o=  # same as filename, but you cleary pass it.
#
# Returns   : if 's' option is set, it will make say,
#               HI001.mspa HI002.mspa HI003.mspa  rather than
#
#               HI001HI002HI003.mspa
#  eg of one output(single file case)
#
#   1027     0.0     1     154   HI0004     1     154   HI0004
#   40       0.0     84    132   HI0004     63    108   HI0001
#   31       0.0     79    84    HI0004     98    103   HI0003
#
# Category  :
# Version   : 3.3
#----------------------------------------------------------------------------------
sub write_mspa_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my ($output_MSP_file_name, $add_range, @final_out, $mspa_file_out,$output_MSP_file_name,
        @keys, $N, $temp_1, %hash, $query_seq_name, $single_out_opt);

    if($char_opt=~/r/){ $add_range      ='r' };
	if($char_opt=~/s/){ $single_out_opt ='s' };
    if(@file == 1){ $output_MSP_file_name=$file[0]; $single_out_opt='' } # s is for single file output
    if($vars{'o'}){ $output_MSP_file_name=$vars{'o'} }
    if(@hash < 1){ warn "\n WARNING: write_mspa_files, \@hash is empty. This can be fatal \n\n"; }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # (0) When outfilename is not given
    #___________________________________________________________
    if($single_out_opt eq 's' and !$output_MSP_file_name){
		 $mspa_file_out='default_single_out.mspa';
		 for($i=0; $i< @hash; $i++){
			 my %hash=%{$hash[$i]};
			 my @keys =sort keys %hash;
			 #------------------ Writing the first line ---------------------------
			 for($j=0; $j< @keys; $j++){
                if($keys[$j]=~/(\S+)_\d+\-\d+/){ $N = $1 }else{ $N = $keys[$j] }
                if($hash{$keys[$j]}=~/\s+$N[\_\d+\-\d+]*\s+\d+\s+\d+\s+$N[\_\d+\-\d+]*/){
                    open(MSP_FILE, ">$mspa_file_out") ||
                            die "# write_mspa_files: I can not create $mspa_file_out, check permission\n";
                    chomp( $hash{$keys[$j]} ); ## precaution
                    print MSP_FILE "# (H) $0 write_mspa_files: $keys[$j]\n";
                    print MSP_FILE $hash{$keys[$j]}, "\n";
                    splice(@keys, $j, 1);
                    $j--; last;
                }
             }
             #------------- Writing the rest of the lines ____________________
             for($j=0; $j< @keys; $j++){
                 chomp( $hash{$keys[$j]} );
                 print MSP_FILE $hash{$keys[$j]}, "\n";
             }
             print MSP_FILE "\n";
          }
          if(-s $mspa_file_out){
                 print "\n# write_mspa_files: $mspa_file_out is written \n";
          }else{
                 print "\n# Error, write_mspa_files\n"; die
          }
          push(@final_out, $mspa_file_out);
          close(MSP_FILE);
          return(\@final_out);
    #~~~~~~~~~~~~~ DEfault ~~~~~~~~~~~~~~~~~~
    #  (1) When output file name was given!
    #________________________________________
    }elsif($output_MSP_file_name){
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # When FILE input is given (NOT hash )
        #___________________________________________________________
        if(@file==1){
            my($temp_1);
            open(MSP_FILE, ">$output_MSP_file_name") ||  die "# write_mspa_files: I can not create $output_MSP_file_name, check permission\n";
            print MSP_FILE "# (H) $0 write_mspa_files: @file\n";
            for($i=0; $i< @hash; $i++){
                 %hash=%{$hash[$i]};
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Sorting %hash values by the second column(Evalue)
                 #_______________________________________________________
                 @keys= map {$_->[0]} sort { $a->[1] <=> $b->[1] } map { $hash{$_}=~/^\s*\S+\s+(\S+)\s+/ and [$_, $1] } keys %hash;

                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # for Final output
                 #_____________________________
                 push(@final_out, $output_MSP_file_name);

                 #--------- Writing the first line only --------------
                 for($j=0; $j< @keys; $j++){
                     if($keys[$j]=~/(\S+)_\d+\-\d+$/){ $N = $1 }else{ $N = $keys[$j] }

                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # Following is to put the self match on top of the list
                     #________________________________________________________
                     if($hash{$keys[$j]}=~/\s+$N[\_\d+\-\d+]*\s+\d+\s+\d+\s+$N[\_\d+\-\d+]*/){
                          $temp_1=$keys[0]; $keys[0]=$keys[$j]; $keys[$j]=$temp_1;
                     }
                 }
                 for($j=0; $j< @keys; $j++){
                     chomp($hash{$keys[$j]});
                     print MSP_FILE $hash{$keys[$j]}, "\n";
                 }
                 print MSP_FILE "\n";
            }
            print MSP_FILE "\n";
            close(MSP_FILE);
            if(-s $output_MSP_file_name and $output_MSP_file_name !~/^\s*\.mspa$/){
                    print "\n# write_mspa_files: $output_MSP_file_name is written\n" if(-s $output_MSP_file_name);
            }else{
                    print "\n# write_mspa_files: ERROR. Either $output_MSP_file_name is empty or \".msp\" is written\n";
            }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # When HASH INPUT IS given
        #__________________________________________
        }else{
            for($i=0; $i< @hash; $i++){
                my %hash=%{$hash[$i]};
                my @keys =sort keys %hash;
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # If s option with $output_MSP_file_name is given
                #____________________________________________________
                if($single_out_opt eq 's' ){      $mspa_file_out=$output_MSP_file_name;
                }elsif($hash{$keys[0]}){
                    ($query_seq_name)=$hash{$keys[0]}=~/\S+\s+\d+\s+\d+\s+(\S+)\s+\d*\s+\d*\s+\S+\s*\d*$/;
                    $mspa_file_out="$query_seq_name\.msp";
                }else{ die "\n :-<  \$query_seq_name is not defined. Error\n\n\n"; }

                open(MSP_FILE, ">$mspa_file_out") or die "\n# write_mspa_files: Failed to open $mspa_file_out\n";
                print MSP_FILE "# (H) $0 write_mspa_files: $query_seq_name\n";
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # for Final output
                #_____________________________
                push(@final_out, $mspa_file_out);
                #~~~~~~~ Writing the first line only ~~~~~~~~~~~~~~~~~~
                for($j=0; $j< @keys; $j++){
                    if($keys[$j]=~/^(\S+)_\d+\-\d+/){
                       $N = $1
                    }elsif($keys[$j]=~/^(\S+)\s+(\S+)/){
                       $N = $1;
                    }else{ $N = $keys[$j] }
                    if($hash{$keys[$j]}=~/\s+$N[\_\d+\-\d+]*\s+\d+\s+\d+\s+$N[\_\d+\-\d+]*/){
                       $keys[0]=$temp_1; $keys[0]=$keys[$j]; $keys[$j]=$temp_1;
                    }
                }
                for($j=0; $j< @keys; $j++){
                    chomp($hash{$keys[$j]});
                    print MSP_FILE $hash{$keys[$j]}, "\n";

                }
                print MSP_FILE "\n";
            }
            print MSP_FILE "\n";
            if(-s $mspa_file_out and $mspa_file_out=~/\S+\.msp/){
                 print "\n :-) write_mspa_files: $mspa_file_out is written\n";
            }else{
                 print "\n\n :-(  write_mspa_files: Either $output_MSP_file_name empty or only \".msp\" is written\n\n\n";
            }
            close MSP_FILE;
         }
    }
    if(@final_out ==1){ return( \$final_out[0] );
    }else{    return(\@final_out);    }
}




#______________________________________________________________________
# Title    : write_aln_files
# Function : writes multiple seqs. in msf format (takes one or more than one seq.!!)
# Usage    : two argments:  $seq_hash_reference  and $output_file_name
#             takes a hash which has got names keys and sequences values.
#             uses Perl5 pointers(references).
# Example  : &write_aln(\%hash, \$out_file_name);
#  CLUSTAL W (1.74) multiple sequence alignment
#
#
#  MMAF6040_1           -----MATDD--SIIVLDD----DDEDEA-AAQP-GPSNLPPN-PASTGPGPGLSQQATG
#  AF015956_1           -----MATAN--SIIVLDD----DDEDEA-AAQP-GPSHPLPN-AASPGAG---------
#  HSAB2381_80-900      KQRLLSVTSDEGSMNAFTGRGSPDTEIKINIKQESADVNVIGNKDVVTEEDLDVFKQAQE
#                             .* :  *: .: .    * * :    *  .  :   *  . .  .
#
# Options  :
#     $first_sequence_name= by f=  # to put a certain seq at the first in writing
# Keywords :
# Version  : 1.1
#----------------------------------------------------------------------
sub write_aln_files{

	 $| =1;
	 my($string, %input, $temp, $output_file, $first_sequence_name,
			$name, $k, %final_output);
	 for($k=0; $k< @_; $k++){
			 if(ref($_[$k]) eq 'HASH'){
					 %input=%{$_[$k]};
			 }elsif(ref($_[$k]) eq 'SCALAR'){
					 $output_file=${$_[$k]};
			 }else{
					 if($_[$k]=~/f=(\S+)/){
								$first_sequence_name=$1;
					 }else{
								$output_file=$_[$k];
					 }
			 }
	 }
	 open (ALN_FILE_OUT,">$output_file");		# $string is the seq string.

	 print ALN_FILE_OUT 'CLUSTAL W (1.74) multiple sequence alignment', "\n\n";

	 my(@names) = sort keys %input;
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # Putting the wanted top first seq name at the top
	 #____________________________________________________
	 if($first_sequence_name){
			 for($k=0; $k< @names; $k++){
					 if($names[$k]=~/$first_sequence_name/){
							 $temp=$names[0];
							 $names[0]=$names[$k];
							 $names[$k]=$temp;
					 }
			 }
	 }
	 my($larg)  = length($input{$names[0]});

	 for ($k=0; $k < $larg; $k+= 60){    # 60 residues interval
	for($i=0; $i < @names; $i++){    # number of sequences
						 $names = $names[$i];
						 $input{$names[$i]}=~ s/\n//g; ## this is to remove MANY new lines in the input !!
						 $seq = substr($input{$names[$i]}, $k, 60);
						 #$seq = &put_gaps_every_x_position_in_string($seq, 10, ' ');
						 printf ALN_FILE_OUT ("%-18s %-60s\n", $names, $seq);
						 $final_output{$output_file}.=sprintf("%-18s %-60s\n", $names, $seq);
	}
	printf ALN_FILE_OUT "\n";
	$final_output{$output_file}.="\n";
	 }
	 close(ALN_FILE_OUT);
	 return(\%final_output);
}

#______________________________________________________________________
# Title    : write_msf
# Function : writes multiple seqs. in msf format (takes one or more than one seq.!!)
# Usage    : two argments:  $seq_hash_reference  and $output_file_name
#            takes a hash which has got names keys and sequences values.
#            uses Perl5 pointers(references).
# Example  : &write_msf(\%hash, \$out_file_name, ["o=$seq_order"]);
#             eg) $seq_order='asdf seq2 seq3 seq5';
#    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#    PileUp
#
#       MSF: 1205  Type: P    Check:  9937   ..
#
#     Name: PYC1_YEAST      oo  Len: 1205  Check:  7954  Weight:  1.00
#     Name: PYC2_YEAST      oo  Len: 1205  Check:  5807  Weight:  1.00
#     Name: PYC_MOUSE       oo  Len: 1205  Check:  6176  Weight:  1.00
#
#    //
#
#    PYC1_YEAST      MSQ.RKFAGL RDNFNLLGEK N......... .......... .KILVANRGE
#    PYC2_YEAST      MSSSKKLAGL RDNFSLLGEK N......... .......... .KILVANRGE
#    PYC_MOUSE       ...MLKFQTV RGGLRLLGVR RSSSAPVASP NVRRLEYKPI KKVMVANRGE
#
#    PYC1_YEAST      IPIRIFRTAH ELSMQTVAIY SHEDRLSTHK QKADEAYVIG EVGQYTPVGA
#    PYC2_YEAST      IPIRIFRSAH ELSMRTIAIY SHEDRLSMHR LKADEAYVIG EEGQYTPVGA
#    PYC_MOUSE       IAIRVFRACT ELGIRTVAVY SEQDTGQMHR QKADEAYLIG R..GLAPVQA
#
#    PYC1_YEAST      YLAIDEIISI AQKHQVDFIH PGYGFLSENS EFADKVVKAG ITWIGPPAEV
#    PYC2_YEAST      YLAMDEIIEI AKKHKVDFIH PGYGFLSENS EFADKVVKAG ITWIGPPAEV
#    PYC_MOUSE       YLHIPDIIKV AKENGVDAVH PGYGFLSERA DFAQACQDAG VRFIGPSPEV
#
# Keywords : write_msf_files, save_msf_files
# Version  : 2.2
#------------------------------------------------------------
sub write_msf{
		 my($seq, $string, $name, $k, $i, $longest_seq_leng, @seq_order_final,
				$seq_order, @files_created, @names, $fill_seq_to_the_end);
		 $| =1;
		 if(@_ < 2){
					print "\n# write_msf: I need 2 arguments(hash and filename). Look at the header box\n";
					print chr(7); die;
		 }
		 my($gap_char)='-';
		 my(%input)=%{$_[0]};
		 my($output_file)=${$_[1]} || $_[1];

		 if($_[2]=~/o=(.+)/){
				 $seq_order=$1;
				 @seq_order=split(/\s+/, $seq_order);
		 }elsif(ref($_[2]) eq 'ARRAY'){
				 @seq_order=@{$_[2]};
		 }
		 @names = sort keys %input;

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 # If seq order information is given, sort the out output
		 #________________________________________________________________
		 if(@seq_order > 0){ # when seq names were given in an order, you just use it
				 print "\n# (INFO) \@seq_order is given \n";
				 for($i=0; $i< @seq_order; $i++){
						 $seq_order_item=$seq_order[$i];
						 if($seq_order_item=~/_rv$/){ $seq_order_item=~s/_rv$// }
						 for($j=0; $j<@names; $j++){
								$names_item=$names[$j];
								if($names_item=~/_rv$/){ $names_item=~s/_rv$// }
								if($seq_order_item eq $names_item){
										push(@seq_order_final, $names[$j]);
										splice(@names, $j, 1); $j--;
								}else{ next }
						 }
				 }
				 @names=@seq_order_final;
		 }
		 $longest_seq_leng=length($input{$names[0]});
		 for $name (@names){
				 $len = length($input{$name});
				 if($len< 1){ print "\n# (ERROR) The length of seq. in \%input with $name key is 0, error!\n";
						 die;  }
				 $longest_seq_leng=$len if $len > $longest_seq_leng;
		 }

		 push(@files_created, $output_file);
		 open (MSF_FILE_OUT,">$output_file");        # $string is the seq string.

		 print MSF_FILE_OUT " $output_file  MSF: $longest_seq_leng",' Type: P    Check:  9937   .. '; ## This is dummy
		 print MSF_FILE_OUT "\n\n";


		 for $name (@names){
					 $len = length($input{$name});
					 printf MSF_FILE_OUT (" Name: %-15s   Len: %-5s Check:  9999  Weight:  1.00\n", $name, $longest_seq_leng);
		 }
		 print MSF_FILE_OUT "\n";
		 print MSF_FILE_OUT "\/\/\n\n";
#""""""""""""""""""""""""""""""""""""""""""""""""""
#             MSF file form
#==================================================
format MSF_FILE_OUT =
@<<<<<<<<<<<<<<<<<<<<  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$names,         $seq
.

		 for ($k=0; $k < $longest_seq_leng; $k+=50){    # 50 residues interval
					 for($i=0; $i < @names; $i++){    # number of sequences
									$names = $names[$i];
									$input{$names[$i]}=~ s/\n//g;
									#$input{$names[$i]}=~ s/_/$gap_char/g; # automatically changes '_' to '-'

									$seq = substr($input{$names[$i]}, $k, 50);
									$seq_leng=length($seq);

									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# This is to fill the empty space to make complete block of seq
									#________________________________________________________________
									if($fill_seq_to_the_end){
												$seq .="$gap_char"x($longest_seq_leng-$seq_leng); # putting '---' at the blank line end
												# Above option will coredump 'seaview' seq editor
									}
									$seq=~s/[\-_ ]/$gap_char/g; # setting the final gap_char you like

									$seq = &put_gaps_every_x_position_in_string_special($seq, 10, ' ');
									sub put_gaps_every_x_position_in_string_special{
											my($string); if(ref($_[0])){ $string = ${$_[0]};
																	 }else{ $string = $_[0]; }
											my($interval) = $_[1];     my($gap_char) = $_[2];
											$string =~ s/(.{$interval,$interval})/$1$gap_char/g;
											return($string);
									}

									select (MSF_FILE_OUT); ## to print out to a FILE
									write MSF_FILE_OUT;
					 }
					 print "\n";                       # next block starts.
		 }
		 close(MSF_FILE_OUT);
		 select STDOUT;  # <- this is necessary to normalize output for other sub
		 return(\@files_created);
}




#______________________________________________________________
# Title     : get_seqblock
# Usage     :
# Function  :
# Example   : @blocks_in_hash=@{&get_seqblock(\%msf, 30)};
# Warning   :
# Keywords  : find_sequence_block, get_sequence_block, BLOCK
#             make_seq_block, make_seqblock, find_seqblock, sequence_block
# Options   : _  for debugging.
#             #  for debugging.
#             m=  for margin length of the seqblock
#             t=  for threshold
#             l=  for min seqlet length
#
# Returns   :
# Argument  :
# Category  :
# Authors   : jong@mrc-lmb.cam.ac.uk
# Version   : 1.4
#--------------------------------------------------------------
sub get_seqblock{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my ($connect_gap, @seq_frag, %digitized, $verbose, %hash, $best_block_opt);
	my $margin=3;
	my $threshold=0.8;
	my $min_seqlet_size=25;
	$connect_gap=5;
	my @vars=keys %vars;
	for($i=0; $i< @vars; $i++){
	   if($vars[$i] eq 'm'){
		  $margin=$margin_ori=$vars{$vars[$i]};
	   }elsif($vars[$i] eq 't'){
		  $threshold=$vars{$vars[$i]};
	   }elsif($vars[$i] eq 'l'){
		  $min_seqlet_size=$vars{$vars[$i]};
	   }elsif($vars[$i] eq 'c'){
		  $connect_gap=$vars{$vars[$i]} if( defined($vars{$vars[$i]}) );
	   }
	}
	if($char_opt=~/b/){ $best_block_opt='b' }
	if($char_opt=~/r/){ $range_in_name='r' }
	if($char_opt=~/c/){ $connect_opt ='c' }
	if($char_opt=~/v/){ $verbose='v' }
	for($o=0; $o<@hash; $o++){
	  %hash=%{$hash[$o]};
	  %digitized=%{&convert_char_to_0_or_1_hash($hash[$o])};
	}

	%added=%{&add_columns(\%digitized)}; # 11111 + 1010101 => 2121211

	&show_hash(\%added) if ($debug==1);

	%blocks=%{&get_high_score_blocks(\%added,
			   "m=$margin", "t=$threshold", "l=$min_seqlet_size", $verbose,
			   "c=$connect_gap", $connect_opt, $best_block_opt, $range_in_name)};

	my @keys=keys %blocks;
	for($e=0; $e< @keys; $e++){

	   my $range="$keys[$e]\-$blocks{$keys[$e]}";
	   my $seq_let_leng=$blocks{$keys[$e]} - $keys[$e] + 1;
	   if($seq_let_leng < $min_seqlet_size){
		  next;
	   }else{
	      push(@RANGE, $range);
	   }
	}
	@seq_frag=&get_seq_fragments(\%hash, @RANGE,
	    "l=$min_seqlet_size", "$range_in_name");
	return(\@seq_frag);
}


#______________________________________________________________
# Title     : add_columns
# Usage     :
# Function  :
# Example   :
# Warning   : if the attached name is too long(over 12 char),
#             it changes to 'Added_upX' while X is a numb.
# Keywords  : add_seq_columns, add_sequence_columns,
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------
sub add_columns{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my $gap_char=' ';
	for($i=0; $i<@hash; $i++){
	  my %hash=%{$hash[$i]};
	  my @names=keys %hash;
	  my %final_hash_out;
	  my @final_added;
	  my $out_seq_name='Add';
	  for($j=0; $j<@names; $j++){
	     $out_seq_name.= "_$names[$j]";
		 my $string =$hash{$names[$j]};
		 my @ar_string;
		 if($string=~/\d{1,5}[ \,]\d{1,5}[ \,]\d{1,5}/){
			@ar_string =split(/$gap_char|\,/, $string );
		 }elsif($string=~/^\d{5,}$/){
			@ar_string =split(//, $string );
		 }
		 for($s=0; $s < @ar_string; $s++){
			$final_added[$s]=$ar_string[$s]+$final_added[$s];
		 }
	  }
	  if(length($out_seq_name) > 12){ $out_seq_name="Added_up${i}"; }
	  $final_hash_out{$out_seq_name}=join("$gap_char", @final_added);
	  push(@OUT_HASH, \%final_hash_out);
	}
				wantarray ? return(@OUT_HASH) : return($OUT_HASH[0]);
}


#____________________________________________________________________
# Title     : get_high_score_blocks
# Usage     : get_high_score_blocks(<ref. of hash for number string>)
# Function  : gets hash of key and number string and filters out the
#              number string region which is below certain threshold
#              determined inside this sub and returns a selected high
#              number regions
# Example   : %block_start_end=%{&get_high_score_blocks(\%input_numb_block)};
#             %out=%{&get_high_score_blocks(\%inp_numbs, 'v', 'b')};
# Warning   : This assumes that the inputs are multiply aligned seq
# Keywords  : high_scoring_regions
#             get_high_scoring_blocks, find_blocks, get_blocks
# Options   : _  for debugging.
#             #  for debugging.
#             b  for best_block_opt, returns best block only
#             v  for showing the final range hash output
#             c  for connect close blocks
#             c= for connect close blocks with specific closing gap size
#             m=  for margin length of the seqblock
#             t=  for threshold
#             l=  for min seqlet length
#
# Returns   :
# Argument  : accepts one single ref. of hash
# Category  :
# Version   : 1.4
#--------------------------------------------------------------------
sub get_high_score_blocks{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	my $min_seqblock_leng=25;
	my $threshold=0.8;
	my (%block_start_end, @possible_block, %hash, $range_in_name,$connect_gap);
	my $margin=$margin_ori=2;  # $margin is m in .....mmm111111111111mmm.....
	my $gap_char=' ';
	my @vars=keys %vars;
	my $connection_gap=5;
	my $connect_opt=1;
	for($i=0; $i< @vars; $i++){
	   if($vars[$i] eq 'm'){
		  $margin=$margin_ori=$vars{$vars[$i]};
	   }elsif($vars[$i] eq 't'){
		  $threshold=$vars{$vars[$i]};
	   }elsif($vars[$i] eq 'l'){
		  $min_seqblock_leng=$vars{$vars[$i]};
	   }elsif($vars[$i] eq 'c'){
		  $connect_opt='c';
		  $connection_gap=$vars{$vars[$i]};
		  #print "\n get_high_score_blocks: \$connection_gap is $connection_gap\n";
	   }
	}
	if($char_opt=~/c/){ $connect_opt='c' }
	if($char_opt=~/r/){ $range_in_name='r' }
	if($char_opt=~/v/){
		print "\n  \$threshold         is $threshold    ";
		print "\n  \$margin            is $margin       ";
		print "\n  \$min_seqblock_leng is $min_seqblock_leng \n\n";
		print "\n  \$connection_gap   is $connection_gap \n\n";
		print "\n  \$connect_opt      is $connect_opt \n\n";
	}

	for($i=0; $i<@hash; $i++){
	   my @range;
	   my %hash_ori=%{$hash[$i]};
	   my @names=keys %hash_ori;
	   if(@names>1){ # If the hash has multi entry, make one added up hash
	      %hash=%{&add_columns(\%hash_ori)};
	      @names=keys %hash;
	   }else{  %hash=%hash_ori;    }
	   for($j=0; $j< @names; $j++){
		  my $string=$hash{$names[$j]};
		  if($string=~/\d{1,5}[ \,]\d{1,5}[ \,]\d{1,5}/){
			 @ar_string =split(/$gap_char|\,/, $string );
		  }elsif($string=~/^\d{4,}$/){ ## the string should be minimum 4 length
			 @ar_string =split(//, $string );
		  }
		  my $largest = ${&get_largest_element(\@ar_string)};
		  my $cut_line=$largest*$threshold;
		  #print "\n \$cutline in get_high_score_blocks is $cut_line \n" if $debug==1;
		  #~~~~~~~~~~~~  Cutting the tops The core algorythm #######
		  for($s=0; $s< @ar_string; $s++){
			 if($ar_string[$s] > $cut_line){ # possible_block is the increasing seqlet
				if(@possible_block == $min_seqblock_leng){
				   while( $ar_string[$s] > $cut_line){
					  $ar_string[$s]=1;
					  while($s+1+$margin > @ar_string){ $margin-- }
					  push(@possible_block, ($s+1+$margin));
					  $margin=$margin_ori;
					  $s++;
				   }
				   $ar_string[$s]=0;  #<--- Should be 0 than 1
				   $block_start_end{$possible_block[0]}=$possible_block[$#possible_block];
				   @possible_block=();
				}else{
				   $ar_string[$s]=1;
				   while(($s+1-$margin) < 0){ $margin-- };
				   push(@possible_block, ($s+1-$margin) );
				   $margin=$margin_ori;
				}
			 }elsif($ar_string[$s] <= $cut_line){
				$ar_string[$s]=0;
				@possible_block=();
			 }
		  }
		  #print "\n", @ar_string,"\n" if $debug==1;
		  #~~~~~~~~~~~~  Cutting the tops The core algorythm #######
	   }
	}
	#print "\n@ar_string\n";
	#&show_hash(\%block_start_end);
	&show_hash(\%block_start_end) if($char_opt=~/v/);

	#~~~~~~~~~~~~  Connecting blocks ~~~~~~~~~~~~~~~~~~~~~~
	if($connect_opt=~/c/){
	   my @keys=sort numerically keys %block_start_end;
	   sub numerically{  $a <=> $b;  }

	   ### sorting the %block_start_end
	   for($i=0; $i< @keys; $i++){
		  push(@block_s_e, $keys[$i], $block_start_end{$keys[$i]});
	   }

	   for($i=1; $i< $#block_s_e; $i++){  ## must be $#block_s_e to stop
		  $first_end   =$block_s_e[$i];   ## before it removes everything
		  $second_start=$block_s_e[$i+1];

		  #""""""" if gap is smaller than connection_gap given """"""""
		  if($connection_gap > ($second_start-$first_end) ){
			 splice(@block_s_e, $i, 2);
			 $i--;
		  }else{
		     $i++; # to skip to the next start correctly
		  }
	   }
	   %block_start_end=@block_s_e;
	}
	print "\n# Blocks start and end after connection(gap was $connection_gap)\n"  if($char_opt=~/v/);

	&show_hash(\%block_start_end)  if($char_opt=~/v/);

	#~~~~~~~~~~~~ Getting the largest ~~~~~~~~~~~~~~~~~~~~~~~
	if($char_opt=~/b/){
	   print "\n# Getting the largest block only to get all the blocks use a opt\n";
	   my @keys=keys %block_start_end;
	   my ($largest, %largest,$range_size, $largest_key);
	   for($i=0; $i< @keys; $i++){
		  $range_size = $block_start_end{$keys[$i]}-$keys[$i];
		  if($range_size > $largest){
			 $largest=$range_size;
			 $largest_key=$keys[$i];
			 #print "\n $largest_key \n";
		  }
	   }
	   $largest{$largest_key}=$block_start_end{$largest_key};
	   %block_start_end=%largest;
	   print "\n# The best block chosen (from to) \n"  if($char_opt=~/v/);
	   &show_hash(\%block_start_end) if($char_opt=~/v/);
	}
	return(\%block_start_end);
}






#______________________________________________________________
# Title     : delbut
# Usage     : delbut *.zip  (delete files except xxxx.zip)
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------
sub delbut{
		my ($remove_subdir, $i);
		@save_files=@{$_[0]} || @_;
		$remove_subdir=${$_[1]} || $_;
		for(@save_files){
			 if($_=~/^s\s*$/ and !(-e $_)){ $remove_subdir='s'; next }
			 unless(-e $_){
				 print "\n\n \"$_\" does not exist, so nothing is deleted\n\n";
				 print chr(7);
				 die;
			 }
		}
		my @files=@{&read_dir_and_file_names_only('.')};
		my @del_files=@{&subtract_array(\@files, \@save_files)};

		for($i=0; $i< @del_files; $i++){
			 if(-d $del_files[$i]){
			    if( $remove_subdir=~/s/i){
						 system("rm -fr $del_files[$i]");
					}else{
					   print "\n# subdir $del_files[$i] has not been deleted\n";
					}
			 }else{
			    unlink($del_files[$i]);
			 }
		}
}

#______________________________________________________________________________
# Title     : subtract_hash
# Usage     :
# Function  :
# Example   :
# Keywords  : subtract_hash_by_keys, get_diff_between_2_hashes, subtract_hashes
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub subtract_hash{
    my(%counter, %File_1, %File_2, @keys1, @keys2, @diff, %Hash1_minus_Hash2);
    %File_1=%{$_[0]};
    %File_2=%{$_[1]};
    @keys1=sort keys (%File_1);
    @keys2=sort keys (%File_2);
    grep($counter{$_}++, @keys2 );
    @diff=grep(!$counter{$_}, @keys1);
    foreach(@diff){
       $Hash1_minus_Hash2{$_}=$File_1{$_};
    }
    return(\%Hash1_minus_Hash2);
}

#________________________________________________________________________
# Title     : subtract_array
# Usage     : @subs = @{&subtract_array(\@array1, \@array2)};
# Function  : removes any occurances of certain elem. of the first
#             input array with second input array.
# Example   : Following will produce (A K C);
#		@array1= qw( A B K B B C);
#  		@array2= qw( B E D);
#  		@subs = @{&subtract_array(\@array1, \@array2)};
# Keywords  : array_subtract, substract_array, ary1_minus_ary2
# Options   :
# Returns   :
# Argument  :
# Authors   : jong@biosophy.org
# Version   : 1.4
#--------------------------------------------------------------------
sub subtract_array{
    my(@first, @second, %counter);
    @first=@{$_[0]};
    @second=@{$_[1]};
    grep($counter{$_}++, @second );
    return ( [grep(!$counter{$_}, @first)] );
}


#______________________________________________________________
# Title     : get_mspa_range
# Usage     : @range=@{&get_mspa_range($seqlet)};
#             @temp=&get_mspa_range($seqlet);
#
# Function  :
# Example   :
# Warning   :
# Keywords  : get_mspa_file_ranges
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.5
#--------------------------------------------------------------
sub get_mspa_range{
	 my $lines1=${$_[0]} || $_[0];
	 my ($SEQ, $num_seq, $matched_SEQ, @Ranges);
	 if($lines1 =~/^\s*\d+\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
	  $SEQ        =$3;
	  $matched_SEQ=$6;
	  if($SEQ eq $matched_SEQ){ ## skipping self match
		  $num_seq++;
	  }else{
		  @Ranges=($1, $2, $4, $5);  ## <-- example. (10-20, 30-45)
	  }
	 }
	 return wantarray ? (\@Ranges, \$SEQ, \$matched_SEQ): \@Ranges;
}
#______________________________________________________________
# Title     : get_mspa_enquiry_sequence
# Usage     :
# Function  : gets the name of sequence used as enquiry(target)
# Example   :
# Warning   :
# Keywords  : get_mspa_target_sequence, get_mspa_enquiry_sequence_name
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub get_mspa_enquiry_sequence{
	 my $lines1=${$_[0]} || $_[0];
	 my ($SEQ, $matched_SEQ);
	 if($lines1 =~/^\s*\d+\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
	  $SEQ        =$3;
	  $matched_SEQ=$6;
	 }
	 return \$SEQ;
}

#______________________________________________________________
# Title     : get_mspa_matched_sequence
# Usage     :
# Function  : gets the name of sequence used as enquiry(target)
# Example   :
# Warning   :
# Keywords  : get_mspa_matched_sequence_name
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub get_mspa_matched_sequence{
	 my $lines1=${$_[0]} || $_[0];
	 my ($SEQ, $matched_SEQ);
	 if($lines1 =~/^\s*\d+\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
	  $SEQ        =$3;
	  $matched_SEQ=$6;
	 }
	 return \$matched_SEQ;
}


#______________________________________________________________________________
# Title     : get_line_number
# Usage     :
# Function  :
# Example   :
# Keywords  : get_line_number_from_cursor, line_number, get_line_position
# Options   :
# Author    : jong@biosophy.org, from Andrew E. Page, aep@world.std.com
# Category  : Tk
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_line_number{
    my ($self) = @_ ;
    my ($line_num_info) ;

    $line_num_info = $self->index('insert') ; # get the location for the insertion point
    $line_num_info =~ s/\..*$/\.0/ ;
    return \(int $info); # return a reference
} # end of get_line_number


#______________________________________________________________
# Title     : get_linked_sequence
# Function  : opens msp file and links the sequences according
#             to the matches.
# Usage     :
# Example   : seq1 ------------------------------
#                            |||||||||||
#             seq2        --------------------------------
#             OUT  000000000011111111111000000000000000000
#
# Warning   :
# Keywords  : link_sequence_from_mspa_file, linked_sequenced_length
#             get_clustered_sequence_length, get_annexed_sequence_length
#             connect_sequences, merge_sequences, combine_sequences
# Options   : _  for debugging.
#             #  for debugging.
# Returns   : A ref. of an array
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub get_linked_sequence{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my ($final_leng, $start_diff,@MSP, %seq_sizes, $final_leng);
				 my ($max_head_overhang, $head_diff, $tail_diff,
		 $off_set, $max_tail_overhang, @LINKED, $LINKED);
	 my $Threshold=40;
	 for($i=0; $i< @file; $i++){
	  my($input_file) = ${$file[$i]} || $file[$i];
	  if($debug eq 1){ print "\n inputfile is $input_file\n" };
	  unless (-e $input_file){
		  print chr(7);
		  print "\n\n\t This is sub open_mspa_files in $0  \n\n";
		  print "\t Fatal: The input file $input_file is not in the directory \n";
	  }
	  my %seq_sizes=%{&open_mspa_files(\$input_file, '-s')};
	  my @NAmes=keys %seq_sizes;
	  for($s=0; $s< @NAmes; $s++){ # making '000000000000000.....';
		 my $len=$seq_sizes{$NAmes[$s]};
		 for($t=0; $t< $len; $t++){
			${"$NAmes[$s]"}[$t]=0;
		 }
	  }
	  open(FILE_1,"$input_file");
	  my @MSP=<FILE_1>;
	  close(FILE_1);
	  for($j=0; $j<@MSP; $j++){
		 if($MSP[$j]=~/^\s*(\d+)\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\w+)\s+(\d+)\s+(\d+)\s+(\w+)\s+(.+)/i){
			if(($1 >= $Threshold)&& ($4 eq $7)){
			   push(@matched_members, $4);
			}elsif(($1 >= $Threshold)&& ($4 ne $7)){
			   $matched_segment_count++;
			   if($match_name ne $7){  push(@matched_members, $7);  }
			   $query_start=$2-1;  $query_end  =$3-1;
			   $query_seq  =$4;    $match_start=$5-1;
			   $match_end  =$6-1;  $desc       =$8;
			   $match_name =$7;
			   for($x=$query_start; $x<= $query_end; $x++){
				  ${"$query_name"}[$x]++;
			   }
			   for($y=$match_start; $y<= $match_end; $y++){
				  ${"$match_name"}[$y]++;
			   }
			}
		 }
	  }
	  for($j=0; $j<@MSP; $j++){
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 #                 $1                $2     $3    $4      $5     $6    $7     $8
		 #                 171     41.18      6      73  HI1690    9      76  HI0736 sodium...
		 #,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
		 if($MSP[$j]=~/^\s*(\d+)\s+\d+\.?[e\-\d]*\s+(\d+)\s+(\d+)\s+(\w+)\s+(\d+)\s+(\d+)\s+(\w+)\s+(.+)/i){
			if(($1 >= $Threshold)&& ($4 eq $7)){
			   $query_name=$4;   $query_leng=$3;
			   push(@matched_members, $4);
			}elsif(($1 >= $Threshold)&& ($4 ne $7)){
			   $matched_segment_count++;
			   if($match_name ne $7){  push(@matched_members, $7);  }
			   $query_start=$2-1;  $query_end  =$3-1;
			   $query_seq  =$4;    $match_start=$5-1;
			   $match_end  =$6-1;  $desc       =$8;
			   $match_name =$7;
			}
			@matched_seq_array= @{"$match_name"};
			$matched_seq_array=join('', @matched_seq_array);
			my $start_diff= $query_start - $match_start;
			if($start_diff >= 0){
			   my $tail_diff= $start_diff + $seq_sizes{$match_name} - $seq_sizes{$query_name};
			   if($tail_diff > 0){
				  $max_tail_overhang = $tail_diff if $tail_diff > $max_tail_overhang;
				  for($x=0; $x< $tail_diff; $x++){
					 $tail_start=$seq_sizes{$match_name}-$tail_diff + $x;
					 @matched_seq_array=split(//,$matched_seq_array);
					 $tail_array[$x] +=$matched_seq_array[$tail_start];
				  }
			   }
			}elsif($start_diff < 0){
			   $head_diff = abs($start_diff);
			   $max_head_overhang=$head_diff if $head_diff > $max_head_overhang;
			   for($z=0; $z< $head_diff; $z++){
				  $head_array[$z] += ${"$match_name"}[$z];
			   }
			}
		 }
	  }
	 }
	 @LINKED=( @{"$match_name"}[0..($max_head_overhang-1)], @{"$query_name"}, @tail_array);
	 $LINKED=join('', @LINKED);
	 if($debug eq 1){
	 print __LINE__, " In open_mspa_files \%sequence is", %sequence ,"\n";
	 }
	 $final_offset=$extened_number_line - $query_leng;
	 return(\@LINKED);
}

#______________________________________________________________________________
# Title     : get_averaged_prediction
# Usage     : %av_of_forw_backw_pred=%{&get_averaged_prediction(\%sec1, \%sec1_rv)};
# Function  : The content of out %average is
#               $averaged{$position}=[$residue1, $sec_str2, $dif_reliability];
# Example   :
# Keywords  : get_average_predator_prediction, average_predator_prediction
#             get_averaged_sec_prediction get_average_prediction, give_weights
# Options   :
#   $ignore_non_matching_residues=i by i  ## do not predict non-matching for backward pred.
#   $reverse_order_of_one_hash=r by r
#   $give_weight_with_good_match=w by w # this is to give preference to well
#   $weight_factor= by w=
#                                        matching sec. str. I add '0.1'
# Author    : jong@biosophy.org sat@mrc-lmb.cam.ac.uk
# Version   : 2.1
#------------------------------------------------------------------------------
sub get_averaged_prediction{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		 my($position, $residue1, $residue2, %averaged, %hash1, %hash2, $sec_str1,
				$sec_str2, $sum_reliability, $average_reliability, $dif_reliability,
				$reverse_order_of_one_hash, $give_weight_with_good_match, $weight_factor,
				$mismatched_prediction_count, $matched_prediction_count,
				%mismatch_stats, $num_of_residues, $ignore_non_matching_residues);
		 $weight_factor=1.8; # default positive weight factor which is really small.

		 if($char_opt=~/r/){  $reverse_order_of_one_hash='r';
				 print "\n# (i) get_averaged_prediction : \$reverse_order_of_one_hash is $reverse_order_of_one_hash";
		 }
		 if($char_opt=~/w/){  $give_weight_with_good_match='w';     $weight_factor=1.8; }
		 if($char_opt=~/i/){  $ignore_non_matching_residues='i';    }
		 if($vars{'w'}=~/(\S+)/){ $give_weight_with_good_match='w'; $weight_factor=$1 }
		 $input_hash_num=@hash;

		 print "\n#    (i) get_averaged_prediction: The number of hashes to get_averaged_prediction was $input_hash_num\n";
		 for($i=0; $i< @hash; $i++){
				 unless(%averaged > 2){
							%hash1=%{$hash[$i]};
							%hash2=%{$hash[$i+1]};
							$i++;
				 }elsif( %averaged ){
							%hash1=%averaged;
							%hash2=%{$hash[$i]};
							print "\n   # (i) Iteratively averaging hash $i (counted from 0) with previous average\n";
				 }

				 $num_of_residues=@keys=sort { $a <=> $b} keys %hash1;
				 for($k=0; $k< @keys; $k++){
							$position      =$keys[$k]; ## in case of predator prediction, key is the position of residue
							$rev_posi      =@keys-$position+1;

							$residue1      =$hash1{$position}->[0];
							if($reverse_order_of_one_hash){
								 $residue2      =$hash2{$rev_posi}->[0];
							}else{
								 $residue2      =$hash2{$position}->[0];
							}

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``~
							# (1)This is for Identical sequence averaging with REVERSING option (for and backward forward perhaps)
							#____________________________________________________________________________________________
							if($residue1=~/$residue2/i){ # if they are the same aa
									 $sec_str1      =$hash1{$position}->[1]; ## usually one of 'c h e'
									 if($reverse_order_of_one_hash){
											$sec_str2      =$hash2{$rev_posi}->[1];
									 }else{
											$sec_str2      =$hash2{$position}->[1];
									 }

									 #print "# ($position) $sec_str1 $sec_str2, $residue1 $residue2 ";

									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									 # If both predictions are matching  H->H and E->E cases
									 #________________________________________________________
									 if($sec_str1=~/$sec_str2/i){
											 $matched_prediction_count++;
											 if($sec_str1=~/^[eEhHcC]$/i){
													 $sum_reliability = ($hash1{$position}->[2] + $hash2{$rev_posi}->[2] + $weight_factor/3);
													 $average_reliability=($sum_reliability/2) * $weight_factor;  # usually 0.1
													 $averaged{$position}=[$residue1, $sec_str1, $average_reliability];
													 #print " $sum_reliability, $average_reliability\n";
													 $average_reliability=$sum_reliability='';
											 }else{
													 $sum_reliability = ($hash1{$position}->[2] + $hash2{$rev_posi}->[2]);
													 $average_reliability=($sum_reliability/2) * $weight_factor;
													 $averaged{$position}=[$residue1, $sec_str1, $average_reliability];
													 $average_reliability=$sum_reliability='';
											 }
									 }
									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
									 # If both predictions are NOT matching eg)  E->H, C-H, E-C,,,
									 #________________________________________________________________
									 else{
											 if ($sec_str1 =~/h/i){
													 if($sec_str2 =~/e/i){     $mismatch_stats{'H_E_mismatch'}++;
													 }elsif($sec_str2 =~/c/i){ $mismatch_stats{'H_C_mismatch'}++;
													 }
											 }elsif($sec_str1 =~/e/i){
													 if($sec_str2 =~/h/i){     $mismatch_stats{'E_H_mismatch'}++;
													 }elsif($sec_str2 =~/c/i){ $mismatch_stats{'E_C_mismatch'}++;
													 }
											 }elsif($sec_str1 =~/c/i){
													 if($sec_str2 =~/h/i){     $mismatch_stats{'C_H_mismatch'}++;
													 }elsif($sec_str2 =~/e/i){ $mismatch_stats{'C_E_mismatch'}++;
													 }
											 }
											 $mismatched_prediction_count++;
											 $dif_reliability =$hash1{$position}->[2];
											 if($ignore_non_matching_residues){
													 $averaged{$position}=[$residue1, '_', $dif_reliability];
											 }else{
													 $averaged{$position}=[$residue1, $sec_str2 , $dif_reliability];
											 }
											 #$averaged{$position}=[$residue1, $sec_str1, $dif_reliability];
											 #print "  << $dif_reliability, $dif_reliability\n";
											 $dif_reliability=$sum_reliability='';
									 }
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# (2) This is for NOT identical sequences averaging. From multi alignment perhaps
							#_________________________________________________________________________________
							}else{
									 #print "   # (i) $position: $residue1: Not reversing the order here, From multi alignment perhaps\n";
									 print chr(7), "\n# (W) Somehow the residues are not identical: $residue1 $residue2\n\n";
									 sleep (4);
									 $sec_str1      =$hash1{$position}->[1]; ## usually one of 'c h e'
									 if($reverse_order_of_one_hash){
											$sec_str2      =$hash2{$rev_posi}->[1];
									 }else{
											$sec_str2      =$hash2{$position}->[1];
									 }

									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									 # If both predictions are matching eg)  H->H
									 #________________________________________________
									 if($sec_str1=~/$sec_str2/i){
											 $sum_reliability = ($hash1{$position}->[2] + $hash2{$rev_posi}->[2]);
											 if($residue1 ne $residue2){
													 $average_reliability=($sum_reliability/2) * $weight_factor;  # usually 0.1
											 }else{
													 $average_reliability=($sum_reliability/2) * $weight_factor;  # usually 0.1
											 }
											 $averaged{$position}=[$residue1, $sec_str1, $average_reliability];
											 print "# ($position) $sec_str1 $sec_str2, $residue1 $residue2, $sum_reliability, $average_reliability\n";
											 $average_reliability=$sum_reliability='';

									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									 # If both predictions are NOT matching eg)  E->H
									 #________________________________________________
									 }else{

											 $average_reliability = ($hash1{$position}->[2]);
											 if($ignore_non_matching_residues){
													 $averaged{$position}=[$residue1, '_', $average_reliability];
											 }else{
													 $averaged{$position}=[$residue1, $sec_str2 , $average_reliability]; ##<--- Watch out
											 }
											 $average_reliability=$sum_reliability='';
									 }

							}
				 }
		 }
		 $averaged{'mismatched_prediction_count'}=$mismatched_prediction_count;
		 $averaged{'matched_prediction_count'}   =$matched_prediction_count;
		 $averaged{'mismatch_stats'}={%mismatch_stats};
		 $averaged{'num_of_residues'}=$num_of_residues;
		 return(\%averaged);
}



#______________________________________________________________
# Title     : get_average_sequence_size
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  : get_av_sequence_size, get_average_seq_size
#             get_av_seq_size, average_seq_size, av_seq_size
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub get_average_sequence_size{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my( @OUT_AV, $size, @size, @names, %hash, $sum, $av);
	 for($i=0; $i<@hash; $i++){
	 %hash=%{$hash[$i]};
	 @names=keys %hash;
	 for($j=0; $j<@names; $j++){
		$size=length($hash{$names[$j]});
		push(@size, $size);
	 }
	 for($j=0; $j<@size; $j++){
		$sum+=$size[$j];
	 }
	 $av=int($sum/@names);
	 push(@OUT_AV, $av);
	 }
	 wantarray ? \@OUT_AV : \$OUT_AV[0];
}


#______________________________________________________________
# Title     : get_linux_kernel_version
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  : get_kernel_version, kernel_version,
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub get_linux_kernel_version {
	my($image, $version, $i);
	for($i=0; $i< @_; $i++){
		 if(ref($_[$i]) eq 'SCALAR'){
				$image  = ${$_[$i]};
		 }else{
				$image  = $_[$i];
		 }
		 unless(defined($image)){
				if(-e '/vmlinuz'){
					 $image='/vmlinuz';
				}elsif(-e '/boot/vmlinuz'){
					 $image='/boot/vmlinuz';
				}elsif(-f '/boot/bvmlinux' ){
					 $image='/boot/bvmlinux';
				}
		 }
		 print "\n# The final chosn \$image is $image\n";
		 my($str)             = "phlogiston";
		 my($version_start)   = 0;
		 my($version_length)  = 10;

		 open(DATA, $image) or return(undef);
		 #seek(DATA, $version_start, 0);
		 while(<DATA>){
				if(/(\d+\.\d+\.\d+)/){
						$version=$1;
						push(@versions, $version);
						last;
				}
		 }
		 close(DATA);
	}
	if(@versions > 1){
			return(\@versions);
	}else{
			return(\$version)
	}
}



#______________________________________________________________
# Title     : load_mount_info
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub load_mount_info {
	undef %mounted;
	undef %fs_type;

	open(MTAB, "</etc/mtab") or die "Can't read /etc/mtab: $!\n";
	while (<MTAB>) {
	my($dev, $mp, $type) = split;
	next if $dev eq 'none';
	$mounted{$dev} = $mp;
	$mounted{$mp}  = $dev;
	$fs_type{$dev} = $type;
	}
	close(MTAB);
}



#______________________________________________________________
# Title     : plot_vertically
# Usage     : &plot_vertically(\@query);
# Function  : This is a sub used for plot_domains.pl for
#             genome_analysis
# Example   :
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub plot_vertically{
	@numbers=@{$_[0]};
	print "\n    |===================================================\>\n";
	for($i=0; $i<@numbers;$i++){
	 printf ("%-4d\|", $i);
	 print "\*"x$numbers[$i], "\n";
	}
	print "    |===================================================\>\n";
}

#______________________________________________________________
# Title     : plot_histogram_horizontally
# Usage     : &plot_horizontally(\@query);
# Function  :
# Example   :
#  Input: $input= '00001111111113333333333444444444111111111111111';
#
#  Output:
#   00001111111113333333333444444444111111111111111
#   1-------------------------------------------47
#  |
#  |
#  |                       *********
#  |             *******************
#  |             *******************
#  |    *******************************************
#  |-----------------------------------------------
#
# Warning   :
# Keywords  : plot_horizontally, plot_numbers_horizontally, plot,
#             plot_numbers,
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------
sub plot_histogram_horizontally{
	my @numbers=@{$_[0]};
	my $leng= @numbers;
	my ($largest, @inversed, $m, $i);
	for($i=0; $i< @numbers; $i++){
	$largest=$numbers[$i] if $largest < $numbers[$i];
	}
	for($i=0; $i< @numbers; $i++){ # this inverse the digits
	$inversed[$i]=abs($numbers[$i]-$largest);
	}
	print "\n ", @numbers;
	print "\n 1", "\-"x($leng-4),$leng;
	print "\n\|";
	print "\n\|";

	for($m=0; $m< $largest; $m++){
	print "\n\|";
	for($i=0; $i<@inversed;$i++){
	   if($inversed[$i] > 0){
		 print " ";
		 $inversed[$i]--;
	   }else{
		 print "\*";
	   }
	}
	}
	print "\n\|", "\-"x@numbers;
	print "\n";
}




#______________________________________________________________
# Title     : condense_number_string
# Usage     :
# Function  : condenses the numbers by making an average with
#             given factor. If the factor is 2 on number seq
#              1334284425 , result will be 23543
#              133428442  ,                23541 <-- preserved end
#             Factor 3 =>
#              133428442  , (1+3+3)/3 = 2
#                           (4+2+8)/3 = 4,,,
# Example   : @output=@{&condense_number_string(\@input, $factor)};
#             with @input=qw(1 2 4 10 10 22 2 3 44 2 3); and $factor=3
# Warning   :
# Keywords  : compact_number_string, compact_digits, condense
#             condense_string
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub condense_number_string{
	my @ARRAY=@{$_[0]};
	my $factor = ${$_[1]} || $_[1];
	my ( $i, $j, @out );
	unless(defined($factor)){ $factor=1 }
	for($i=0; $i< @ARRAY; $i+=$factor){
	  my $temp_sum;
	  for($j=$i; $j < ($factor+$i); $j++){
		$temp_sum+=$ARRAY[$j]
	  }
	  push(@out, int($temp_sum/$factor) );
	}
	return(\@out);
}


#___________________________________________________________
# Title     : get_seq_fragments
# Usage     : @seq_frag=&get_seq_fragments(\%msf, @RANGE);
# Function  : gets sequence(string) segments with defined
#             ranges.
# Example   :
#  %test=('seq1', '1234AAAAAAAAAAAaaaaa', 'seq2', '1234BBBBBBB');
#  @range = ('1-4', '5-8');
#
#  %out = %{&get_seq_fragments(\%test, \@range)};
#  %out => (seq1_5-8   AAAAA
#           seq2_5-8   BBBBB
#           seq1_1-4    1234
#           seq2_1-4    1234 )
#
# Warning   :
# Keywords  : get_sequence_fragments,
# Options   : _  for debugging.
#             #  for debugging.
#             l=  for min seqlet length
#             r  for adding ranges in the seq names
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.8
#-------------------------------------------------------
sub get_seq_fragments{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my $min_seqlet_size=10;
	 my @vars=keys %vars;
	 my $no_range_in_name=1;
	 for($i=0; $i< @vars; $i++){
	   if($vars[$i] eq 'l'){
		  $min_seqlet_size=$vars{$vars[$i]};
	   }
	 }
	 if($char_opt=~/v/){ print "\n \$char_opt is $char_opt  @char_opt\n"; }
	 if($char_opt=~/n/){ $no_range_in_name = 1 }
	 if($char_opt=~/r/){ $no_range_in_name = 0 }

	 print "\nget_seq_fragments \$no_range_in_name is $no_range_in_name \n";
	 for($i=0; $i< @hash; $i++){
	 my (%out_frag, $frag_name, $range_start, $range_end, @out_hash);
	 my %seqs = %{$hash[$i]};
	 my @names = keys %seqs;
	 if(@names==1){
	    for($j=0; $j < @names; $j++){
		   my $seq_name = $names[$j];
		   my $seq = $seqs{$seq_name};
		   for($k=0; $k< @range; $k++){
			  my $range = $range[$k];
			  if($no_range_in_name==1){
				 $frag_name = "$seq_name";
			  }else{
			     $frag_name = "$seq_name\_$range";
			  }
			  #if(length($frag_name)>14 ){
			  #	 $frag_name ='x'."${j}_${range}";
		      #}
			  ($range_start, $range_end)=$range=~/(\d+\.?\d*)\-(\d+\.?\d*)/;
			  my $frag_len = $range_end-$range_start+1;
			  if($frag_len < $min_seqlet_size){
			     next;
			  }
			  my $fragment = substr($seq, $range_start-1, $frag_len);
			  $out_frag{$frag_name}=$fragment;
		   }
		}
		push(@out_hash,  \%out_frag);
	 }elsif(@names > 1){
	    for($k=0; $k< @range; $k++){
		  my %out_frag=();
	      my $range=$range[$k];
		  ($range_start, $range_end)=$range=~/(\d+\.?\d*)\-(\d+\.?\d*)/;
	      my $frag_len = $range_end-$range_start+1;
		  if($frag_len < $min_seqlet_size){
		     next;
		  }
	      for($j=0; $j < @names; $j++){
	         my $seq_name=$names[$j];
			 my $seq = $seqs{$seq_name};
		     if($no_range_in_name==1){
				 $frag_name = "$seq_name";
			 }else{
			     $frag_name = "$seq_name\_$range";
			 }
			 #if(length($frag_name)>15 ){
			 #	$frag_name ='x'."${j}_${range}";
		     #}
			 if($range_start==0){ $range_start++; } ## This is a bugfix
			 my $fragment = substr($seq, $range_start-1, $frag_len);
			 $out_frag{$frag_name}=$fragment;
		  }
		  push(@out_hash, \%out_frag);
		}
	 }
	 }
	 if(@out_hash > 1){ return(@out_hash)
	 }elsif(@out_hash==1){ return($out_hash[0]) }
}




#________________________________________________________________________
# Title     : make_standalone_subroutines
# Usage     : &make_standalone_subroutines(@ARGV);
# Example   : &make_standalone_subroutines(@ARGV);
# Function  : Creates each subroutine derived xxx.pl file from Bio.pl or any
#             given library file. If there is a file for a sub already, it
#             skips.
# Class     : Utility
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub make_standalone_subroutines{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($each_sub, %out_subs, %left_out, @lib, $ver, $real_sub_entry_found);
	$|=1;
	for($i=0; $i < @file; $i++){
		open(LIB_FILE, "<$file[$i]")|| die  "\n $file[$i]  <- $! \n";
		my @lib =<LIB_FILE>;
		FOR: for($j=0; $j < @lib; $j++){
				  my (%out_subs, $each_sub);
				  my $title_found;
				  #"""" Taking the headbox """""""""""""
				  if( ($lib[$j]=~/^#+[_\-\*]{10,120} *$/)
					 &&($lib[$j+1]=~/^(#\s*title\s*:\s*([\w\-]+))[^\.pl]/i) ){
					  $each_sub=$2;
					  $title_found =1;
					  if( (-s "$each_sub\.pl") > 200 ){
						  print (-s "$each_sub\.pl"), "   ";
						  print "  $each_sub", " exists \n";
						  next FOR;
					  }elsif((-s "$each_sub\.pl") <= 200){
					     my $temp;
					     open (TEMP, "<$each_sub\.pl");
					     while(<TEMP>){
					        if(/^#[_\-\*]{10,120}\s*$/){ $temp++ }
					        elsif(/^#\s*title\s*:\s*[\w\-]+[^\.pl]/i ){
					           $temp++;
					        }elsif(/^#\s*\w+/){
					           $temp=$temp+0.5;
					        }
					     }
					     if($temp >2){
					        next FOR;
					     }
					  }

					  $out_subs{"$each_sub"}.="$lib[$j]$1\n";
					  $j+=2;
					  until( ($lib[$j]=~/^sub\s*\w+\s*\{/)||($lib[$j]=~/^#---+\s*$/) ||
							 ($lib[$j]=~/^#_____+\s*$/) || ($lib[$j]=~/^#\*\*+\s*$/) ){
							 $lib[$j]=~s/(\s*)$//;  #<-- removing ending space
							 $out_subs{"$each_sub"}.="$lib[$j]";
							 $j++;
					  }
					  $out_subs{"$each_sub"}.="$lib[$j]";
					  $j++;    ## essential to remove #------------- line
				  }

				  #"""""""" Reading sub {  } """""""
				  if( ($title_found==1)&&($lib[$j]=~/^sub\s+([\w\-]+)\s*\{/) ){
				     $each_sub=$1;
					  $out_subs{"$each_sub"}.="$lib[$j]";
					  if($lib[$j]=~/^sub\s+([\w\-]+)\s*\{.+\}/){
						  goto WRITE;
					  }
					  $j++;
					  until($lib[$j]=~/^\}/){
					     $out_subs{"$each_sub"}.="$lib[$j]";  $j++;
					  }
					  $out_subs{"$each_sub"}.="$lib[$j]";  ## to fetch '}'
					  $j++;

					  WRITE:
				     open (EACH_FILE, ">$each_sub\.pl");
				     print EACH_FILE  "#\!\/perl\n";
				     print EACH_FILE  "# Made by $0 at: ", `date`, "\n";
				     print EACH_FILE $out_subs{$each_sub};
		           close EACH_FILE;
		           %out_subs=();
		           #chmod

				  }
			  }
	}#""""""""""""" end of for (@file)
	close LIB_FILE;
}



#___________________________________________________________
# Title     : is_html
# Usage     :
# Function  : Checks if it is an html file.
# Example   : $html=&is_html(\@test);
# Warning   :
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#-------------------------------------------------------
sub is_html{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my $html=0;
	if( @string >0 ){
	 for($i=0; $i<@string; $i++){
		if($string[$i]=~/^[.\n]{0, 100}\<\s*HTML\s*\>/i){
			$html_head=1;
		}if($string[$i]=~/[.\n]+\<\s*\/HTML\s*\>[\n.]{0,100}$/i){
			$html_end=1;
		}
	 }
	 if( ($html_head eq $html_end)&&($html_end=1)){
		$html=1;
	 }
	 if($debug==1){ print "\n \@string is @string\n"; }
	}elsif(@file>0){
	 for($i=0; $i< @file; $i++){
		my $all_lines;
		open(F, "$file[$i]");
		while(<F>){
		  $all_lines.=$_;
		}
		print "\n All the lines of $file[$i] is $all_lines\n" if $debug==1;
		if($all_lines =~/\<\s*HTML\s*\>/i){
		  if($all_lines=~/\<\s*\/\s*HTML\s*\>/i){
			  $html=1;
			  print "\n html matched $html\n" if $debug ==1;
		  }
		}
	 }
	}elsif( @array>0 ){
	 @arr = @{$array[$i]};
	 for($i=0; $i< @arr; $i++){
		 if($arr[$i]=~/^[.\n]{0, 100}\<\s*HTML\s*\>/i){
			$html_head=1;
		 }if($arr[$i]=~/[.\n]+\<\s*\/HTML\s*\>[\n.]{0,100}$/i){
			$html_end=1;
		 }
	 }
	 if( ($html_head eq $html_end)&&($html_end=1) ){
		$html=1;
	 }
	}elsif(@hash>0){
	 for($i=0; $i< @hash; $i++){
		@hash=%{$hash[$i]};
		for($i=0; $i< @hash; $i++){
			if($hash[$i]=~/^[.\n]{0, 100}\<\s*HTML\s*\>/i){
			  $html_head=1;
			}if($hash[$i]=~/[.\n]+\<\s*\/HTML\s*\>[\n.]{0,100}$/i){
			  $html_end=1;
			}
		}

	 }
	}
	return($html);
}

#___________________________________________________________________
# Title     : get_sum_of_columns
# Usage     : &get_sum_of_columns(\@ar, 1,2 ,3);
#             &get_sum_of_columns(\%ha, 1,2 ,3);
#             &get_sum_of_columns(@ARGV);
#             # where prompt is like: column.pl temp.txt 1 2 3 4
# Function  : Prints any specified columns, can change order of them,
#             can filter values of columns to filter (max or min value)
#             Skipps blank line.
# Example   : For getting only necessary columns
#             Input: %Hash=(1, 'col1 col2 col3',
#                           2, 'col1 col2 col3',
#                           3, 'col1 col2 col3');
#             input format: &get_sum_of_columns(\%Hash, 3,2,1, 'k'); # k is opt
#             Ouput format: STDOUT as
#
#                1     col3 col2 col1
#                2     col3 col2 col1
#                3     col3 col2 col1
#
# Keywords  : columns, column.pl, column, get_sum_of_columns, take_columns,
# Options   : #  for debugging.
#             _  for debugging.
#             k  for Key print when hash input is given.
#             n  for no first line display(Handy when you have title line
#                                          and wanna remove it)
#             ?max?=xxx for filtering column numbers by maximum of xxx
#             ?min?=yyy for filtering column numbers by minimum of yyy
#                      (eg, min4=100000 means 4th column minimum is 100000)
#                      (eg, 1min4=10, 2min3=10, means get 4th column values
#                           below 10 as the first output column. Get 3rd
#                           column values below 10 as the second out column.
#
#  $combine           =1  by -c c   # c is for combining columns in different file
#  $ignore            =1  by -i i   # i is for ignoring leng diff in columns over
#  $reverse_line_order=r by r -r
#
# Returns   : Ref of
# Argument  : Ref of Hash, Array or just filename, and wanted column numbers.
# Category  :
# Version   : 1.7
#---------------------------------------------------------------
sub get_sum_of_columns{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (%whole, %sum_of_colmuns, $previous, @out, @columns);
    my $len =4;
    my @v_keys= sort keys %vars; ## To be able to exchange order of column.
    if($char_opt=~/i/i){
        $ignore =1;
    }elsif($char_opt=~/c/i){
        $combine=1;
    }
    if($char_opt=~/r/){ $reverse_line_order='r' }

    if(@v_keys > 0){
       for($i=0; $i< @v_keys; $i++){
          if($v_keys[$i]=~/\d*(m..)(\d+)/i){
         $M=$1.$2;
         ${"$1$2"}= $vars{$&};
             push(@columns, $2);
          }
       }
    }else{
       @columns=@num_opt;
    }
    my $troubled_column ;

    if((@num_opt==0)&&(@file>1)){ $combine=1 }; # when no column num. is given assume $combine

    #""""""""""" When combine option is set """"""""""""""""""""""
    if(($combine==1)&&(@file > 1)){
       for ($f=0; $f<@file; $f++){
        open(IN, "$file[$f]"); # real showing is now.
        my @all_lines=<IN>;
        if((@all_lines != $previous)&&($ignore !=1)){
            print "\n The column lengths do not match in the inputs\n";
            print "\n you can use -i option \n";
            exit;
        }
        $previous=@all_lines;
        for($w=0; $w< @all_lines; $w++){
            if($all_lines[$w]=~/^[\t ]*$/){ next }  # skipping blank line
            chomp($all_lines[$w]);
            $out[$w].="$all_lines[$w] ";
        }
        close IN;
       }
       push(@array, \@out);
    }

    ###### File is given as input #######""""""""""""""""""""""""""""""""""""""
    if((@file >=1)&&(@array < 1)){
       my $file;
       for $file(@file){
         my ($line_num, $line_read, $change, $line_counter, @all_lines);
         $change=0.1;
         open(IN, "$file");
         @all_lines=<IN>;
         for($q=0; $q < @all_lines; $q++){ # This open is only for getting largest column width size
             $line_read++;
             @splited=split(/\s+/, $all_lines[$q]);
             $l=${&get_longest_str_size(\@splited)};
             if($l>$len){ $len=$l; $change++ }
             if( ($line_read/$change) > 50 ){ last } # this is to check the column
         }                                          # consistency and stops after some
         close(IN);

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Reverse LINE order if -r option is set
         #_____________________________________________
         if($reverse_line_order){
            @all_lines=reverse(@all_lines);
         }
         for($x=0; $x < @all_lines; $x++){
            if($all_lines[$x]=~/^[\s\#]*$/){ next }  # skipping blank line and comment lines
            if($all_lines[$x]=~/^\s{1,3}#/){ next }  # skipping  comment lines
            $line_counter++;
            if(($char_opt=~/n/i)&&($line_counter==1)){ next } ## NO title #
            if(@M=$all_lines[$x]=~/([\-\.\d]+)/g){
               if(@columns < 1){
                 for($n=0; $n< @M; $n++){  $columns[$n]=$n+1;    }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  if( defined( ${"max$col"} ) &&    # when max or min is defined
                       defined( ${"min$col"} ) ){
                        if( ( ${"max$col"}  > $M[$col])&&
                       ( ${"min$col"}  < $M[$col]) ){
                             printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $M[$col] ){
                             printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $M[$col] ){
                            printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                        }else{
                            printf "%-${len}s ";
                        }
                  }else{
                        printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                  }
                  $sum_of_colmuns{$col} +=$M[$col];
              }
              print "\n";

           }
        } #for
      }
    }    ###### Array is given as input #######""""""""""""""""""""""""""""""""""
    elsif(@array>0){  # if input is ('x y xx y','k t yy zz',,,,)
      for($t=0; $t<@array; $t++){
         my @arr=@{$array[$t]};
         #print "\n Array input\n" if $debug ==1;
         for($i=0; $i<@arr;$i++){
           @splited=split(/\s+/,$arr[$i]);
           $l=${&get_longest_str_size(\@splited)};
           $len=$l if $l>$len;
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Reverse LINE order if r option is set
        #_____________________________________________
        if($reverse_line_order){
           @arr=reverse(@arr);
        }
        for($i=0; $i< @arr; $i++){
            if($arr[$i]=~/^[\t ]*$/){ splice(@arr, $i, 1); $i--; next }
            if(($char_opt=~/n/i)&&($i==0)){ next } # skipping the first line
            if(@M=$arr[$i]=~/(\S+)/g){
               if(@columns < 1){
                  for($n=0; $n< @M; $n++){
                     $columns[$n]=$n+1;
                  }
               }
               for($j=0; $j< @columns; $j++){
                  $col =$columns[$j]-1;  #

                  if( defined( ${"max$col"} ) &&    # when max or min is defined
                        defined( ${"min$col"} ) ){
                        if( ( ${"max$col"}  > $M["$col"] )&&
                       ( ${"min$col"}  < $M[$col]) ){
                             printf "%-${len}s ",$M["$col"]  unless($M["$col"]  eq '');
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $M["$col"]  ){
                             printf "%-${len}s ",$M["$col"]  unless($M["$col"]  eq '');
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $M["$col"]  ){
                            printf "%-${len}s ",$M["$col"]  unless($M["$col"] eq '');
                        }else{
                            printf "%-${len}s ";
                        }
                  }else{
                        printf "%-${len}s ",$M["$col"] unless($M["$col"] eq '');
                  }
                  $sum_of_colmuns{$col} +=$M[$col];
               }
               print "\n";
            }
        }
      }
    }  ##### Hash is given as input #######""""""""""""""""""""""""""""""""""
    elsif(@hash>0){
      my @arr;
      for($h=0; $h<@hash; $h++){
          my @array=values %{$hash[$h]};
          my @keys =keys %{$hash[$h]};
          for($i=0; $i< @array; $i++){ # getting the longest str size
             @arr=split(/\s+/,$array[$i]);
             $l=${&get_longest_str_size(\@arr)};
             $len=$l if $l>$len;
          }

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Reverse LINE order if r option is set
          #_____________________________________________
          if($reverse_line_order){
             @array=reverse(@array);
          }
          for($i=0; $i< @array; $i++){
            if($array[$i]=~/^[\t ]*$/){ splice(@array, $i, 1); $i--; next }
            if(($char_opt=~/n/i)&&($i==0)){ next } #  skipping the first line
            printf "%-10s", $keys[$i] if($char_opt=~/k/i); ## Option for key printing
             if(@M=$array[$i]=~/(\S+)/g){
               if(@columns < 1){
                  for($n=0; $n< @M; $n++){
                     $columns[$n]=$n+1;
                  }
               }
               for($j=0; $j< @columns; $j++){

                  $col =$columns[$j]-1;

                  if( defined( ${"max$col"} ) &&    # when max or min is defined
                        defined( ${"min$col"} ) ){
                        if( ( ${"max$col"}  > $M[$col])&&
                       ( ${"min$col"}  < $M[$col]) ){
                             printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $M[$col] ){
                             printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $M[$col] ){
                            printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                        }else{
                            printf "%-${len}s ";
                        }
                  }else{
                        printf "%-${len}s ",$M[$col] unless($M[$col] eq '');
                  }
                  $sum_of_colmuns{$col} +=$M[$col];
               }
               print "\n";
            }
          }
      }
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Writing down the SUM line
    #___________________________________________________
    print "The sum of the columns\' numbers only is:\n\n";
    for($r=0; $r< @columns; $r++){
       $col =$columns[$r]-1;  #
       printf "%-${len}s ", $sum_of_colmuns{$col};
    }
    print "\n\n";
}




#___________________________________________________________________
# Title     : get_column
# Usage     : &get_column(\@ar, 1,2 ,3);
#             &get_column(\%ha, 1,2 ,3);
#             &get_column(@ARGV);
#             # where prompt is like: column.pl temp.txt 1 2 3 4
# Function  : Prints any specified columns, can change order of them,
#             can filter values of columns to filter (max or min value)
#             Skipps blank line.
# Example   : For getting only necessary columns
#             Input: %Hash=(1, 'col1 col2 col3',
#                           2, 'col1 col2 col3',
#                           3, 'col1 col2 col3');
#             input format: &get_column(\%Hash, 3,2,1, 'k'); # k is opt
#             Ouput format: STDOUT as
#
#                1     col3 col2 col1
#                2     col3 col2 col1
#                3     col3 col2 col1
#
# Keywords  : columns, column.pl, column, get_columns, take_columns,
# Options   : #  for debugging.
#             _  for debugging.
#             k  for Key print when hash input is given.
#             n  for no first line display(Handy when you have title line
#                                          and wanna remove it)
#             ?max?=xxx for filtering column numbers by maximum of xxx
#             ?min?=yyy for filtering column numbers by minimum of yyy
#                      (eg, min4=100000 means 4th column minimum is 100000)
#                      (eg, 1min4=10, 2min3=10, means get 4th column values
#                           below 10 as the first output column. Get 3rd
#                           column values below 10 as the second out column.
#
#  $combine           =1  by -c c   # c is for combining columns in different file
#  $ignore            =1  by -i i   # i is for ignoring leng diff in columns over
#  $reverse_line_order=r by r -r
#  $get_SUM_of_columns=S by S
#
# Returns   : Ref of
# Argument  : Ref of Hash, Array or just filename, and wanted column numbers.
# Category  :
# Version   : 1.9
#---------------------------------------------------------------
sub get_column{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (%whole, $previous, @out, @v_keys, %sum_of_colmuns, @columns, $get_SUM_of_columns, $len,
        $file, $q, $x, $troubled_column, $max_column_number );
    $len =4;
    @v_keys= sort keys %vars; ## To be able to exchange order of column.
    if($char_opt=~/i/i){      $ignore =1; }
    if($char_opt=~/c/i){  $combine=1;    }
    if($char_opt=~/r/){ $reverse_line_order='r' }
    if($char_opt=~/S/){ $get_SUM_of_columns='S' }
    if(@v_keys > 0){
       for($i=0; $i< @v_keys; $i++){
          if($v_keys[$i]=~/\d*(m..)(\d+)/i){
         $M=$1.$2;
         ${"$1$2"}= $vars{$&};
             push(@columns, $2);
          }
       }
    }else{
       @columns=@num_opt;
    }

    $max_column_number=${&get_largest_element(\@columns)};

    if((@num_opt==0)&&(@file>1)){ $combine=1 }; # when no column num. is given assume $combine

    #""""""""""" When combine option is set """"""""""""""""""""""
    # Combine means combining 2 file columns
    #_____________________________________________________________
    if($combine==1  and  @file > 1){
       for ($f=0; $f<@file; $f++){
        open(IN, "$file[$f]"); # real showing is now.
        my @all_lines=<IN>;
        if((@all_lines != $previous)&&($ignore !=1)){
            print "\n The column lengths do not match in the inputs\n";
            print "\n you can use -i option \n";
            die;
        }
        $previous=@all_lines;
        for($w=0; $w< @all_lines; $w++){
            if($all_lines[$w]=~/^\s*$/){ next }  # skipping blank line
            chomp($all_lines[$w]);
            $out[$w].="$all_lines[$w] ";
        }
        close IN;
       }
       push(@array, \@out);
    }
    ###### File is given as input #######""""""""""""""""""""""""""""""""""""""
    if((@file >=1)&&(@array < 1)){
       for $file(@file){
         my ($line_num, $line_read, $line_counter, @all_lines);
         my $change=0.1;
         open(IN, "$file");
         @all_lines=<IN>;
         for($q=0; $q < @all_lines; $q++){ # This open is only for getting largest column width size
             @splited=split(/\s+/, $all_lines[$q]);
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # If you set column size 3 to parse and the file has only 2 columns, I remove the line
             #________________________________________________________________________________________
             if(@splited < $max_column_number){
                 splice(@all_lines, $q, 1);
                 next;
             }
             $l=${&get_longest_str_size(\@splited)};
             $line_read++;
             if($l>$len){ $len=$l; $change++ }
             if( ($line_read/$change) > 100 ){ last } # this is to check the column
         }                                          # consistency and stops after some
         close(IN);

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Reverse LINE order if -r option is set
         #_____________________________________________
         if($reverse_line_order){    @all_lines=reverse(@all_lines);         }

         for($x=0; $x < @all_lines; $x++){
            if($all_lines[$x]=~/^[\t \#]*$/){ next }  # skipping blank line and comment lines
            if($all_lines[$x]=~/^ {1,2}#/){ next }  # skipping  comment lines
            $line_counter++;
            if(($char_opt=~/n/i)&&($line_counter==1)){ next } ## NO title #
            if(@M=$all_lines[$x]=~/(\S+)/g){
               if(@columns < 1){
                 for($n=0; $n< @M; $n++){  $columns[$n]=$n+1;    }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  if( defined(${"max$col"}) and defined(${"min$col"}) ){ # when max or min is defined
                        if( ( ${"max$col"}  > $M[$col])&&
                       ( ${"min$col"}  < $M[$col]) ){
                             printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                             printf "%-${len}s \n";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $M[$col] ){
                             printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                             printf "%-${len}s \n";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $M[$col] ){
                            printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                            printf "%-${len}s \n";
                        }
                  }else{
                        printf "%-${len}s \n", $M[$col] if($M[$col] =~/\S/);
                  }
                  $sum_of_colmuns{$col} +=$M[$col];
              }
           }
        } #for

      }
    }    ###### Array is given as input #######""""""""""""""""""""""""""""""""""
    elsif(@array>0){  # if input is ('x y xx y','k t yy zz',,,,)
      for($t=0; $t<@array; $t++){
         my @arr=@{$array[$t]};
         #print "\n Array input\n" if $debug ==1;
         for($i=0; $i<@arr;$i++){
           @splited=split(/\s+/,$arr[$i]);
           $l=${&get_longest_str_size(\@splited)};
           $len=$l if $l>$len;
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Reverse LINE order if r option is set
        #_____________________________________________
        if($reverse_line_order){
           @arr=reverse(@arr);
        }
        for($i=0; $i< @arr; $i++){
            if($arr[$i]=~/^\s*$/){ splice(@arr, $i, 1); $i--; next }
            if(($char_opt=~/n/i)&&($i==0)){ next } # skipping the first line
            if(@M=$arr[$i]=~/(\S+)/g){
               if(@columns < 1){
                  for($n=0; $n< @M; $n++){
                     $columns[$n]=$n+1;
                  }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  if( defined(${"max$col"}) and defined(${"min$col"}) ){ # when max or min is defined
                        if( ( ${"max$col"}  > $M[$col])&&
                       ( ${"min$col"}  < $M[$col]) ){
                             printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                             printf "%-${len}s \n";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $M[$col] ){
                             printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                             printf "%-${len}s \n";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $M[$col] ){
                            printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                            printf "%-${len}s \n";
                        }
                  }else{
                        printf "%-${len}s \n", $M[$col] if($M[$col] =~/\S/);
                  }
                  $sum_of_colmuns{$col} +=$M[$col];
               }
            }
        }
      }
    }  ##### Hash is given as input #######""""""""""""""""""""""""""""""""""
    elsif(@hash>0){
      my @arr;
      for($h=0; $h<@hash; $h++){
          my @array=values %{$hash[$h]};
          my @keys =keys %{$hash[$h]};
          for($i=0; $i< @array; $i++){ # getting the longest str size
             @arr=split(/\s+/,$array[$i]);
             $l=${&get_longest_str_size(\@arr)};
             $len=$l if $l>$len;
          }

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Reverse LINE order if r option is set
          #_____________________________________________
          if($reverse_line_order){
             @array=reverse(@array);
          }
          for($i=0; $i< @array; $i++){
            if($array[$i]=~/^\s*$/){ splice(@array, $i, 1); $i--; next }
            if(($char_opt=~/n/i)&&($i==0)){ next } #  skipping the first line
            printf "%-10s", $keys[$i] if($char_opt=~/k/i); ## Option for key printing
             if(@M=$array[$i]=~/(\S+)/g){
               if(@columns < 1){
                  for($n=0; $n< @M; $n++){
                     $columns[$n]=$n+1;
                  }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  if( defined(${"max$col"}) and defined(${"min$col"}) ){ # when max or min is defined
                        if( ( ${"max$col"}  > $M[$col])&&
                       ( ${"min$col"}  < $M[$col]) ){
                             printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                             printf "%-${len}s \n";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $M[$col] ){
                             printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                             printf "%-${len}s \n";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $M[$col] ){
                            printf "%-${len}s \n",$M[$col] if($M[$col]=~/\S/);
                        }else{
                            printf "%-${len}s \n";
                        }
                  }else{
                        printf "%-${len}s \n", $M[$col] if($M[$col] =~/\S/);
                  }
                  $sum_of_colmuns{$col} +=$M[$col];
               }
            }
          }
      }
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Writing down the SUM line
    #___________________________________________________
    print "The sum of the columns\' numbers only is:\n\n";
    for($r=0; $r< @columns; $r++){
       $col =$columns[$r]-1;  #
       printf "%-${len}s ", $sum_of_colmuns{$col};
    }
    print "\n\n";
}



#____________________________________________________________________
# Title    : write_sdb_file
# Function : gets a hash ref. and writes the SDB file with 'sprintf'
# Usage    : @out=@{&write_sdb_file(\%seq)};
# Example  : @out=@{&write_sdb_file(\%seq, 'v')};  ## for STDOUT as well
#    ___________________________________________________________________________
#    Title      : EST_YEAST.sdb
#    Full Name  : Telomerase_yeast_699aa
#    Nicknames  :
#    EMBL       :
#    PDB        :
#    Swissprot  :
#
# Argument : \%ref_of_seq
# Keywords : write_sdb
# Returns  :
# Options  : v  for verbose representation. This will print boxes on STDOUT
#            n  for no '#' leader.
#            e  for Endline( '-----------------------------..' )
# Version  : 1.1
#---------------------------------------------------------------
sub write_sdb_file{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($Commont_Symbol, $delimiter, $Enclosed_came, $end_found, $end_line, $entry,
	  $length, $line,  $name, $name_found, $name_found, $num,
	  $original_dir, $output, $out_string, $pre, $pwd, $start_line, $string, $string1,
	  $temp, $title_found, $type_DSSP, @arg_output, @Final_out, @k, @keys, @names, @out, @out_hash,
	  @out_hash_final, @output_box, @outref, @read_files, @str1, @str2,  @string1,
	  %correct_head_box_entry, %Final_out, %hash, %input, %out_hash_final
	 );
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($Entry_length) =9 ;
	my($VL) =60; ## key length( like in  # Title )  ## value length
	$num    =80;
	if($char_opt =~ /n/i){
	  $Commont_Symbol=' '; ## Comment symbol. For help display, you can change into ' '
	}else{
	  $Commont_Symbol='';   #  Comment symbol. Default head_box display.
	}
	for($x=0; $x < @hash; $x++){
		my(%input) = %{$hash[$x]};  my(@keys)= sort (keys %input); my(@out);

		#''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		##  PUTTING an order in the printout entries. To make 'Title' come first
		#''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		for($i=0; $i < @keys; $i++){
		  if($keys[$i]=~/^Title/i){
			  $temp=$keys[0];	   $keys[0]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Enclosed?/i){
			  $temp=$keys[$#keys];	   $keys[$#keys]=$keys[$i];   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Usage$/i){
			  $temp=$keys[1];	   $keys[1]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Function/i){
			  $temp=$keys[2];	   $keys[2]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Example/i){
			  $temp=$keys[3];	   $keys[3]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Version/i){
			  $temp=$keys[$#keys-2];  $keys[$#keys-2]=$keys[$i];   $keys[$i]=$temp;
			  #### To make null version value to '1.0'
			  if($input{$keys[$#keys-2]}=~/^\s*$/){ $input{$keys[$#keys-2]}='1.0'; }
		  }elsif($keys[$i]=~/^Warning/i){
			  $temp2=$keys[$#keys-1]; $keys[$#keys-1]=$keys[$i];   $keys[$i]=$temp2;
		  }
		}
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		##       Writing starting line
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($start_line) = "$Commont_Symbol".'_'x"$num"."\n";
		if( $char_opt =~ /v/i){
			print $start_line;      } # Prints to STDOUT,

		my($Enclosed_came);  ## <<-- This should be HERE !
		$Entry_length=${&get_longest_str_size(\@keys)};
		for( $i =0; $i < @keys; $i++){  #### @keys has been sorted before.
		  my($Len) = length($input{$keys[$i]});
		  my $delimiter = ':';
		  my($entry) = $keys[$i];
		  $entry =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e; ## capitalizing word
		  if($entry=~/^Enclosed?$/i){ $Enclosed_came = 1; }
		  my(@input) = split(/\n+/, $input{$keys[$i]});
		  if(@input > 0){
			  for($j =0; $j < @input; $j++){
				 ## If NO entry name(blank) is given    ##
				 if($j > 0){  ## If the value is a multi line.
					  $entry = '';   $delimiter=' ';    }
				 if( $char_opt =~ /v/i){
					  #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
					  ###  This is to reduce the entry length of Enclosed content lines   ##
					  #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
					  if( ($Enclosed_came==1)&&($entry eq '') ){
						  $Entry_length=2; $VL=80; }
					  printf("$Commont_Symbol %-${Entry_length}s $delimiter %-${VL}s\n", $entry , $input[$j]);
				 }
				 if(($Enclosed_came==1)&&($entry eq '')){ $Entry_length=2; $VL=80; }
				 $out[$k++]=sprintf("$Commont_Symbol %-${Entry_length}s $delimiter %-${VL}s\n", $entry,$input[$j]);
				 if($entry=~/^Enclosed?/){ $Enclosed_came = 1; }   }}
		  #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		  ##   If the entries have null descriptions, just print entries  ######
		  #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		  elsif(@input ==0){
				 if( $char_opt =~ /v/i){
					 printf("$Commont_Symbol %-${Entry_length}s $delimiter %-${VL}s\n", $entry, ' ');   }
				 $out[$k++]=sprintf("$Commont_Symbol %-${Entry_length}s $delimiter %-${VL}s\n", $entry, ' ');
		  }
		}
		############################################################
		##       Writing  Ending  line                            ##
		############################################################
		$end_line = "$Commont_Symbol".'-'x"$num"."\n";
		if( ($char_opt =~ /v/i)&&($char_opt =~ /e/i) ){  print $end_line;  }
		if( $char_opt =~ /e/i){  push(@out, $end_line)   }
		unshift(@out, $start_line);
		push(@Final_out, \@out);
	}
	if(@Final_out > 1){ @Final_out; }
	elsif( @Final_out==1){ $Final_out[0] }
} #<--- END of write_sdb_file
#________________________________________________________________________
# Title     : push_if_not_already
# Usage     : @out=@{&push_if_not_already(\@mother_array, \@adding_array )};
#             @out=@{&push_if_not_already(\@mother_array, $adding_scalar)};
# Function  : returns ref. of an array for a list of non-repetitive entry.
# Example   :
# Warning   :
# Keywords  : add_if_not_already, add_element_if_not_already, if_not_already
#             add_element_if_not_already, push_element_if_not_already,
#             if_no_already_push, put_element_if_not_already, add_new_element
#             add_new_items_only, push_new_items_only, push_new_elements_only
#             put_if_not_already,
# Options   :
# Returns   : a ref. of an array.
# Argument  : two references. The first should be an array ref. The 2nd can be either
#             scalar or array reference.
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub push_if_not_already{
	my($already_in, $already, $i, @push_items_given);
	my(@out_array)=@{$_[0]};
	if(ref($_[0]) ne 'ARRAY'){ print "\n push_if_not_array need ref\n"; die; }
	push(@push_items_given, ${$_[1]}) if(ref($_[1]) eq 'SCALAR');
	@push_items_given=@{$_[1]} if(ref($_[1]) eq 'ARRAY');
	for $already (@out_array){  ## This for is to remove repetitive
	  for ($i=0; $i< @push_items_given; $i++){
		 if($already eq $push_items_given[$i]){ splice(@push_items_given,$i, 1); $i--; }
	  }
	}
	push(@out_array, @push_items_given);
	return(\@out_array);
}

#______________________________________________________________________________
# Title     : compare_sec_str_predictions
# Usage     : &compare_sec_str_predictions(\@files, \$use_universal_seq_hash_format);
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub compare_sec_str_predictions{
    my(@files, $use_universal_seq_hash_format,
       $i, $seq_name1, $seq_name2, %seq1, %seq2, %predator_sec1 ,
       %predator_sec2, @final_hashes, %DSSP, %STRIDE, $in, %PHD_sec,%Aln);
    @files=@{$_[0]};
    $use_universal_seq_hash_format=${$_[1]};

    foreach $in (@files){
        if(!%predator_sec1 and $in=~/\S\.pr[edl]+$/){
            print "\n# (i) I found the first predator file \"$in\"";
            if($in=~/\S\_rv\./){
               print "\n# (i) _rv. string is detected. I am reversing the seq!! \"$in\"";
               $put_reverse_seq_option='r';
            }
            %predator_sec1  = %{&open_predator_files(\$in, $put_reverse_seq_option,
                                                     $use_universal_seq_hash_format)};
            push(@final_hashes, \%predator_sec1);
        }elsif(%predator_sec1 and $in=~/\S\.pr[edl]+$/){
            print "\n# (i) I found the second predator file \"$in\"";
            if($in=~/\S\_rv\./){
               $put_reverse_seq_option='r' ;
               print "\n# (i) _rv. string is detected. I am reversing the seq!! \"$in\"";
            }
            %predator_sec2  = %{&open_predator_files(\$in, $put_reverse_seq_option,
                                                      $use_universal_seq_hash_format)};
            push(@final_hashes, \%predator_sec2);
        }elsif($in=~/\.phd/){
            print "\n# (i) I found a PHD sec str pred. file \"$in\"";
            %PHD_sec  = %{&open_phd_files(\$in, $use_universal_seq_hash_format)};
            push(@final_hashes, {%PHD_sec});
        }elsif($in=~/\.dssp/){
            print "\n# (i) I found a DSSP file \"$in\"";
            %DSSP = %{&open_dssp_files(\$in, $use_universal_seq_hash_format)};
            push(@final_hashes, \%DSSP);
        }elsif($in=~/\.stride/){
            print "\n# (i) I found a Stride file \"$in\"";
            %STRIDE = %{&open_stride_files(\$in, $use_universal_seq_hash_format)};
            push(@final_hashes, \%STRIDE);
        }elsif($in=~/\S\.msf/){
            print "\n# (i) I found a MSF file \n";
            %Aln = %{&open_msf_files($in, $use_universal_seq_hash_format)};
        }else{
            print "\n# (E) Is $in  a sec. struc. prediction file??\n";
        }
     }
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # The final data set is  @final_hashes, %Aln, %DSSP
     #_____________________________________________________
     for($i=0; $i<@final_hashes; $i+=2){
        %seq1=%{$final_hashes[$i]};
        %seq2=%{$final_hashes[$i+1]};
        #&show_hash(\%seq1);
        #&show_hash(\%seq2);
        $seq_name1=$seq1{name};
        $seq_name2=$seq2{name};
        $sequence1=$seq1{sequence};
        $sequence2=$seq2{sequence};
        $sec_str1=$seq1{sec_str_string};
        $sec_str2=$seq2{sec_str_string};
        $sec_str1=~tr/[a-z]IiGgBbTt/[A-Z]CcCcCcCc/;
        $sec_str2=~tr/[a-z]IiGgBbTt/[A-Z]CcCcCcCc/;
        if(length($sec_str1) != length($sec_str2)){  print "\n# (E) The lengths are different!!! error??\n"; }
        print "\n# 1 $seq_name1  $seq_name2 \n";
        print "\n$sequence1\n$sequence2\n";
        print "\n$sec_str1\n$sec_str2\n";
        @sec1=split(//, $sec_str1);
        @sec2=split(//, $sec_str2);
        for($j=0; $j< @sec1; $j++){
           if($sec1[$j] eq $sec2[$j]){
              print '*';
              $hits++;
           }else{
              print ' ';
              $errors++;
           }
        }
        print "\n\n Rate of identity : ", $hits/length($sec_str2), "\n\n";
     }
}


#______________________________________________________________________________
# Title     : compare_PDBD_structural_domain_hashes
# Usage     :
# Function  :
# Example   :
# Keywords  : compare_PDBD_scop_domain_hashes
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub compare_PDBD_structural_domain_hashes{
    my($i, @pdbd1_domains, @pdbd2_domains, %PDBD1_hash, %PDBD2_hash,
       %DIFF_classification_domains, $pdbd2_domain, $pdbd2_scop_class,
       $pdbd1_scop_class);
    %PDBD1_hash=%{$_[0]};
    %PDBD2_hash=%{$_[1]};
    @pdbd1_domains=keys %PDBD1_hash;
    @pdbd2_domains=keys %PDBD2_hash;
    for($i=0; $i< @pdbd1_domains; $i++){
       $pdbd1_domain=$pdbd1_domains[$i];
       $pdbd1_scop_class=$PDBD1_hash{$pdbd1_domain};
       $pdbd2_scop_class=$PDBD2_hash{$pdbd1_domain};
       if($pdbd2_scop_class){
          if($pdbd1_scop_class eq $pdbd2_scop_class){
             #Good! the domain exists in both hashes with same classification
          }else{
             $DIFF_classification_domains{'DIF_CLASSIFICATION'}{$pdbd1_domain}="$pdbd1_scop_class : $pdbd2_scop_class";
          }
       }else{
          $DIFF_classification_domains{'MISSING_IN_PDBD2'}{$pdbd1_domain}=$pdbd1_scop_class;
       }
    }
    for($i=0; $i< @pdbd2_domains; $i++){
       $pdbd2_domain=$pdbd2_domains[$i];
       $pdbd2_scop_class=$PDBD2_hash{$pdbd2_domain};
       $pdbd1_scop_class=$PDBD1_hash{$pdbd2_domain};
       if($pdbd1_scop_class){
       }else{
          $DIFF_classification_domains{'MISSING_IN_PDBD1'}{$pdbd2_domain}=$pdbd2_scop_class;
       }
    }
    return(\%DIFF_classification_domains);
}

#___________________________________________________________________
# Title     : compare_proline_residue_sec_str_prediction
# Usage     : compare_proline_residue_sec_str_prediction stx_fb.prdl stx.prdl [stx.stride, stx.dssp]
# Function  :
# Example   : assess_sec_str_pred.pl bpip.pre bpip.phd $DSSP/1bll.dssp 1bllE_bpip.msf
#
#           H        Alpha helix
#           G        3-10 helix
#           I        PI-helix
#           E        Extended conformation
#           B or b   Isolated bridge
#           T        Turn
#           C        Coil (none of the above)
#       ONE example run result>>
#             $total_proline_count 13746, $total_identical 12247, $total_non_identical 1499
#             $total_num_correct_identical 9657, $total_num_wrong_identical 2590
#
# Class     : Perl::Utility::Arg_handling
# Keywords  :
# Options   : #  for debugging.
#             _  for debugging.
#    $use_universal_seq_hash_format=u by u -u
#
# Reference : http://cyrah.med.harvard.edu/perl_for_bio.html
# Returns   : Ref of
# Version   : 1.4
#---------------------------------------------------------------
sub compare_proline_residue_prediction{
    my (%SEC_STR_ASSIGN, %str_prediction1, %str_prediction2,
        $num_PROLINE, $num_identical, $num_non_identical,
        @success_rates, $num_correct_identical,
        $num_wrong_identical, @sec_structure, $num_of_residues  );

    %SEC_STR_ASSIGN =%{$_[0]};
    %str_prediction1=%{$_[1]};
    %str_prediction2=%{$_[2]};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # $matched_prediction_count is matched pred. res. between forw and backward seq
    #________________________________________________________________________________
    $matched_prediction_count   =$str_prediction2{'matched_prediction_count'};
    $num_of_diff_pred_for_both_methods=$str_prediction2{'mismatched_prediction_count'};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # %mismatch_stats has 'H_E_mismatch', 'H_C_mismatch' etc keys
    #______________________________________________________________
    %mismatch_stats=%{$str_prediction2{'mismatch_stats'}};

    $num_of_residues =@sec_structure= @{$SEC_STR_ASSIGN{'sec_str_array'}};
    $num_of_residues1=@prediction1=   @{$str_prediction1{'sec_str_array'}};
    $num_of_residues2=@prediction2=   @{$str_prediction2{'sec_str_array'}};
    @residues1 = @{$str_prediction1{'residue_array'}};
    @residues2 = @{$str_prediction2{'residue_array'}};
    for($i=0; $i< @residues1; $i++){
       if($residues1[$i] =~/P/i and $residues2[$i]=~/P/i){
          $num_PROLINE++;
          if($prediction1[$i] ne $prediction2[$i]){
             $num_non_identical++;
          }elsif($prediction1[$i] eq $prediction2[$i]){
             $num_identical++;
             $sec_structure[$i]=~tr/IiGgBbTt/CcCcCcCc/;
             if($sec_structure[$i]=~/c/){
                $coil_predicted_PRO++;
             }
             if($prediction1[$i] =~/$sec_structure[$i]/i){
                $num_correct_identical++;
             }else{
                print "$residues1[$i] $prediction1[$i] $prediction2[$i] $sec_structure[$i] ***\n";
                $num_wrong_identical++;
             }
          }
       }
    }
    print "\$num_PROLINE $num_PROLINE, \$num_identical $num_identical, \$num_non_identical $num_non_identical\n";
    return([$num_PROLINE, $num_identical, $num_non_identical,
            $num_correct_identical, $num_wrong_identical]);
}



#______________________________________________________________________________
# Title     : compare_MIPS_interaction_with_SISF
# Usage     : &compare_MIPS_interaction_with_SISF($ARGV[0], $ARGV[1]);
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub compare_MIPS_interaction_with_SISF{
    my($i, $Strintergene, $Sinteraction_pair, $all_mips_inter, $all_sisf_inter,
       @interact_pairs_MIPS, @interact_pairs_SISF, %MIPS, %SISF,
       @common, $common);
    if(@_ < 1){ die "\nUsage: $0 strintergene_pairs.txt Sinteraction_pair_seqID_0.4_0.001.txt \n"; }
    $Strintergene=$_[0];
    $Sinteraction_pair=$_[1];

    open(MIPS, "<$Strintergene") or die;
    while(<MIPS>){
      if(/(\S+)\s+(\S+)/){
         $sorted_pair=join(' ', sort($1, $2));  $MIPS{$sorted_pair}=$sorted_pair;
      }
    }
    close(MIPS);

    open(SISF, "<$Sinteraction_pair") || die;
    while(<SISF>){
      if(/^(\S+)\|\s+\S[\S ]+\s+\|\s+(\S+)\|\s+\S+/){
         $sorted_pair=join(' ', sort($1, $2));
         $SISF{$sorted_pair}=$sorted_pair;
      }elsif(/^(\S+)\s+(\S+)/){
         $sorted_pair=join(' ', sort($1, $2));
         $SISF{$sorted_pair}=$sorted_pair;
      }
    }
    $all_mips_inter=@interact_pairs_MIPS=sort keys %MIPS;
    $all_sisf_inter=@interact_pairs_SISF=sort keys %SISF;
    $sisf_only=@SISF_only=@{&subtract_array(\@interact_pairs_SISF, \@interact_pairs_MIPS)};
    $mips_only=@MIPS_only=@{&subtract_array(\@interact_pairs_MIPS, \@interact_pairs_SISF)};
    $common   =@common   =@{&get_common_array_entry(\@interact_pairs_MIPS, \@interact_pairs_SISF)};

    open(MIPS_only, ">MIPS_only.txt");
    for($i=0; $i< @MIPS_only; $i++){    print  MIPS_only"\n$MIPS_only[$i]";   }

    open(SISF_only, ">SISF_only.txt");
    for($i=0; $i< @SISF_only; $i++){    print SISF_only "\n$SISF_only[$i]";   }

    for(@common){
      if(/(\S+)\s+(\S+)/){
         if($1 eq $2){    $homopartner++;
         }else{           $heteropartner++;
         }
      }
    }
    print "\n\nCommon: $common,  \$mips_only: $mips_only (Total: $all_mips_inter), \$sisf_only: $sisf_only (Total: $all_sisf_inter) \n";
    print "\n \"MIPS_only.txt\" and \"SISF_only.txt\" are made \n";
    print "\n \$homopartner $homopartner, \$heteropartner $heteropartner\n";
    return(\@common);
}





#______________________________________________________________________________
# Title     : compare_diff_version_of_PDBD_fasta_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub compare_diff_version_of_PDBD_fasta_files{
    my($pdbd1, $pdbd2, $pdbd_id, $scop_classification, %PDBD1_hash, %PDBD2_hash,
       %DIFF_classification_domains);
    $pdbd1=${$_[0]} || $_[0];
    $pdbd2=${$_[1]} || $_[1];

    open(PDBD1, "<$pdbd1") || die "can not open $pdbd1 \n";
    open(PDBD2, "<$pdbd2") || die "can not open $pdbd2 \n";

    while(<PDBD1>){
      if(/\>(\S+)\s+(\S+)/){
         $pdbd_id=$1;
         $scop_classification=$2;
         $PDBD1_hash{$pdbd_id}=$scop_classification;
      }
    }
    close(PDBD1);
    while(<PDBD2>){
      if(/\>(\S+)\s+(\S+)/){
         $pdbd_id=$1;
         $scop_classification=$2;
         $PDBD2_hash{$pdbd_id}=$scop_classification;
      }
    }
    close(PDBD2);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # %DIFF_classification_domains{'DIF_CLASSIFICATION'}{$pdbd1_domain}
    # $DIFF_classification_domains{'MISSING_IN_PDBD1'}{$pdbd2_domain}
    # $DIFF_classification_domains{'MISSING_IN_PDBD2'}{$pdbd1_domain}
    #______________________________________________________________________
    %DIFF_classification_domains=%{&compare_PDBD_structural_domain_hashes(\%PDBD1_hash, \%PDBD2_hash)};
    &write_SDDIF_file(\%DIFF_classification_domains, \$pdbd1, \$pdbd2);
}




#________________________________________________________________________________
# Title     : compare_parf_files.pl
# Usage     :
# Function  :
# Example   :
#    PARF file looks like this>
#   d1nsca_   d3nn9__   Homolog -664.92 2.43.1.1.3  2.43.1.1.2
#   d1dppa_   d2olba_   Homolog -617.41 3.68.1.1.6  3.68.1.1.1
#   d2ach.1a1 d9api.1a1 Homolog -556.38 5.2.1.1.3   5.2.1.1.4
#
# Keywords  :
# Options   :
# Author    :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub compare_parf_files{
     #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
     my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
     my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
     my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
     my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
     my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
     if($debug==1){print "\n\t\@hash=\"@hash\"
     \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
     \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
     #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
     my (@parf_file,  %all_parf_file_hash);
     my $number_of_lines_to_read   = 5000;
     my $number_of_Homologs_to_read= 700; # 699 is for 1% error in 935 PDB40D
     my $number_of_Nomologs_to_read= 9; # 9 is for 1% error in 935 PDB40D

     if($vars{'l'}=~/\S+/){ $number_of_lines_to_read=$vars{'l'} }
     for($i=0; $i< @file; $i++){
         my ($counter);
         if($file[$i]=~/\.parf/){
             push(@parf_file, $file[$i]);
         }else{
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Check if it is parf file inside the file
             #__________________________________________________________
             open(INPUT_FILE, "<$file[$i]");
             while(<INPUT_FILE>){
                  $counter++;
                  if(/^\s*\S+\s+\S+\s+[NH]omolog\s+\S+\s+\S+\s+\S+/){
                      push(@parf_file, $file[$i]);
                      last;
                  }else{
                      if($counter > 100){  ## giving up, it is not PARF file!
                          print "\n# $0 needs to have PARF files, others are ignored";
                          last;
                      }else{
                          next;
                      }
                  }
             }
             close(INPUT_FILE);
         }
     }
     for($i=0; $i< @parf_file; $i++){
         my($nomolog_counter, $homolog_counter, $sorted_pair, @sorted_seq_name_pairs);
         open(PARF_FILE, "<$parf_file[$i]");
         while(<PARF_FILE>){
              if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
                   $sorted_pair=join(' ', sort($1, $2));
                   $homology_info=$3;
                   $score=$4;
                   push(@sorted_seq_name_pairs, $sorted_pair);
                   if($3 =~/Nomolog/i){
                       $nomolog_counter++;
                   }elsif($3 =~/Homolog/i){
                       $homolog_counter++;
                   }
                   $pair_hash{$sorted_pair}="$homology_info   $score   Homol rank: $homolog_counter    Nomol rank: $nomolog_counter";
              }
              $number_of_lines_read=$nomolog_counter+$homolog_counter;
              if($number_of_lines_read == $number_of_lines_to_read){
                   last;
              }
              if($nomolog_counter == $number_of_Nomologs_to_read){
                   last;
              }
              if($homolog_counter == $number_of_Homologs_to_read){
                   last;
              }
         }
         close(PARF_FILE);
         $all_parf_file_hash{$parf_file[$i]}=[@sorted_seq_name_pairs];
     }
     @parf_file_keys = keys %all_parf_file_hash;

     for($i=0; $i< @parf_file_keys; $i++){
         @seq_pair_array=@{ $all_parf_file_hash{$parf_file_keys[$i]} };
         push(@redundant_all, @seq_pair_array);
     }

     @all=@{&remove_dup_in_array(\@redundant_all)};
     $num_of_all_seq_pairs=@all;

     for($i=0; $i< @parf_file_keys; $i++){
         $first_set_name=$parf_file_keys[$i];
         @first_seq_pair_array=@{ $all_parf_file_hash{$first_set_name} };
         for($j=0; $j< @parf_file_keys; $j++){
              if($i == $j){ next }
              $second_set_name=$parf_file_keys[$j];
              @second_seq_pair_array=@{ $all_parf_file_hash{$second_set_name} };
              $first_minus_second="$first_set_name\_$second_set_name";
              @first_minus_second=@{&subtract_array(\@first_seq_pair_array, \@second_seq_pair_array)};
              @second_minus_first=@{&subtract_array(\@second_seq_pair_array, \@first_seq_pair_array)};
              @first_and_second=@{remove_dup_in_array([@first_seq_pair_array, @second_seq_pair_array])};
         }
     }
     for(@first_minus_second){
         print $_, " $pair_hash{$_} \n";
     }
     print "-----------------------------------------------------------\n";
     for(@second_minus_first){
         print $_, " $pair_hash{$_} \n";
     }
}





#______________________________________________________________________________
# Title     : compare_MSP_hash_data
# Usage     :
# Function  : Compares the matched sequences of 2 HASH MSP files input
#             There can be 2 different types of HASH format.
#
# Example   : The input format is like (1) <-- From open_mspa_files sub
#                'file_name_of_msp' => 'A long line of MSP with \n for each match'
#
#             The input format is like (2) <-- From convert_bla_to_msp sub
#                'Seq_name_match_name' => 'ONE line of MSP with for each match'
#                'Seq_name_match_name' => 'ONE line of MSP with for each match'
#                'Seq_name_match_name' => 'ONE line of MSP with for each match'
#                'Seq_name_match_name' => 'ONE line of MSP with for each match'
#
# Keywords  :
# Options   :
#     $Percent_similarity= by Percent_similarity=
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub compare_MSP_hash_data{
    my(%hash1, %hash2, @subtracted_diff_elements, @hash1, @hash2,
       @each_lines1, @each_lines2, @matches1, @matches2, @subtracted_diff_elements,
       $Percent_similarity);
    $Percent_similarity=80;
    @hash1=%{$_[0]};
    @hash2=%{$_[1]};
    if($_[2]=~/Percent_similarity=(\S+)/){  $Percent_similarity=$1;   }

    if(@hash1 == 2 and $hash1[1]=~/\n/){  # IF the input is MSP hash format (1)
           @each_lines1=split(/\n+/, $hash1[1]);
    }elsif(@hash1 > 2){
           @each_lines1=values %{$_[0]};
    }else{
           @each_lines1=split(/\n+/, $hash1[1]);
    }

    if(@hash2 == 2 and $hash2[1]=~/\n/){  # IF the input is MSP hash format (1)
           @each_lines2=split(/\n+/, $hash2[1]);
    }elsif(@hash2 > 2){                     # IF the input is MSP hash format (2)
           @each_lines2=values %{$_[1]};
    }else{
           @each_lines2=split(/\n+/, $hash2[1]);
    }

    @matches1= map {(/(\S+)/g)[8] } @each_lines1;
    @matches2= map {(/(\S+)/g)[8] } @each_lines2;

    if(@matches2 > @matches1){
        @subtracted_diff_elements=@{&subtract_similar_seq_elements(\@matches2, \@matches1,
                                      "Percent_similarity=")}; ## @matches2 is supposedly bigger
    }elsif(@matches1 >= @matches2){
        @subtracted_diff_elements=@{&subtract_similar_seq_elements(\@matches1, \@matches2,
                                      "Percent_similarity=80")}; ## @matches2 is supposedly bigger
    }
    return(\@subtracted_diff_elements);
}

#________________________________________________________________________
# Title     : subtract_similar_seq_elements
# Usage     : @subs = @{&subtract_similar_seq_elements(\@match_seqs1, \@match_seqs2, "Percent_similarity=80")};
# Function  : removes any occurances of certain elem. of the first
#             input array with second input array.
# Example   :
#
#     @match_seqs1=('xxxx_1-30', 'YYYYY_30-44', 'ZZZZ_1-4000');
#     @match_seqs2=('xxxx_4-32', 'YYYYY_25-41', 'ZZZZ_2000-3000');
#
# Keywords  : remove_similar_seq_elements, subtract_similar_sequence_elements
#              remove_similar_sequence_elements
# Options   :
# Returns   :
# Argument  :
#     $Percent_similarity= by Percent_similarity=
#
# Authors   : jong@biosophy.org
# Version   : 1.1
#--------------------------------------------------------------------
sub subtract_similar_seq_elements{
		my($i, $j, @seq_match_array1, @seq_match_array2, $Percent_similarity, %counter,
		   @diff_elements, $seq1, $start1, $end1, $tail1,
		   $seq2, $start2, $end2, $tail2, $diff_start, $diff_end,
		   $leng1, $leng2, $smaller_leng, %truly_diff_elements);
		$Percent_similarity=80; # 80% similarity is accepted
		$leng_thresh=10;

		@seq_match_array1=@{$_[0]}; ## this is the larger Array (supposedly)
		@seq_match_array2=@{$_[1]};
		if($_[2]=~/Percent_similarity=(\S+)/){
				$Percent_similarity=$1;
		}

		grep($counter{$_}++, @seq_match_array2 );
		grep($counter_seq_name_only{$_}++, map {/(\S+)_\d+\-\d+/ && $1} @seq_match_array2 );
		@diff_elements= grep(!$counter{$_}, @seq_match_array1);

		for($i=0; $i< @diff_elements; $i++){  ## @diff_elements is from  @seq_match_array1
			 if($diff_elements[$i]=~/^(\S+)_(\d+)\-(\d+)(\S*)/){
					 ($seq1, $start1, $end1, $tail1)=($1, $2, $3, $4);
					 for($j=0; $j< @seq_match_array2; $j++){
							if($seq_match_array2[$j]=~/^(\S+)_(\d+)\-(\d+)(\S*)/){
									($seq2, $start2, $end2, $tail2)=($1, $2, $3, $4);
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
									# Check if the seqs are identicl (from the two arrays), no point to merge which are not identical from the first
									#__________________________________________________________________________________________
									if($seq1 eq $seq2){
											 $diff_start=abs($start1-$start2);
											 $diff_end  =abs($end1  -$end2  );
											 $leng1=$end1-$start1;
											 $leng2=$end2-$start2;
											 if($leng1 >= $leng2){
													 $smaller_leng=$leng2;
													 $larger_leng =$leng1
											 }else{
													 $smaller_leng=$leng1;
													 $larger_leng =$leng2
											 }
											 $average_leng_of_2=($smaller_leng+$larger_leng)/2;
											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
											 # Checking the minimal seq region leng here
											 #______________________________________________________
											 if($smaller_leng < $leng_thresh){ next }
											 $overlapping_seq_match_size=${&get_overlapping_seq_match_size($start1, $end1, $start2, $end2)};
											 $averge_seq_leng_of_2_seqs=($leng1+$leng2)/2;

											 $finally_adjusted_seq_leng = $average_leng_of_2*($Percent_similarity/100);

											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
											 # Now let's check if we regard them homologous or not\
											 #_______________________________________________________
											 if( $overlapping_seq_match_size >=  $finally_adjusted_seq_leng){
													 #print "\n \$overlapping_seq_match_size :$overlapping_seq_match_size, \$finally_adjusted_seq_leng $finally_adjusted_seq_leng\n";
													 $truly_diff_elements{$diff_elements[$i]}=$diff_elements[$i];
											 }
									 }else{
											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									     # this is a case of totally NEW sequence in the First Larger Array given
									     #______________________________________________________________________________________
									     unless($counter_seq_name_only{$seq1}){
													 $truly_diff_elements{$diff_elements[$i]}=$diff_elements[$i];
									     }
									 }
							 }
					  }
				}
		} # END of for($i=0; $i< @diff_elements; $i++){
		return([keys %truly_diff_elements]);
}




#___________________________________________________________________
# Title     : get_peptide_occurance
# Usage     :
# Function  : gets the number of occurances of peptide(with given size) for
#             any number of sequences given.
# Example   : %stat=%{&get_peptide_occurance(\%pro_sequence, $size)};
#              while %pro_sequence has one or more sequences like
#              seq1 AAAAAAAAAAAA, seq2 BBBBBBBBBBBBBB, ...
#              $size is number. For dipeptide=2, tripeptide=3, tetrapep=4...
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  : eg=> (\%ref_hash, 4)
# Category  :
# Version   : 1.2
#---------------------------------------------------------------
sub get_peptide_occurance{
	 my($k, $i, $s, $peptide, $pep_entry_num, @name, %stat);
	 %all=%{$_[0]};
	 $size=$_[1];
	 @name=keys %all;
	 for($k=0; $k<@name; $k++){
		if($all{$name[$k]}=~/[BZX]/i){ next;
		}else{
			$seq_leng += length($all{$name[$k]});
	      my @seq=split(//, $all{$name[$k]});
			my $all_occur_pep;
	      for($i=0; $i< (@seq-($size-1)); $i ++){
	        my $peptide;
	        for($s=0; $s < $size; $s++){
		       $peptide .= $seq[$i+$s];
	        }
	        $stat{$peptide}++;
			  $all_occur_pep ++;
	        print "\n$peptide  $stat{$peptide}" if $debug==1;
	        $pep_entry_num=keys %stat;
			  if( ($debug==1)&&($pep_entry_num%100 == 0 ) ){
				  print "\n Present peptide entries are:  $pep_entry_num  out of $all_occur_pep residues \n";
			  }
	      }
		 }
	 }
	 return(\%stat);
}


#___________________________________________________________________
# Title     : open_lottery_file
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#---------------------------------------------------------------
sub open_lottery_file{
	my ($i, @lines, @bin1, @bin2, @bin3, @bin4, @bin5, @bin6, @bonus, @allbins);
	open(F, "$_[0]");
	if($_[1] =~/\-a/i){ $single_array_return=1 };
	@lines = <F>;
	for($i=0; $i< @lines; $i++){
		if($lines[$i]=~/ {1,3}(\d\d) {1,3}(\d\d) {1,3}(\d\d) {1,3}(\d\d) {1,3}(\d\d) {1,3}(\d\d) {1,2}(\d\d)/){
	push(@bin1, $1);
	#print $1, "\n";
	push(@bin2, $2);
	push(@bin3, $3);
	push(@bin4, $4);
	push(@bin5, $5);
	push(@bin6, $6);
		  push(@bonus, $7);
		}
	}
	if($single_array_return == 1){ @allbins=( @bin1, @bin2, @bin3, @bin4, @bin5, @bin6, @bonus); }
	else{  return(\@bin1, \@bin2, \@bin3, \@bin4, \@bin5, \@bin6, \@bonus); }
}


#_________________________________________________________________
# Title     : get_probable_half
# Usage     :
# Function  : This produces a hash ref. which is supposed to be most probable
#             according to the given array. It divides array into halves
#             gets the more probable half until it gets one single number.
# Example   :
# Warning   :
# Keywords  : get_frequent_halves,
# Options   :
# Returns   :
# Argument  : \@array
# Category  :
# Version   : 1.0
#-----------------------------------------------------------------
sub get_probable_half{
    my (%hash, $i, @keys, @values);
    %hash=%{$_[0]};
    @keys=  sort {$a<=$b} keys   %hash;
    @values= values %hash;
    print "\n Hash is ",%hash,"\n";
    if(@keys == 1){
             return(\%hash); last;
    }elsif(@keys >1){
            if((@keys % 2) != 0){ # make the number even
                     $keys[@keys]=$keys[$#keys];
            }
            @first_half=@keys[0..(@keys/2-1)];
            @second_half=@keys[(@keys/2)..$#keys];
            print "@first_half", "\n";
            print "@second_half", "\n";
            my($sum1, $sum2, %hash1, %hash2);
            for($i=0; $i<(@keys/2); $i++){
                     $sum1 +=$hash{$first_half[$i]};
                     $sum2 +=$hash{$second_half[$i]};
                     $hash1{$first_half[$i]} =$hash{$first_half[$i]};
                     $hash2{$second_half[$i]}=$hash{$second_half[$i]};
            }
            if($sum1 > $sum2){ &get_probable_half(\%hash1);}
            else{  &get_probable_half(\%hash2);}
    }
}

#_______________________________________________________________
# Title     : divide_array
# Usage     : &show_array(&divide_array(\@input, 6));
# Function  : divides any array to the denominator given.
#             If you give array of 100 elem, with 5, you will
#             get 5 arrays with 20 elem each.
# Example   :
# Warning   :
# Keywords  : split_array_into_pieces, split_array, chop_array,
#             fragment_array,
# Options   : s=  for dividing the array with sub array size
#                 eg) to get 20 elem length sub arrays from
#                     a big array
#                     @ar_ref=@{&divide_array(\@array, 's=20')};
# Returns   :
# Argument  :
# Category  :
# Version   : 1.4
#-----------------------------------------------------------
sub divide_array{
	 my ($size,$remaining, $size_div, $s);
	 my @array = @{$_[0]};
	 my  @final_array_ref=();
	 if(ref($_[1])){
		if(${$_[1]}=~/^\d+$/){
		   $denominator = ${$_[1]};
		}elsif(${$_[1]}=~/s=(\d+)$/i){
	       $size=$1;
		   $size_div=1;
	    }
	 }elsif($_[1]=~/^\d+$/){
	    $denominator = $_[1];
	 }elsif($_[1]=~/s=(\d+)$/i){
		$size=$1;
		$size_div=1;
	 }

	if((@_ ==1)&&($denominator == 0)){
	   print "\n Denominator is 0, error, setting to 1\n";
	   $denominator = 1;
	}

	if($size_div==1){
	   while(@array){
		  push(@final_array_ref, [splice(@array, 0, $size)]);
	   }
	}else{
	   my $frag_ar_size = int(@array/$denominator);
	   if($debug eq 1){ print "\n Frag arr size is :  $frag_ar_size \n" }
	   $remaining = @array % $denominator;
	   if($debug eq 1){ print "\n Remnant elem size is : $remaining \n" }
	   for($i=0; $i < $denominator; $i++){
		  if($remaining > 0){
			  push(@final_array_ref, [splice(@array, 0, ($frag_ar_size+1),)] );
		      $remaining --;
		  }elsif(($remaining == 0)&&(@array>0)){
			  push(@final_array_ref, [splice(@array, 0, ($frag_ar_size),)] );
		  }
	   }
	}
	return(\@final_array_ref);
}


#__________________________________________________________________________
# Title     : split_fasta_files
# Usage     : @names_of_single_files=@{&split_fasta_files(\@files)};
# Function  :
# Example   :
# Keywords  : divide_fasta_files, split_fasta_db_files, divide_fasta_db_files
#             make_single_fasta_files, write_single_fasta, write_single_fasta_files
# Options   :
#   $return_seq_file_name=f by f  # to return file names than seq names array
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#----------------------------------------------------------------------------
sub split_fasta_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my (@each_single_seq_names, $seq_name, $single_seq_fasta_exists,
				$return_seq_file_name, $out_single_fasta_file_name );
		if($char_opt=~/f/){ $return_seq_file_name='f'; }

		for($i=0; $i< @file; $i++){
				open(FASTA, "$file[$i]");
				while(<FASTA>){
					 if(/\>\s*(\S+)/){
							 $seq_name=$1;
							 $out_single_fasta_file_name="$1\.spfa";
							 unless(-s $out_single_fasta_file_name){
									open(OUT_SINGLE, ">$out_single_fasta_file_name");
									print OUT_SINGLE $_;
							 }else{
									print "\n# (i) split_fasta_files: $out_single_fasta_file_name exists, skipping";
							 }
							 if($return_seq_file_name){
									 push(@each_single_seq_names, $out_single_fasta_file_name);
							 }else{
									 push(@each_single_seq_names, $seq_name);
							 }
					 }elsif(/\w+/){
							 unless(-s $out_single_fasta_file_name){
									print OUT_SINGLE $_;
							 }
					 }

				}
				close OUT_SINGLE;
		}
		return(\@each_single_seq_names);
}




#______________________________________________________________________________
# Title     : split_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
#  $division_factor= by d=
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub split_files{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		 my($division_factor, $base_name);
		 $division_factor=2;
		 if($vars{'d'}=~/(\d+)/){ $division_factor=$1 };

		 for($i=0; $i< @file; $i++){
				 open(FILE, $file[$i]);
				 $base_name=${&get_base_names($file[$i])};
				 $extension=${&get_extension_names($file[$i])};
				 $total_line_num=@lines=<FILE>;
				 $splited_frag_size=int(@lines/$division_factor);
				 for($j=0; $j< $division_factor; $j++){
						 #$frag_file="$base_name\_s${j}\.split${j}";
						 $frag_file="$base_name\_s${j}\.$extension";
						 push(@splited_files, $frag_file);
						 open(FRAGMENT_FILE, ">$frag_file");
						 for($k=0; $k<= $splited_frag_size; $k++){
								 print FRAGMENT_FILE $lines[$k];
						 }
						 splice(@lines, 0, $splited_frag_size);

				 }
				 print FRAGMENT_FILE @lines; # Writing the very last remaining lines
				 close (FRAGMENT_FILE);
		 }
		 return(\@splited_files);
}


#_______________________________________________________________
# Title     : split_sequence
# Usage     : %out=%{&split_sequence(\%input, 2 )};
# Function  : divides any string to the denominator given.
# Example   : &show_array( &divide_string(\%input, 3) );
#              while  $input is 'seq', '12345789ABCDEFHIJKLMN'
#              The output will be 'seq_1_half', '1234578'
#                                 'seq_2_half', '9ABCDEF'
#                                 'seq_3_half', 'HIJKLMN'
# Warning   :
# Keywords  : divide_string, split_string, chop_string, divide_sequence
#             split_sequence(look at separate split_sequence sub),
#              break_sequence, break_string
# Options   :
#  $reverse_second_half=S by S -S
#  $reverse_first_half =F by F -F
#  $reverse_rest   =R by R -R  ## reversing all except the first
#  $reverse_all  =A by A -A # reverse all the fragments
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#-----------------------------------------------------------
sub split_sequence{
    my(@string, $frag_str_size, $remaining, @hash, $i, $j,
         @seq_names, $denominator, %input_seq, @final_hash_ref,
         $frag, $reverse_second_half, $reverse_first_half,
         $reverse_rest, $reverse_all);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Checking arguments
    #________________________________________________
	for($i=0; $i< @_; $i++){
	   if(ref($_[$i]) eq 'HASH'){
					push(@hash, $_[$i]);
	   }elsif(ref($_[$i]) eq 'SCALAR'){
					 if(${$_[$i]}=~/^(\d+\.?\d*)$/){ # this can handle fraction number!!
							$denominator = int($1);            # like  9.5
					 }
			 }elsif($_[$i]=~/^(\d+\.?\d*)$/){ # this can handle fraction number!!
			   $denominator = int($1);            # like  9.5
			 }elsif($_[$i]=~/F/){ # this can handle fraction number!!
					 $reverse_first_half='F';
			 }elsif($_[$i]=~/S/){ # this can handle fraction number!!
					 $reverse_second_half='S';
			 }elsif($_[$i]=~/R/){ # this can handle fraction number!!
					 $reverse_rest='R'; $reverse_second_half='s';
			 }elsif($_[$i]=~/A/){ # this can handle fraction number!!
					 $reverse_all='A'; $reverse_rest='r'; $reverse_first_half='f';
					 $reverse_second_half='S';
	   }elsif($_[$i]=~/\S/){
	       print "\n# $0: split_sequence, You put some strange stuff to me!!\n\n";
	       die;
	   }
	}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
		# When s option is given while denominator is over 2, set r option
		#____________________________________________________________________
	if($denominator > 2 and $reverse_second_half){
	   $reverse_rest='r';
	}

	if($denominator == 0){
	   print "\n Denominator is 0, error, setting to 1\n";
	   $denominator = 1;
	}

		print "\n# split_sequence: \$denominator is $denominator, with \@hash\n";

	for($i=0; $i< @hash; $i++){
			 my %input_seq=%{$hash[$i]};
			 @seq_names=keys %input_seq;
			 my (%out_seq);

			 for($k=0; $k < @seq_names; $k++){
					 $seq_name=$seq_names[$k];

					 @string = split(//, $input_seq{ $seq_name });
					 $frag_str_size = int(@string/$denominator);
					 if($debug eq 1){ print "\n Frag str size is :  $frag_str_size \n" }
					 $remaining = @string % $denominator;

					 for($j=0; $j < $denominator; $j++){
								$frag_number=$j+1;

								if($remaining > 0){
										$frag=join('', splice(@string, 0, ($frag_str_size+1) ) );
										$remaining --;
										$seq_name_split="$seq_name\_$frag_number";

										#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
										# Before final, set the seq types
										#_________________________________________________________________
										if($frag_number==1 and $reverse_first_half){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}elsif($frag_number==2 and $reverse_second_half){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}elsif($frag_number >2 and $reverse_rest){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}elsif($reverse_all){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}
										$out_seq{$seq_name_split}=$frag;
								}elsif( $remaining == 0  and  @string>0){
										$seq_name_split="$seq_name\_$frag_number";
										$frag=join('', splice(@string, 0, $frag_str_size,) );

										#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
										# Before final, set the seq types
										#_________________________________________________________________
										if($frag_number==1 and $reverse_first_half){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}elsif($frag_number==2 and $reverse_second_half){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}elsif($frag_number >2 and $reverse_rest){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}elsif($reverse_all){
												$frag=reverse($frag);
												$seq_name_split="$seq_name_split\_rv";
										}
										$out_seq{$seq_name_split}=$frag;
								}
					 }
			 }
			 push(@final_hash_ref, \%out_seq);
	}
	wantarray? \@final_hash_ref : $final_hash_ref[0];
}




#_______________________________________________________________
# Title     : divide_string
# Usage     : &show_array(&divide_string(\$input, 6));
# Function  : divides any string to the denominator given.
# Example   : &show_array( &divide_string(\$input, 3) );
#              while  $input is '12345789ABCDEFHIJKLMN'
#              The output will be '1234578 9ABCDEF HIJKLMN'
# Warning   :
# Keywords  : divide_string, split_string, chop_string, divide_sequence
#             split_sequence(look at separate split_sequence sub),
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.4
#-----------------------------------------------------------
sub divide_string{
	my (@array, $i, $j, $denominator, @temp, @string, $frag_str_size,
	   $remaining, $frag);

	for($i=0; $i< @_; $i++){
	   if(ref($_[$i]) eq 'ARRAY'){
		  push(@array, @{$_[$i]});
	   }elsif(ref($_[$i]) eq 'SCALAR'){
		  if(${$_[$i]} =~/^(\d+)$/){
			 $denominator = $1;
		  }else{
			 push(@array, ${$_[$i]});
		  }
	   }elsif($_[$i]=~/^(\d+\.?\d*)$/){ # this can handle fraction number!!
		  $denominator = int($1);            # like  9.5
	   }else{
		  push(@array, $_[$i]);
	   }
	}
	if($denominator == 0){
	   print "\n Denominator is 0, error, setting to 1\n";
	   $denominator = 1;
	}
	for($i=0; $i< @array; $i++){
	   my @temp;
	   my @string = split(//, $array[$i]);
	   $frag_str_size = int(@string/$denominator);
	   if($debug eq 1){ print "\n Frag str size is :  $frag_str_size \n" }
	   $remaining = @string % $denominator;
	   for($j=0; $j < $denominator; $j++){
	 	    if($remaining > 0){
			    $frag=join('', splice(@string, 0, ($frag_str_size+1) ) );
	            push(@temp, $frag);
			    $remaining --;
		    }elsif( $remaining == 0  and  @string>0){
								$frag=join('', splice(@string, 0, $frag_str_size,) );
	            push(@temp, $frag);
		    }
	   }
	   push(@final_array_ref, \@temp);
	}
	wantarray? \@final_array_ref : $final_array_ref[0];
}

#____________________________________________________________
# Title     : write_html_headbox
# Usage     : &write_html_headbox($outfilename, \%entries);
# Function  : write html format headbox explanation with
#              given hashes of headbox content.
# Example   :
# Warning   : It takes off the last '/' when $URL has it
#
# Keywords  : write_headbox_html, write headbox in html,
#               write_headbox_files
# Options   : 'd' for date inclusion at the top of the page
#   $URL=  by f=  for default ftp dir name
#   $SUB_DB_DIR= by d=
#   $put_date_information=D by D
#
# Version   : 1.9
#-----------------------------------------------------------
sub write_html_headbox{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my(%in, $HOME_DIR, $name, $name1, $SUB_DB_DIR, $put_date_information,
			 $out_sub_file_base, $this_prog_name);
		$SUB_DB_DIR='/Proj/Comp/Perl/Sub_DB'; ## default
		$HOME_DIR=$ENV{'HOME'};
		my $URL='ftp://cyrah.med.harvard.edu/pub/Perl/';

		if($vars{'f'}=~/(\S+)\/$/){ $URL=$1; }  ## checking if 'f' opt is set(for default ftp dir name)
		if($vars{'d'}=~/(\S+)/){    $SUB_DB_DIR=$1 }
		if($char_opt=~/D/){ $put_date_information='D' }
		for ($f=0; $f< @file; $f++){
			 $output_file=$file[$f];
			 $output_file=~/([^\/]+)\.\w/; $out_sub_file_base=$1;
			 open(FILE, ">$output_file") || die "\n# (E) Can not open $output_file, check permission\n";
			 print FILE "\<html\>\n";
			 if($char_opt =~/d/i){
					 print FILE "\<H2  ALIGN=CENTER\>";
					 print FILE "\<FONT COLOR=\"#DC143C\"\>$file[$f]\<\/H2\>\<\/FONT\>\n";
					 print FILE "\<br\>\n";
					 if($0=~/([^\/]+)\.pl/){ $this_prog_name=$1 }
					 print FILE "\<H6 ALIGN=RIGHT\>", `date`, "Created by  \<A href=\"$SUB_DB_DIR\/$this_prog_name\.html\"\>
								 $SUB_DB_DIR\/$this_prog_name\.html\<\/A\>\<\/H6\> \<hr\>";
			 }

			 for($i=0; $i< @hash; $i++){
					 my %in =  %{$hash[$i]};
					 my @keys = sort keys %in;
					 $name= $in{'Title'};
					 if($name=~/(\S+)\.pl/){ ## to prevent making 'xxxx.pl.pl'
							$name1=$1;
					 }elsif($name=~/\:\:(\w+)\s*$/){
							$name1=$1;  ## This prevents Bio::Bioinf  like title to be refered to a file
					 }else{
							$name1=$name;
					 }
					 print FILE "\<H3\>\<A href=\"$SUB_DB_DIR\/$name1\.html\"\>$name1\<\/A\>\<\/H3\>";
					 print FILE "Download \<A href=\"${URL}\/$name1\.pl\"\>$name1\.pl\<\/A\>\n";
					 print FILE "\<pre\>\n";
					 for($j = 0; $j < @keys; $j ++){
							 if($keys[$j]=~/(title)/i){
							 }elsif( ($keys[$j]=~/\w+/i)&&( $in{$keys[$j]}=~/\w+/) ){
										chomp( $in{$keys[$j]} );
										printf FILE ("\<b\>%-10s\<\/b\> %s\n", $keys[$j], $in{$keys[$j]});
							 }
					 }
					 print FILE "\<\/pre\>";
					 print FILE "\<hr\>\n\n";
			}
			print FILE "\<\/html\>\n";
			close FILE;
		}
		if(-d $HOME_DIR and $out_sub_file_base=~/Bioinf/){
				&cp("$HOME_DIR\/$SUB_DB_DIR\/Bioinf.html", "$HOME_DIR\/Bio.pl.html");
				print "$SUB_DB_DIR\/Bioinf.html has been copied to $HOME_DIR\/Bio.pl.html\n";
		}
}

#______________________________________________________________________________
# Title     : open_DALI_domain_table_file
# Usage     :
# Function  : reads DOMTABLE
# Example   : DOMTABLE1 in ~/Proj/Bio/3Dserver  is the INPUT file
#             $DC_number means Structural Classification number.
#         $DOM_table_hash{$DALI_str_ID}{$DALI_node_ID}=[$DC_number,
#                                                       $str_length,
#                                                       $SSC_sec_str_composition,
#                                                       $description ];
#   With 'L' option it returns the following hashes:
#      return(\%FOLDREP, \%DC, \%SSE, \%NRES, \%NFAMILY, \$largest_DC_number);
#
# Keywords  : open_DDTF_file, open_ddtf_file, open_DOMTABLE1_file
# Options   :
#    $make_Liisa_Holm_style_HASH_output=L by L    for Liisa Holm style output
# Author    : holm@ebi.ac.uk jong@biosophy.org,
# Category  :
# Returns   : ref. of hashes
# Version   : 1.5
#------------------------------------------------------------------------------
sub open_DALI_domain_table_file{
    my($DOM_table_file, $DC_number, %DOM_table_hash, $str_length,
       $SSC_sec_str_composition, $description,
       $make_Liisa_Holm_style_HASH_output, $olddc, $domid, $nres,$he,
       $ifam, %NFAMILY, %FOLDREP, %DC, %SSE, %NRES, $largest_DC_number);
    $DOM_table_file=${$_[0]} || $_[0];

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Check for Liisa Holm style HASH output flag (L)
    #_____________________________________________________
    if($_[1]=~/L/i){ $make_Liisa_Holm_style_HASH_output='L' }

    open(DOM_TABLE_file, "<$DOM_table_file") || die " open_DALI_domain_table_file : Can not open $DOM_table_file by open_DALI_domain_table_file\n\n";
    if($make_Liisa_Holm_style_HASH_output){
        $olddc=0;
        while(<DOM_TABLE_file>) {
            ($dc,$domid,$nres,$he)=/^\s*(\S+)\s+(\S+).*\s+(\d+)\s+([HE]*)\s*$/;
            if($dc != $olddc) { $ifam=0; $olddc=$dc; $FOLDREP{$dc}=$domid; }
            $ifam++;
            $DC{$domid}="$dc\.$ifam"; $REP{"$dc\.$ifam"}=$domid;
            $SSE{$domid}=$he;
            $NRES{$domid}=$nres;
            $NFAMILY{$dc}++;
        }

    }else{
        while(<DOM_TABLE_file>){
           if(/^\s+([\d\.]+)\.\s+(\w+)\:(\d+)\s+(\S.{39,46})\s(\d+)\s+([HE]+)\s*$/){
               $DC_number="D.C.$1";
               $DALI_str_ID=$2;
               $DALI_node_ID=$3;
               $description=$4;
               $str_length=$5;
               $SSC_sec_str_composition=$6;
               $DOM_table_hash{$DALI_str_ID}{$DALI_node_ID}=[$DC_number,
                                                             $str_length,
                                                             $SSC_sec_str_composition,
                                                             $description ];

           }
        }
    }
    close(DOM_TABLE_file);
    $largest_DC_number=$dc; ## remember the largest DC number
    if($make_Liisa_Holm_style_HASH_output){
        return(\%FOLDREP, \%DC, \%SSE, \%NRES, \%NFAMILY, \$largest_DC_number);
    }else{
        return(\%DOM_table_hash);
    }
}





#________________________________________________________________________
# Title     : open_sdb_files
# Usage     : %entries = %{&open_sdb_files(\$file_to_read )};
# Function  :
# Example   : Output is something like
#             ('Title', 'read_head_box', 'Tips', 'Use to parse doc', ...)
# Warning   :
# Keywords  : read_sdb_files,read_sdb,
# Options   : 'b' for remove blank lines. This will remove all the entries
#             with no descriptions
# Returns   : A hash ref.
# Argument  : One or None. If you give an argu. it should be a ref. of an ARRAY
#              or a filename, or ref. of a filename.
#             If no arg is given, it reads SELF, ie. the program itself.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub open_sdb_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($title_found, %Final_out, $variable_string, $TITLE, $title, @keys,
	  $end_found, $line, $entry, $entry_match, $End_line_num, $remove_blank,
	  $title_entry_null, $end_found, $Enclosed_entry, $Enclosed_var,
	  $blank_counter, $title_entry_exist, $entry_value, $temp_W, $Warning_part
	);

	for($r=0; $r<@file; $r++){
		open(SEQ_IN, "$file[$r]");
		my @whole_file =<SEQ_IN>;

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		for($i=0; $i<@whole_file; $i++){
	$whole_file[$i] =~ tr/\t/ {7}/;  ## This is quite important to some parsing!!!
	#"""""""""""""""""""""""""""""""""""""""""""
	##  The first and second line of box 1 ##
	#"""""""""""""""""""""""""""""""""""""""""""
	if( ($whole_file[$i]=~/^[_\*\-\/]{55,}$/)&&    ##  '______' is discarded
	   ($whole_file[$i+1]=~/^ {0,4}([TitlNam]+e) {0,8}:? {0,20}(\S[\-\w\.:]*) *(Copyright.*)/i) ){
	   $TITLE = $1;      $title = "$2\n";   $Final_out{'Warning'}.="$3\n";
	   $entry_match=$TITLE; ## The very first $entry_match is set to 'Title' to prevent null entry
	   if($TITLE =~ /^Title|Name$/i){   #
	       if( ($title=~/^\s+$/)||( $title eq "\n") ){
		  $title_entry_null =1;  $title = '';  }    }
	   $Final_out{$TITLE}=$title;
	   $title_found ++ ;   $i++;  ## << this is essential to prevent reading the same line again.
	}

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	## The first and second line of box 2, #__________ or #**************
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($end_found != 1)&&($whole_file[$i]=~/^[_\*]{20,}$/)&&
	   ($whole_file[$i+1]=~/^\s*(\w{1,6}\s{0,2}\w+) {0,7}: {1,5}(.*)\s*/i) ){
	   $title_found ++ ;        $i++;
	   $entry_match=$1;       $entry_value=$2;
	   $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;  ## Capitalize words
	   $Final_out{$entry_match}.= "$entry_value\n";
	   last if $title_found > 1;  next;   }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	##  With PROPER entry 2 : descriptins like. 'Ussage : ssssssxxjkk  kj'
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($end_found != 1)&&($title_found==1)&&
	   ($whole_file[$i]=~ /^ {0,3}(\w{1,4}\s{0,2}\w{1,7}) {0,8}[:\)] {0,9}(\S.*)\s*/i)){
	   $entry_match = $1;
			  $entry_value = $2;
	   $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
	   $Final_out{$entry_match}.= "$entry_value\n"; }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#  With proper entry 3 : descriptins like. 'Ussage :', But blank description ##
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($end_found != 1)&&($title_found==1)&&
	   ($whole_file[$i]=~ /^ {0,3}(\w{1,4}\s{0,2}\w{1,7}) {0,8}[:\)]( {0,})$/i)){
	   $entry_match = $1;
			  $entry_value = $2;
	   $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
	   $Final_out{$entry_match}.= " $entry_value\n"; }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	###  all space line matching                 ##
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($end_found != 1)&&  ##<----- If blank line is matched. Take the line
	   ($title_found==1)&&($whole_file[$i]=~/^ {0, 110}$/) ){
	   $blank_counter++;
	   if($blank_counter > 2){ $blank_counter--; }
	   else{ $Final_out{$entry_match}.= " \n";  }     }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	###  Anything after 3 space to 14 positions eg: '#           HHHHHHHHH'
	###  To match 'examples' etc. INC. ':'
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($end_found != 1)&&
	   ($title_found==1)&&($whole_file[$i]=~/^( {0,50})(\S.+)/) ){
	   $Final_out{$entry_match}.= "$2\n"; $blank_counter=0; }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	###  Anything after 1 space to 11 positions  ##
	###  To match 'examples' etc. EXC. ':'       ##
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($end_found != 1)&&
	   ($title_found==1)&&($whole_file[$i]=~/^ {0,16}([^:.]+)/) ){
	   $Final_out{$entry_match}.= "$1\n"; $blank_counter=0;}

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	###-------End of the read_box reading--------##
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif( ($title_found==1)&&
	   ($whole_file[$i]=~ /^[\*\-_]{15,}/)){  ## to match '#-----..' or '#*******..'(Astrid's)
	   $End_line_num = $i;       $end_found++;
	   last;      }
		} ## < End of for loop


		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		### If title is not there at all     ####
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		@keys=keys %Final_out;
		for(@keys){
	 if(/^Title$/i){    ## No Entry of Title at all??
	    $TITLE =$&;
	    $title_entry_exist = 1;
	    if($Final_out{$_}=~/^\s*$/){   ## if Title => Null or just space
	       $title_entry_null = 1;    }  }  }

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		### When title entry is not there    ####
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		if( $title_entry_exist != 1){
	  for($s=$End_line_num+1; $s < $End_line_num+20; $s++){
	     if( $whole_file[$s] =~ /^sub {1,5}([\w\.]+) {0,6}\{/){
		$Final_out{'Title'} = "$1\n";   last;       }
	     elsif( $whole_file[$s] =~/^________________________________+/){
		#######################################
		## Uses running file name as titile  ##
		#######################################
		$Final_out{'Title'} = "$0";     last;
	     }else{
		#######################################
		## Uses running file name as titile  ##
		#######################################
		$Final_out{'Title'} = "$0";
	     }
	  }
		}
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		### When title is blank              ####
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		elsif($title_entry_null ==1){  ## It looks for 'sub xxxxx{ ' line to get title
	  ### $End_line_num is the last line read.
	  for($s = $End_line_num+1; $s < $End_line_num+20; $s++){
	     if( $whole_file[$s] =~ /^sub {1,5}(\w+\.*\w*) {0,7}{/){
		$Final_out{$TITLE} = "$1\n";    last;     }
	     elsif( $whole_file[$s] =~/^#________________________+/){
		#######################################
		## Uses running file name as titile  ##
		#######################################
		$Final_out{$TITLE} = "$0";     last;
	     }else{
		#######################################
		## Uses running file name as titile  ##
		#######################################
		$Final_out{$TITLE} = "$0";
	     }
	  }
		}
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		## Error handling, if no head box is found   ####
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		if($title_found < 1){ print "\nFatal: No headbox found by read_head_box2 sub.\n";  }
		push(@ref_of_seq_entry, \%Final_out);
	}
	if(@ref_of_seq_entry > 1){
		@ref_of_seq_entry;
	}else{ return (\%Final_out) }
}


#_______________________________________________________________
# Title     : open_stride_files
# Usage     :
# Function  :
# Example   :
#           H        Alpha helix
#           G        3-10 helix
#           I        PI-helix
#           E        Extended conformation
#           B or b   Isolated bridge
#           T        Turn
#           C        Coil (none of the above)
#           S        A bend without a hydrogen bond
# Warning   :
# Class     : Utility
# Keywords  :
# Options   :
#   $chain_number= by C=
#   $simplify=s by s     # reduces to H E C
# Package   :
# Reference : http://sonja.acad.cai.cam.ac.uk/bioperl.html
# Returns   :
# Tips      :
# Argument  :
# Todo      :
# Author    : A Biomatic
# Version   : 2.0
#-----------------------------------------------------------
sub open_stride_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (%sequence, %HASH, @Keys, $seq_found1, $S_start, $S_end, $seq_found,
      $present_seq, @seq_Names, %Sizes, $bare_seq_name, $fasta_seq_idx_file,
      %seq_fragments, $min_seq_leng_accepted, $No_gap_char_allowed,
      $remove_strange_and_masked_residues, $make_Upper_case_seq,
      %sec_str, $chain, $name,$number_of_residues,$simplify, $read_any_chain,
      $sec_str, $secondary_structure, $chain_number_wanted, $sequence);
    $min_seq_leng_accepted=0;
    my %AA=%{&convert_3_to_1_letter};
    $name='name';
    $prediction_reliability=1;
    if(@file<1){
      print "\n \@file has less than 1 elem. There is no fileinput for open_stride_files\n";
      die
    }

    if($vars{'C'}=~/(\w+)/){ $chain_number_wanted=$1; print "\n# (i) open_stride_files: Chain wanted= $1\n"; }
    if($vars{'m'}=~/(\d+)/){ $min_seq_leng_accepted=$1; }
    if($char_opt=~/N/){  $No_gap_char_allowed='N'; }
    if($char_opt=~/s/){  $simplify='s'; }
    if($char_opt=~/R/){  $remove_strange_and_masked_residues='R'; }
    if($char_opt=~/U/){  $make_Upper_case_seq='U'; }

    $stride_file=$file[0]; ## for the time being
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # The following is to handle name input like 8rnxA.stride
    #_______________________________________________________________________________
    if(! $chain_number_wanted and $stride_file=~/\d\w\w\w(\w)\./){
       $chain_number_wanted=$1;
    }elsif(!$chain_number_wanted and $stride_file=~/^\d\w\w\w\./){
       $read_any_chain=1;
       print "\nWARN: The STRIDE file does not have pdb chain information!! \n";
    }
    open(STRIDE_FILE, $stride_file) || die "\n# (E) Cant open $stride_file\n";
    while(<STRIDE_FILE>){
       if(/ASG\s+(\w+)\s+(\S)\s+(\d+)\s+(\d+)\s+(\w) .+?([\~\w]+)\s*$/){  #>>->  ASG  LYS -  305  287    H    AlphaHelix    -69.14    -26.24     171.0      1FND
           $chain =$2;  # _ , A or B like things
           if($read_any_chain){
           }elsif($chain eq '-'){ $chain = ''; ## NO chain case
           }elsif($chain ne $chain_number_wanted){ next } ## skipping NOT maching chain number
           $name="\L$6";
           $s=$4;
           $pdb_position=$3;
           $residue=$AA{$1};
           $position=$s;
           $residues ={$position, $residue};
           $sequence .=$residue;
           $sec_str .=$5;
       }
    }
    close(STRIDE_FILE);
    if($simplify){ $sec_str=~tr/IiGgBbTt/CcCcCcCc/; }   # secture conversion rule
    $secondary_structure=[split(//, $sec_str)];
    $number_of_residues=length($sec_str);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Definition of Seq information detail, Ver 1.1
    #______________________________________________________________________________
    %sec_str=('name'                  =>$name,
              'protein_name'          =>$name,
              'ID'                    =>$name,
              'PDB_chain_number'      =>$chain,
              'chain_number'          =>$chain,
              'number_of_residues'    =>$number_of_residues,
              'seq_name'              =>$name,
              'residue_array'         =>$residues,
              'residue_string'        =>$sequence,
              'sec_str_array'         =>$secondary_structure,
              'sec_str_string'        =>$sec_str,
              'sec_str'               =>$sec_str,
              'mol_type'              =>'protein',
              'type'                  =>'protein',
              'prediction_reliability'=>$prediction_reliability,
              'prediction'            =>'prediction',
              'sequence'              =>"$sequence",
              'seq_string'            =>$sequence,
              'structure_assignment'  =>0); # this is not a struc. assignment as in DSSP
    #__________________________________________________________________________________
    return(\%sec_str);
}



#______________________________________________________________________________
# Title     : open_stride_dat_files
# Usage     : @out=@{&open_stride_dat_files(@ARGV)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub open_stride_dat_files{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my( @residues, @sec_str, $seq_name, $seq, %stride_sec_str_hash,
				$stride_dat_file, @stride_sec_str_hash_final);

		 for($i=0; $i< @file; $i++){
				 my $stride_dat_file=$file[$i];
				 print "\n# (INFO) \$stride_dat_file $stride_dat_file is being opened\n";
				 open(STRIDE_DAT_FILE, $stride_dat_file);
				 while(<STRIDE_DAT_FILE>){
						if(/^NM\s+(\S+)\.brk/){
								$seq_name=$1;
						}elsif(/^NM\s+(\S+)/){
								$seq_name=$1;
						}elsif(/^\s*SQ\s+(\S+)/){
								$seq=$1;
						}elsif(/^\s*SS\s+(\S+)/){
								$sec_str=$1;
								my %stride_sec_str_hash;
								@residues=split(//, $seq);
								@sec_str=split(//, $sec_str);
								for($j=0; $j < @residues; $j++){
										$stride_sec_str_hash{$j}=[$residues[$j], $sec_str[$j], '1.0',  "$seq_name"];
								}
								push(@stride_sec_str_hash_final, \%stride_sec_str_hash);
						}
				 }
				 close(STRIDE_DAT_FILE);
		 }
		 if(@stride_sec_str_hash_final > 1){
				 return(\@stride_sec_str_hash_final);
		 }elsif(@stride_sec_str_hash_final==1){
				 return(\%stride_sec_str_hash);
		 }
}



#_______________________________________________________________
# Title     : get_pdb_file_start_number
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  : start_number_of_pdb, startnumber, start number of PDB,
#             get_start_number_of_pdb_file,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#-----------------------------------------------------------
sub get_pdb_file_start_number{
	my($start_number, $pdb_file);
	if( ref($_[0]) ){
	 $pdb_file = ${$_[0]};
	}else{
	 $pdb_file = $_[0];
	}
	open (PDB_FILE, "$pdb_file");
	while(<PDB_FILE>){
	 if(/^ATOM      1\s+\w+\s+\w+\s+[\w]*\s+(\d+) \s+/){
		 $start_number = $1; last;
	 }
	}
	\$start_number;
}
#_______________________________________________________________
# Title     : write_modeller_top_file
# Usage     : &write_modeller_top_file(\%hash, [v]);
# Function  : Writes Modeller command file format.
# Example   :
#     $modelname = 'gfct';
#     $template = '1ovt';
#     %hash=($modelname, $template);
#     &write_modeller_top_file(\%hash);
# Warning   :
# Keywords  :
# Options   : v  for verbose. You will get STDOUT of the result as well as file
# Returns   : a file of xxxx.top form.
# Argument  : 1 hash ref which has model name and template name -> (\%hash)
#             while %hash is (modelname, tempalatename)
# Category  :
# Version   : 1.0
#-----------------------------------------------------------
sub write_modeller_top_file{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
format MODELLER_TOP_FORMAT =
INCLUDE
SET ALNFILE = @<<<<<<<<<<<<<<<<
$ali_file
SET KNOWNS = @<<<<<<<<<<<<<<<<
$pdb_file
SET SEQUENCE = @<<<<<<<<<<<<<<<<
$model
SET ATOM_FILES_DIRECTORY = './:../atom_files'
SET STARTING_MODEL = 1
SET ENDING_MODEL = 1
CALL ROUTINE = 'model'
.
format STDOUT =
INCLUDE
SET ALNFILE = @<<<<<<<<<<<<<<<<
$ali_file
SET KNOWNS = @<<<<<<<<<<<<<<<<
$pdb_file
SET SEQUENCE = @<<<<<<<<<<<<<<<<
$model
SET ATOM_FILES_DIRECTORY = './:../atom_files'
SET STARTING_MODEL = 1
SET ENDING_MODEL = 1
CALL ROUTINE = 'model'
.
	########## Program starts ####################
	for($i=0; $i<@hash;$i++){
		($model, $pdb_file) = each %{$hash[$i]};
		$out_file = "$model.top";
		$ali_file = "$model.ali";
		open (MODELLER_TOP_FORMAT, ">$out_file");
		$pdb1 = "$ENV{'PDB'}\/$pdb_file.brk";
		$pdb2 = "$ENV{'PDB'}\/$pdb_file.pdb";
		if( !(-e $pdb1 ) && !( -e $pdb2 ) ){
			print "\n Error the file $pdb1  or  $pdb2\n";
		}
		$model ="\'$model\'";
		$pdb_file ="\'$pdb_file\'";
		$ali_file ="\'$ali_file\'";
		write MODELLER_TOP_FORMAT;
		if( $char_opt=~/v/i){ write STDOUT; }
	}
}
#_______________________________________________________________
# Title     : write_modeller_ali_file
# Usage     : &write_modeller_ali_file(\%model, \%template, [\$outfilename], [v]);
# Function  : Writes Modeller alignment format.
# Example   :
#             $out = 'test.ali';
#             %model =    qw(model AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAccccccccccc);
#             %template = qw(templ CCAAAAAAAACCCCCCCCCCCCCCCCCCCCCCCCCCCCC 3 42);
#             &write_modeller_ali_file(\%model, \%template, \$out);
# Warning   :
# Keywords  :
# Options   : You can put 2 numbers for the second set of key and element for
#             the second hash input as the starting and ending points of
#             template(i.e. pdb file seq). Unless I calculate the size of seq.
#             By default, it reads PDB file defined by ENV setting of 'PDB' and
#             gets the starting number of pdb. If starting number is defined
#             explicitly at input hash, the given starting number is used instead
#             of PDB's.
#             v  for verbose. You will get STDOUT of the result as well as file
# Returns   : a file of xxxx.ali form.
# Argument  : 2 ref. of hash for seq. and optional output.name and option(s).
#             If second input hash (for template) has 3rd and 4th element which are
#             numbers they are regarded as the starting and ending number of the
#             template(i.e. pdb file seq)
# Category  :
# Version   : 1.0
#-----------------------------------------------------------
sub write_modeller_ali_file{
	#""""""""""""""""""""""< handle_arguments{ head Ver 1.2 >""""""""""""""""""""""""""""""""
	my(@A ) = &handle_arguments( @_ ); my( $num_opt )=${$A[7]};my( $char_opt )=${$A[8]};
	my(@hash)  =@{$A[0]};my(@file)   =@{$A[4]};my(@dir   )  =@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};my(@raw_string)=@{$A[9]};
	my($i, $j, $c, $d, $e, $f, $g, $h, $k, $l, $p, $q, $r, $s, $t, $u, $v, $w, $x,$y,$z);
	if($debug==1){ print "   \@hash has \"@hash\"\n   \@raw_string has \"@raw_string\"
	\@array has \"@array\"\n   \@char_opt has \"@char_opt\"\n   \@file has \"@file\"\n"; }
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
format MODELLER_ALI_FORMAT =
>P1;@<<<<<<<<<<<<<<<
$name
structureX: @<<<<<<<<<<<<<<: @<<<: : @<<<<<: : @<<<<<<<<<<<<<: :
$name $start_seq $seq_leng $name
@*
$seq
*
.
format STDOUT =
>P1;@<<<<<<<<<<<<<<<
$name
structureX: @<<<<<<<<<<<<<<: @<<<: : @<<<<<: : @<<<<<<<<<<<<<: :
$name $start_seq $seq_leng $name
@*
$seq
*
.
	########## Program starts ####################
	if($file[0]){
		 open (MODELLER_ALI_FORMAT, ">$file[0]");
	}else{
		@seq  = %{$hash[0]};
		$name = $seq[0]; print "\n\$name is $name" if $debug ==1;
		open (MODELLER_ALI_FORMAT, ">$name.ali");
	}
	for($i=0; $i<@hash;$i++){
		@seq  = %{$hash[$i]};
		$name = $seq[0]; print "\n\$name is $name" if $debug ==1;
		$seq  = $seq[1]; print "\n\$seq  is $seq" if $debug ==1;
		$seq_leng = length($seq);
		## checking PDB entry of the template ##
		$pdb1 = "$ENV{'PDB'}\/$name.brk";
		$pdb2 = "$ENV{'PDB'}\/$name.pdb";
		if( (-e $pdb1 ) || ( -e $pdb2 ) ){
			$pdb_file = $pdb1;
			$start_seq = ${&get_pdb_file_start_number( $pdb_file )};
		}
		## Handling the starting and ending seq points of template
		if( defined($seq[2])&&($seq[2]=~/^\d+/) ){
		  $start_seq=$seq[2]; $seq_leng+=$start_seq; }
		elsif( defined($start_seq) ){
		  $seq_leng+=$start_seq; }
		else{ $start_seq =1; }
		if( (defined($seq[2])) &&($end_seq != $seq_leng ) ){
		  print "\n Your template seq length does not match with actual seq size
					\n I will put the calculated value \"$seq_leng\" as the template length\n\n";
		}
		print "\n\$seq_leng is $seq_leng\n" if $debug ==1;
		write MODELLER_ALI_FORMAT;
		if( $char_opt=~/v/i){ write STDOUT; }
	}
}

#_______________________________________________________________
# Title     : make_template_from_sec_str
# Usage     : %target   = %{&make_template_from_sec_str(\%seq)};
# Function  : makes template of sec. str. like: 'H5 E4 E2' out of '__HHHHH__EEEE__EE__'
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#-----------------------------------------------------------
sub make_template_from_sec_str{
	my(%out, @name, @fragments, %in, $name, $leng, $frag_seq, $name2);
	#""""""""""""""""""""""< handle_arguments{ head Ver 1.1 >""""""""""""""""""""""""""""""""
	my(@A ) = &handle_arguments( @_ ); my( $num_opt )=${$A[7]};my( $char_opt )=${$A[8]};
	my(@hash)  =@{$A[0]};my(@file)   =@{$A[4]};my(@dir   )  =@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};my(@raw_string)=@{$A[9]};
	my($i, $j, $c, $d, $e, $f, $g, $h, $k, $l, $p, $q, $r, $s, $t, $u, $v, $w, $x,$y,$z);
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	for($j = 0; $j < @hash ; $j ++){
	 %in = %{$hash[$j]};

	 @name = keys  %in;
	 print "\@name is @name\n", if($debug eq 1);

	 for($t=0; $t < @name; $t++){
		$name = $name[$t];
			print "\$name is $name\n", if($debug eq 1);
		$leng=length($in{$name});
			print "$leng\n", if($debug eq 1);
		$name2 ="$name"."$leng"; # to attach sequence length
		@fragments = split(/_+/, $in{$name});
			print "\@fragments is @fragments\n", if($debug eq 1);
		for($i = 0; $i < @fragments; $i++){
		  if($fragments[$i] =~/(\w)\w+/){
			  $fraglength = length($fragments[$i]);
			  $frag_seq .= "$1"."$fraglength "; # space is delimiter  'H5 E3 E5 E4'
			  print "\$frag_seq is $frag_seq\n", if($debug eq 1);
		  }
		  $out{$name2}=$frag_seq;
		}
	 }
	}
	return(\%out);
}

#______________________________________________________________________________
# Title     : calculate_protein_symmetry_index
# Usage     :
# Function  : Using symst files
# Example   :  Conversion rule
#               $sec_str=~tr/IiGgBbTt/CcCcCcCc/;
#           H        Alpha helix
#           G        3-10 helix
#           I        PI-helix
#           E        Extended conformation
#           B or b   Isolated bridge
#           T        Turn
#           C        Coil (none of the above)
#           S        A bend without a hydrogen bond (a kind of coil)
# Keywords  : PROSIX (protein symmetry index)
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 2.4
#------------------------------------------------------------------------------
sub calculate_protein_symmetry_index{
    local($symst_file, $pdb_id_query, $range_query, $seqlet_query, $secturlet_query,
        $pdb_id_match, $range_match, $seqlet_match, $secturlet_match, $simplify,
        $NON_self_stragment_match, $SELF_self_stragment_match,
        $SELF_palindrome_count, $NON_palindrome_count, $entry_count,
        $Total_unique_pdb_match, $num_of_unique_pdb_match,
        $Total_SELF_monotonous_seqlet, $Total_NON_monotonous_seqlet,
        $Total_NON_palindrome_seqlet, $Total_NON_palindrome_seqlet,
        $Total_palindrome, %NON_self_PDBD_entry, %SELF_secture_composition_hash,
        $composition_simil_counter, $sum_query_occur, $sum_match_occur,
        $running_av_compos_simil, $skip_self_stragment, %secture_compos_hash_query,
        %secture_compos_hash_match, %PDB_seq_containing_rev_stragment);
    $simplify='s'; ## simplify secture types
    $SELF_stragment_match=0;
    $symst_file=${$_[0]} || $_[0];
    $skip_self_stragment=${$_[1]} || $_[1];
    open(SYMST, "<$symst_file") || die "\n Cannot open $symst_file file\n";

    while(<SYMST>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Matching the very first occurance of '>xxxx_38-123_KJKJKJKJ...'
       #_______________________________________________________________
       if(/^\>(\S+)\_(\d+\-\d+)_(\S+):(\S+)/){
           $pdb_id_query   =$1;       $range_query    =$2;
           $seqlet_query   =$3;       $secturlet_query=$4;
           $number_of_unique_frag_entry{$pdb_id_query}++;

           if($simplify){ $secturlet_query=~tr/SsIiGgBbTt/CcCcCcCcCc/; }
           @secture_residues_query=split(//, $secturlet_query);
           @seqlet_residues_query =split(//, $seqlet_query);

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Show interim summary for each PDB entry when new pdb_id query entries is met
           #_________________________________________________________________________________
           if($seqlet_match and $pdb_id_query ne $pdb_id_query_prev){
                $entry_count++;
                print "      (2-1) calculate_and_print_prosix \n";
                &calculate_and_print_prosix;
                $seqlet_match='';
           }elsif($seqlet_match){  #print "\nNO new $entry_count $pdb_id_query  $seqlet_query $secturlet_query";
                &calculate_composition_prosix($running_av_compos_simil,
                                              $seqlet_match);
           }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Calculating secture composition(query)
           #______________________________________
           #print "\n\n\n----------------------\n  (1) putting H E C to secture_compos_hash_query hash \n";
           for($i=0;$i<@secture_residues_query; $i++){
               $secture_compos_hash_query{$secture_residues_query[$i]}++;
           }
           #print "\n   (2) \$seqlet_query $seqlet_query  @secture_residues_query\t", %secture_compos_hash_query, "\n";
           $secturlet_query_prev=$secturlet_query;
           $range_query_prev=$range_query;
           $seqlet_query_prev=$seqlet_query;
           $pdb_id_query_prev=$pdb_id_query;  %NON_self_PDBD_entry=();

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Matching the indented match line: '    2bpa1_80-86_QWIKFMK:HHHHHHH'
       #________________________________________________________________________
       }elsif(/^\s+[\>]?(\S+)\_(\d+\-\d+)_(\S+):(\S+)/){
           $pdb_id_match   =$1;      $range_match    =$2;
           $seqlet_match   =$3;      $secturlet_match=$4;

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Exact reverse of the same region is skipped
           #__________________________________________________________________________
           if($skip_self_stragment and
              $pdb_id_match eq $pdb_id_query and
              $range_query eq $range_match){ next }
           if($simplify){ $secturlet_match=~tr/SsIiGgBbTt/CcCcCcCcCc/; }

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
           # The critical step is here !! There has been no reversing by me with previous programs
           #___________________________________________________________________________________________
           $secturlet_match_rv=reverse($secturlet_match); ## this is theoretically correct
           #$secturlet_match_rv=$secturlet_match;         ## however, non-reverse has better secture matching as many of sectures are palindrome

           @secture_rv_residues_match=split(//, $secturlet_match_rv);
           @seqlet_residues_match=split(//, $seqlet_match);
           $num_of_unique_pdb_match{$pdb_id_match}++;

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # SELF-SELF stragment
           #___________________________________________________
           if($pdb_id_query_prev eq $pdb_id_match){
              my(%monotony_check);
              $PDB_seq_containing_rev_stragment{$pdb_id_match}++;
              $SELF_stragment_match++;
              $Total_SELF_stragment_match =$SELF_stragment_match;
              if($seqlet_query eq $seqlet_match){  $SELF_palindrome_count++;    }

              for($i=0; $i<@secture_residues_query; $i++){
                 $monotony_check{$secture_residues_query[$i]};
                 if($secture_residues_query[$i] eq $secture_rv_residues_match[$i]){
                    $SELF_self_identical_secture++;
                    $SELF_same_secture_AA_residue{$seqlet_residues_query[$i]}++;
                    $SELF_same_secture_type{$secture_residues_query[$i]}++;
                 }else{
                    $SELF_self_non_identical_secture++;
                    $SELF_diff_secture_AA_residue{$seqlet_residues_query[$i]}++;
                    $SELF_diff_secture_type{$secture_residues_query[$i]}+=0.5;
                    $SELF_diff_secture_type{$secture_residues_match[$i]}+=0.5;
                 }
              }
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Calculating secture composition(match)
              #________________________________________
              for($i=0;$i<@secture_rv_residues_match; $i++){
                  $secture_compos_hash_match{$secture_rv_residues_match[$i]}++;
              }
              #print "\n     (3) $pdb_id_match @secture_rv_residues_match ==> ", %secture_compos_hash_match;
              if((keys %monotony_check)==1){  $SELF_monotonous_seqlet++;   }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # NELF-NELF stragment (Nelf == non-self)
           #___________________________________________________
           }elsif($pdb_id_query ne $pdb_id_match){
              #print "\n     (3-1) $pdb_id_query != $pdb_id_match \n";
              $NON_self_PDBD_entry{$pdb_id_match}++;
              my(%monotony_check);
              $NON_self_stragment_match++;
              $Total_NON_stragment_match +=$NON_self_stragment_match;
              if($seqlet_query eq $seqlet_match){  $NON_palindrome_count++;       }

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Comparing Secture to count the identical secture for the query and match seqlets
              #________________________________________________________________________________________
              for($i=0; $i<@secture_residues_query; $i++){
                 $monotony_check{$secture_residues_query[$i]};
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Compare the SECTUREs. Note that I reverse the matched secture.
                 #__________________________________________________________________
                 if($secture_residues_query[$i] eq $secture_rv_residues_match[$i]){
                    $NON_self_identical_secture++;
                    $NON_same_secture_AA_residue{$seqlet_residues_query[$i]}++;
                    $NON_same_secture_type{$secture_residues_query[$i]}++;
                 }else{
                    $NON_self_non_identical_secture++;
                    $NON_diff_secture_AA_residue{$seqlet_residues_query[$i]}++;
                    $NON_diff_secture_type{$secture_residues_query[$i]}+=0.5;
                    $NON_diff_secture_type{$secture_residues_match[$i]}+=0.5;
                 }
              }
              if((keys %monotony_check)==1){   $NON_monotonous_seqlet++;    }
           }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # When end of line is matched
       #______________________________________________
       }elsif(eof){
           #print "\n    END of file reached , $running_av_compos_simil $seqlet_match\n";
           $entry_count++;
           #&calculate_composition_prosix($running_av_compos_simil,
           #                              $seqlet_match);
           &calculate_and_print_prosix;
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Title   : calculate_and_print_prosix
           # Usage   : An internal subroutine
           #_____________________________________________________
           sub calculate_and_print_prosix{
               $num_of_unique_pdb_match       = keys %num_of_unique_pdb_match;
               $Total_unique_pdb_match       +=$num_of_unique_pdb_match;
               #print "\n $seqlet_query_prev : $seqlet_match ,,,,,,,\n";
               &calculate_composition_prosix($running_av_compos_simil,
                                             $seqlet_match);

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # $Total_identical_secture!! <-- most important
               #___________________________________________________________
               $Total_identical_secture        =$SELF_self_identical_secture+$NON_self_identical_secture;
               $Total_non_identical_secture    =$SELF_self_non_identical_secture+$NON_self_non_identical_secture;
               $Total_residue_number           =$Total_identical_secture+$Total_non_identical_secture;
               $Total_SELF_monotonous_seqlet  +=$SELF_monotonous_seqlet;
               $Total_NON_monotonous_seqlet   +=$NON_monotonous_seqlet;
               $Total_SELF_palindrome_seqlet   =$SELF_palindrome_count;
               $Total_NON_palindrome_seqlet    =$NON_palindrome_count;
               $Total_palindrome               =$SELF_palindrome_count + $NON_palindrome_count;
               @NON_self_PDBD_entry            =keys %NON_self_PDBD_entry;
               $number_of_unique_frag_entry    =keys %number_of_unique_frag_entry;
               $Total_SELF_self_secture_residue=$SELF_self_identical_secture+$SELF_self_non_identical_secture;
               $Total_NON_self_secture_residue =$NON_self_identical_secture +$NON_self_non_identical_secture;
               $rate_SELF_self_secture_residue =$SELF_self_identical_secture/$Total_SELF_self_secture_residue if $Total_SELF_self_secture_residue;
               $rate_NON_self_secture_residue  =$NON_self_identical_secture /$Total_NON_self_secture_residue  if $Total_NON_self_secture_residue;
               if($Total_residue_number < 1){ $Total_residue_number=1 }
               $rate_Total_iden_secture        =$Total_identical_secture/$Total_residue_number;
               print "#($entry_count, $pdb_id_query_prev) $pdb_id_match $seqlet_query_prev $secturlet_query_prev:$secturlet_match_rv <-(reversed)\n";
               print "\$Total_identical_secture           : $Total_identical_secture /$Total_residue_number ($rate_Total_iden_secture)\n";
               print "  \$SELF_stragment_match            :  $SELF_stragment_match     for $pdb_id_match\n";
               print "  \$Total_SELF_stragment_match      :  $Total_SELF_stragment_match     for $pdb_id_match\n";
               print "  \$NON_self_stragment_match        :  $NON_self_stragment_match (@NON_self_PDBD_entry)\n";
               print "  \$num_of_unique_pdb_match(+self)  :  $num_of_unique_pdb_match\n";
               print "\$SELF_self_identical_secture       :  $SELF_self_identical_secture / $Total_SELF_self_secture_residue ($rate_SELF_self_secture_residue)\n";
               print "  \$NON_self_identical_secture      :  $NON_self_identical_secture / $Total_NON_self_secture_residue($rate_NON_self_secture_residue)\n";
               print "  \$Total_non_identical_secture     :  $Total_non_identical_secture / $Total_residue_number\n";
               print "  \$SELF_monotonous_seqlet          :  $SELF_monotonous_seqlet / $Total_SELF_monotonous_seqlet\n";
               print "  \$SELF_palindrome_count           :  $SELF_palindrome_count / $Total_SELF_palindrome_seqlet\n";
               print "  \$NON_monotonous_seqlet           :  $NON_monotonous_seqlet / $Total_NON_monotonous_seqlet\n";
               print "  \$NON_palindrome_count            :  $NON_palindrome_count  / $Total_NON_palindrome_seqlet\n";
               print "  \$Total_palindrome                :  $Total_palindrome / $Total_residue_number\n";
               print "   Number of unique PDB entry      :  $number_of_unique_frag_entry for $pdb_id_query_prev\n";
               print "   SELF_running_av_compos_simil    : \"$running_av_compos_simil\" (only self-self stragment considered)\n";
               print "  \$NON_SELF_running_av_compos_simil: $NON_SELF_running_av_compos_simil \n";
               $SELF_stragment_match=$NON_self_stragment_match=$seqlet_match=0;
           }
       }
    }
    $num_PDB_seq_with_rev_stragment_inside=keys %PDB_seq_containing_rev_stragment;
    print "\n    There were $num_PDB_seq_with_rev_stragment_inside PDB seq with rev stragment inside\n\n";
    close(SYMST);
}




#_______________________________________________________________
# Title     : calculate_protein_volume
# Usage     : %volumes=%{&calculate_protein_volume(\%seq)}
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#-----------------------------------------------------------
sub calculate_protein_volume{
	my %final_volume;
	my %volume=("A","88.6" ,"C","108.5","D","111.1","E","138.4",
					"F","189.9","G","60.1" ,"H","153.2","I","166.7",
					"K","168.6","L","166.7","M","162.9","N","117.7",
					"P","122.7","Q","143.9","R","173.4","S","89.0",
					"T","116.1","V","140.0","W","227.8","Y","193.6",
					"a","88.6" ,"c","108.5","d","111.1","e","138.4",
					"f","189.9","g","60.1" ,"h","153.2","i","166.7",
					"k","168.6","l","166.7","m","162.9","n","117.7",
					"p","122.7","q","143.9","r","173.4","s","89.0",
					"t","116.1","v","140.0","w","227.8","y","193.6");
	#""""""""""""""""""""""< handle_arguments{ head Ver 1.1 >""""""""""""""""""""""""""""""""""""""
	my(@A ) = &handle_arguments( @_ ); my( $num_opt )=${$A[7]};my( $char_opt )=${$A[8]};
	my(@hash)  =@{$A[0]};my(@file)   =@{$A[4]};my(@dir   )  =@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};my(@raw_string)=@{$A[9]};
	my($i, $j, $c, $d, $e, $f, $g, $h, $k, $l, $p, $q, $r, $s, $t, $u, $v, $w, $x,$y,$z);
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my %seq_hash =  %{$hash[0]};
	my @names = keys %seq_hash;
	#if($debug == 1){
	  print "\n ",__LINE__, " Seq names are @names\n";
	# }

	for( $i=0 ; $i < @names; $i++){
	  my @seq=split(//, $seq_hash{$names[$i]});
	  for( $j=0; $j < @seq; $j ++){
		  $final_volume{$names[$i]} += $volume{$seq[$j]};
	  }
	}
	\%final_volume;
}




#_______________________________________________________________
# Title     : extract_words
# Usage     : @words = @{&extract_words(\$string)};
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#-----------------------------------------------------------
sub extract_words{
	#""""""""""""""""""""""< handle_arguments{ head Ver 1.1 >"""""""""""""""""""""""""""""""
	my(@A ) = &handle_arguments( @_ ); my( $num_opt )=${$A[7]}; my( $char_opt )=${$A[8]};
	my(@hash)  =@{$A[0]}; my(@file)   =@{$A[4]}; my(@dir   )  =@{$A[3]}; my(@array)=@{$A[1]};
	my(@string)=@{$A[2]}; my(@num_opt)=@{$A[5]}; my(@char_opt)=@{$A[6]}; my(@raw_string)=@{$A[9]};
	my($i, $j, $c, $d, $e, $f, $g, $h, $k, $l, $p, $q, $r, $s, $t, $u, $v, $w, $x,$y,$z);
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if($debug==1){
	  print __LINE__, " Args to extract_words are: \"@raw_string\"\n";
	}
	for($i=0; $i < @raw_string; $i ++){
	  if(ref($raw_string[$i]) eq 'SCALAR'){
		 $line = ${$raw_string[$i]};
	  }else{
		 $line = $raw_string[$i];
	  }
	  push( @words, split(/[\W\-\_]+/, $line) );
	}
	if($debug==1){
	  $num = @words;
	  print __LINE__, " Num of words are : \"$num\"\n";
	}
	\@words;
}

#________________________________________________________________________
# Title     : replace_subroutines
# Usage     :
# Function  : replaces subroutines of given file(s) with supplied subs.
#             Doesn't care version
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub replace_subroutines{
	#"""""""""""""""""< handle_arguments{ head Ver 1.6 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my($i,$j,$c,$d,$e,$f,$g,$h,$k,
	$l,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($each_sub, %out_subs, $VER, %left_out, @lib, $ver, $sub_name,
	  $real_sub_entry_found);
	my %hash=%{&merge_hash(@hash)};
	@array= keys %hash;
	my @values= values %hash;

	for($i=0; $i < @file; $i++){
		open(LIB_FILE, "<$file[$i]")|| die  "\n $file[$i]  <- $! \n";
		@lib =<LIB_FILE>;
		for($j=0; $j < @lib; $j++){
			  for($s=0; $s < @array; $s++){
				  if($array[$s] =~/^([_a-zA-Z\-]+)(\d*\.*\d*)$/){
					  $sub_name=$1;
					  $VER =$2;
				  }
				  #"""" Taking the headbox """""""""""""
				  if( ($lib[$j]=~/^#[_\-\*]{10,130}\s*$/)&&($lib[$j+1]=~/^(#\s*title\s*:\s*$sub_name)[^\.pl]/i) ){
					  $real_sub_entry_found=0;
					  $out_subs{"$sub_name"}.="$lib[$j]$1\n";
					  $j+=2;
					  until( ($lib[$j]=~/^sub\s*\w+\s*\{/)||($lib[$j]=~/^#[\-_\*]{10,130}\s*$/) ){
							 $lib[$j]=~s/(\s*)$//;  #<-- removing ending space
							 #"""""""""""""""""""""""""""""""""""
							 #  Taking version no.
							 #"""""""""""""""""""""""""""""""""""
							 if( ($char_opt !~ /nv/i) && ($lib[$j]=~/^#\s*version\s*:\s*([\d+\.\d+]*)\s*/i) ){
								  if( $1=~/^[ ]*$/){ $ver = '1.0'; }     ##  make null to 1.0
								  elsif( $1=~/^(\d+)$/){ $ver = "$1\.0"; } ### make  2   to 2.0
								  elsif($1=~/^([\d+\.\d+]+)$/){ $ver = $1; } ##  assign version
							 }
							 $out_subs{"$sub_name"}.="$lib[$j]";
							 $j++;
					  }
					  $out_subs{"$sub_name"}.="$lib[$j]";
					  $j++;  ## essential to remove #------------- line
				  }

				  #"""""""" Reading sub {  } """""""
				  if($lib[$j]=~/^sub\s+$sub_name\s*\{/){
					  $out_subs{"$sub_name"}.="$lib[$j]";
					  $j++;
					  until($lib[$j]=~/^\}/){
						  $out_subs{"$sub_name"}.="$lib[$j]";  $j++;
					  }
					  $out_subs{"$sub_name"}.="$lib[$j]";  ## to fetch '}'

					  $j++;

					  splice(@array, $s, 1); ## removing the subnames found
					  $s--;
					  unless(defined($ver)){ $ver = '1.0' }
					  unless($char_opt=~/nv/i){ ## if No version attachment option is set
						  $out_subs{"$sub_name$ver"}=$out_subs{$sub_name};
						  delete $out_subs{$sub_name};
					  }
				  }
			  }
			  $left_out{$file[$i]}.=$lib[$j]; ## Remnant file content of the operation
			                                  ## just in case you want the left out ones.
		}
		close LIB_FILE;
		open (LEFT_FILE, ">$file[$i]");
		for($h= 0; $h < @values; $h++){### appending the new subs.
			 $left_out{$file[$i]} .= $values[$h];
		}
		print LEFT_FILE $left_out{$file[$i]};
		close LEFT_FILE;

	}#""""""""""""" end of for (@file)

	@no_of_subs_fetched = keys %out_subs;
	if(@array>0){
		print chr(7);
		print "\n# Following subs are not found in \"", "@file","\"\n  ", "@array", "\n\n";
	}
	return( \%left_out ); # this has all the sub routines and other lines.
}


#________________________________________________________________________
# Title     : replace_text_recursively
# Usage     : &replace_text_recursively(<old_string>, <new_string>, <dir_name>);
# Function  : finds patterns of text and replaces them in multiple input files
# Example   :
# Warning   : This produces a temporary file and rename it...
# Class     :
# Keywords  :
# Options   :
# Package   :
# Reference :
# Returns   : nothing
# Tips      :
# Argument  : reference of one array of file names in pwd
# Todo      :
# Author    : jong
# Version   : 1.1
#--------------------------------------------------------------------
sub replace_text_recursively{
    my ($each_file, $file, $new_fasta_name, %pdb_seq, @included_files,
        $min_seq_leng_accepted, @read_files, $original_dir,
        $old_text_string, $new_text_string, @modified_files,
        $each_line, $file_extension);

    $old_text_string=$_[0];
    $new_text_string=$_[1];

	if(-d $_[2]){ $original_dir=$_[2];
		@read_files=@{&read_any_dir_simple(\$original_dir)};
		sub read_any_dir_simple { my($in_dir); $in_dir=${$_[0]} || $_[0]; opendir(DIR1,"$in_dir");
		    my(@read_files) = readdir(DIR1);closedir(DIR1);	splice(@read_files, 0, 2);
		    return(\@read_files); }
	}else{
	    die "\n $0 needs a dir name as the 3rd argument\n\n";
	}

    if($_[3]){ $file_extension=$_[3]; }

    foreach $file(@read_files){
         $each_file="$original_dir/$file";
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If the File read is DIR => Recurse
         #________________________________________________________
         if( -d "$each_file" ){  ## If it is a directory.
              $num=@included_files=(@included_files,
                  &replace_text_recursively($old_text_string,
                                            $new_text_string,
                                            $each_file,
                                            $file_extension) );   # RECURSION occurrs here!!

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If the File read is FILE => PROCESS!
         #________________________________________________________
         }elsif (-T $each_file){     #<<------ This is where things match
              if($file_extension and $each_file !~/\.$file_extension$/){ next }
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # If you need to write in the subdir, first you need to chdir
              #_______________________________________________________________
              open (IN, "$each_file");
              my @lines=<IN>;
              close(IN);
              open (OUT, ">$each_file") or warn "\n# $0: ERROR opening $each_file, check permission!\n";
              for $each_line (@lines){
                 if($each_line=~/(.*)($old_text_string)(.*)/){
                     $temp="$1${new_text_string}$3\n";
                     print "\nmatched $each_line in $each_file, becomes: $temp\n";
                     print OUT $temp;
                     print "$each_file has been modified\n";
                     print "$old_text_string became $new_text_string in $each_line\n";
                     push(@modified_files, $each_file);
                 }else{
                     print OUT $each_line;
                 }
              }
              close OUT;
              if($each_file =~/\.pl$/){ chmod 0755, $each_file; } # this makes it execu..

         }elsif (-l $each_file){
              print "\n\n$each_file is linked, skipping. \n";
         }
	}
	return(\@modified_files);
}




#______________________________________________________________________________
# Title     : write_subroutines
# Usage     : @out_file=@{&write_subroutines(\%head_box)};
# Function  : Writes subroutine file xxxx.psub with given headbox including
#              hash
# Example   :
# Keywords  : write_psub_files, write_perl_subroutines
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub write_subroutines{
		my($i, $j, $pwd, @final_output_file, $sub_title, $subroutine_file);
		$pwd=`pwd`;

		print "\n<br>Writing psub file<br>\n" if $verbose;
		for($i=0; $i< @_; $i++){
				if(ref($_[$i]) eq 'HASH'){
						push(@hash, $_[$i]);
				}
		}
		for($i=0; $i< @hash; $i++){
				 my %hash=%{$hash[$i]};
				 @entries=keys %hash;
				 foreach (@entries){
						if(/title/i){       $hash{'Title'}=$hash{$_}; $sub_title=$hash{$_}; $subroutine_file="$sub_title\.psub";
						}elsif(/function/i){ $hash{'Function'}=$hash{$_};
						}elsif(/usage/i){ $hash{'Usage'}=$hash{$_};
						}elsif(/content/i){ $hash{'Content'}=$hash{$_};
						}elsif(/options/i){ $hash{'Options'}=$hash{$_};
						}elsif(/author/i){ $hash{'Author'}=$hash{$_};
						}elsif(/version/i){ $hash{'Version'}=$hash{$_};
						}elsif(/category/i){ $hash{'Category'}=$hash{$_};
						}elsif(/keyword/i){ $hash{'Keywords'}=$hash{$_};
						}elsif(/example/i){ $hash{'Example'}=$hash{$_};
						}
				 }
				 print "\n<br> Opening $subroutine_file at \$pwd :  $pwd<br>";
				 open(SUBROUTINE_FILE, ">$subroutine_file") or print "<br># (E) Could not open $subroutine_file<br>";
				 push(@final_output_file, $subroutine_file);
				 print SUBROUTINE_FILE "#\!\/usr\/bin\/perl\n";
				 @keys=qw(Title Function Usage Example Keywords Options Author Category Version);
				 print SUBROUTINE_FILE "#"."____"x20, "\n";
				 for($j=0; $j < @keys; $j++){
						 printf SUBROUTINE_FILE ("# %-9s : %s\n", $keys[$j], $hash{$keys[$j]});
				 }
				 print SUBROUTINE_FILE "#"."----"x20, "\n";
				 print SUBROUTINE_FILE $hash{'Content'}, "\n";
				 close SUBROUTINE_FILE;
				 chmod 0777, $subroutine_file;
				 print "<br> Good!<br>";
		}
		print "\n<br>@final_output_file were written<br>\n" if $verbose;
		return(\@final_output_file);
}

#______________________________________________________________________________
# Title     : read_FSSP_TREE_TABLE
# Usage     :
# Function  :
# Example   :
# Keywords  : memorize_FSSP_TREE_TABLE open_FSSP_TREE_TABLE
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub read_FSSP_TREE_TABLE {
    my $FSSP_TREE_TABLE=${$_[0]};
    open(IN, $FSSP_TREE_TABLE) || die "\n Can not open $FSSP_TREE_TABLE by read_FSSP_TREE_TABLE\n\n";
    while(<IN>) { last if(/Family index\s+PDB-code\s+compound/) }
	while(<IN>) { ($x,$cd)=/^\s+(\d+)\S+\s+[_]*(\w+)/; $class{$cd}=$x; }close(IN);
    return(\%class);
}

#______________________________________________________________________________
# Title     : read_phi_psi_angles_in_dssp_file
# Usage     :
# Function  :
# Example   :
#  #  RESIDUE AA STRUCTURE BP1 BP2  ACC   N-H-->O  O-->H-N  N-H-->O  O-->H-N    TCO  KAPPA ALPHA  PHI   PSI    X-CA   Y-CA   Z-CA
#    1   -2 E S              0   0   60    0, 0.0 152,-1.6   0, 0.0   2,-0.3   0.000 360.0 360.0 360.0 122.1   29.8    8.7   25.1
#    6    3 E T  E     -A  168   0A  78   -2,-0.4   2,-0.3 162,-0.2 162,-0.3  -0.657  24.2-154.5 -71.9 133.5   28.1    9.6    7.8
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub read_phi_psi_angles_in_dssp_file{
    my(@phi_psi_angles, $dssp_file, $read_point_found, $phi_psi_angles);
    $dssp_file=$_[0];
    open(DSSP, "<$dssp_file") || die "\n read_phi_psi_angles_in_dssp_file: \$dssp_file not found \n";
    while(<DSSP>){
        if(/^\s+#\s+RESIDUE\s+AA\s+STRUCTURE/){
           $read_point_found=1;
        }elsif($read_point_found and /(.{6})(.{6})\s+\S+\s+\S+\s+\S+$/){
           $phi_psi_angles="$1 $2";
           push(@phi_psi_angles, $phi_psi_angles);
        }
    }
    return(\@phi_psi_angles);
}



#______________________________________________________________________________
# Title     : read_matrix_for_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub read_matrix_for_DALI {
        local($cd2,$fsspfile)=@_;
        local($iali,$i);
#       print ">>> read_matrix_for_DALI $cd2 -> $alino{$cd2} from $fsspfile\n";
        $iali=$alino{$cd2};
        undef(@u); undef(@t);
        open(IN,$fsspfile) || die "FATAL: bad file name $fsspfile\n";
        $x=0;
        while(<IN>) {
                last if(/^## FOOTER/);
                last if(/^\/\//);
                next unless (/U\(/);
                ($i)=/^\s*(\d+)\:/;
                if($i==$iali) { # four last real numbers on line
                        ($a,$b,$c,$d)=
        (/.*\s+([\d\.\-]+)\s+([\d\.\-]+)\s+([\d\.\-]+)\s+([\d\.\-]+)\s*$/);
                        push(@u,$a,$b,$c);
                        push(@t,$d);
                        $x++;
                        last if ($x == 3);
                }
        }
        close(IN);
#       if(!$u[0]) { print "<PRE>FATAL: no matrix for $cd2 found in $fsspfile<\/PRE>\n"; }
#       else {  printf "<PRE>$cd2 U: %8.5f %8.5f %8.5f\n   %8.5f %8.5f %8.5f\n   %8.5f %8.5f %8.5f\n",@u; printf "T: %8.3f %8.3f %8.3f\n",@t,'<\/PRE>'; }

}


#______________________________________________________________________________
# Title     : read_dssp_seq_only
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub read_dssp_seq_only {
        local ($cd,$chainid)=@_;
        local ($file,@seq);
        &open_db_file_DALI(1,$cd,%dsspdir);
        while(<IN>) { next unless (/^  #  /); last; } # skip headers
        # put a dummy residue as zeroth element
        push(@seq,"?");
        while(<IN>) {   # residues
        #   1    1 A G              0   0  101    0, 0.0  26,-0.1   0, 0.0   2, 0.0   0.000 360.0 360.0 360.0-165.7    1.5   -9.0   17.3
                $x=substr($_,11,1);
                next unless ($x eq $chainid);
                $x=substr($_,13,1);
                next if($x eq '!');
                $x=~tr/a-z/C/; # disulphides!
                push(@seq,$x);
        }
        close(IN);

        return(@seq);
}



#______________________________________________________________________________
# Title     : read_hssp_file_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub read_hssp_file_DALI {
        local ($cd,$chainid)=@_;
        local ($file,@acc,@resno,@seq,@alistring,$x,$i,$swisscode,$dir,$ext);
#       print "\n<P>read_hssp_file_DALI: $cd chain: |$chainid|<P>\n";
        undef (%data,@acc);
        $find=&opendbfile(0,$cd,%hsspdir);
        if($find == 0) {
          while(<IN>) {         # skip headers
                next unless(/^## PROTEINS/);
                last;
          }
          $x=<IN>;
          $swisscode="?";
          while(<IN>) {         # remember swisscodes
                last if(/^## ALIGNMENT/);
                ($x)=/^[ \d]+: (\w+)/;
                $swisscode .= "\n" . $x ;
          }
          $x=<IN>;
          # put a dummy residue as zeroth element
          push(@acc,0);push(@resno,0);push(@seq,'?');
          push(@alistring,$swisscode);
          while(<IN>) { # residues
                last if(/^##/);                 # can have >1 aliblocks!
                $x=substr($_,12,1);
                next unless ($x eq $chainid);
                $x=substr($_,14,1);
                next if($x eq '!');
                push(@seq,$x);
                $x=substr($_,45,5);
                push(@acc,$x);
                $x=substr($_,6,6);
                push(@resno,$x);
                $x=substr($_,51,70);
                $x=~s/\n//;
                $y=length($x); if($y<70) { foreach($y..69) {$x.=' ';}}
                push(@alistring,$x);
          }
          while(/^## ALIGNMENTS/) {
                $x=<IN>;
                $i=0;
                while(<IN>) {
                        last if(/^##/);
                        $x=substr($_,12,1);
                        next unless ($x eq $chainid);
                        $x=substr($_,14,1);
                        next if($x eq '!');
                        $x=substr($_,51,70);
                        $x=~s/\n//;
                        $y=length($x); if($y<70) { foreach($y..69) {$x.=' ';}}
                        $i++;
                        $alistring[$i] .= $x;
                }
          }
          close(IN);

          foreach $i (0..$#acc) {
                $data{$i}=join(':',$acc[$i],$resno[$i],$seq[$i],$alistring[$i]);
          }
        } else { print "read_hssp_file_DALI failed\n"; }
        return($#acc,%data);
}

#______________________________________________________________________________
# Title     : aliview
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub aliview {
    local($cd1,$fsspfile,$outfile,@cd2list,@swiss,$cd2,$x);
    ($cd1,$fsspfile,$outfile,@cd2list)=@_;

        if($domain) {
                $cd=substr($cd1,$[,4);
                ($x,$idom)=split(/\:/,$cd1); $x=~s/[\s\-]+//g;
                if(length($x)<5) { $chainid=' '; } else { $chainid=substr($x,$[+4,1); }
        } else {
                $cd1=~s/[\s\-]+//g;
                $cd=substr($cd1,$[,4);
                if(length($cd1)<5) { $chainid=' '; } else { $chainid=substr($cd1,$[+4,1); }
        }
        ($nres,%data)=&read_hssp_file_DALI($cd,$chainid);
#       print "read_hssp_file_DALI returned $nres residues for $cd chainid=$chainid cd1=$cd1 x=$x idom=$idom<P>\n";
        foreach $i (0 .. $nres) {
          ($acc[$i],$resno[$i],$seq[$i],$alistring[$i])=split(/:/,$data{$i});
        }
        # if no hssp file defined ($nres=-1) then nres,sequence from fssp file !
        if($nres<0) {
                $alistring[0]=join("\n",$cd1,$cd1,0);
                open(IN,"<$fsspfile") || print "FATAL can't open $fsspfile\n";
                while(<IN>) { last if /^## ALIGNMENTS/; }
                $x=<IN>;
                $nres=0;
                while(<IN>) {
                        last if /^##/;
                        last unless /^.{12}(\w)/;
                        $x=$1;
                        $nres++;
                        $seq[$nres]=$x;
                        $alistring[$nres]=$x;
                }
                close(IN);
                print "patched sequence from $fsspfile: nres = $nres \n";
        }
        #
        @swiss=split("\n",$alistring[0]);
        undef(@lines);
        $l=0;
        foreach $i (1..$nres) {
                $x=length($alistring[$i]);
                if($x > $l) { $l=$x; }
#               print "$i $l: $alistring[$i]\n";
        }
        # query sequence
        shift(@seq); $ali=join('',@seq); $ali=~s/\s/~/g;
        $x=sprintf "%-20.20s ","$cd1"; $x.=$ali;
        push(@lines,"$x\n");
        foreach $iseq (1..$l) {
                undef (@ali);
                $lali=0;
                foreach $ires (1..$nres) {
                        $x=substr($alistring[$ires],$iseq-1,1);
                        push(@ali,$x);
                        if($x=~/\w/) { $lali++; }
                }
                if ($lali > 0) {
                        $ali=join('',@ali); $ali=~s/\s/~/g;
                        $x=sprintf "%-20.20s ","$cd1\|$swiss[$iseq]"; $x.=$ali;
                        push(@lines,"$x\n");  # exclude empty lines
                }
        }

## more than one cd2 !
      foreach ($[..$#cd2list) {
              $cd2=$cd2list[$_]; $cd2=~s/[\s\-]+//g;
              $iali=$alino{$cd2}; $dold=0; $bold=0;
              # print $query->h3("search for $cd2 = $alino{$cd2} in $fsspfile");
              # append other selected HSSP files
              if($domain) {
                      $cd=substr($cd2,$[,4);
                      ($x,$idom)=split(/\:/,$cd2); $x=~s/[\s\-]+//g;
                      if(length($x)<5) { $chainid=' '; } else { $chainid=substr($cd2,$[+4,1); }
              } else {
                      $cd2=~s/[\s\-]+//g;
                      $cd=substr($cd2,$[,4);
                      if(length($cd2)<5) { $chainid=' '; } else { $chainid=substr($cd2,$[+4,1); }
              }
              ($nres2,%data)=&read_hssp_file_DALI($cd,$chainid);
      #       print "read_hssp_file_DALI returned $nres2 residues for $cd cd2=$cd2 x=$x idom=$idom<P>\n";
              # read equivalences & print blocks
              undef(%ali1); undef(%border);
              $nblock=0;
              open(IN,$fsspfile) || print "FATAL can't open $fsspfile\n";
              while(<IN>) {
                      last if (/^## EQUIVALENCES/);
              }
              while(<IN>) {
                      last if /^##/;
                      last if /^\/\//;
                      if(/^\s+$iali\:/) {
                              $nblock++;
                              tr/<==>/ /;
                              s/\s-/ /g;
                              ($a,$b,$c,$d)=
                                /.*:\s+\S+\s+\S+\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
                              if($c-$dold>1) {
                                      $border{$a}=1;
                                      $border{$bold}=1;
                              }
                              $dold=$d; $bold=$b;
                              # print "block $a ($border{$a}).. $b ($border{$b}) <=> $c .. $d<P>\n";
                              foreach $ires ($a..$b) { $ali1{$ires}=$c; $c++; }
                      }
              }
              if($nres2-$dold>0) { $border{$bold}=1; }
              close(IN);
              foreach $i (0 .. $nres2) {
                ($acc[$i],$resno[$i],$seq[$i],$alistring[$i])=split(/:/,$data{$i});
              }
              @swiss=split("\n",$alistring[0]);
              $l=0;
              foreach $i (1..$nres2) {
                      $x=length($alistring[$i]);
                      if($x > $l) { $l=$x; }
              }
              foreach $iseq (1..$l) {
                      undef (@ali);
                      $lali=0;
                      foreach $ires (1..$nres) {
                              if(defined($ali1{$ires})) {
                                      $jres=$ali1{$ires};     ##alignment !!!##
                                      $x=substr($alistring[$jres],$iseq-1,1);
                                      if($border{$ires}) {
                                              $x=~tr/A-Z/a-z/;
                                      }
                                      push(@ali,$x);
                                      if($x=~/\w/) { $lali++; }
                              } else {
                                      push(@ali,"~");
                              }
                      }
                      if ($lali > 0) {
                              $ali=join('',@ali); $ali=~s/\s/~/g;
                              $x=sprintf "%-20.20s ","$cd2\|$swiss[$iseq]"; $x.=$ali;
                              push(@lines,"$x\n");  # exclude empty lines
                      }
              }
      } ## more than one cd2 !
      return(@lines);
}



#______________________________________________________________________________
# Title     : read_fssp_alignment_only
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub read_fssp_alignment_only {
        local ($cd,$chainid)=@_;
        local (@acc,@resno,@seq,@alistring,$x,$i,$swisscode);
#       print "\nread_fssp_alignment_only: $cd $chainid from $fsspfile\n";
        open(IN,"<$fsspfile") || die "can't read $fsspfile\n";
        while(<IN>) {           # skip headers
                next unless(/^## SUMMARY/);
                last;
        }
        $x=<IN>;
        $swisscode="?";
        while(<IN>) {           # remember PDBcodes
                last if(/^## ALIGNMENT/);
                ($x)=/^[ \d]+: [-\w]+\s+([-\w]{4,6})/;
                $swisscode .= "\n$x\n$x\n";
        }
        $x=<IN>;
        # put a dummy residue as zeroth element
        push(@acc,0);push(@resno,0);push(@seq,'?');
        push(@alistring,$swisscode);
        while(<IN>) {   # residues
                last if(/^##/);                 # can have >1 aliblocks!
                $x=substr($_,10,1);
                next unless ($x eq $chainid);
                $x=substr($_,12,1);
                next if($x eq '!');
                push(@seq,$x);
                $x=/.{32}\s+(\d+)/;
                push(@acc,$x);
                $x=substr($_,4,5);
                push(@resno,$x);
                $x=substr($_,42,90);
                $x=~s/\n//;
                push(@alistring,$x);
        }
        while(/^## ALIGNMENTS/) {
                $x=<IN>;
                $i=0;
                while(<IN>) {
                        last if(/^##/);
                        $x=substr($_,10,1);
                        next unless ($x eq $chainid);
                        $x=substr($_,12,1);
                        next if($x eq '!');
                        $x=substr($_,42,90);
                        $x=~s/\n//;
                        $i++;
                        $alistring[$i] .= $x;
                }
        }
        close(IN);

        undef %data;
        foreach $i (0..$#acc) {
                $data{$i}=join(':',$acc[$i],$resno[$i],$seq[$i],$alistring[$i]);
        }

        return($#acc,%data);
}



#______________________________________________________________________________
# Title     : open_FSSP_PAIR_TABLE_file
# Usage     : %FSSP_PAIR_hash=%{&open_FSSP_PAIR_TABLE_file(\$FSSP_PAIR_TAB_file)};
# Function  :
# Example   : The first column of FSSP_PAIR_TABLE is PDB ID and the second line
#              is representative seq ID.
#
#  PDBid Repre  Rmsd Lali  Lseq %ide   Compound
#  101m   1a6m   0.5  151   154   99   myoglobin Mutant
#  102l   1l92   0.2  162   163   99   Lysozyme insertion mutant with ala inserted after asn 4
#  102m   1a6m   0.5  151   154   99   myoglobin Mutant
#  103l   1l92   0.4  158   159   99   Phage t4 lysozyme insertion mutant with ser, leu, and a
#  103m   1a6m   0.4  151   154   99   myoglobin Mutant
#
#    %FSSP_PAIR_TABLE_hash is assigned this way>>
#    $FSSP_PAIR_TABLE_hash{$representative_member}->{$str1}=[$RMSD,
#                                                            $align_leng,
#                                                            $sequence_leng,
#                                                            $mutual_percent_sequence_identity,
#                                                            $protein_name_and_description];
#
# Keywords  : open_TABLE2_file
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.8
#------------------------------------------------------------------------------
sub open_FSSP_PAIR_TABLE_file{
    my(%FSSP_PAIR_TABLE_hash, $str1, $str2, $RMSD, $align_leng, $sequence_leng,
       $mutual_percent_sequence_identity, $protein_name_and_description,
       $representative_member);
    my $FSSP_PAIR_TABLE_file=${$_[0]} || $_[0];
    #print "\n open_FSSP_PAIR_TABLE_file : openning $FSSP_PAIR_TABLE_file file \n";
    open(FSSP_PAIR_TABLE, "<$FSSP_PAIR_TABLE_file") || die "\n open_FSSP_PAIR_TABLE_file: Can not open $FSSP_PAIR_TABLE_file \n\n";
    while(<FSSP_PAIR_TABLE>){
       if(/^(\S+)\s+(\S+)\s+([\d\.]+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(.+)/){
          $str1=$1;
          $str2=$representative_member=$2;
          $RMSD=$3;
          $align_leng=$4;
          $sequence_leng=$5;
          $mutual_percent_sequence_identity=$6;
          $protein_name_and_description=$7;
          $str1_str2_pair=join(' ', sort($str1, $str2));
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Making Hash of Hash (2D hash), hash of hash, 2 dimentional hash
          #___________________________________________________________________
          $FSSP_PAIR_TABLE_hash{$representative_member}->{$str1}=[$RMSD,
                                                                  $mutual_percent_sequence_identity,
                                                                  $align_leng,
                                                                  $sequence_leng,
                                                                  $protein_name_and_description];
       }
    }
    return(\%FSSP_PAIR_TABLE_hash);
}






#________________________________________________________________________
# Title     : read_subroutines
# Usage     : @out_subs=@{&read_subroutines(\@file, $separate_hash_entry_opt)}; or
#             %out_subs=%{&read_subroutines(\@file)};
# Function  : retunrns ALL subroutines with the keys as subroutine names
#             with version like ('show_array2.2' => 'subroutine in one string')
#             It reports the subroutines not found in searched file(s)
# Example   :
# Warning   :
# Keywords  : read_perl_subroutines, open_subroutines, open_perl_subroutines
#              parse_subroutines
# Options   : 'nv' for no version attachment in the keys of returning hash of subroutines
#             'r'  for getting remnant file content rather than the sub routines
#             't'  for leaving the original file without the sub routines taken.
#     $separate_hash_entry_opt=s by s
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub read_subroutines{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my($each_sub, %out_subs, %left_out, @lib, $ver, $real_sub_entry_found,
				%final_out_subs, %out_subs, $separate_hash_entry_opt, $long_subname,
				@final_separate_entry_out);
		 if($char_opt=~/s/){ $separate_hash_entry_opt = 's';
				print "\n# (INFO) \$separate_hash_entry_opt opt is set"
		 }

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 # Parsing input files of perl programs
		 #_____________________________________________
		 for($i=0; $i < @file; $i++){
				 print "\n# (INFO) Opening $file[$i] to read subroutines\n";
				 open(LIB_FILE, "<$file[$i]")|| die  "\n $file[$i]  <- $! \n";
				 @lib =<LIB_FILE>;

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
				 #  This for loop does not allow return until each sub is finished
				 #_____________________________________________________________________
				 for($j=0; $j < @lib; $j++){
						 my(%out_subs_separate);

						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						 # Reading the first delimiter line and 'Title' line altogether
						 #_______________________________________________________________
						 if( ($lib[$j]=~/^#+[_\-\*]{10,120}\s*$/)
									and $lib[$j+1]=~/^(#+\s*title\s*:\s*([\w\-\.]+))/i ){

									$long_subname=$1;
									$sub_name=$2;
									if($sub_name=~/\.pl$/){ next } ## to avoid the very first headbox

									if($separate_hash_entry_opt){
											 $out_subs_separate{'Title'}=$sub_name;
									}else{
											 $out_subs{"$sub_name"}.="$lib[$j]$long_subname\n";
									}
									$j+=2;

									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# Until I hit end of headbox or sub {} line
									#________________________________________________
									until( $lib[$j]=~/^#+[\-\*_]{10,160}\s*$/ or
												 $lib[$j]=~/^sub\s+\w[\w\.]+/ ){
												$lib[$j]=~s/(\s*)$//;  #<-- removing ending space
												#"""""""""""""""""""""""""""""""""""
												#  Taking version no.
												#___________________________________
												if( ($char_opt !~ /nv/i) && ($lib[$j]=~/^#\s*version\s*:\s*([\d+\.\d+]*)\s*/i) ){
													 if( $1=~/^[ ]*$/){ $ver = '1.0'; }     ##  make null to 1.0
													 elsif( $1=~/^(\d+)$/){ $ver = "$1\.0"; } ### make  2   to 2.0
													 elsif($1=~/^([\d+\.\d+]+)$/){ $ver = $1; } ##  assign version
												}
												if($separate_hash_entry_opt and $lib[$j]=~/^#\s*(\S\S\S+)\s*:\s*(.*)$/){
													 $sub_entry=$1;
													 $out_subs_separate{$sub_entry}=$2;
													 $j++;
												}elsif($separate_hash_entry_opt and $lib[$j]=~/^# \s+(.*)$/){
													 $out_subs_separate{$sub_entry}.="    $1\n";
													 $j++;
												}else{
													 $out_subs{"$sub_name"}.="$lib[$j]";
													 $j++;
												}
									 }
									 $out_subs{"$sub_name"}.="$lib[$j]";
									 $j++;    ## essential to remove #------------- line
							 }

							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
							 # Reading sub {   } part , the Content part
							 #__________________________________________
							 if($lib[$j]=~/^sub {1,9}([\w\-]+)\s*\{/){
									 print "\n# (INFO) Found sub $1\{  \tline ";
									 $sub_name=$1;
									 $out_subs{"$sub_name"}.="$lib[$j]";
									 $out_subs_separate{'Content'}.="$lib[$j]";
									 $j++;
									 until($lib[$j]=~/^\}/){
											 $out_subs{"$sub_name"}.="$lib[$j]";
											 $out_subs_separate{'Content'}.="$lib[$j]";
											 $j++;
											 print "\n# (INFO) reading in the content of sub" if $verbose;
									 }
									 $out_subs{"$sub_name"}.="$lib[$j]";  ## to fetch '}'
									 $out_subs_separate{'Content'}.="$lib[$j]";  ## to fetch '}'
									 $j++;
									 unless(defined($ver)){ $ver = '1.0' }
									 unless($char_opt=~/nv/i){ ## if No version attachment option is set
											 $final_out_subs{"$sub_name$ver"}=$out_subs{$sub_name};
											 $out_subs_separate{'Version'}=$ver;
									 }
									 print "\n# (INFO) Pushing the read lines for one sub to \@final_separate_entry_out";
									 push(@final_separate_entry_out, \%out_subs_separate);
							 }
					 }##------- for @lib loop

					 if($char_opt =~/[rt]/i){
							$left_out{$file[$i]}.=$lib[$j]; ## Remnant file content of the operation
					 }
	   close LIB_FILE;
	   if($char_opt =~/t/i){ ## t is for takeout(take the subroutine out of the original file!!
	       open (LIB_FILE, ">$file[$i]");
	       print LIB_FILE $left_out{$file[$i]};
	       close LIB_FILE;
	   }
					 print $final_out_subs;

	}#""""""""""""" end of for (@file)

	if($char_opt =~ /r/i){
	   return( \%left_out ); # to get the files sans the subroutines.
	}else{
	   if($separate_hash_entry_opt){
							if(@final_separate_entry_out==1){
	          return( $final_separate_entry_out[0]);
	      }else{
	          print "\n\n# (INFO) returning multiple subroutine read";
	          return(\@final_separate_entry_out);
	      }
	   }else{
	      return( \%final_out_subs );
	   }
	}
}


#______________________________________________________________________________
# Title     : fetch_rasmol_summary
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub fetch_rasmol_summary {
        local($fsspfile)=@_;
        undef(%summary);
        open(IN,$fsspfile) || die "FATAL: bad file name $fsspfile\n";
        while(<IN>) {
                if((/^COMPND/) || (/^HEADER/) || (/^SOURCE/) || (/^AUTHOR/)) {
                        $head .= join("\n",$_);
                }
                last if(/^\/\//);
                last if(/^## [AEMF]/);
                chop;
                if(substr($_,0,5) eq "  NR.") { $head .= join("\n",$_); }
                if(substr($_,4,1) eq ":") {
                        if($domain) {
#                               ($iali,$cd,$idom)=/^\s*(\d+)\: \S+\s+(\S+) .* S \s*(\d+) /;
                                ($iali,$cd,$idom)=/^\s*(\d+)\: \S+\s+(\S+) .* 0\s+0\s+\d+[\sS]+(\d+) /;
                                ($cd)=~s/[\s\-]+//;
                                $x="$cd\:$idom";
                        } else {
                                ($iali,$x)=/^\s*(\d+)\: \S+\s+(\S+)/;
                                $x=~s/[\s\-]+//;
                        }
                        $summary{$x}=$_;
                        $alino{$x}=$iali;
                }
        }
        close(IN);
}


#________________________________________________________________________
# Title     : fetch_subroutines
# Usage     :
# Function  : retunrns subroutines with the keys as subroutine names with version
#             like in the form( 'show_array2.2' => 'subroutine in one string')
#             It reports the subroutines not found in searched file(s). This
#             requires the names of sub you want while read_subroutines will
#             read any subroutines with their headbox to a hash.
# Example   :
# Warning   :
# Keywords  :
# Options   : 'nv' for no version attachment in the keys of returning hash of subroutines
#             'r'  for getting remnant file content rather than the sub routines
#             't'  for leaving the original file without the sub routines taken.
#             'h'  for headbox only output.
# Returns   :
# Argument  :
# Category  :
# Version   : 2.5
#--------------------------------------------------------------------
sub fetch_subroutines{
	 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	 if($debug==1){print "\n\t\@hash=\"@hash\"
	 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my($each_sub, %hash2, %out_subs, %left_out, @lib, $ver);

	 @array=@{&remove_dup_in_array(\@string)};

	 print "\n# $0: I am fetching @array from @file\n\n";

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # (1) Processing each file of sub lib file(yes, it can read many source lib
	 #__________________________________________________________________________
	 for($i=0; $i < @file; $i++){
				open(LIB_FILE, "<$file[$i]")|| die  "\n $file[$i]  <- $! \n";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (2) reading the whole lib. file into array
				#__________________________________________
	@lib =<LIB_FILE>;

	for($j=0; $j < @lib; $j++){
	     my $title_found;

	     for($s=0; $s < @array; $s++){ # array has subroutine names
	         $each_sub = $array[$s];

	         #"""" Taking the headbox """""""""""""
	         if( ($lib[$j]=~/^#+[_\-\*]{8,140}\s*$/)
		     and ($lib[$j+1]=~/^(#+\s*Title\s*\:\s*$each_sub\b).*/i) ){

		     $out_subs{"$each_sub"} .="$lib[$j]$1\n";
		     $j+=2;
		     $title_found=1;
		     until( ($lib[$j]=~/^#+[\-_\*]{8,150}\s*$/) or
		           ($lib[$j]=~/^ {0,2}sub\s*$each_sub\s*\{\s*[version]*\:?(\S*)/)  ){
														$version_number=$1;
			    $lib[$j]=~s/\s*$//;  #<-- removing ending space

			    #"""""""""""""""""""""""""""""""""""
			    #  Taking version no.
			    #"""""""""""""""""""""""""""""""""""
			    if( ($char_opt !~ /nv/i)
			        and ($lib[$j]=~/^#\s*Version\s*\:\s*([\d+\.\d+]*)\s*/i) ){
				  if( $1=~/^[ ]*$/){ $ver = '1.0'; }     ##  make null to 1.0
				  elsif($1=~/^(\d+)$/){ $ver = "$1\.0"; } ### make  2   to 2.0
				  elsif($1=~/^([\d+\.\d+]+)$/){ $ver = $1; } ##  assign version
			    }
			    unless($ver){
			        $ver=$version_number;
			    }
			    $out_subs{"$each_sub"}.="$lib[$j]";
			    $j++;
		     }
		     $out_subs{"$each_sub"}.="$lib[$j]";
		     $j++;    ## essential to remove #------------- line
		 }
		 if($char_opt =~ /h/i){ # 'h'  for headbox only output.
		      goto SPLICE2;
		 }
	         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	         # Reading sub {  }, when headbox is included, for JONG's lib
	         #____________________________________________________________
								 if( $title_found==1  and  $lib[$j]=~/^sub\s+$each_sub\b\s*\{/ ){
											$out_subs{"$each_sub"}.="$lib[$j]";
											$j++; $title_found='';
											until($lib[$j]=~/^\}/){
													 $out_subs{"$each_sub"}.="$lib[$j]";  $j++;
											}
											$out_subs{"$each_sub"}.="$lib[$j]";  ## to fetch '}'
											$j++;
											SPLICE2:
											splice(@array, $s, 1); ## removing the subnames found
											$s--;
											unless(defined($ver)){ $ver = '1.0' }
											unless($char_opt=~/nv/i){ ## if No version attachment option is set
													 $hash2{"$each_sub${ver}"}=$out_subs{$each_sub};
													 %out_subs=();
											}else{
													 $hash2{"$each_sub"}=$out_subs{$each_sub};
													 %out_subs=();
											}
		  }
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	          # Reading sub {  }, when headbox is NOT included
	          #_________________________________________________________
		  elsif($lib[$j]=~/^ {0,2}sub\s+$each_sub\b\s*\{\s*#*\s*(.*)/ ){
											print "\n# (WARN) $0: $file[$i] does not have headbox(jong\' lib style)\n";
											print "\n#    I will assume you do NOT have it in your sub lib. All subs will have 1.0 version no.\n";
											if($1=~/(\d+\.?\d*)/){
													 $version_number=$ver=$1;
											}
											$out_subs{"$each_sub"}.="$lib[$j]";
											$j++; $title_found='';
											until($lib[$j]=~/^\}/){
													 $out_subs{"$each_sub"}.="$lib[$j]";  $j++;
											}
											$out_subs{"$each_sub"}.="$lib[$j]";  ## to fetch '}'
											$j++;
											goto SPLICE2; # it is in a previous line
									}
	     }
	     if($char_opt =~/[rt]/i){
		     $left_out{$file[$i]}.=$lib[$j]; ## Remnant file content of the operation
	     }
	}
	close LIB_FILE;
	if($char_opt =~/t/i){
						 open (LIB_FILE, ">$file[$i]");
	     print LIB_FILE $left_out{$file[$i]};
	     close LIB_FILE;
	}

	 }#""""""""""""" end of for (@file)

	 $no_of_subs_fetched = keys %out_subs;
	 if(@array>0){
			 print chr(7), chr(7);
			 print "\n# Following subs are not found in \"", "@file","\"\n  ", "@array", "\n\n";
	 }

	 if($char_opt =~ /r/i){
			 return( \%left_out ); # to get the files sans the subroutines.
	 }else{
			 return( \%hash2 );
	 }
}

#______________________________________________________________________________
# Title     : update_line_number_variable
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub update_line_number_variable{
    my $t=shift;
    $line_number_info=int $t->index('current');
    return($line_number_info);
}

#______________________________________________________________________________
# Title     : update_SCOP_classification_in_MSP_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub update_SCOP_classification_in_MSP_files{
    my($PDBG_file, $MSP_file, %PDBG_hash);
    $PDBG_file=${$_[0]};
    $MSP_file=${$_[1]};
    %PDBG_hash=%{&open_pdbg_files(\$PDBG_file)};
    open(MSP_FILE, "<$MSP_file") || die "\n Can not open $MSP_file\n";
    while(<MSP_FILE>){
        my($intermediate_seq, $homol, $raw_score, @sorted_name, $sorted_name, $query, $match, $evalue, $ISL_classif);
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # (1) For handling FASTA search output(NORMAL MSP output style, I mean.  LYG_ANSAN_1-182_d153l___4.2.1_1-179    1
        #__________________________________________________________________________
        if( /^\s*(\S+\s+\S+\s+\S*\s*\d+\s+\d+\s+\S+\s+\d+\s+\d+\s+\S+_\d+\-\d+_(\S+)_)(\d+\.\d+\.\d+)(.+)/){ ## to match ISL search  nr_RIP3_SAPOF_1-220_d1mrj___4.102.1_42-198
            $match=$2;
            $superfam_number=$3;
            if($PDBG_hash{$match} != $superfam_number){
                print "$1$PDBG_hash{$match}$4\n";
            }else{
                print ;
            }
        }else{
            print;
        }
    }
    close(MSP_FILE);
}


#________________________________________________________________________
# Title     : update_subroutines
# Usage     : &update_subroutines(\@file, \%fetched_subs);
# Function  : replaces subroutines of given file(s) with supplied subs.
#             If the given subroutine versions are not higher than the
#             ones in the program, no upgrade would happen.
#             This can read version information from '# Version  : 1.0' line
#              or sub xxxxx{  # Version : 1.0   line
# Example   : &update_subroutines($file, \%fetched_subs);
# Warning   :
# Keywords  : upgrade_subroutines,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 2.8
#--------------------------------------------------------------------
sub update_subroutines{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# (1) %subs_from_lib is a default variable from &handle_arguments
	#______________________________________________________
	my %subs_from_lib=%{&merge_hash(@hash)};
	my @subs_from_lib = keys %subs_from_lib;            # @subs_from_lib are subroutine names

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
	# update_subroutines can handle many input perl files
	#__________________________________________________________________
	for($i=0; $i < @file; $i++){
				open(TARGET_FILE, "<$file[$i]") or die  "\n $file[$i]  <- $! \n";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				# (2) Reading in all the perl_file_lines into arrary
				#___________________________________________________
	my @perl_file_lines =<TARGET_FILE>;
	close TARGET_FILE;
				my (%temp, %temp_with_version_info, %final_out, %latest_sub_hash, $VER, $sub_name,$ver,
	    $first_line, @found_subs, $sub_name2);

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (3) checking each line in @perl_file_lines of target file with already provided %subs_from_lib of subroutines
				#____________________________________________________________________________________________________
				for($j=0; $j < @perl_file_lines; $j++){
	      my ($loop_count, $title_found, $sub_name,
									$title_found, $sub_found, $VER, $ver);
							if( $perl_file_lines[$j]=~/^(#\!\/\w+.+perl)/){ ## first line match
									$final_out{$file[$i]}.=$perl_file_lines[$j];
		  $j++;
		  print "\n# (INFO) Good! I found the very first line, $1 !!\n";
							}
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# (4) Putting update information  line-> # Last Update by ./update_subrout
							#______________________________________________________________________________
							if($perl_file_lines[$j]=~/^#\s*last\s*update\s*/i){
									$final_out{$file[$i]}.="# Last Update by $0: ".`date`;
									$j++;
							}elsif($perl_file_lines[$j+1]=~/^#\s*last\s*update\s*/i){
									$final_out{$file[$i]}.="$perl_file_lines[$j]# Last Update by $0: ".`date`;
									$j+=2;
							}elsif($j < 4 and (!$perl_file_lines[$j]=~/^#\s*last\s*update\s*/i) ){
									$final_out{$file[$i]}.="# Last Update by $0: ".`date`.$perl_file_lines[$j];
									$j++;
							}

	      if($perl_file_lines[$j]=~/^__END__/){ last } ## this is to stop $0 reading in junk sub calls after __END__ line

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
							# (5) this is to read non-subroutine related stuff
							#_______________________________________________________
							until( ($perl_file_lines[$j]=~/^#+[_\-\*\~]{8,160}\s*$/
									and $perl_file_lines[$j+1]=~/^(#+\s*Title\s*[:\;]*\s*\S+\b)[^\.]?\s*/i )   ## NO 'xxxx.pl'
									or ($perl_file_lines[$j]=~/^ {0,1}sub\s+[\w\-\.]+\s*\{/)                # until we hit  sub xxxx{  line
									or $j == $#perl_file_lines ){          ## when there is no headbox
										 $final_out{$file[$i]}.=$perl_file_lines[$j];  ## %final_out is the final output hash with perl_file_lines!!
										 $j++;                                         # %final_out stores only non-subroutine stuff until the end
							}
							print "\n# (INFO) \$final_out\{\$file\[\$i\]\} so far is: \n$final_out{$file[$i]}\n" if $verbose;

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
							# (6) NOW we found the headbox and let's go through all @subs_from_lib entry to match
							#     Going through all sub names. Now I am reading sub routine parts. @subs_from_lib has the names of subs to fetch
							#__________________________________________________________________________________________________________
							SUBS: for($s=0; $s < @subs_from_lib; $s++){
									if($subs_from_lib[$s] =~/^([_a-zA-Z\-\d]+)(\d+\.*\d*)\s*$/){
											 $sub_name=$1;
											 if($2){  $VER =$2; }else{ $VER='1.0' } ## <--- this line is redundant
		  }elsif($subs_from_lib[$s] =~/^(\S+)\s*$/){  #### This is critically necessary
		       $sub_name=$1;
		       print "\n# (WARN) $0: \$subs_from_lib\[\$s\] doesnt seem to have ver info. Is this O.K?\n";
											 $VER='1.0';
		  }

									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# (7) matching #______________ and # Title :,  IE, matching HEADBOX region
									#___________________________________________________________________________
									if( ($perl_file_lines[$j]=~/^#+[_\-\*\~]{8,160}\s*$/)
												&& ($perl_file_lines[$j+1]=~/^(#+\s*Title\s*[\:]*\s*$sub_name)[^\.]?\s*/i) ){

												$temp{"$sub_name"}.="$perl_file_lines[$j]$1\n";

												$j+=2;
												$title_found=1;
												until( $perl_file_lines[$j]=~/^#+[\-_\*]{10,180}\s*$/ ){
													 $perl_file_lines[$j]=~s/\s*$//;
													 if($perl_file_lines[$j] =~ /^#\s*Version\s*[\:\;]?\s*([\d*\.*\d*]*)\s*/i){
															 if( $1 =~/^\s*$/){ $ver = '1.0';  }     ##  make null to 1.0
															 elsif($1 =~/^(\d+)$/){ $ver = "$1\.0"; } ### make  1   to 1.0
															 elsif($1 =~/^(\d+\.\d+)$/){ $ver = $1; }
													 }
													 $temp{"$sub_name"}.="$perl_file_lines[$j]";
													 $j++;
												}
												$temp{"$sub_name"}.="$perl_file_lines[$j]";
												$j++;
		  }

									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# (8) matching sub xxxxx{
									#_____________________________________________
	          if($perl_file_lines[$j]=~/^sub\s+$sub_name\s*\{\s*(.*)/){
											 $possible_version_info=$1;
											 if($possible_version_info=~/(\d+\.?\d*)/){
													 $ver=$1;
											 }
		       $sub_found =1;
											 $temp{"$sub_name"}.="$perl_file_lines[$j]";

		       $j++;
		       until( $perl_file_lines[$j] =~/^\}/){
														$temp{"$sub_name"}.="$perl_file_lines[$j]";
														$j++;

														#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`````
														# following is out of paranoia
														#___________________________________________
														if( $perl_file_lines[$j] =~/^#[_\-\*]{8,150}\s*$/
																and $perl_file_lines[$j+1]=~/^(#\s*Title\s*[:]*\s*$sub_name)[^\.pl]/i ){
																$temp{"$sub_name"}.="\n\}\n"; $j++; # fixes missing '}' in the read sub hash.
																goto SPLICE;
														}elsif($perl_file_lines[$j+1]=~/^sub\s+[\w\-\.]+\s*\{/){
																$temp{"$sub_name"}.="\n\}\n";
																goto SPLICE;
														}
														$loop_count++;
														if($loop_count > 10000){
																$final_out{$file[$i]} .="\n\}\n";    # fixes missing '}' in the input file
																$temp{"$sub_name"}.="\n\}\n";   # fixes missing '}' in the read sub hash.
																goto SPLICE;
														}
		       }
		       if($perl_file_lines[$j]=~/^\}/){ $temp{"$sub_name"}.=$perl_file_lines[$j];  }

		       SPLICE:
											 push(@found_subs, splice(@subs_from_lib, $s, 1) );
		       $s--;
		       unless(defined($ver)){ $ver = '1.0' }
											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
											 # Changing  $temp{$sub_name}  to  $temp{"$sub_name$ver"}
											 #_________________________________________________________
											 if(!$temp_with_version_info{"$sub_name$ver"}){
													 $temp_with_version_info{"$sub_name$ver"}=$temp{$sub_name};
											 }
											 %temp=();
											 last;
		  }else{ # end of  if ($perl_file_lines[$j]=~/sub xxxxxx/)
											 next; # next to for(@subs_from_lib)
									}
							}## END of for(@subs_from_lib)

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# (9) putting %temp hash to %latest_sub_hash
							#____________________________________________________
							if( $title_found and $sub_found and  $VER < $ver ){
										print "\nTitle found, SUB found for $sub_name VER $sub_name${VER} \< ver $ver";
										unless($latest_sub_hash{ "$sub_name$ver" }){
												$latest_sub_hash{ "$sub_name$ver" }= $temp_with_version_info{ "$sub_name$ver" };
										}
										delete($subs_from_lib{"$sub_name$VER"} );
										$VER=$ver=$title_found=$sub_found='';
							}elsif( $title_found and $sub_found and  $VER >=$ver ){
										print "\nTitle found,  SUB found for $sub_name  VER \>= ver ";
										unless($latest_sub_hash{ "$sub_name$VER" }){
												$latest_sub_hash{ "$sub_name$VER" }= $subs_from_lib{"$sub_name$VER"};
										}
										delete($temp_with_version_info{"$sub_name$ver"});
										delete($subs_from_lib{"$sub_name$VER"});
										$VER=$ver=$title_found=$sub_found='';
							}elsif( !$title_found  and $sub_found ){
										print "\nTitle Not found, SUB found for $sub_name";
										unless($latest_sub_hash{ "$sub_name$VER" }){
												$latest_sub_hash{ "$sub_name$VER" }= $subs_from_lib{"$sub_name$VER"};
										}
										delete($subs_from_lib{"$sub_name$VER"});
										delete($temp_with_version_info{"$sub_name$ver"});
										$VER=$ver=$title_found=$sub_found='';

							}elsif( $title_found  and !$sub_found   ){
										print "\nTitle found, SUB not found for $sub_name";
										$VER=$ver=$title_found=$sub_found='';
										next;
							}elsif( !$title_found and !$sub_found  ){
										$final_out{$file[$i]}.=$perl_file_lines[$j];
							}
				} # for (@perl_file_lines)

				%merged_final_hash=%{&merge_hash(\%subs_from_lib, \%latest_sub_hash)};
				@values= values %merged_final_hash;

				open (LEFT_FILE, ">$file[$i]");
				for($h= 0; $h < @values; $h++){ ### appending the new subs.
						 $final_out{$file[$i]} .= $values[$h];
				}
				print LEFT_FILE $final_out{$file[$i]};
				close LEFT_FILE;
		}#""""""""""""" end of for (@file)
		return( \%final_out ); # this has all the sub routines and other lines.
}


#______________________________________________________________________________
# Title     : tan
# Usage     :
# Function  :
# Example   :
# Keywords  : get_tan get_tangent atan2
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub tan{
    sin($_[0]) / cos($_[1]);
}

#______________________________________________________________________________
# Title     : transport_3D_coordinates
# Usage     : %trans_points=%{&transport_3D_coordinates(\%points)};
# Function  :
# Example   :
#      $points{1}=[@p1];     @p1=(1, 1, 1);
#      $points{2}=[@p2];     @p2=(2, 3, 4);
#      $points{3}=[@p3];     @p3=(3, 4, 6);
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub transport_3D_coordinates{
    my(%points, $new_dot1_Y, $original_axis_value, @dots_of_XYZ, @each_point);
    %points=%{$_[0]};
    @dot=sort keys %points;
    #print "\n@dot\n\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # moving the first dot to (0,0,0) and adjusting other dots according to the move
    #_______________________________________________________________________________
    for($i=0; $i< @dot; $i ++){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # @each_point has things like '3, 2, 8',
       #_____________________________________________
       @each_point=@{$points{$dot[$i]}};
       for($j=0; $j< @each_point; $j++){
          $original_axis_value=$points{$dot[0]}[$j];
          $points{$dot[$#dot-$i]}[$j]=$points{$dot[$#dot-$i]}[$j]- $original_axis_value;
       }
    }
    print "\n@{$points{$dot[0]}} \n";
    print "@{$points{$dot[1]}} \n";
    print "@{$points{$dot[2]}} \n\n";
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Rotate around X axis.
    #_______________________________________________________________________________
    #
    #            | Z
    #            |
    #            .~~~~~~~~~~~.
    #          .~|         .~|
    #        .~  |        .~ | (0, 1, 2)
    #       |------------#   |
    #       |    |      /|   |
    #       |    |     / |   |
    #       |    |    /  |   |
    #       |    |   /   |   |   TAN    a = Y/Z
    #       |    |a /    |   |   ATAN(Y/Z)= a
    #       |    |^/     |   |
    #       |   .|/______|___|______________
    #     X |  /      Y  |  /
    #       |/           |/
    #      / ~~~~~~~~~~~`       atan2 (0,1)=> 0, atan2(1,0)=> 1.57
    #    /                      3.1415926= 180
    #                           1.570    = 90, sin(1.57) = 1.0
    #
    $a_angle= atan2($points{1}[2], $points{1}[1]);
    print "\$a_angle $a_angle <= ATAN( $points{1}[1] / $points{1}[2]) ";
    $SIN_a=sin($a_angle);
    $COS_a=cos($a_angle);

    $new_dot1_X=$points{1}[0];
    $new_dot1_Y=$points{1}[1] * (-$SIN_a) + $points{1}[2] * ($COS_a); # <----- this should be 0
    $new_dot1_Z=$points{1}[1] * ($SIN_a)  + $points{1}[2] * ($COS_a);
    if(abs($new_dot1_Y) < 0.000001){ $new_dot1_Y=0 }
    $new_dot2_X=$points{2}[0];
    $new_dot2_Y=$points{2}[1] * (-$SIN_a) + $points{2}[2] * ($COS_a); # <----- this should be 0
    $new_dot2_Z=$points{2}[1] * ($SIN_a)  + $points{2}[2] * ($COS_a);
    if(abs($new_dot2_Y) < 0.000001){ $new_dot2_Y=0 }
    print "\n $SIN_a $COS_a\n";
    print "$new_dot1_X, $new_dot1_Y, $new_dot1_Z\n";
    print "$new_dot2_X, $new_dot2_Y, $new_dot2_Z\n";

    $points{1}[1]=$new_dot1_Y;
    $points{1}[2]=$new_dot1_Z;
    $points{2}[1]=$new_dot2_Y;
    $points{2}[2]=$new_dot2_Z;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Rotate around Y axis.
    #_______________________________________________________________________________
    #
    #                   |
    #                   | Z
    #                  .|
    #                .~ |
    #              .~   |
    #   (1,0,2)  *~     |
    #            \      |          # the Angle 'a' is about 300 degree !!! (for correct direction)
    #            |\     |
    #            | \    |
    #            |  \   |
    #            |   \  |
    #            |    \ |
    #            |    (\|)_________
    #            |     /.    Y
    #            |   /  a
    #            | /          atan2 (0,1)=> 0, atan2(1,0)=> 1.57
    #            /  X         3.1415926= 180
    #          /              1.570    = 90, sin(1.57) = 1.0
    #
    $a_angle= atan2($points{1}[2], $points{1}[0]);
    print "\$a_angle $a_angle <= ATAN( $points{1}[0] / $points{1}[2]) ";
    $SIN_a=sin($a_angle);
    $COS_a=cos($a_angle);

    $new_dot1_Y=$points{1}[1];
    $new_dot1_X=$points{1}[0] * (-$SIN_a) + $points{1}[2] * ($COS_a); # <----- this should be 0
    $new_dot1_Z=$points{1}[2] * ( $SIN_a) + $points{1}[2] * ($COS_a);
    print "\n $new_dot1_X $points{1}[0]  $SIN_a  $points{1}[2] $COS_a ======\n";
    if(abs($new_dot1_X) < 1.11022302e-15){ $new_dot1_X=0 }
    $new_dot2_Y=$points{2}[1];
    $new_dot2_X=$points{2}[0] * (-$SIN_a) + $points{2}[2] * ($COS_a); # <----- this should be 0
    $new_dot2_Z=$points{2}[2] * ($SIN_a) + $points{2}[2] * ($COS_a);
    if(abs($new_dot2_X) < 1.11022302e-15){ $new_dot2_X=0 }

    print "\n SIN $SIN_a COS $COS_a\n\n";
    print "$new_dot1_X, $new_dot1_Y, $new_dot1_Z\n";
    print "$new_dot2_X, $new_dot2_Y, $new_dot2_Z\n";

}


#________________________________________________________________________
# Title     : takeout_subroutines
# Usage     :
# Function  : retunrns subroutines with the keys as subroutine names with version
#             like in the form( 'show_array2.2' => 'subroutine in one string')
#             It reports the subroutines not found in searched file(s)
#             fetch_subroutines  also has this feature.
# Example   :
# Warning   : If there is no headbox and version no. It thinks the version
#             is 1.0
# Keywords  : take_out_subroutines, take_subroutines, cut_subroutines,
#             cutout_subroutines, remove_subroutines
# Options   : 'nv' for no version attachment in the keys of returning hash of subroutines
#             'r'  for getting remnant file content rather than the sub routines
# Returns   :
# Argument  :
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------
sub takeout_subroutines{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($each_sub, %duplicate, %out_subs, %left_out, @lib, $ver, $real_sub_entry_found);
	@array = @ori_array = grep { ! $duplicate{$_}++ } @raw_string;  ## removing duplicates

	for($i=0; $i < @file; $i++){
		@array=@ori_array;
		open(LIB_FILE, "$file[$i]") or die  "\n $file[$i]  <- $! \n";
		@lib =<LIB_FILE>;
		for($j=0; $j < @lib; $j++){
			  for($s=0; $s < @array; $s++){
				  $each_sub = $array[$s];
				  #"""" Taking the headbox """""""""""""
				  if( ($lib[$j]=~/^#[_\-\*\~]{20,140}\s*$/)&&
				      ($lib[$j+1]=~/^(#\s*title\s*:\s*$each_sub)[^\.pl]/i) ){
					  $real_sub_entry_found=0;
					  $out_subs{"$each_sub"}.="$lib[$j]$1\n";
					  $j+=2;
					  until( ($lib[$j]=~/^sub\s*\w+\s*\{/)||
					         ($lib[$j]=~/^#[\-_\*\~]{20,140}\s*$/) ){
							 $lib[$j]=~s/(\s*)$//;  #<-- removing ending space
							 #"""""""""""""""""""""""""""""""""""
							 #  Taking version no.
							 #"""""""""""""""""""""""""""""""""""
							 if( ($char_opt !~ /nv/i) && ($lib[$j]=~/^#\s*version\s*:\s*([\d+\.\d+]*)\s*/i) ){
								  if( $1=~/^[ ]*$/){ $ver = '1.0'; }     ##  make null to 1.0
								  elsif( $1=~/^(\d+)$/){ $ver = "$1\.0"; } ### make  2   to 2.0
								  elsif($1=~/^([\d+\.\d+]+)$/){ $ver = $1; } ##  assign version
							 }
							 $out_subs{"$each_sub"}.="$lib[$j]";
							 $j++;
					  }
					  $out_subs{"$each_sub"}.="$lib[$j]";
					  $j++;  ##<< essential to remove #------------- line
				  }

				  #"""""""" Reading sub {  } """""""
				  if($lib[$j]=~/^sub\s+$each_sub\s*\{/){
					  $out_subs{"$each_sub"}.="$lib[$j]";
					  $j++;
					  until($lib[$j]=~/^\}/){
						  $out_subs{"$each_sub"}.="$lib[$j]";  $j++;
					  }
					  $out_subs{"$each_sub"}.="$lib[$j]";  ## to fetch '}'

					  $j++;

					  splice(@array, $s, 1); ## removing the subnames found
					  $s--;
					  unless(defined($ver)){ $ver = '1.0' }
					  unless($char_opt=~/nv/i){ ## if No version attachment option is set
						  $out_subs{"$each_sub$ver"}=$out_subs{$each_sub};
						  delete $out_subs{$each_sub};
					  }
				  }
			  }
			  $left_out{$file[$i]}.=$lib[$j]; ## Remnant file content of the operation
			                                  ## just in case you want the left out ones.
		}
		close LIB_FILE;
		open (LEFT_FILE, ">$file[$i]");
		print LEFT_FILE $left_out{$file[$i]};
		close LEFT_FILE;
	}#""""""""""""" end of for (@file)

	@no_of_subs_fetched = keys %out_subs;
	if(@array>0){
		print chr(7);
		print "\n# Following subs are not found in \"", "@file","\"\n  ", "@array", "\n\n";
	}
	if($char_opt =~ /r/i){
	   return( \%left_out ); # to get the files without the subroutines.
	}else{
	   return( \%out_subs );
	}
}

#________________________________________________________________________
# Title     : get_subroutine_calls
# Usage     : @sub_name_array= @{&get_subroutine_calls(\@AR))};
# Function  : gets all the subroutine calls( like &show_hash ) in the given
#             file name or array of lines which is the content of a file,
#             text etc. If there is no input arg, it reads the running
#             program as default input
# Example   :
# Keywords  : get_sub_names,get_subroutine_names, get_sub_calls,
#             get_subroutine_calls, find_sub_calls, find_subroutine_calls
# Options   :
# Category  :
# Version   : 2.2
#--------------------------------------------------------------------
sub get_subroutine_calls{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(@keywords)=qw(getc shift system warn undef abs cmp close fork caller
				   eval time chdir connect disconnect wait main);
	my($keywords)=join(' ', @keywords);
	my(@arr, @sub_names, @nondup, %duplicate, @sub_calls);
	if(@_== 0){  open(FILE, "$0"); @arr = <FILE>;  } # open self
	elsif( @file > 0){
					 for($i=0; $i < @file; $i++){
									open(FILE, "$file[$i]");
									push(@arr, <FILE>);
					 }
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	# When subroutine names are specified as input
	#_______________________________________________
	if(@array>0){
	   for($i=0; $i<@array; $i++){
		 push(@arr, @{$array[$i]} ) if ref($array[$i]) eq 'ARRAY';
	   }
	}
	if( @raw_string>0){ push(@arr, @raw_string) }

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# Main pattern matching part for  &xxxxxx ;  line
	#__________________________________________________
	for($i=0; $i< @arr; $i ++){
						if($arr[$i]=~/^#+/){ next }
						$arr[$i]=~s/^(.+)(# ..+)$/$1/;  # I have to remove all COMMENTS as comments can have &xxx

						if($arr[$i]=~/\$\~ =\s*\S/){
										next;
						}elsif($arr[$i]=~/^format\s*=/){
										until($arr[$i]=~/^\./){  $i++ }
						}elsif(@sub_calls=$arr[$i]=~/\&([\w\.\-]+)/g ){  # for  $X = &round(&some(&some2(\$ssssss))); sort of thing
										push(@sub_names, @sub_calls);
						}elsif($arr[$i]=~/\&[^\&]+\w+\:\:(\w[\w\-\.\:]+) {0,3}.*[\;\,]/){ ## to handle &main::ssssub::sussb
										push(@sub_names, $1);
						}elsif($arr[$i]=~/\&(\w[\w\-\.\:]+) {0,3}.*[\;\,]/){
										push(@sub_names, $1);
						}elsif($arr[$i]=~/=\s*([a-zA-Z][\w\-]+) {0,3}\;/){
										push(@sub_names, $1) unless($keywords=~/\b$1\b/);
						}elsif($arr[$i]=~/=\s*[\@\%\$]\s*\{\s*([a-zA-Z_\-]+[\d]*).+\}\s*\;/){ # for =${ xxxx }; or =${&xxxxx};
										push(@sub_names, $1);
						}
	}
	@nondup = grep { ! $duplicate{$_}++ } @sub_names;  ## removing duplicates
	for($i=0; $i< @keywords; $i++){
						for($j=0; $j < @nondup; $j ++){
										if($keywords[$i] eq $nondup[$j]){
													 splice(@nondup, $j, 1); $j--;
										}
						}
	}
	return(\@nondup);
}



#________________________________________________________________________
# Title     : set_special_options   (derived from set_debug_option)
# Usage     : &set_special_options;
# Function  : If you put special chars like '#' or  '##', '###..' at the
#             prompt of any program which uses
#             this sub you will get verbose printouts for the program if
#             the program has a lot of comments.
# Example   : &set_special_options.pl  ##    <-- at prompt.
# Warning   :
# Keywords  :
# Options   : #   for 1st level of debugging printouts
#             ##  for even more debugging printouts
#             +   for more outputs(more calculations are shown, like statistics)
#             ++  even more outputs.(
#    $DEBUG    becomes 1 by '#'
#    $DEBUG2   becomes 1 by '##'
#    $VERBOSE  becomes 1 by '+'
#    $VERBOSE2 becomes 1 by '++'
#
# Returns   :  $debug, $verbose
# Argument  : Nothing in a program.
# Category  :
# Version   : 1.0
#             generalized debug var is added for more verbose printouts.
#--------------------------------------------------------------------
sub set_special_options{
	my($j, $i, $level, $key, %special_chars);
	%special_chars=('DEBUG'=>'#', 'VERBOSE'=>'+');

	for $key (keys %special_chars){
	 for($j=0; $j < @ARGV; $j ++){
		 if( $ARGV[$j] =~/([$special_chars{$key}]+)/){
			 print __LINE__," >>>>>>> Debug option is set by $1 <<<<<<<<<\n";
			 ${"$key"}=1; print chr(7);
			 print __LINE__," \$$key  is set to ", ${"$key"}, "\n";
			 splice(@ARGV,$j,1); $j-- ;
			 $level = length($1)+1;
			 for($i=0; $i < $level; $i++){
				 ${"$key$i"}=1;
				 print __LINE__," \$${key}${i} is set to ", ${"$key$i"}, "\n";
			 }
		 }
	 }
	}
}

#________________________________________________________________________
# Title     : set_debug
# Usage     : &set_debug;
# Function  : If you put '#' or  '##' at the prompt of any program which uses
#             this sub you will get verbose printouts for the program if the program
#             has a lot of comments.
# Example   : set_debug #    <-- at prompt.
# Warning   :
# Keywords  :
# Options   : #   for 1st level of verbose printouts
#             ##  for even more verbose printouts
# $debug  becomes 1 by '#'  or '_'
# $debug2 becomes 1 by '##'  or '__'
#
# Returns   :  $debug
# Argument  :
# Category  :
# Version   : 1.8
#             generalized debug var is added for more verbose printouts.
#--------------------------------------------------------------------
sub set_debug{
	my($j, $i, $level);
	unless( defined($debug) ){
	 for($j=0; $j < @ARGV; $j ++){
		 if( $ARGV[$j] =~/^(_+)$|^(#+)$/){ # in bash, '#' is a special var, so use '_'
			 print __LINE__," >>>>>>> Debug option is set by $1 <<<<<<<<<\n";
			 $debug=1;
				  print chr(7);
			 print __LINE__," \$debug  is set to ", $debug, "\n";
			 splice(@ARGV,$j,1); $j-- ;
			 $level = length($1)+1;
			 for($i=0; $i < $level; $i++){
				 ${"debug$i"}=1;
				 print __LINE__," \$debug${i} is set to ", ${"debug$i"}, "\n";
			 }
		 }
	 }
	}
}

#________________________________________________________________________
# Title     : open_self
# Usage     : @lines =  &open_self;
# Function  :
# Example   :
# Warning   :
# Keywords  : read self, read_self, open self, open itself
# Options   :
# Returns   : one array
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_self{
	open(SELF, "$0");
	my(@Line)=<SELF>;
	return( \@Line );
}



#________________________________________________________________________
# Title     : tell_seq_length
# Usage     : %hash_out = %{&tell_seq_length(\%hash_in)};
# Function  : tells the sequence sizes of given sequences
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub tell_seq_length{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(@out_hash, %hash);
	for($i=0; $i < @hash; $i++){
	 %hash = %{$hash[$i]};
	 @keys = keys %hash;
	 for ($j=0; $j < @keys; $j ++){
		if($hash{$keys[$j]}=~/\,\S+\,/){ @string= split(/\,/, $hash{$keys[$j]});
		}else{ @string= split(//, $hash{$keys[$j]}); }
		$h -> {$keys[$j]} = @string;  ## $h is the ref. of the anonymous hash
	 }                               ## This is equivalent to "$h{$keys[$j]}= $length;"
	 push(@out_hash , $h ) ;
	}
	if(@out_hash == 1){ $out_hash[0]; }
	elsif(@out_hash < 1){ die "\nSomething is wrong at tell_seq_length\n"; }
	elsif(@out_hash > 1){ return(@out_hash); }
}

#________________________________________________________________________
# Title     : do_window_scan
# Usage     : @out_array = @{&do_window_scan(\@input_array, $win_size)};
#             Often, bioters(Bio Computer Scientists) need to scan a long sequences
#             of DNA or Protein like(ABADFAFASDFASFASDFDFA or 109384717817947) to
#             caculate something out of them.
#             This routine is providing such scanning
#             function.
# Function  : This is the core part of any window (of sequences)
#             scanning function.
# Example   :
# Warning   :
# Keywords  : scan_sequence, scan_window
# Options   :
# Returns   :
# Argument  :
# Author    : jong@biosophy.org
# Version   : 1.5
#--------------------------------------------------------------------
sub do_window_scan{
    my(@string1, $win_size, $w, $start, $end, $average1, @window_1, $w_abs, @out_string);
    @string1  = @{$_[0]};
    $win_size = ${$_[1]} || $_[1];

    $start = -($win_size - ($win_size%2))/2; ## If the window size is odd numbers (eg 5),
                                     ## the starting average position is 0  from (-2,-1,0,1,2)
                                     ## If it is even numbers (eg 4)
                                     ## the starting position is 0 from (-2,-1,0,1)
    $end = @string1 - ($win_size - ($win_size%2))/2;
                                 ## End point is also dependent on oddity of the numbers
                                 ## for window size.
    for ($w= $start; $w < $end ; $w ++){
       $moving_window = $w + $win_size - 1;
       @window_1= @string1[$w .. $moving_window ];
       if($w < 0){          #### This if is to prevent the circularization of the array
           $w_abs = abs($w); #### (like  6 7 1 2 3 4 5 , for  . . 1 2 3 4 5 from 1234567 )
           splice(@window_1, 0, $w_abs);  # $w_abs is the absolute value of $w
       }

       ################ PUT YOUR calculation HERE #####

        $average1= ${average_of_array(\@window_1, 'int')};

       ################ PUT YOUR calculation HERE #####

       push(@out_string, $average1);
       print "\nWinSize:$win_size halfwin: $half_win_size str size: $string_size \(from offset: $offset to  mov_wind: $moving_window \) AV: $average1 of  win1:", @window_1, "\n";
    }
    return(\@out_string);
}

#________________________________________________________________________
# Title     : scan_window_and_calc_something
# Usage     :
# Function  : scans any given length window of sequence and computes something.
# Example   :
# Warning   :
# Keywords  :
# Options   : average for getting average of given window size.
#             sum for getting sum of given window size.
# Returns   :
# Argument  :
# Category  :
# Author    : jong@biosophy.org
# Version   : 1.0
#--------------------------------------------------------------------
sub scan_window_and_calc_something{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    my $win_size = $num_opt[0];
    print "\n $win_size\n";
    for($o = 0; $o < @char_opt; $o ++){
      if($char_opt[$o] eq ""){
          splice(@char_opt, $o, 1); $o --;
      }
      elsif($char_opt[$o] eq "a"){
          if(@hash ==1){
              print "\n Now I am doing  scan_window_and_calc_average with \n\t\t
                            @hash, and $win_size ";
              %out_hash_final = %{scan_window_and_calc_average(@hash, \$win_size)};

          }elsif(@hash > 1){
              @out_hash_final = @{scan_window_and_calc_average(@hash, \$win_size)};
          }
      }
      elsif($char_opt[$o] eq "s"){
          if(@hash ==1){
              %out_hash_final = %{scan_window_and_calc_sum(\@hash, \$win_size)};
          }elsif(@hash > 1){
              @out_hash_final = @{scan_window_and_calc_sum(\@hash, \$win_size)};
          }
      }
    }

    #_______________________________________________
    # Options  : 1, 2
    #######################################################
    sub scan_window_and_calc_sum{
        my(@hash)=@{$_[0]};
        my($win_size)  =${$_[1]};
        my(%out_hash, $i, $j, $w, $string1, @string, @window_1, $moving_window,
            $sum, $out_string, @keys, %input, $half_win, $actual_win_size);

        for($i = 0; $i < @hash; $i++){
            %input = %{$hash[$i]};
            @keys = sort keys %input;
            for ($j=0; $j < @keys; $j ++){
                $string1 = $input{$keys[$j]};
                @string1 = split(//, $string1);

                ##### This small for loop is important for AVERAGE calc. To return the original residue value
                ##### as there is no point in calculating segment smaller than window size.
                if ($return_type_option eq ''){
                    &main_calc_from_half_win_size_pos;
                }elsif($return_type_option == 1){
                    &return_the_av_for_small_win_size;
                    &main_calc_from_half_win_size_pos;
                }

                #############################################
                sub return_the_resicue_value{
                    $half_win = int($win_size/2);
                    for($pre = 0; $pre < $half_win; $pre ++){
                        $out_string .= "$string1[$pre]\,";

                        print "\nWindow size $win_size \(from 0 to  $pre \)  of  ", @window_1, "\n";
                    }
                }

                ###################################################################
                #### The actual Window scanning and summing part.           ####
                ###################################################################
                sub main_calc_from_half_win_size_pos{
                  for ($w=0; $w < @string1; $w++){

                     my($offset) = $w - int($win_size/2);  # $offset starts from -5 when window_size is 10.
                     my($half_win_size)= int($win_size/2);
                     $offset = 0 if ($offset < 0);

                     $moving_window = $w + $half_win_size - 1;

                     $actual_win_size = $moving_window - $offset + 1;

                     @window_1= @string1[$offset..($moving_window)]; ### This is the segment.

                     $sum= ${sum_of_array(\@window_1, 'int')};
                     $out_string .="$sum\,";
                     print "\nWindow size $actual_win_size \(from $offset to  $moving_window \) $sum of  ", @window_1, "\n";

                  }
                  $out_hash{$keys[$j]} = $out_string;
                  $out_string='';
                }
                #############################################
            }
            push(@out_hash, \%out_hash);
        }
        if(@out_hash ==1){ \%out_hash; }elsif(@out_hash >1){ \@out_hash; }
    }
    ############### Sub end ########################################
    if(@hash ==1){ \%out_hash_final; }elsif(@hash >1){ \@out_hash_final; }

}

#________________________________________________________________________
# Title     : scan_window_and_calc_average
# Usage     : %out_hash_final = %{scan_window_and_calc_average(\@hash, \$win_size)};
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub scan_window_and_calc_average{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (%input, @string1, $string1, $start, $end, $moving_window, $average1, $out_string);
    my ($win_size)            =$num_opt[0];

    for($i = 0; $i < @hash; $i++){
      %input = %{$hash[$i]};
      @keys = sort keys %input;
      for ($j=0; $j < @keys; $j ++){
          $string1 = $input{$keys[$j]};
          @string1 = split(//, $string1);
          &do_window_scan_for_average;

          sub do_window_scan_for_average{
             ##### Following $start and $end are critically important for correct calc.
             $start = -($win_size - ($win_size%2))/2; ## If the window size is odd numbers (eg 5),
                                                                    ## the starting average position is 0  from (-2,-1,0,1,2)
                                                                    ## If it is even numbers (eg 4)
                                                                    ## the starting position is 0 from (-2,-1,0,1)
             $end = @string1 - ($win_size - ($win_size%2))/2;
                                                                    ## End point is also dependent on oddity of the numbers
                                                                    ## for window size.
             #################################################################
             for ($w= $start; $w < $end ; $w ++){
                $moving_window = $w + $win_size - 1;
                @window_1= @string1[$w .. $moving_window ];
                if($w < 0){          #### This if is to prevent the circularization of the array
                    $w_abs = abs($w); #### (like  6 7 1 2 3 4 5 , for  . . 1 2 3 4 5 from 1234567 )
                    splice(@window_1, 0, $w_abs);  # $w_abs is the absolute value of $w
                }
                $average1= ${average_of_array(\@window_1, 'int')};
                $out_string .="$average1\,";
                print "WinSize:$win_size halfwin: $half_win_size str size: $string_size \(from offset: $offset to  mov_wind: $moving_window \) AV: $average1 of  win1:", @window_1, "\n";
             }
             $out_hash{$keys[$j]} = $out_string;
             $out_string='';
             print "\n";
          }
          #############################################
      }
      push(@out_hash, \%out_hash);
    }
    if(@out_hash ==1){ \%out_hash; }elsif(@out_hash >1){ \@out_hash; }
}

#________________________________________________________________________________
# Title     : read_matrix
# Usage     : %matrix=%{&read_matrix(\$string)};
# Function  : Makes similarrity matrix hash(reflexive, so it has AT as well as TA)
#             %matrix looks like this:  $matrix{X}{Y}= 4
# Example   :
# Keywords  : get_2D_aa_matrix, read_seq_matrix
# Options   :
#     $reflexive_combi=r by r -r    # both direction  AC=-1, CA=-1
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub read_matrix{
		my ($reflexive_combi, %matrix, %out_matrix, @matrix_lines,
		    @residue, $residue_num, $first_residue, $second_residue,
		    @matrix_val, $paired_residues, @sorted, $i, $j, $k, $l);
		$reflexive_combi='r'; ## both direction  AC=-1, CA=-1

		@matrix_lines=split(/\n/, ${$_[0]});
		if(@matrix_lines < 1){ print "\n Error, \@matrix_lines is empty in  read_matrix sub\n"; die }

		for($j=0; $j < @matrix_lines; $j++){

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # Skipping all non-matrix contents
			 #_________________________________________________________
			 if($matrix_lines[$j]=~/^\s*# .+\S\S\S/ or $matrix_lines[$j]=~/^\s*#\s*\W/){ next }

					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # matching top line:  '   A  R  N  D  C  Q  E  G  H  I ..' line
					 #___________________________________________________
					 if(@residue=$matrix_lines[$j]=~/ ([\*\w])/g){
							 $residue_num=@residue;
							 if($residue_num < 20){ next }
							 #print "\n@residue $residue_num\n,,,,,,,\n";
							 $j++;

							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # matching ' A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -'
							 #          ' R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -'
							 #___________________________________________________
							 for($k=0; $k<@residue; $k++){
									$first_residue=$residue[$k];
									#print "$first_residue\n";
									#print $matrix_lines[$j] if $verbose;
									if(@matrix_val=$matrix_lines[$j]=~/\s*([\-\d]+)/g){
											#print "\n-> @matrix_val\n";
											for($l=0; $l< @matrix_val; $l++){
												 $second_residue=$residue[$l];
												 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
												 #  Taking only non-reflexive ones
												 #________________________________________________
												 if($reflexive_combi){
														 $paired_residues=join('', $first_residue, $second_residue);
												 }else{
														 @sorted = sort($first_residue, $second_residue);
														 $paired_residues=join('', @sorted);
												 }
												 $matrix{$paired_residues}=$matrix_val[$l]  unless $matrix{$paired_residues};
												 #print "\n$paired_residues $matrix{$paired_residues}";
												 $out_matrix{$first_residue}{$second_residue}=$matrix_val[$l];
												 #print "\n$out_matrix{$first_residue}{$second_residue}";
											}
											$j++;
									}
							 }
					 }

				}
		if($string_pair_hash_out==1){  ## out looks : $matrix_lines{'XY'}    =4
				return(\%matrix);
		}else{                         ## out looks : $matrix_lines{'X'}{'Y'}=4
				print "\n read_matrix returns a matrix form of \$matrix\{A\}\{C\} \n";
				return(\%out_matrix);
		}
}





#________________________________________________________________________
# Title     : read_blast_hits
# Usage     : @array_of_names = @{&read_blast_hits(\$file_name, \$threshold)};
# Function  : This reads the output of blastp program(xxxx.bla or whatever file extension
#             you attatched). And produces the names of found sequences which are
#             above(smaller in probability) a certain threshold in the blast result.
#             For example, it will produce a reference of an array (@hits, in the code)
#             which contains (1mbs, 1pmb, 1ymb) from the example in this header box(down the
#             lines) with the given (you give!) threshold of, say, 0.0001.
# Example   :
#      - - - - -  EXample of blastp file  - - - - - - - - - - - - - - - - - - - - - - - - -
#      BLASTP 1.4.8 [19-Dec-94] [Build 16:06:14 Jul 26 1995]
#      Reference:  Altschul, Stephen F., Warren Gish, Webb Miller, Eugene W. Myers,
#      and David J. Lipman (1990).  Basic local alignment search tool.  J. Mol. Biol.
#      215:403-10.
#      Query=  1mbs
#      (153 letters)
#      Database:  /nfs/ind4/ccpe1/people/A Biomatic /jpo/align/all_in_fasta.fastas
#      406 sequences; 77,134 total letters.
#      Searching..................................................done
#      WARNING:  -hspmax 100 was exceeded with 13 of the database sequences, with as
#      many as 173 HSPs being found at one time.
#      Smallest
#      Sum
#      High  Probability
#      Sequences producing High-scoring Segment Pairs:              Score  P(N)      N
#      1mbs                                                          804  2.0e-109  1
#      1pmb                                                          718  1.4e-97   1
#      1ymb                                                          707  4.7e-96   1
#      2xxx                                                           31  0.55      1
# Warning   :
# Keywords  : bla2fasta, take_blast_hits
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub read_blast_hits{
	my ($threshold);
	my(@hits);
	my($file)= ${$_[0]};
	$threshold = ${$_[1]} ;

	open(BLA_FILE, "$file");
	while(<BLA_FILE>){
	  if(/^\s*(\w+)\s+\d+\s+(\d+[\.]*[\d]+[\w\-\d]*)\s+\d+/){
		 $probability = $2;
		 if($probability <= $threshold){
			push(@hits, $1);
		 }elsif( $probability > 0.6 ){ ### In Blast, p value over 0.3 or 0.4 is too high.
			last;                       ### So, to reduce the file reading time.
		 }
	 }
	}
	return(\@hits);  ## I am returning a ref. of the array rather than array.
}          ## In fact, just @array is fine enough, but for future addition of arg.

#________________________________________________________________________
# Title     : put_gaps_every_x_position_in_string.pl  (operator function)
# Usage     :
# Function  :
# Example   : "1234567890123456789012345678901234567890"  will be
#             "1234567890 1234567890 1234567890 1234567890"
#             with
#                &put_gaps_every_x_position_in_string(\$test, 10, ' ')
# Warning   : it does not returns reference
# Keywords  : put_space_in_sequence, put_gaps_in_sequence, put_gaps,
#             put_space, insert_gaps_in_sequence, insert_char_in_sequence
#             insert_gaps_in_string, insert_char_in_string
# Options   :
# Returns   :
#             every char.
# Argument  : 3 arg. One is the string, second is the interval number, third is
#             the gap separater
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub put_gaps_every_x_position_in_string{
    my($string, $interval, $gap_char);
    $string=${$_[0]} || $_[0];
    $interval = ${$_[1]} || $_[1];
    $gap_char = ${$_[2]} || $_[2];
    $string =~s/(.{$interval,$interval})/$1$gap_char/g;
    return($string);  ### Not a reference ###
}

#______________________________________________________________________________
# Title     : insert_new_lines_in_string
# Usage     : $new_string=${&insert_new_lines_in_string($string, 20)};
# Function  : At every X position, it puts the char you want (here '\n')
# Example   :
# Keywords  : put_new_lines_in_string, break_string_by_new_line
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub insert_new_lines_in_string{
		my($string, $interval, $gap_char);
		$interval=10;
		$gap_char="\n";
		$string=${$_[0]} || $_[0];
		$string =~s/(.{$interval,$interval})/$1$gap_char/g;
		return(\$string);  ### Not a reference ###
}




#________________________________________________________________________
# Title     : transform_values
# Usage     : Used in predict_secondary_structure
# Function  : transform any value to another value with given table, matrix..
#             This is used to transform Amino Acid to its various propensities
#             If you feed a sequence 'ACDEDA', this transforms it to '
#             '124741' if the table given is 'A->1, C->2, D->4, E->7'
# Example   :
#             IN =>  to transform E and H to 9 and 4
#
#             1cdg_6taa      -------EEE-----------HH--HHHH------EE---------EEE-
#             1cdg_2aaa      -------EEE-----------HH--HHHH------EE---------EEE-
#             2aaa_6taa      -------EEEEE------EE-HHHHHHHH----EEEE-------EEEEE-
#
#             OUT
#             1cdg_6taa      -------999-----------44--4444------99---------999-
#             1cdg_2aaa      -------999-----------44--4444------99---------999-
#             2aaa_6taa      -------99999------99-44444444----9999-------99999-
#
# Warning   :
# Keywords  :
# Options   :
# Returns   : hash(es)
#             Sheraga_alpha_matrix
#             Richardson_alpha_matrix  or any conversion table made in a hash.
#
# Argument  : hash(es) and Matrix or table for conversion.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub transform_values{
	my($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r,
	  $s, $t, $u, $v, $w, $x, $y, $z, $pwd, $file, $dir, $output, $in_dir,
	  %hash, @keys, @array, @hash, $option_string, $string, @in,
	  $name, %out, $gap_chr, @str1, @str2, @hash_output, $given_matrix
	);

	##########################################
	#####   general argument handling   ######
	##########################################
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^(\w)$/) ){
		  $option_string  .= $1;
	  }elsif( ( !ref($_[$k]) )&&($_[$k]=~ /^(\d*\w+matrix)/) ){
		  $given_matrix  = $1;
	  }elsif( ( !ref($_[$k]) )&&($_[$k]=~ /^(\d*\w+table)/) ){
		  $given_table  =  $1;
	  }elsif((ref($_[$k]) eq "ARRAY")&&(${$_[$k]}=~ /^(\w)$/) ){
		  $option_string  .= $1;
	  }elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(\w)$/) ){
		  $option_string  .= $1;
	  }elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(\d*\w+matrix)$/) ){
		  $given_matrix  = $1;
	  }elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(\d*\w+table)$/) ){
		  $given_table  =  $1;
	  }elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(\w+)$/) ){
		  $dummy{'dummy'}=${$_[$k]};       ## When mere sequence string is given, it
		  push(@hash,  \%dummy);     # makes a dummy hash to mimick hash input
	  }elsif(ref($_[$k]) eq "HASH") { push(@hash,  $_[$k]); }
	}

	if( defined( $given_matrix ) ){   ## calling given matrix.
	  &{"$given_matrix"};
	}elsif( defined( &{"$given_table"} ) ){  ## calling given table.
	  &{"$given_table"};
	}

	for( $k=0; $k < @hash; $k ++){
	  my(%hash) = %{$hash[$k]};
	  my(@keys) = keys %hash;
	  my(@out_string);
	  for($i=0; $i < @keys; $i++){
		  @string = split(/|\,/, $hash{$keys[$i]} ); ## splitting the string(value of
																	## the hash into array.
		  for($j=0; $j < @string; $j ++){
			  $out_string[$j]= ${"$given_matrix"}{ $string[$j] };
		  }
		  $out_hash{$keys[$i]} = join(',', @out_string);
	  }
	  push(@hash_output, \%out_hash);
	}
	if(@hash_output > 1){ @hash_output }else{ $hash_output[0] }
}

#________________________________________________________________________
# Title     : Sheraga_alpha_matrix
# Usage     :
# Function  : an alpha matrix propensity table.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub Sheraga_alpha_matrix{
	%Sheraga_alpha_matrix = ( ## ref: Protein Eng. V.8, no9, pp905-913, 1995
		  'A', 	1.07,
		  'C', 	0.99,
		  'D', 	0.68,
		  'E', 	0.97,
		  'F', 	1.09,
		  'G', 	0.59,
		  'H', 	0.69,
		  'I', 	1.14,
		  'K', 	0.94,
		  'L', 	1.14,
		  'M', 	1.20,
		  'N', 	0.78,
		  'P',    0.19,
		  'Q', 	0.98,
		  'R', 	1.03,
		  'S', 	0.76,
		  'T', 	0.82,
		  'V', 	0.95,
		  'W', 	1.11,
		  'Y',    1.02
	);
	return(%Sheraga_alpha_matrix);
}
#________________________________________________________________________
# Title     : Richardson_alpha_matrix
# Usage     :
# Function  : an alpha matrix propensity table.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub Richardson_alpha_matrix{
	%Richardson_alpha_matrix = ( ## ref: Protein Eng. V.8, no9, pp905-913, 1995
		  'A', 	1.80,
		  'C', 	0.70,
		  'D', 	1.00,
		  'E', 	0.80,
		  'F', 	1.30,
		  'G', 	0.,     ## <<----
		  'H', 	0.69,
		  'I', 	1.14,
		  'K', 	0.94,
		  'L', 	1.14,
		  'M', 	1.20,
		  'N', 	0.78,
		  'P',    0.19,
		  'Q', 	0.98,
		  'R', 	1.03,
		  'S', 	0.76,
		  'T', 	0.82,
		  'V', 	0.95,
		  'W', 	1.11,
		  'Y',    1.02
	);
	return(%Richardson_alpha_matrix);
}


#________________________________________________________________________
# Title     : get_segment_shift_rate
# Usage     : &get_segment_shift_rate(\%hash_for_errors, \%hash_for_sec_str);
# Function  : calculates the secture segment shift rate.
# Example   : <input example> First block is for the first hash input
#                             and Second is for the second hash input.
#
#             1cdg_6taa      00000442222222222242222222222777700000007000000000
#             1cdg_2aaa      00000442222222222242222222222777700000007000000000
#             2aaa_6taa      00000000000000000000000000000000000000000000000000
#
#             1cdg_6taa      -------EEE-----------EE--EEEE------EE---------EEE-
#             1cdg_2aaa      -------EEE-----------EE--EEEE------EE---------EEE-
#             2aaa_6taa      -------EEEEE------EE-EEEEEEEE----EEEE-------EEEEE-
#
#             <intermediate output example>
#             2aaa_6taa      -------00000---------00000000----0000-------00000-
#             1cdg_6taa      -------442---------------2222-----------------000-
#             1cdg_2aaa      -------222---------------2222-----------------000-
#
#             <Final output>
#             2aaa_6taa      0%
#             1cdg_6taa      67%
#             1cdg_2aaa      67%
#
# Warning   :
# Keywords  :
# Options   : 'p' or 'P' for percentage term(default)
#             'r' or 'R' for ratio term (0.0 - 1.0), where 1 means all the
#              segments were wrongly aligned.
#             's' or 'S' for Shift rate (it actually caculates the position shift
#              rate for the secture segment.
#             'h' or 'H' for position Shift rate (it actually caculates the position
#              shift rate for helical segments). If this is the only option, it
#              will show the default percentage term rate for helical segments.
#              If used with 'r', it will give you ratio (0.0 - 1.0) for helical
#              segment. If used with 's' option, it will give you position shift
#              rate for only helical segments.
#             'e' or 'E' for position Shift rate (it actually caculates the position
#              shift rate for beta segments). If this is the only option, it will
#              show the default percentage term rate for beta segments. If used
#              with 'r', it will give you ratio (0.0 - 1.0) for beta. If used
#              with 's' option, it will give you position shift rate for only
#              beta segments.
# Returns   :
# Argument  : Two references of hashes. One for error rate the other for sec.
#             assignment.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_segment_shift_rate{
	my($i, $k, $j, @hash, $option_string, %h, %superposed_hash,
	  $name, %out, $gap_chr, @str1, @str2, %temp, %hash_error, %hash_secondary);
	#"""""""""""""""""""""""""""""""""""""""""
	#       general argument handling        #
	#"""""""""""""""""""""""""""""""""""""""""
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^(\w)$/) ){
		  $option_string  .= $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(\w)$/) ){
		  $option_string  .= $1;    }
	  elsif(ref($_[$k]) eq "HASH") {
		  %temp = %{$_[$k]};
		  my(@keys)= sort keys (%temp);
		  my($temp_seq) = $temp{$keys[0]};

		  if($temp_seq=~/\d\d+/){
			  %hash_error = %temp; }
		  else{ %hash_secondary = %temp; }
	  }
	}#### OUTPUT are  : %hash_error  &  %hash_secondary
	#"""""""""""""""""""""""""""""""""""""""""
	#       general argument handling end    #
	#"""""""""""""""""""""""""""""""""""""""""
	%hash_secondary =%{&tidy_secondary_structure_segments(\%hash_secondary)};
	%superposed_hash =%{&superpose_seq_hash(\%hash_error, \%hash_secondary)};
	%h=%{&get_wrong_segment_rate(\%superposed_hash)};
	return(\%h);
}

#________________________________________________________________________
# Title     : get_wrong_segment_rate
# Usage     : print_seq_in_block( &get_wrong_segment_rate(\%superposed_hash) );
# Function  : Treats the segment as one single big error.
#             calculates the wrong segment number compared to the correct ones.
# Example   : <input example> hash of 3 keys and values.
#             2aaa_6taa      -------00000---------00000000----0000-------00000-
#             1cdg_6taa      -------442---------------2222-----------------000-
#             1cdg_2aaa      -------222---------------2222-----------------000-
#
#             In the above there are two segments wrong in 3 segment blocks = 2/3
#             <output example> hash of 3 percentage rates.
#
#             2aaa_6taa      0 %
#             1cdg_6taa      66.6666666666667 %
#             1cdg_2aaa      66.6666666666667 %
#
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_wrong_segment_rate{
	my($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r,
	  $s, $t, $u, $v, $w, $x, $y, $z, %h, $seg_min,
	  %hash, @keys, @array, @hash, $option_string, $string,
	  $name, %out, $gap_chr, @str1, @str2, $seg, $len, $wrong_seg, $correct_seg
	);
	%hash=%{$_[0]};
	$seg_min =$_[1];
	if($seg_min !~/\d+/){ $seg_min = 3; } ### Default segmin is 3
	@keys = sort keys (%hash);
	for $k (@keys){
	 my($string) = $hash{$k}; $string =~s/\,//g;
	 my(@segments) = split(/[\-\.\ ]+/, $string);
	 for $seg (@segments){
		$len=length($seg);
		if( $len >= $seg_min){
			if($seg =~/[1-9]/){
				$wrong_seg ++;  }
			else{ $correct_seg ++; }
		}
	 }
	 $h{$k}= ($wrong_seg/($wrong_seg + $correct_seg)*100).' %';
	 $wrong_seg=$correct_seg='';
	}
	\%h;
}


#________________________________________________________________________
# Title     : tidy_secondary_structure_segments
# Usage     : print_seq_in_block(&tidy_secondary_structure_segments(\%hash, 'e4', 'h4'), 's');
#
# Function  : receives any secture assignment hashes and
#             tidys up them. That is removes very shoft secture
#             regions like( --HH--, -E-, -EE- ) according to the given minimum
#             lengths(threshold) of segments by you.
# Example   : print_seq_in_block(&tidy_secondary_structure_segments(\%hash, 'e4', 'h4'), 's');
#             <makes following into the next block>
#
#             1cdg_2aaa      -------EEE-----------EE--EEEE------EE---------EEE-
#             1cdg_6taa      -------EEE-----------EE--EEEE------EE---------EEE-
#             2aaa_6taa      -------EEEEE------EE-EEEEEEEE----EEEE-------EEEEE-
#
#             <example output>
#
#             1cdg_6taa      -------------------------EEEE---------------------
#             1cdg_2aaa      -------------------------EEEE---------------------
#             2aaa_6taa      -------EEEEE---------EEEEEEEE----EEEE-------EEEEE-
#
# Warning   :
# Keywords  :
# Options   : something like 'H3' or 'E3' for minimum segment length set to 3 positions.
# Returns   : array of references of hashes.
# Argument  : hashes and [options]. No options result in default of 'H3', 'E3'
# Category  :
# Version   : 1.0.0
#--------------------------------------------------------------------
sub tidy_secondary_structure_segments{
	my($i, $k,$a, $j, $helix_min, $beta_strand_min, %hash, @keys, @hash,
	  $option_string, @hash_out, $string1, $name, %out, $gap_chr, @str1, @str2,
	  @stringout, @string_segH, @string_segE, $countH, $countE
	  );

	#### Default helix and beta strand segment length setting #####
	$helix_min=3;
	$beta_strand_min=3;

	########################################################################
	#####   general argument handling  for options of segment length  ######
	########################################################################
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^[Hh](\d+)$/) ){
		  $helix_min  = $1;    }
	  elsif( ( !ref($_[$k]) )&&($_[$k]=~ /^[Ee](\d+)$/) ){
		  $beta_strand_min  = $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^[Hh](\d+)$/) ){
		  $helix_min  = $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^[EeBb](\d+)$/) ){
		  $beta_strand_min  = $1;    }
	  elsif(ref($_[$k]) eq "HASH") { push(@hash,  $_[$k]); }    }

	for($i=0; $i < @hash; $i++){
	  my(%hash) = %{$hash[$i]};
	  @keys = sort keys( %hash );
	  for($j=0; $j < @keys; $j++){
		  my(@string_segH, @string_segE, @stringout);
		  $string1=$hash{$keys[$j]};
		  $gap_char = $1 if ($string1=~ /(\W)/);

		  ##### actual cleaning ####
		  my(@string) = split(//, $string1);
		  for($a = 0; $a < @string; $a++){
			 if($string[$a] !~/[HE]/){ ### if the splited element doesn't match 'H' or 'E'

				 ##### If any of the HH or EE counter is over the given minimum($helix_min,,)
				 if((@string_segH >= $helix_min)||( @string_segE >=$beta_strand_min)){
					 push(@stringout, @string_segH, @string_segE, '-');
					 @string_segH=@string_segE=();     }   ## just resetting.
				 else{  ### if the accumulated 'HH' or 'EE' is smaller than the minimum
					 for(0.. (@string_segH + @string_segE) ){
						push(@stringout, '-'); ### replace the short 'EE' etc with '-'
					 }
					 @string_segH=@string_segE=();  ## just resetting.
				 }
			 }
			 elsif($string[$a] =~ /^([Hh])$/){
				 push(@string_segH, $1); }
			 elsif($string[$a] =~ /^([Ee])$/){
				 push(@string_segE, $1); }
		  }
		  $hash{$keys[$j]}=join("", @stringout);
	  }
	  push(@hash_out, \%hash);
	}
	if(@hash_out == 1){ return($hash_out[0]);
	}elsif(  @hash_out > 1 ){ return(@hash_out); }
}


#______________________________________________________________________________
# Title     : make_protein_domain_definition_file
# Usage     :
# Function  :
# Example   :
# Keywords  : make_pddf_file make_PDDF_file write_PDDF_file write_pddf_file
#             make_dalie_domain_definition_file
# Options   :
# Author    : holm@ebi.ac.uk jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.6
#------------------------------------------------------------------------------
sub make_protein_domain_definition_file{
    my(%DOM_table_hash, %FSSP_PAIR_TABLE_hash, %DOM_SEL_hash, @domains,
       %FSSP_alignment_1to1_residue_map, $i, $j, $n, $s, @representative_structures,
       $DOMSEL_file, $DOM_table_file, %HOMOL_Motif_node_with_range_info,
       $Dom_motif_ID, @Rep_dom_motif_nodes, $DDD_domain_seg_leng, @HOMOL_DDD_ranges );
    %FSSP_PAIR_TABLE_hash             =%{${$_[0]}[0]};
    %DOM_SEL_hash                     =%{${$_[0]}[1]};
    %FSSP_alignment_1to1_residue_map  =%{${$_[0]}[2]};
    %DOM_table_hash                   =%{${$_[0]}[3]};
    %HOMOL_Motif_node_with_range_info =%{${$_[0]}[4]};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    #    $FSSP_PAIR_TABLE_hash{$represen}->{$str1}=[$RMSD,
    #                                               $align_leng,
    #                                               $sequence_leng,
    #                                               $mutual_percent_sequence_identity,
    #                                               $protein_name_and_description];
    #___________________________________________________________________________________
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # DOM_SEL: Assigned this way>>  $DOMSEL_hash{$structure}=[@domains];
    #   1abc (1,2,3,4), 2xyz (1,8,10,11,12,19) <-- numbers are node numbers
    #___________________________________________________________________
    #unless(@DOM_SEL_structures > 1){ %DOM_SEL_hash=%{&open_DOMSEL_file(\$DOMSEL_file)}; }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # $FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_posi}=$HOMOL_position;
    #____________________________________________________________________________________________________________________
    #unless(%DOM_table_hash > 1){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # $DOM_table_hash{$DALI_str_ID}{$DALI_node_ID}=[$DC_number,
       #                                               $str_length,
       #                                               $SSC_sec_str_composition,
       #                                               $description ];
       #_____________________________________________________________________________
    #   $DOM_table_file='DOMTABLE1.ddtf';
    #   %DOM_table_hash=%{&open_DALI_domain_table_file(\$DOM_table_file)};
    #}
    #print "\n Runnning make_protein_domain_definition_file\n";
    #&show_FSSP_hash(\%FSSP_alignment_1to1_residue_map);

    @representative_structures=sort keys %FSSP_PAIR_TABLE_hash;
    @DOM_SEL_structures=sort keys %DOM_SEL_hash;
    $PDDF_name="protein_domain_definition_file.pddf";
    open(PDDF, ">$PDDF_name") || die "\nmake_protein_domain_definition_file: Can not create $PDDF_name\n\n";

    for($i=0; $i< @representative_structures; $i++){
       $rep_PDB_name =$representative_structures[$i];
       $sequence_leng=$FSSP_PAIR_TABLE_hash{$rep_PDB_name}{$rep_PDB_name}[2];
       $descrip=$FSSP_PAIR_TABLE_hash{$rep_PDB_name}{$rep_PDB_name}[4];
       $FSSP_file_name="$FSSPDIR\/$rep_PDB_name\.fssp";
       if(%FSSP_alignment_1to1_residue_map < 2){
           $get_ranges_info='r';
           %FSSP_alignment_1to1_residue_map=%{&open_FSSP_file(\$FSSP_file_name, $get_ranges_info)};
       }

       $No_homol=@FSSP_homologs=sort keys %{$FSSP_PAIR_TABLE_hash{$rep_PDB_name}};
       $No_homol--;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
       # (*) Writing entry REP line with homologues
       #_______________________________________________________________________________
       printf PDDF ("\n%-5s %s\n", ">>r$i", "$rep_PDB_name Len=$sequence_leng h=$No_homol (@FSSP_homologs)\n      Desc : $descrip");
       if(@{$DOM_SEL_hash{$representative_structures[$i]}}){

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Writin DOMSEL nodes info
          #_____________________________________________________________________
          print PDDF " \@domains(@{$DOM_SEL_hash{$rep_PDB_name}}) <- Domsel Nodes info.\n";
          if(length($rep_PDB_name) == 4){
              $FDAT_file="$FDATDIR\/$rep_PDB_name\_\.dat";
          }else{        $FDAT_file="$FDATDIR\/$rep_PDB_name\.dat";       }
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # $Dali_subdomains{$structure_ID}{$subdomain_number}=[$subdomain1,
          #                                                     $subdomain2,
          #                                                     $residue_leng,
          #                                                     $numb_of_segments,
          #                                                     $ranges
          #                                                     ]
          #__________________________________________________________________________________________
          %FDAT_hash=%{&open_FDAT_file(\$FDAT_file)};
          @domains=sort {$a<=>$b} keys %{$FDAT_hash{$rep_PDB_name}};
          for($s=0; $s < @domains; $s++){
              my($SEC_str, $DC_number);
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Adding DOMTABLE1 info. DC number and SEC. STR. composition
              #________________________________________________________________________
              $DC_number=$DOM_table_hash{$rep_PDB_name}{$domains[$s]}[0];
              $SEC_str  =$DOM_table_hash{$rep_PDB_name}{$domains[$s]}[2];
              print PDDF "        REP($domains[$s]): DC=$DC_number SSC: $SEC_str\n" if $DC_number and $SEC_str;
              if($domains[$s] =~/SEQUENCE/i){
                  printf PDDF " $rep_PDB_name:SEQ $FDAT_hash{$rep_PDB_name}{$domains[$s]}\n";
              }elsif(ref($FDAT_hash{$rep_PDB_name}{$domains[$s]}) eq 'ARRAY'){
                 ($subdomain1, $subdomain2, $residue_leng, $numb_of_segments,$ranges)
                                    =@{$FDAT_hash{$rep_PDB_name}{$domains[$s]}};
                  printf PDDF (" $rep_PDB_name:FDAT %-3s %3s %-3s %-5s %-2s %s\n", $domains[$s],
                         $subdomain1, $subdomain2, $residue_leng, $numb_of_segments, $ranges);
			$residue_leng[$s]=$residue_leng; # needed later
              }
          }

       }

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # (*) Writing about homolog info using  %HOMOL_Motif_node_with_range_info
       #____________________________________________________________________________
       HOMO: for($j=0; $j<@FSSP_homologs; $j++){
           my(@HOMOL_ranges, $homol_PDB_name, $RMSD, $seq_identity, $align_leng,
              @Rep_dom_motif_nodes, $sequence_leng, $descrip);
           $homol_PDB_name=$FSSP_homologs[$j];

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Let's skip the REP seq entry
           #______________________________________________________________
           if($homol_PDB_name eq $rep_PDB_name){ next }

           ($RMSD, $seq_identity, $align_leng, $sequence_leng, $descrip)=
               @{$FSSP_PAIR_TABLE_hash{$representative_structures[$i]}{$FSSP_homologs[$j]}};
           printf PDDF (" %-6s %-6s RMSD=%-4s %3s% Ali=%-5s Len=%-5s %s\n",
                        ">h$j", $FSSP_homologs[$j], $RMSD, $seq_identity, $align_leng, $sequence_leng, $descrip);

#>> no homologs in FDATDIR (reps only); homologs in DALIDATDIR
#? historical - can be deleted...

           if(length($homol_PDB_name) == 4){
               $FDAT_file="$FDATDIR\/$homol_PDB_name\_\.dat";
           }else{
               $FDAT_file="$FDATDIR\/$homol_PDB_name\.dat";
           }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # $Dali_subdomains{$structure_ID}{$subdomain_number}=[$subdomain1,
           #                                                     $subdomain2,
           #                                                    $residue_leng,
           #                                                    $numb_of_segments,
           #                                                    $ranges
           #                                                     ]
           #__________________________________________________________________________________________
           #%FDAT_hash=%{&open_FDAT_file(\$FDAT_file)};
           #@domains=sort {$a <=> $b} keys %{$FDAT_hash{$homol_PDB_name}};
           #for($s=0; $s < @domains; $s++){
           #   my($SEC_str, $DC_number);
           #   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           #   # Adding DOMTABLE1 info. DC number and SEC. STR. composition
           #   #________________________________________________________________________
           #   $DC_number=$DOM_table_hash{$homol_PDB_name}{$domains[$s]}[0];
           #   $SEC_str  =$DOM_table_hash{$homol_PDB_name}{$domains[$s]}[2];
           #   print PDDF "           Hom($domains[$s]): DC=$DC_number SSC: $SEC_str\n" if $DC_number and $SEC_str;
           #    if($domains[$s] =~/SEQUENCE/i){
           #        printf PDDF  "   $homol_PDB_name:SEQ $FDAT_hash{$homol_PDB_name}{$domains[$s]}\n";
           #    }elsif(ref($FDAT_hash{$rep_PDB_name}{$domains[$s]}) eq 'ARRAY'){
           #       ($subdomain1, $subdomain2, $residue_leng, $numb_of_segments,$ranges)
           #                          =@{$FDAT_hash{$rep_PDB_name}{$domains[$s]}};
           #        printf PDDF ("   $homol_PDB_name:FDAT %-3s %3s %-3s %-5s %-2s %s\n", $domains[$s],
           ###               $subdomain1, $subdomain2, $residue_leng, $numb_of_segments, $ranges);
	       ##	   $domain_span_size_rep[$domains[$s]]=$residue_leng; # store for aligned-ratio
           #   }
           #   $REP_residue_leng{$rep_PDB_name}{$domains[$s]}=$residue_leng;
           #
           #}
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # writing FSSP alignment information
           #________________________________________
           @REP_ranges= keys %{$FSSP_alignment_1to1_residue_map{$rep_PDB_name}{$homol_PDB_name}};
           if(!@REP_ranges){
               $homol_FSSP_file_name="$FSSPDIR\/$homol_PDB_name\.fssp";
               print "\n\$homol_FSSP_file_name $homol_FSSP_file_name";
               unless(-s $homol_FSSP_file_name){ print "\n No $homol_FSSP_file_name found"; next }
               $get_ranges_info='r';
               %FSSP_alignment_1to1_residue_map=%{&open_FSSP_file(\$homol_FSSP_file_name, $get_ranges_info)};
               @HOMOL_ranges=sort {$a<=>$b} keys %{$FSSP_alignment_1to1_residue_map{$homol_PDB_name}{$rep_PDB_name}};
               @HOMOL_ranges=@{&sort_sequence_ranges(\@HOMOL_ranges)};
               for($p=0; $p<@HOMOL_ranges; $p++){
                   push(@REP_ranges, $FSSP_alignment_1to1_residue_map{$homol_PDB_name}{$rep_PDB_name}{$HOMOL_ranges[$p]});
               }
               print PDDF "   R-ranges: @HOMOL_ranges";
               print PDDF "   H-ranges: @HOMOL_ranges\n\n";
               print "\n Openned \$homol_FSSP_file_name $homol_FSSP_file_name \n"; sleep 1;

           }else{
               @REP_ranges=@{&sort_sequence_ranges(\@REP_ranges)};
               for($p=0; $p<@REP_ranges; $p++){
                   push(@HOMOL_ranges, $FSSP_alignment_1to1_residue_map{$rep_PDB_name}{$homol_PDB_name}{$REP_ranges[$p]});
               }
               print PDDF "   R-ranges: @REP_ranges\n";
               print PDDF "   H-ranges: @HOMOL_ranges\n";
           }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # writing %HOMOL_Motif_node_with_range_info ($rep_PDB_name, $homol_PDB_name, @Rep_dom_motif_nodes)
           #   $HOMOL_Motif_node_with_range_info{$PDB_str_name}{$FSSP_homolog_name}{$Dom_motif_ID}=\@HOMOL_DDD_ranges;
           #___________________________________________________________________________________________________________
           @Rep_dom_motif_nodes=sort {$a<=>$b} keys %{$HOMOL_Motif_node_with_range_info{$rep_PDB_name}{$homol_PDB_name}};

           for($n=0; $n< @Rep_dom_motif_nodes; $n++){
               my(@HOMOL_DDD_ranges, @HOMOL_ranges_matched_in_number, @REP_dom_node_ranges);
               $Dom_motif_ID=$Rep_dom_motif_nodes[$n];

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	           # HOMOL_DDD_ranges is a list of ranges
	           #___________________________________________________
               @HOMOL_DDD_ranges=@{$HOMOL_Motif_node_with_range_info{$rep_PDB_name}{$homol_PDB_name}{$Dom_motif_ID}};
               #pop(@HOMOL_DDD_ranges) if !$HOMOL_DDD_ranges[$#HOMOL_DDD_ranges];
               #$domain_span_size = $HOMOL_DDD_ranges[$#HOMOL_DDD_ranges] - $HOMOL_DDD_ranges[0] + 1;
               $domain_span_size=0;
               $domain_span_ranges='';
               $ii=0;
               while($ii<$#HOMOL_DDD_ranges) {
                       $from=$HOMOL_DDD_ranges[$ii];
                       $ii++;
                       $to=$HOMOL_DDD_ranges[$ii];
                       $ii++;
                       $domain_span_size+=$to-$from+1;
                       $domain_span_ranges.="$from\-$to ";
                       # want block-borders only!!
               }

              if(@HOMOL_DDD_ranges < 2){
                   print PDDF "   h$j\_dd$Dom_motif_ID: $homol_PDB_name ($Dom_motif_ID) = ABSENT\n";
                   next;
               }
               $DDD_domain_seg_leng=${&get_DDD_domain_length_from_segment_ranges(\@HOMOL_DDD_ranges)};
               print PDDF "   h$j\_dd$Dom_motif_ID: $homol_PDB_name($Dom_motif_ID) = \"@HOMOL_DDD_ranges\"\n";

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # If @HOMOL_DDD_ranges is larger than the @REP_ranges, let's make a representation which
               #  tells the same number of segments for neat FASTA sequence entry in DALI domain fata file
               #_________________________________________________________________________________________________
               @REP_dom_node_ranges=split(/\s+/, $FDAT_hash{$rep_PDB_name}{$Dom_motif_ID}[4]);
               if(@HOMOL_DDD_ranges > @REP_dom_node_ranges){
                   @HOMOL_ranges_matched_in_number=@{&match_number_of_seq_ranges(\@HOMOL_DDD_ranges,
                                                                                 \@REP_dom_node_ranges)};
                   print PDDF "     Seg_matched: $homol_PDB_name($Dom_motif_ID) = \"@HOMOL_ranges_matched_in_number\"\n";
               }else{
                   print PDDF "     Seg_matched: $homol_PDB_name($Dom_motif_ID) = \"@HOMOL_DDD_ranges\"\n";
               }

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
		       #>> maybe, divide by domain_span_size of representative?!
		       #>> accept insertions less than 40 aa??
               #________________________________________________________________________________________
               $domain_span_size_rep=$residue_leng[$Dom_motif_ID]; ## residue_leng is from REP JONG
               $Align_Fraction_Hom=($DDD_domain_seg_leng/($domain_span_size));
               $Align_Fraction_Rep=($DDD_domain_seg_leng/$domain_span_size_rep);
               $dom_leng_threshold=0.7;
               if($Align_Fraction_Hom > $dom_leng_threshold
	        	  && $Align_Fraction_Rep > $dom_leng_threshold
	       	      ){
	       	        $homol_dom_quality="ACCEPTED at $dom_leng_threshold";
               }else{
                    $homol_dom_quality="REJECTED at $dom_leng_threshold";
               }

               print PDDF "     Domain_size: $DDD_domain_seg_leng\n";
               #print PDDF "     Domain_span: $HOMOL_DDD_ranges[0]\-$HOMOL_DDD_ranges[$#HOMOL_DDD_ranges] (size= $domain_span_size)\n";
               #print PDDF "     Align_Fract: $Align_Fraction_Hom ($DDD_domain_seg_leng\/$domain_span_size)\n";
               print PDDF "     Domain_span: $domain_span_ranges (size= $domain_span_size)\n";
               print PDDF "     Align_Fract: $Align_Fraction_Hom ($DDD_domain_seg_leng\/$domain_span_size \| $domain_span_size_rep)\n";
               print PDDF "     Quality    : $homol_dom_quality\n";
           }

       }

    }
}


#______________________________________________________________________________
# Title     : define_domain_boundaries_for_DALI_homologues
# Usage     :
# Function  : This reads DCCP file in ../DCCP directory according to the
#             pair data from FSSP_PAIR_TABLE_file.tpfp file in ../FSSP directory.
#             It looks at the alignment of each pair (containing one representative
#             str. which has been updated in previous STEP1-STEP8). It adjusts
#             the homologues' boundaries and write them down.
#             2. In fact this looks at the FSSP_PAIR_TABLE DOMSEL file and FDATDIR
# Example   :
#    OUT: $DDD_entries_with_seg_info{$REP_DDD_name}{$HOMOL_DDD_name}{$REP_DDD_range_digit}=$HOMOL_DDD_range_digit;
# Keywords  :
# Options   :
#    $get_ranges_info=r by r
# Author    : holm@ebi.ac.uk jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.5
#------------------------------------------------------------------------------
sub define_domain_boundaries_for_DALI_homologues{
    my(@representative_structures, $DOMSEL_file, $i, $r, $m, $h, @structures,
       %DOM_SEL_hash, $FDATDIR, @DOM_SEL_structures, @DOMAIN_MOTIF_id_numbers,
       $FSSPDIR, $each_Domain_Motif_ranges, %FSSP_PAIR_TABLE_hash, @FSSP_homologues,
       %FSSP_alignment_1to1_residue_map, $PDB_str_name, $s, $DDD_domain_length, $DDD_domain_length,
       %FDAT_hash, $REP_DDD_range_start_1, $REP_DDD_range_start_2, @boundaris_as_ranges,
       %PROTEIN_DOMAIN_Definition_hash, $get_ranges_info);
    my($REPRESENTATIVE_FSSP_ENTRIES_file)=${$_[0]};
    my($FSSP_PAIR_TABLE_file)=${$_[1]};
    my(%representative_FSSP_entries)=%{$_[2]};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    #    $FSSP_PAIR_TABLE_hash{$representative_member}->{$str1}=[$RMSD,
    #                                                            $align_leng,
    #                                                            $sequence_leng,
    #                                                            $mutual_percent_sequence_identity,
    #                                                            $protein_name_and_description];
    #___________________________________________________________________________________________________
    %FSSP_PAIR_TABLE_hash=%{&open_FSSP_PAIR_TABLE_file(\$FSSP_PAIR_TABLE_file)}; ## 'str1 str2' -> 99%
    $DOMSEL_file=${$_[3]};
    $FDATDIR=${$_[4]};
    $FSSPDIR=${$_[5]} || $_[5];
    if(!-d $FSSPDIR){ print "\n (E) define_domain_boundaries_for_DALI_homologues: FSSP dir $FSSPDIR is not correct, dying \n"; }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # %FSSP_PAIR_TABLE_hash assigned this way>>
    #___________________________________________________________________________
    @representative_structures=keys %FSSP_PAIR_TABLE_hash;
    #print "\n @representative_structures\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  Assigned this way>>  $DOMSEL_hash{$structure}=[@domains];
    #   1abc (1,2,3,4), 2xyz (1,8,10,11,12,19) <-- numbers are node numbers
    #___________________________________________________________________
    %DOM_SEL_hash      =%{&open_DOMSEL_file(\$DOMSEL_file)}; # %DOM_SEL_hash ==> seq -> [1, 2, 4]
    @DOM_SEL_structures=keys %DOM_SEL_hash;

    DOM: for($i=0; $i< @DOM_SEL_structures; $i++){
       unless($DOM_SEL_structures[$i]=~/\S/){ die };
       $PDB_str_name=$DOM_SEL_structures[$i];

       $FSSP_file_name="$FSSPDIR\/$PDB_str_name\.fssp";

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # $FSSP_align_map{$Rep_name}{$FSSP_hom_name}{$REP_posi}=$HOMOL_posi or $HOMOL_range
       #_____________________________________________________________________
       $get_ranges_info=''; ## $get_ranges_info should be NULL here. for make_protein_domain.. sub, it should be 'r'
       %FSSP_alignment_1to1_residue_map=%{&open_FSSP_file(\$FSSP_file_name, $get_ranges_info)};

       if(length($DOM_SEL_structures[$i]) == 4){   $FDAT_file="$FDATDIR\/$DOM_SEL_structures[$i]\_\.dat";
       }else{        $FDAT_file="$FDATDIR\/$PDB_str_name\.dat";       }

       if(! (-e $FDAT_file) ){ print "\n WARN: \$FDAT_file $FDAT_file does not exist, skipping \n";
            next DOM;
       }


       #~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # FDAT_hash> $Dali_subdomains{$structure_ID}{$subdomain_number}=[$subdomain1,
       #                                                       $subdomain2,
       #                                                       $residue_leng,
       #                                                       $numb_of_segments,
       #                                                       $ranges
       #                                                       ]
       #__________________________________________________________________________________
       %FDAT_hash=%{&open_FDAT_file(\$FDAT_file)};

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
       # @DOMAIN_MOTIF_id_numbers are the target domain motif numbers from Dali domain breakdown
       #________________________________________________________________________________________________
       @DOMAIN_MOTIF_id_numbers=@{$DOM_SEL_hash{$PDB_str_name}};
       @subdomain_numbers=sort {$a<=>$b} keys %{$FDAT_hash{$PDB_str_name}};

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Getting ranges information for the PDB str's Domain MOTIF (node)
       #_______________________________________________________________________
       for($m=0; $m< @DOMAIN_MOTIF_id_numbers; $m++){
          $Dom_motif_ID=$DOMAIN_MOTIF_id_numbers[$m];
          $REP_DDD_name="$PDB_str_name\_$Dom_motif_ID";

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # The ranges information is the 5th element of the anon. array
          #_________________________________________________________________
          @REP_Domain_Motif_ranges=split(/\s+/, ${$FDAT_hash{$PDB_str_name}{$Dom_motif_ID}}[4] );
          $DDD_domain_length=${&get_DDD_domain_length_from_segment_ranges(\@REP_Domain_Motif_ranges)};
          if($DDD_domain_length < 1){
              print "\n \$DDD_domain_length is less than 1, something is wrong
                    @REP_Domain_Motif_ranges\n ${$FDAT_hash{$PDB_str_name}{$Dom_motif_ID}}[4]\n
                    $PDB_str_name $Dom_motif_ID\n${$FDAT_hash{$PDB_str_name}{$Dom_motif_ID}}[3]\n \$FDAT_file $FDAT_file";
          }
          $DDD_leng=${$FDAT_hash{$PDB_str_name}{$Dom_motif_ID}}[2];
          $Num_of_segments=${$FDAT_hash{$PDB_str_name}{$Dom_motif_ID}}[3];
          #print "\n$PDB_str_name : $Dom_motif_ID -  @REP_Domain_Motif_ranges\n";
          @FSSP_homologues=keys %{$FSSP_PAIR_TABLE_hash{$PDB_str_name}};
          #print "\n \@FSSP_homologues are @FSSP_homologues\n";
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
          # Open each fssp homologue and compare the alignment with the one of rep.
          #_______________________________________________________________________________
          HOMOLOGS: for($h=0; $h<@FSSP_homologues; $h++){
             my($good_segment_count, $HOMOL_DDD_range_start, $HOMOL_DDD_range_stop,
                $HOMOL_domain_length, @HOMOL_DDD_ranges, $fraction_of_align_HOMOL_DDD_dom_leng);
             $FSSP_homolog_name=$FSSP_homologues[$h];
             $HOMOL_DDD_name="$FSSP_homolog_name\_$Dom_motif_ID";

             for($r=0; $r< @REP_Domain_Motif_ranges; $r+=2){
                $REP_DDD_range_start=$REP_Domain_Motif_ranges[$r];
                $REP_DDD_range_stop =$REP_Domain_Motif_ranges[$r+1];
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                # !! Some homologues are shorter than the representatives. So, no corresponding residue position.
                #   DDD_motif  1-89   (for rep)   3-89 (for homol). In this case,   3-89  seg. of homol is taken
                #   DDD_motif 110-333 (for rep) 111-330(for homol). In this case, 111-330 seg. of homol is taken
                #________________________________________________________________________________________________________
                $HOMOL_DDD_range_start=$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_start};
                $HOMOL_DDD_range_stop =$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_stop};
                #print "\n\n\n $m $h $r $PDB_str_name $FSSP_homolog_name $REP_DDD_range_digit ->$HOMOL_DDD_range_digit <<<<<<<<<<<<<\n";

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                # If no corresponding res posi for homologue (This is a horrible problem.
                #____________________________________________________________________________________
                if(!$HOMOL_DDD_range_start or !$HOMOL_DDD_range_stop){
                     #print "\n =======> No corresponding \$HOMOL_DDD_range_start is NULL :@REP_Domain_Motif_ranges\n";
                     $domain_motif_seg_half_size=($REP_Domain_Motif_ranges[$r+1]-$REP_Domain_Motif_ranges[$r])+1;

                     if(!$HOMOL_DDD_range_start){
                         #print "\n   $PDB_str_name = $FSSP_homolog_name \$HOMOL_DDD_range_start : $HOMOL_DDD_range_start ";
                         for($x=0; $x < $domain_motif_seg_half_size/2; $x++){
                             $REP_DDD_range_start_1 = $REP_DDD_range_start + $x;
                             #print "\n\$REP_DDD_range_start_1 $REP_DDD_range_start_1, $REP_DDD_range_start + $x";
                             $REP_DDD_range_start_2 = $REP_DDD_range_start - $x;
                             #print "\n\$REP_DDD_range_start_2 $REP_DDD_range_start_2, $REP_DDD_range_start - $x";
                             if($FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_start_1}){
                                $HOMOL_DDD_range_start=$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_start_1};
                                $REP_DDD_range_start = $REP_DDD_range_start_1;
                                last;
                             }elsif($FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_start_2}){
                                $HOMOL_DDD_range_start=$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_start_2};
                                $REP_DDD_range_start = $REP_DDD_range_start_2;
                                last;
                             }
                         }
                     }
                     if(!$HOMOL_DDD_range_stop){
                         #print "\n   $PDB_str_name = $FSSP_homolog_name \$HOMOL_DDD_range_stop : $HOMOL_DDD_range_stop ";
                         for($x=0; $x < $domain_motif_seg_half_size/2; $x++){
                             $REP_DDD_range_stop_1 = $REP_DDD_range_stop - $x;
                             $REP_DDD_range_stop_2 = $REP_DDD_range_stop + $x;
                             if($FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_stop_1}){
                                $HOMOL_DDD_range_stop=$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_stop_1};
                                $REP_DDD_range_stop = $REP_DDD_range_stop_1;
                                last;
                             }elsif($FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_stop_2}){
                                $HOMOL_DDD_range_stop=$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$REP_DDD_range_stop_2};
                                $REP_DDD_range_stop = $REP_DDD_range_stop_2;
                                last;
                             }
                         }
                     }
                }

                @HOMOL_DDD_aligned_res=@{&get_correct_DDD_domain_region_from_alignment(\$PDB_str_name,
                                                                                  \$FSSP_homolog_name,
                                                                                  \%FSSP_alignment_1to1_residue_map,
                                                                                  \$REP_DDD_range_start,
                                                                                  \$REP_DDD_range_stop)};
                $HOMOL_domain_length  += @HOMOL_DDD_aligned_res;
                @HOMOL_DDD_ranges=@{&find_boundaries_in_arrays(\@HOMOL_DDD_aligned_res)};


                #print "\n$r $HOMOL_domain_length : $HOMOL_DDD_range_stop - $HOMOL_DDD_range_start";
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                #  If corresponding positions are found for start and stop
                #_____________________________________________________________
                if($HOMOL_DDD_range_start and $HOMOL_DDD_range_stop){
                    $good_segment_count+=2;
                }else{
                    #print "\n\t !!!!!!\$HOMOL_DDD_range_start or \$HOMOL_DDD_range_stop are not true \n";
                }

             }
             $fraction_of_align_HOMOL_DDD_dom_leng=$HOMOL_domain_length/$DDD_domain_length;
             $range_element_num=@REP_Domain_Motif_ranges;
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Decision making here
             #______________________________________________________________________________
             if( $good_segment_count and ($good_segment_count == $range_element_num and
                                          $fraction_of_align_HOMOL_DDD_dom_leng > 0.75) ){
                #print "\nGood: $fraction_of_align_HOMOL_DDD_dom_leng : $good_segment_count<=>$range_element_num : $PDB_str_name $FSSP_homolog_name @REP_Domain_Motif_ranges\n";
                $DDD_entries_with_seg_info{$PDB_str_name}{$FSSP_homolog_name}{$Dom_motif_ID}=[@HOMOL_DDD_ranges];
                push(@{$DOM_SEL_hash{$FSSP_homolog_name}}, $Dom_motif_ID);
                $fraction_of_align_HOMOL_DDD_dom_leng='';
             }else{
                #print "\nBAD: $fraction_of_align_HOMOL_DDD_dom_leng : $good_segment_count<=>$range_element_num : $PDB_str_name $FSSP_homolog_name @REP_Domain_Motif_ranges\n";
             }
          }
       }
    } # end of FOR loop

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #&make_protein_domain_definition_file(\%FSSP_PAIR_TABLE_hash,
    #                                     \%DOM_SEL_hash,
    #                                     \%FSSP_alignment_1to1_residue_map,
    #                                     \%DOM_table_hash);
    #___________________________________________________________________________________
    #&show_FSSP_hash(\%FSSP_alignment_1to1_residue_map);
    $DOM_table_file="./DOMTABLE1";
    %DOM_table_hash=%{&open_DALI_domain_table_file(\$DOM_table_file)};
    return([\%FSSP_PAIR_TABLE_hash, \%DOM_SEL_hash, \%FSSP_alignment_1to1_residue_map, \%DOM_table_hash ]);
}





#________________________________________________________________________
# Title     : define_secondary_structure_segments, synonim of tidy_secondary_structure_segments
# Usage     : print_seq_in_block(&define_secondary_structure_segments(\%hash, 'e4', 'h4'), 's');
#
# Function  : receives any secture assignment hashes and
#             tidys up them. That is removes very shoft secture
#             regions like( --HH--, -E-, -EE- ) according to the given minimum
#             lengths of segments.
# Example   : print_seq_in_block(&define_secondary_structure_segments(\%hash, 'e4', 'h4'), 's');
#             <makes following into the next block>
#
#             1cdg_2aaa      -------EEE-----------EE--EEEE------EE---------EEE-
#             1cdg_6taa      -------EEE-----------EE--EEEE------EE---------EEE-
#             2aaa_6taa      -------EEEEE------EE-EEEEEEEE----EEEE-------EEEEE-
#
#             <example output>
#
#             1cdg_6taa      -------------------------EEEE---------------------
#             1cdg_2aaa      -------------------------EEEE---------------------
#             2aaa_6taa      -------EEEEE---------EEEEEEEE----EEEE-------EEEEE-
#
# Warning   :
# Keywords  :
# Options   : something like 'H3' or 'E3' for minimum segment length set to 3 positions.
# Returns   : array of references of hashes.
# Argument  : hashes and [options]. No options result in default of 'H3', 'E3'
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub define_secondary_structure_segments{
	my($i, $k,$a, $j, $helix_min, $beta_strand_min, %hash, @keys, @hash,
	  $option_string, @hash_out, $string1, $name, %out, $gap_chr, @str1, @str2,
	  @stringout, @string_segH, @string_segE, $countH, $countE
	  );

	#### Default helix and beta strand segment length setting #####
	$helix_min=3;
	$beta_strand_min=3;

	########################################################################
	#####   general argument handling  for options of segment length  ######
	########################################################################
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^[Hh](\d+)$/) ){
		  $helix_min  = $1;    }
	  elsif( ( !ref($_[$k]) )&&($_[$k]=~ /^[Ee](\d+)$/) ){
		  $beta_strand_min  = $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^[Hh](\d+)$/) ){
		  $helix_min  = $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^[EeBb](\d+)$/) ){
		  $beta_strand_min  = $1;    }
	  elsif(ref($_[$k]) eq "HASH") { push(@hash,  $_[$k]); }    }

	for($i=0; $i < @hash; $i++){
	  my(%hash) = %{$hash[$i]};
	  @keys = sort keys( %hash );
	  for($j=0; $j < @keys; $j++){
		  my(@string_segH, @string_segE, @stringout);
		  $string1=$hash{$keys[$j]};
		  $gap_char = $1 if ($string1=~ /(\W)/);

		  ##### actual cleaning ####
		  my(@string) = split(//, $string1);
		  for($a = 0; $a < @string; $a++){
			 if($string[$a] !~/[HE]/){ ### if the splited element doesn't match 'H' or 'E'

				 ##### If any of the HH or EE counter is over the given minimum($helix_min,,)
				 if((@string_segH >= $helix_min)||( @string_segE >=$beta_strand_min)){
					 push(@stringout, @string_segH, @string_segE, '-');
					 @string_segH=@string_segE=();     }   ## just resetting.
				 else{  ### if the accumulated 'HH' or 'EE' is smaller than the minimum
					 for(0.. (@string_segH + @string_segE) ){
						push(@stringout, '-'); ### replace the short 'EE' etc with '-'
					 }
					 @string_segH=@string_segE=();  ## just resetting.
				 }
			 }
			 elsif($string[$a] =~ /^([Hh])$/){
				 push(@string_segH, $1); }
			 elsif($string[$a] =~ /^([Ee])$/){
				 push(@string_segE, $1); }
		  }
		  $hash{$keys[$j]}=join("", @stringout);
	  }
	  push(@hash_out, \%hash);
	}
	if(@hash_out == 1){ return($hash_out[0]);
	}elsif(  @hash_out > 1 ){ return(@hash_out); }
}






#________________________________________________________________________
# Title     : overlay_seq_by_certain_chars
# Usage     : %out =%{&overlay_seq_by_certain_chars(\%hash1, \%hash2, 'HE')};
# Function  : (name1 000000112324)+(name1  ABC..AD..EFDK ) => (name1 000..00..12324)
#             (name2 000000112324)+(name2  --HHH--EEEE-- ) => (name1 ---000--1123--)
#             uses the second hash a template for the first sequences. gap_char is
#             '-' or '.' or any given char or symbol.
#             To insert gaps rather than overlap, use insert_gaps_in_seq_hash
# Example   : %out =%{&overlay_seq_by_certain_chars(\%hash1, \%hash2, 'E')};
#             output> with 'E' option >>> "name1     --HHH--1232-"
# Warning   : If gap_chr ('H',,,) is not given, it replaces all the
#             non-gap chars (normal alphabet), ie,
#             it becomes 'superpose_seq_hash'
# Keywords  : Overlap, superpose hash, overlay, superpose_seq_hash
# Options   : E for replacing All 'E' occurrances in ---EEEE--HHHH----, etc.
#             : H for replacing all 'H'  "     " "
# Returns   : one hash ref.
# Argument  : 2 ref for hash of identical keys and value length.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub overlay_seq_by_certain_chars{
	my($i, $k,$j, $name, @in, %out, $gap_chr, @str1, @str2);
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	####### Sub argument handling ########  $gap_chr here can be 'HE' etc.
	#______________________________________
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^(.+)$/) ){
		  $gap_chr  .= $1;
	  }elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(.)+$/) ){
		  $gap_chr  .= $1;
	  }elsif(ref($_[$k]) eq "HASH") { push(@in,  $_[$k]); }
	}

	if($#in < 1){
	  print "\n overlay_seq_by_certain_chars needs 2 hashes. Error \n"; die; }
	my(%hash1)=%{$in[0]};
	my(%hash2)=%{$in[1]};
	my(@names1)= sort keys %hash1;
	my(@names2)= sort keys %hash2;
	(@names1 > @names2)? $bigger=@names1 : $bigger=@names2;
	for ($j=0; $j < $bigger; $j++){
	  @str1=split(//, $hash1{$names1[$j]});
	  @str2=split(//, $hash2{$names2[$j]});
	  if( ($gap_chr eq '') && ($hash2{$names2[$j]}=~/(\W)/) ){
		  $gap_chr=$1;
		  for($i=0; $i < @str2; $i++){
			  if($str2[$i] =~ /$gap_chr/){ $str1[$i]=$gap_chr;}     }
		  $out{$names1[$j]}=join(",", @str1);
	  }else{
		  for($i=0; $i < @str2; $i++){
			  if($gap_chr =~ /$str2[$i]/){ $str2[$i]=$str1[$i];}    }
		  $out{$names1[$j]}=join(",", @str2);    }
	}
	return(\%out);
}



#________________________________________________________________________
# Title     : rev_lines_pdb
# Usage     : &rev_lines_pdb(\$ARGV[0]);
# Function  : reorders the lines of any pdb files, but takes only C alpha positions.
# Example   :
#             The INPUT example >
#
#             ATOM    191  CA  ALA   195      -2.566   8.099  42.827  1.00 12.42      1ENG 256
#             ATOM    192  CA  ARG   196      -1.401  11.546  41.629  1.00  8.63      1ENG 257
#             ATOM    193  CA  THR   197      -4.073  13.846  43.107  1.00  9.93      1ENG 258
#
#             The OUTPUT example >             <first file, called  xxxx1.atm >
#
#             ATOM      1  CA  ALA     1      -2.566   8.099  42.827  1.00 12.42      1ENG 256
#             ATOM      2  CA  ARG     2      -1.401  11.546  41.629  1.00  8.63      1ENG 257
#             ATOM      3  CA  THR     3      -4.073  13.846  43.107  1.00  9.93      1ENG 258
#
#                                           <2nd file, called  xxxx2.atm >
#             ATOM      1  CA  THR     1      -4.073  13.846  43.107  1.00  9.93      1ENG 258
#             ATOM      2  CA  ARG     2      -1.401  11.546  41.629  1.00  8.63      1ENG 257
#             ATOM      3  CA  ALA     3      -2.566   8.099  42.827  1.00 12.42      1ENG 256
#
# Warning   : A Biomatic
# Keywords  :
# Options   : None
# Returns   : directly writes two output files  xxxx1.atm  xxxx2.atm
# Argument  : one pdb coordinate file reference
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rev_lines_pdb{
	 my(@lines, $i, $c, @line_rev, $ATOM, $RES );
	 my($input_file_name) = ${$_[0]};
	 open(INPUT, "$input_file_name");
	 while(<INPUT>){  push(@lines, $_); $whole++;  }
	 my($base_name) =${&get_base_name(\$input_file_name)};
	 my($file1) = "${base_name}1\.atm";
	 my($file2) = "${base_name}2\.atm";

	 ##################################################################################
	 # This section is for forward C alpha lines (it renumbers residues and atoms)
	 ##################################################################################
	 open(F1, ">$file1");
	 open(F2, ">$file2");

	 for($i=0; $i < $whole ; $i ++){
		  if($lines[$i]=~ /^(ATOM\s+)(\d+)(  CA  \w+\s+)(\d+)(\s+.+)$/){
				$c++;
				if( length($2)== length($c) ){
					 unshift(@lines2, "$1$c$3$c$5\n");
					 print F1 "$1$c$3$c$5\n"; next;
				}
				if( length($2) != length($c) ){
					 if( abs( ( length($2)- length($c) )) ==1){
						  unshift(@lines2, "$1 $c$3 $c$5\n");
						  print F1 "$1 $c$3 $c$5\n"; next;
					 }
					 if( abs( (length($2)-length($c))) ==2){
						  unshift(@lines2, "$1  $c$3  $c$5\n");
						  print F1 "$1  $c$3  $c$5\n"; next;
					 }
				}
		  }
	 }
	 close F1;

	 ##################################################################################
	 # This section is for reversed C alpha lines (it renumbers residues and atoms)
	 ##################################################################################
	 $c=0;
	 for($i= 0; $i < $whole; $i ++){
		  if($lines2[$i]=~ /^(ATOM\s+)(\d+)(  CA  \w+\s+)(\d+)(\s+.+)$/){
				$c++; $num = $1;
				if( length($2)== length($c) ){  # these are for column position adjustment
					 printf F2 "$1$c$3$c$5\n";
					 next;
				}
				elsif( length($2) != length($c) ){
					 if( (length($2)- length($c)) ==1){
							 print F2 "$1 $c$3 $c$5\n";
							 next;
					 }
					 elsif( (length($2)- length($c)) == -1){
							 $ATOM=$1; $RES=$3;
							 chop($ATOM); chop($RES);
							 print F2 "$ATOM$c$RES$c$5\n";
							 next;
					 }
					 elsif( (length($2)- length($c)) ==2){
							 print F2 "$1  $c$3  $c$5\n";
							 next;
					 }
					 elsif( (length($2)- length($c)) == -2){
							 $ATOM=$1; $RES=$3;
							 chop($ATOM); chop($RES); chop($ATOM); chop($RES);
							 print F2 "$ATOM$c$RES$c$5\n";
							 next;
					 }
				}
		  }
	 }
	 close F2;

	 ##################################################################################
	 #   Final result
	 ##################################################################################

	 print "\n Files   $file1, $file2  are created \n\n\n";

}


#________________________________________________________________________
# Title     : tally_2_hashes (used for get_cs_rate_for_pairs_stat.pl )
# Usage     : ($ref1, $ref2) = &tally_2_hashes(\%hash1, \%hash2, ['n', 'a', 'p', 'i']);
#              %tally_addedup=%{$ref1};    '0' position had addedup value of 1000
#              %tally_occurances=%{$ref2}; '0' position had occurred 100 times,
#                                          '0' on average had 10 in its
#                                              corresponding hash positions
# Function  : Makes hashes of tallied occurances and summed up values for disits in
#             positions.
#             calculates the occurances or occurance rates of CS rate positions.
#             The hashes should have numbers.
# Example   : you put two hash refs. (ass. array) as args (\%hash1, \%hash2)
#             The hashes are like; hash1  (name1, 0000011111, name2, 0000122222 );
#                                  hash2  (name3, 1324..1341, name4, 13424444.. );
#
#             1) The resulting 1st hash output is (0, 20,   1, 13,     2, 12)
#             which means that 0 added up to 24 in the second arg hash positions
#                              1 added up to 15 in the second arg hash positions
#                              2 added up to 18 in the second arg hash positions
#             'p' option only works with 'n' or 'a'
#             2) The resulting 2nd hash output is (0, 5,   1, 5)
#             which means that 0 occurred 5 times in the first input hash
#                              1 occurred 5 times in the first input hash
#             'p' option only works with 'n' or 'a'
# Warning   :
# Keywords  :  tally two hashes of numbers.
# Options   : [a n i p]
# Returns   : ($ref1, $ref2), ie, two references of hash
#             averaging option causes division of 20(added up value)
#                                                by 9(occurance) in the above
#             for '0' of the first hash, so (0, 2.222,  1, 2.1666,  2, 2.4 )
#             Average is the average of numbers
#             average value in 0-9 scale (or 0-100 with 'p' option)
#             So, if there are
#                  seq1 00111110000,   The 'a' value of 0 and 1 as in the seq2
#                  seq2 33000040000    is 0-> 6/6, 1-> 4/5, while the 'n'
#                                        calc would be, 0-> 6 (60%), 1-> 4(40%)
#
# Argument  : (\%hash1, \%hash2) or optionally (\%hash1, \%hash2, ['n', 'i', 'p', 'a'])
#             'n' => normalizing, 'p' => percentage out, 'i' => make int out, 'a'=> averaged
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub tally_2_hashes{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	%hash0 = %{$hash[0]};
	%hash1 = %{$hash[1]};
	@keys1=  keys %hash0;  ### No need to sort here as you will return hash at the end
	@keys2=  keys %hash1;

	if($char_opt =~ /p/i ){ $factor =100; }

	for($i=0; $i < @keys1; $i++ ){

	  ###################################################
	  ##  Gap char detection
	  ###################################################
	  if($hash0{$keys1[$i]} =~ /([\,\-])\S+[\,\-]/){ $gap_char1 = $1; }else{ $gap_char1=''; }
	  if($hash1{$keys2[$i]} =~ /([\,\-])\S+[\,\-]/){ $gap_char2 = $1; }else{ $gap_char2=''; }


	  ###################################################
	  ##  Split the value string by gap char
	  ###################################################
	  @string1=split(/$gap_char1/, $hash0{$keys1[$i]});
	  @string2=split(/$gap_char2/, $hash1{$keys2[$i]});
	  ### @string1 => (0,0,0,0,1,1,1,1,1) @string2 => (3,4,2,13,2,1,23,3)


	  ################################################################
	  ##  Main calc part, you get %tally_all_occur and %tally_occur
	  ################################################################
	  for($j=0; $j < @string1; $j++){
		  $tally_all_occur{$string1[$j]}++ ; ## <-- number of all the positions
		  if( ($string2[$j]=~/[\d\^]+/)&&($string1[$j]=~/[\d\^]+/) ){
			  $tally_occur{$string1[$j]}+=$string2[$j] ; # %tally_occur is for added up counts
		  }                                             # %tally_all_occur is for only the position
	  }                                                #  occurances of '0', '1' or whatever. To know
																		#  how many '0' entry were you should use this.
	  ####################################################################################
	  ##  When options were put, do more calc on %tally_all_occur and %tally_occur
	  ####################################################################################
	  if($char_opt =~ /a/i ){
		 print "\n           $char_opt ";
		 my(@cs_rates) = sort keys %tally_all_occur;
		 for($k=0; $k < @cs_rates; $k++){
			 if($tally_all_occur{$cs_rates[$k]} == 0){
				 $tally{$cs_rates[$k]} =0; next;}
			 if($char_opt =~ /i/i ){
				 $tally{$cs_rates[$k]}=int($tally_occur{$cs_rates[$k]}/$tally_all_occur{$cs_rates[$k]}); }
			 elsif($char_opt !~ /i/i ){
				 $tally{$cs_rates[$k]}= $tally_occur{$cs_rates[$k]}/$tally_all_occur{$cs_rates[$k]};
			 }
		 }
	  }
	  elsif($char_opt =~ /[np]/i){
		 my($big_sum, @cs_digits);
		 @cs_digits = sort keys %tally_occur;  # @cs_digits are (0, 1, and 2 )
		 for(@cs_digits){ $big_sum+=$tally_occur{$_}/$tally_all_occur{$_};   }
		 for($t=0; $t < @cs_digits; $t++){
			if($big_sum ==0){ $tally{$cs_digits[$t]}=0; next; }
			else{
			  if($char_opt =~ /i/i){
				 $tally{$cs_digits[$t]}= int(($tally_occur{$cs_digits[$t]}/$tally_all_occur{$cs_digits[$t]}/$big_sum*$factor)+0.4999);}
			  elsif($char_opt !~ /i/i ){
				 $tally{$cs_digits[$t]}= $tally_occur{$cs_digits[$t]}/$tally_all_occur{$cs_digits[$t]}/$big_sum*$factor;}
			}
		 }
	  }
	}
	if($char_opt =~ /[an]/i){
		 print "\n           $char_opt ";
	  return(\%tally, \%tally_all_occur);}
	else{ return(\%tally_occur, \%tally_all_occur);}
}
#________________________________________________________________________
# Title     : superpose_seq_hash   ( first to second hash) ## the oldest version.
# Usage     : %out =%{&superpose_seq_hash(\%hash1, \%hash2)};
# Function  : (name1 000000112324)+(name1  ABC..AD..EFD ) => (name1 000..01..324)
#             uses the second hash a template for the first sequences. gap_char is
#             '-' or '.'
#             To insert gaps rather than overlap, use insert_gaps_in_seq_hash
# Example   :
# Warning   : Accepts only two HASHes and many possible gap_chr. Default gap is '-'
# Keywords  : overlay sequence, overlay alphabet, superpose sequence,
# Options   :
# Returns   : one hash ref.
# Argument  : 2 refs. for hash of identical keys and value length and gap_chr.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub superpose_seq_hash{
	if($debug eq 1){ print __LINE__, " # superpose_seq_hash : \n"; }
	my($gap_chr)='-';
	my($i, $j, %hash1, %hash2, $name, %out, @str1, @str2);

	if((ref($_[0]) eq 'HASH')&&(ref($_[1]) eq 'HASH')){
	  %hash1=%{$_[0]}; %hash2=%{$_[1]}; }
	else{ print "\n superpose_seq_hash needs hash ref\n"; print chr(007); die; }

	my(@names1)=sort keys %hash1; my(@names2)=sort keys %hash2;
	(@names1 > @names2)? $bigger=@names1 : $bigger=@names2;

	for ($j=0; $j < $bigger; $j++){
	 if($hash2{$names2[$j]}=~/(\W)/){ $gap_chr = $1; }
		@str1=split(/|\,/, $hash1{$names1[$j]});
		@str2=split(/|\,/, $hash2{$names2[$j]});
		for($i=0; $i < @str2; $i++){
		  if($str2[$i] ne $gap_chr){ $str2[$i]=$str1[$i];  } }
		$out{$names1[$j]}=join(",", @str2);
	}
	return(\%out);
}


#________________________________________________________________________
# Title     : overlay_seq_hash   ( first to second hash) ## the oldest version.
# Usage     : %out =%{&overlay_seq_hash(\%hash1, \%hash2)};
# Function  : (name1 000000112324)+(name1  ABC..AD..EFD ) => (name1 000..01..324)
#             uses the second hash a template for the first sequences. gap_char is
#             '-' or '.'
#             To insert gaps rather than overlap, use insert_gaps_in_seq_hash
# Example   :
# Warning   : Accepts only two HASHes and many possible gap_chr. Default gap is '-'
# Keywords  :
# Options   :
# Returns   : one hash ref.
# Argument  : 2 refs. for hash of identical keys and value length and gap_chr.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub overlay_seq_hash{
	my($gap_chr)='-'; my($i, $j, $name, %out, @str1, @str2);

	if((ref($_[0]) eq 'HASH')&&(ref($_[1]) eq 'HASH')){
	  my(%hash1)=%{$_[0]}; my(%hash2)=%{$_[1]}; }
	else{ print "\n overlay_seq_hash needs hash ref\n"; print chr(007); die; }

	my(@names1)=keys %hash1; my(@names2)=keys %hash2;
	(@names1 > @names2)? $bigger=@names1 : $bigger=@names2;

	for ($j=0; $j < $bigger; $j++){
	 if($hash2{$names2[$j]}=~/(\W)/){ $gap_chr = $1; }
		@str1=split(//, $hash1{$names1[$j]}); @str2=split(//, $hash2{$names2[$j]});
		for($i=0; $i < @str2; $i++){
		  if(($str2[$i] =~ /\W/)||($str2[$i] =~ //)){ $str1[$i]="$gap_chr";}}
		$out{$names1[$j]}=join(",", @str1);
	}
	\%out;
}


#________________________________________________________________________
# Title     : insert_gaps_in_seq_hash  ( first to second hash)
# Usage     : %out_extended_seq =%{&insert_gaps_in_seq_hash(\%hash1, \%hash2)};
# Function  : superpose two hashes of the same sequence or same seq. length sequences,
#             but unlike 'superpose_seq_hash', this inserts gaps and extend the
#             sequences.
#             (name1_sec  hHHHHHH EEEEEEE) +
#             (name1_seq  .CDEABC..AD..EFD..EKST) => (name1_ext  .hHHHHH..H...EEE..EEEE)
#             In the example, the undefined sec. str. position is replaced as gaps('.')
#             Uses the second hash a template for the first sequences. gap_char is
#             '-' or '.'
#             One rule is that the SECOND hash contains gaps!!
#             There are two types of hash input. One is simple seq hash(both args)
#              The other is from secture prediction. The hash has contents
#              like: $averaged{$position}=[$residue1, $sec_str2, $dif_reliability];
# Example   :
# Warning   : coded by A Biomatic
# Keywords  : superposing sequences with gaps, interpolate_sequences, interpolate_gaps
# Options   :
# Returns   : one hash ref.
# Argument  : 2 ref for hash of identical keys and value length.
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub insert_gaps_in_seq_hash{
		my($gap_char)='-';
		my($g, $i, $j, $t, %hash1, %hash2, $bigger, $name, %new_hash_with_gap, @str1,
			 @posi, @str2, $char_from_gapped_hash, $GAP_CHAR);
		my($join_char) =',';  ## <<-- This is for the final output joined by this var.
		$GAP_CHAR='-';

		if((ref($_[0]) eq 'HASH')&&(ref($_[1]) eq 'HASH')){
			 %hash1=%{$_[0]};
			 %hash2=%{$_[1]};
		}else{
			 print "\n superpose_seq_hash needs hash ref\n";
			 print chr(007); die;
		}
		my(@names1)=keys %hash1;
		my(@names2)=keys %hash2;

		if($hash1{$names1[0]}->[0] =~/\w/){ # this means that the input hash is sec str hash type
				print "\n# (INFO) insert_gaps_in_seq_hash: You have put sec str pred hash as an input.\n\n";
				@posi=split(//, $hash2{$names2[0]});

				for($i=1; $i< @posi; $i++){  #<------ Note that $i starts with '1' not '0'
						 $char_from_gapped_hash=$posi[$i];
						 if($char_from_gapped_hash=~/(\W)$/){
								 $GAP_CHAR=$1;
								 $new_hash_with_gap{$i}=[$GAP_CHAR, $GAP_CHAR, '0.0'];
								 $g++;  ## this is to adjust the difference between %hash2 and %$new_hash_with_gap
						 }else{
								 $new_hash_with_gap{$i}=$hash1{$i-$g} if $hash1{$i-$g}; ## this if line is crucial!!
						 }
				}
		}else{ ## simple seq hash input case
				 (@names1 > @names2)? $bigger=@names1 : $bigger=@names2;

				 for ($j=0; $j < $bigger; $j++){
						 if( $hash2{$names2[$j]}=~/(\W)/){
										 $gap_char = $1; } ## <<-- finding the gap_char
						 $hash1{$names1[$j]}=~ s/ /$gap_char/g; ## <<-- replacing space with 'gap_char';

						 @str1=split(/|\,/, $hash1{$names1[$j]});
						 @str2=split(/|\,/, $hash2{$names2[$j]});
						 for($i=0 ; $i < @str2; $i++){
								 if($str2[$i] =~ /\w/){
										 $str2[$i] = shift @str1;
								 }
						 }
						 $new_hash_with_gap{$names1[$j]}=join(",", @str2);
				 }
		}
		return(\%new_hash_with_gap);
}

#______________________________________________________________________________
# Title     : insert_char_in_strings
# Usage     : $out=${&insert_char_in_strings($string, 4, $gap_char)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub insert_char_in_strings{
		my($string); if(ref($_[0])){ $string = ${$_[0]};
								 }else{ $string = $_[0]; }
		my($interval) = $_[1];
		my($gap_char) = $_[2];
		print "\n# (i) Gap char is $gap_char\n";
		$string =~ s/(.{$interval})/$1${gap_char}/g;
		return(\$string);
}


#________________________________________________________________________
# Title     : scan_win_get_average (gets averages of windows of sequences of num)
# Usage     : %out1 = %{&scan_win_get_av(\%input, \$window_size, \%input2,,,,)};
#             The order of the arguments doesn't matter.
# Function  :
# Example   : input hash: ( seq1,  '13241234141234234',      (2 or more sequences accepted)
#                           seq2,  '1341324123413241234')
#             input winsize : 5;
#
#             output hash; (seq1, 1234123413241234);
#             output hash; (seq2, 1344234123412341);
#                  The numbers are ratios(compos/seqid) with given window size.
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub scan_win_get_average{
	my($window_size)=6; my($k,$r, @in_hash);
	for($k=0; $k < @_; $k++){ ######### Arg handling.
	 if(ref($_[$k]) eq 'HASH'){  push(@in_hash, $_[$k]);  }
	 elsif( ref($_[$k]) eq 'SCALAR'){ $window_size = ${$_[$k]}; }
	 elsif( !(ref($_[$k])) && ( $_[$k] =~ /\d+/)){ $window_size=$_[$k]; }
	}
	for($r=0; $r < @in_hash; $r++){ my($i,$window_1, $sepa,%out_hash,$offset, $sum, $w,@win_elem_array);
	 my(%input)=%{$in_hash[$r]};  my(@keys)= keys %input;
	 for ($i=0; $i< @keys; $i++){ my($av);
		 $input{$keys[$i]}=~ s/,//g; $input{$keys[$i]}=~ s/\./0/g;
		 $input{$keys[$i]}=~ s/\-/0/g;
		 for($w=0; $w < length($input{$keys[$i]}); $w++){
			$offset = $w - int($window_size/2);  if($offset < 0){ $offset = 0; }
			$window_1= substr($input{$keys[$i]}, $offset, $window_size);
			@win_elem_array= split(//,$window_1);
			for(@win_elem_array){    if(/^\d[\.\d]*/){   $sum+=$_;  }    }
			$av.=int($sum/@win_elem_array);         $sum=0;
		 }
		 $out_hash{$keys[$i]}=$av;
	 }
	 push(@final_out_ref, \%out_hash);
	}
	if( @final_out_ref == 1){  return($final_out_ref[0]); }
	elsif(  @final_out_ref > 1){  return(@final_out_ref); }
}
#________________________________________________________________________
# Title     : scan_win_and_get_sc_rate_pairs
# Usage     : %out1 = %{&scan_win_and_get_sc_rate_pairs(\%input, \$window_size)};
# Function  : scans input sequences(arg1) in a given(arg2) window size and gets
#             each composition and sequence identity rate(sc_rate) of the window.
#             sc rate = Sequence Id(%)/ Composition Id(%)
# Example   : input hash: ( seq1,  'ABCDEFG.HIK',      (2 or more sequences accepted)
#                         seq2,  'DFD..ASDFAFS',
#                         seq3,  'DDDDD..ASDFAFS' );
#             input winsize : 5;
#
#             output hash; (seq1seq2, 1,2,2,2,1,1,2,2); <-- joined by ',';
#             output hash; (seq1seq3, 1,2,2,2,1,1,2,2); <-- joined by ',';
#                  The numbers are ratios(compos/seqid) with given window size.
# Warning   : when $seqid is zero  the rate becomes $compos_id/10   !!!
# Keywords  :
# Options   :
# Returns   : a reference of a hash.
# Argument  : One ref. for hash, one ref. for a scalar.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub scan_win_and_get_sc_rate_pairs{
	my($base_l)=1; my($scale)=1;
	my(%input, $i, $j, $window_size, $show_calculation, $redu_window,
	  $variable_win_size);
	for($i=0; $i < @_; $i ++){
	 if( (ref($_[$i])) eq 'HASH'  ){ %input=%{$_[$i]};}
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /^d+/)){ $window_size= ${$_[$i]}; }
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /^[vV]+/)){ $variable_win_size= 'v' }
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /[sS]+/)){ $show_calculation = 's'}
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /[rR]+/)){ $redu_window  = 'r'}
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /[fF]+/)){ $apply_factor  = 'f'}
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /[dD]+/)){ $make_gap_dot  = 'd'}
	 elsif( (ref($_[$i]) eq 'SCALAR' )&&(${$_[$i]} =~ /[mM]+/)){ $minus_whole_cs  = 'm'}
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^\d+/) ){ $window_size= $_[$i]; }
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^[vV]+/) ){ $variable_win_size = 'v'; }
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^[sS]+/) ){ $show_calculation  = 's'; }
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^[rR]+/) ){ $redu_window  = 'r'; }
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^[fF]+/) ){ $apply_factor  = 'f'; }
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^[dD]+/) ){ $make_gap_dot  = 'd'; }
	 elsif( (!(ref($_[$i])))&&($_[$i] =~ /^[mM]+/) ){ $minus_whole_cs  = 'm'; }
	}

	if(defined(${$_[2]})){ $base_l=${$_[2]}; }
	if(defined(${$_[3]})){ $scale =${$_[3]}; }
	my(@sequences, @out_rate, $title, $window_1, $window_2,
	  $ratio_compos_vs_seqid, @array_of_2_seq,%out_hash );
	my(@keys)= sort keys %input;
	for ($i=0; $i<@keys; $i++){    # putting sequences from hash to an array
	 for($j=$i+1; $j< @keys; $j++){
		push(@sequences, $input{$keys[$i]}, $input{$keys[$j]});

		######################################################################
		#################  PASSING OVER TO the next SUB routine ##############
		######################################################################
		#---> @sequences will have ('ABCDEFG.HIK', 'DFD..ASDFAFS'); ##########
		($out_rate_arr_ref,$whole_rate_ref)= &get_windows_sc_rate_array(

						\@sequences,\$window_size, $variable_win_size, \$apply_factor,
						\$redu_window, $make_gap_dot, $show_calculation, \$minus_whole_cs );

		undef(@sequences);
		@out_rate=@{$out_rate_arr_ref};
		$whole_rate=${$whole_rate_ref};
		$title = "$keys[$i]_$keys[$j]\($whole_rate\)";
		$out_hash{$title}=join(",", @out_rate);
	 }
	}
	return( \%out_hash );
}

#________________________________________________________________________
# Title     : get_windows_sc_rate_array
# Usage     : @out_rate = @{&get_windows_compos_and_seqid_rate_array(\@seq, \$win_size)};
# Function  : actual working part of scan_windows_and_get_compos_seqid_rate
# Example   :
# Warning   :
# Class     :
# Keywords  :
# Options   :
# Reference :
# Returns   : \@ratio_array, \$ratio_whole_seq
# Tips      :
# Argument  : (\@input, \$window_size);  @input => ('ABCDEFG.HIK', 'DFD..ASDFAFS', 'ASDFASDFASAS');
#             Input ar => ( 'ABCDEFG
#                'DFD..ASDFAFS'
#                'ASDFASDFASAS' )  as the name of  @sequences.
# Todo      :
# Author    : A Biomatic
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_windows_sc_rate_array{
	my($base_level)=1; my($scale)=1; my($window_size, $show_calculation, $redu_window,
	 @input, @input0, @input1, $variable_win_size, $apply_factor,
	 @ratio_array, @array_of_2_seq, $seq_id, $offset, $half_of_w_size, $length,
	 $compos_id, $seq_id, $window_2, $window_1, $compos_whole_seq, $seq_id_whole_seq,
	 $ratio_whole_seq, $win_rate_div_by_whole_rate, $normalizing_factor, $lowest_rate,
	 $winsize_reduc_factor, $largest_win_reached, $ori_win_size);

	#""""""""""""""""""""""< handle_arguments{ head Ver 1.3 >"""""""""""""""""""
	my(@A )=&handle_arguments( @_ );my( $num_opt )=${$A[7]};my( $char_opt )=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};my(@raw_string)=@{$A[9]};
	my($i, $j, $c, $d, $e, $f, $g, $h, $k, $l, $p, $q, $r, $s, $t, $u, $v, $w, $x,$y,$z);
	if($debug==1){ print "\n   \@hash has \"@hash\"\n   \@raw_string has   \"@raw_string\"
	\@array has \"@array\"\n   \@char_opt has   \"@char_opt\"\n   \@file has \"@file\"
	\@string has \"@string\""; }
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 if( $num_opt =~/^(d+)/){  $window_size= $1; }
	 if( $char_opt=~/v/i){  $variable_win_size= 'v' }
	 if( $char_opt=~/s/i){  $show_calculation = 's'}
	 if( $char_opt=~/r/i){  $redu_window  = 'r'}
	 if( $char_opt=~/f/i){  $apply_factor  = 'f'}
	 if( $char_opt=~/d/i){  $make_gap_dot  = 'd'}
	 if( $char_opt=~/m/i){  $minus_whole_cs  = 'm'}

	@input = @{$array[0]};
	if(defined(${$_[2]})){ $base_level =${$_[2]}; }
	if(defined(${$_[3]})){ $scale  =${$_[3]}; }

	for ($t=0; $t< @input; $t++){ $length=length($input[$t]) if(length($input[$t])>$length);}
	if ($length < $window_size){  $window_size = $length;   }
	 #___________ getting ratio for the whole sequence ___________

	$compos_whole_seq=${&main::compos_id_percent_array(\@input)};  ## for whole composition rate
	$seq_id_whole_seq=${&main::seq_id_percent_array(\@input)};
	print "\nComposition ID of the alignment:  $compos_whole_seq\%\n";
	print "Sequence    ID of the alignment:  $seq_id_whole_seq\%\n";
	if ($seq_id_whole_seq == 0){  $ratio_whole_seq =0; }
	else{  $ratio_whole_seq = $compos_whole_seq/$seq_id_whole_seq;  }
	print "Composition and Sequ.  ID Ratio:   $ratio_whole_seq\n";

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	##########   Initial Window size setting      ##############################
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if   (  $ratio_whole_seq >9 ){ $window_size= 28; } # $ratio_whole_seq is
	elsif(  $ratio_whole_seq >8 ){ $window_size= 26; } # a whole CS rate !!
	elsif(  $ratio_whole_seq >7 ){ $window_size= 24; }
	elsif(  $ratio_whole_seq >6 ){ $window_size= 22; }
	elsif(  $ratio_whole_seq >5 ){ $window_size= 20; }
	elsif(  $ratio_whole_seq >4 ){ $window_size= 18; }
	elsif(  $ratio_whole_seq >3 ){ $window_size= 16; }
	elsif(  $ratio_whole_seq >2 ){ $window_size= 12; }
	elsif(  $ratio_whole_seq >0 ){ $window_size= 8; }

	print "Window size used is :  $window_size\n";
	#$window_size = 10;
	$largest_win_reached = 24;
	$ori_win_size        = $window_size;

	#----------- Spliting the seq. into arrays to enable $make_gap_dot var -----
	if( $make_gap_dot =~ /^[dD]+/){
	 $input[0] =~s/,//g;             $input[1] =~s/,//g;
	 @input0 = split('', $input[0]); @input1 = split('', $input[1]);
	}

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#        MAIN Calc part
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	for ($w=0; $w < $length; $w++){

	 $largest_win_reached = $window_size if $window_size > $largest_win_reached;

	 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ###          FACTOR calculation                                    ##
	 #####################################################################
	 $factor= ($window_size/40)*2  if ($apply_factor eq 'f');

	 #####################################################################
	 ##       Turn RATES to DOTs when there are gaps                    ##
	 #####################################################################
	 # @input0, @input1 are the whole length sequence splited.
	 if($make_gap_dot =~ /^[dD]+/){
		if( ($input0[$w] eq '.') || ($input1[$w] eq '.') ){
		  $ratio_compos_vs_seqid = '.';
		  push(@ratio_array, $ratio_compos_vs_seqid);
	  next;
	}
	 }

	 #####################################################################
	 ###               Getting small windows                            ##
	 #####################################################################
	 $offset = $w - int($window_size/2); # $offset starts from -5 when window_size is 10.
	 $offset = 0 if ($offset < 0);
	 if($variable_win_size ne 'v'){ $window_size = $ori_win_size;}
	 $window_1=substr($input[0], $offset, $window_size);  # window_1 is one segment
	 $window_2=substr($input[1], $offset, $window_size);  # of defined length(size)
	 @array_of_2_seq=($window_1, $window_2);

	 #####################################################################
	 ##      This is to remove the common gaps in the two windows       ##
	 #####################################################################
	 ($win_no_gap1, $win_no_gap2) = @{&main::remov_com_column(\@array_of_2_seq)};

	 #####################################################################
	 ##      Go back if the window size is too small due to gaps        ##
	 #####################################################################
	 if( (length($win_no_gap1) < $ori_win_size)&&($variable_win_size ==1) )
	 {
		$window_size+=1; $w--; next;
	 }

	 #####################################################################
	 ##      Getting Compos and Seq ids                                 ##
	 #####################################################################
	 $compos_id=${&main::compos_id_percent_array(\@array_of_2_seq)};
	 $seq_id   =${&main::seq_id_percent_array(\@array_of_2_seq)};


	 #####################################################################
	 ####    Go back if the Seq id is bigger than Compos id        #######
	 #####################################################################
	 if(($variable_win_size eq 'v') && ($seq_id >  $compos_id))
	 {
		$window_size+=1;  $w--;   next;
	 }

	 #####################################################################
	 ####   Special ID value handling                              #######
	 #####################################################################
	 if   (($seq_id    == 0  ) || ($compos_id == 0)){ $compos_id = 1;}


	 #####################################################################
	 ####     The actual calculation                               #######
	 #####################################################################
	 if(  $minus_whole_cs  eq 'm' ){  ### this substracts rates with whole CS rate
	   $ratio_compos_vs_seqid = int( $seq_id/$compos_id*10 - $ratio_whole_seq );
	   if( $ratio_compos_vs_seqid <= 0){ $ratio_compos_vs_seqid =0; }
	   if( $ratio_compos_vs_seqid > 9){ $ratio_compos_vs_seqid = 9; }
	   if( ($apply_factor eq 'f')&&($variable_win_size eq 'v') ){
		  $ratio_compos_vs_seqid =int($ratio_compos_vs_seqid * $factor); }   }
	 else{
		$ratio_compos_vs_seqid = int($seq_id/$compos_id*10);
		if( ($apply_factor eq 'f')&&($variable_win_size eq 'v') ){
		   $ratio_compos_vs_seqid =int($ratio_compos_vs_seqid * $factor); }
		if( $ratio_compos_vs_seqid > 9){ $ratio_compos_vs_seqid = 9; }
	 }

	 #$ratio_compos_vs_seqid =int(($seq_id/$compos_id)*10-$factor);}
	 #$seq_id/abs($seq_id-$compos_id+0.1)*


	 #####################################################################
	 #######       OUT of the loop (at the near to the end  ##############
	 #####################################################################
	 if( ($w + $window_size/3) > $length ){ $ratio_compos_vs_seqid='.'; }


	 #####################################################################
	 ####    When 's'how option is set(defined at prompt)          #######
	 #####################################################################
	 if( $show_calculation eq 's' ){
		printf ("SC=%-4s %-45s Seq=%-3.2s Compos=%-3.2s W=%-2s F=%-2s\n",
			  $ratio_compos_vs_seqid, $win_no_gap1,$seq_id, $compos_id, $window_size, $factor);
		printf ("        %-45s \n\n", $win_no_gap2);
	 }

	 #####################################################################
	 # Reducing increased window size according to SC rate (option 'r') ##
	 #####################################################################
	 if( ($variable_win_size eq 'v')&&($redu_window eq 'r') ){
		if( $window_size > $ori_win_size ){
	   if( $window_size > ($length/2)){ print chr(7);
	      print "\n The increased window size is over half of seq. suspicious !! \n";
	      print "\n Disable 'v' (for variable window size), at prompt and run again\n\n";
	   }
		   $window_size -= ($winsize_reduc_factor);
		   if   ($ratio_compos_vs_seqid > 7) { $winsize_reduc_factor = 3; }
		   elsif($ratio_compos_vs_seqid >  5){ $winsize_reduc_factor = 2; }
		   elsif($ratio_compos_vs_seqid >  3){ $winsize_reduc_factor = 1; }
		   elsif($ratio_compos_vs_seqid == 3){ $winsize_reduc_factor = -0.2; }
		   elsif($ratio_compos_vs_seqid == 2){ $winsize_reduc_factor = -0.4; } # This will increase the winsize
		   elsif($ratio_compos_vs_seqid == 1){ $winsize_reduc_factor = -0.8; }
		   elsif($ratio_compos_vs_seqid == 0){ $winsize_reduc_factor = -1.6; }
	}
	 }
	 push(@ratio_array, $ratio_compos_vs_seqid);
	}
	#############################################################################
	#######     FINAL outputs, 2 types                                ###########
	#############################################################################
	$ratio_whole_seq=int($ratio_whole_seq);
	return( \@ratio_array, \$ratio_whole_seq);  package main;
}


#________________________________________________________________________
# Title     : scan_win_and_get_cs_rate_pairs
# Usage     : %out1 = %{&scan_win_and_get_cs_rate_pairs(\%input, \$window_size)};
# Function  : scans input sequences(arg1) in a given(arg2) window size and gets
#             each composition and sequence identity rate(cs_rate) of the window.
#             CS rate = Composition Id / Sequence Id
# Example   :     input hash: ( seq1,  'ABCDEFG.HIK',      (2 or more sequences accepted)
#                               seq2,  'DFD..ASDFAFS',
#                               seq3,  'DDDDD..ASDFAFS' );
#                 input winsize : 5;
#
#                 output hash; (seq1seq2, 1,2,2,2,1,1,2,2); <-- joined by ',';
#                 output hash; (seq1seq3, 1,2,2,2,1,1,2,2); <-- joined by ',';
#             The numbers are ratios(compos/seqid) with given window size.
#
# Warning   : when $seqid is zero  the rate becomes $compos_id/10   !!!
# Keywords  :
# Options   :
# Returns   : a reference of a hash.
#             It is getting the entropy of the column and calculates something after.
# Argument  : One ref. for hash, one ref. for a scalar.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub scan_win_and_get_cs_rate_pairs{
	my($base_l)=1;
	my($scale)=1;   # these are default params.
	my(%input)=%{$_[0]};
	my($window_size)=${$_[1]};

	if(defined(${$_[2]})){ $base_l=${$_[2]}; } ### <---$base_c is the baseline controller for sensitivity.
	if(defined(${$_[3]})){ $scale =${$_[3]}; } ### <---$base_c is the baseline controller for sensitivity.

	my(@sequences, @out_rate, $i, $j, $title, $window_1, $window_2,
	  $ratio_compos_vs_seqid, @array_of_2_seq,  %out_hash, $whole_rate );
	my(@keys)= keys %input;

	for ($i=0; $i < @keys; $i++){    # putting sequences from hash to an array
	 for($j=$i+1; $j < @keys; $j++){
		push(@sequences, $input{$keys[$i]}, $input{$keys[$j]});
		#---> @sequences will have ('ABCDEFG.HIK', 'DFD..ASDFAFS'); ##########
		($out_rate_arr_ref,$whole_rate_ref)
			 = &get_windows_cs_rate_array(\@sequences,\$window_size,\$base_l,\$scale);
		undef(@sequences);
		@out_rate=@{$out_rate_arr_ref};
		$whole_rate=${$whole_rate_ref};
		$title="$keys[$i]_$keys[$j]\($whole_rate\)";
		$out_hash{$title}=join(",", @out_rate);
	 }
	}
	return( \%out_hash );
}
#________________________________________________________________________
# Title     : get_residue_error_rate  (used in get_posi_rates_hash_out)
# Usage     : %position_diffs =%{&get_residue_error_rate(\@seq_position1, \@seq_position2)};
# Function  : This is the final step in error rate getting.
#             gets a ref. of a hash and calculates the absolute position diffs.
# Example   :
# Warning   : split and join char is ',';
# Keywords  :
# Options   : 'L' for limitting the error rate to 9 to make one digit output
#  $LIMIT becomes 'L' by L, l, -l, -L
# Returns   : one ref. for an array of differences of input arrays. array context.
#             ---Example input (a hash with sequences); The values are differences after
#                                comparion with structural and sequential alignments.
#             %diffs =('seq1', '117742433441...000',   <-- input (can be speparated by '' or ','.
#                      'seq2', '12222...99999.8888',
#                      'seq3', '66222...44444.8822',
#                      'seq4', '12262...00666.772.');
#             example output;
#             seq3_seq4       '0,1,0,0,0,.,.,.,,.,0,,0,0,,0,0,,.,0,,0,0,.'
#             seq1_seq2       '0,1,0,1,1,.,.,.,,.,2,,2,2,,2,2,,.,.,,2,2,1'
#             seq1_seq3       '0,1,0,1,1,.,.,.,,.,1,,1,1,,0,.,,.,.,,1,1,1'
#             seq1_seq4       '0,1,0,,1,1,.,.,.,,.,1,,1,1,0,.,.,,.,1,,2,2'
#             seq2_seq3       '0,1,0,,0,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,0'
#             seq2_seq4       '0,0,0,,1,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,.'
# Argument  : Takes a ref. for hash which have positions of residues of sequences.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_residue_error_rate{
	my ($LIMIT);
	my(%diffs)= %{$_[0]}; my(@names)= keys (%diffs);
	$LIMIT=${$_[1]} if ref($_[1]) eq 'SCALAR';
	$LIMIT= $_[1] unless ref($_[1]);
	my(%seqs_comp_in_pair, @temp, @temp2,$split_char, $i);
	for ($i=0; $i < @names; $i++){
		if($diffs{$names[$i]}=~/\,/){ $split_char =',';}else{ $split_char = ''; }
		(@{"string$i"}) = split(/$split_char/, $diffs{$names[$i]});   }
	for ($i=0; $i < @names; $i++){
		for ($j=$i+1; $j < @names; $j ++){
			for ($k=0; $k < @string0; $k++){
				if ((${"string$i"}[$k] =~ /[-\d+]/) && (${"string$j"}[$k] =~ /[-\d+]/)){
					my($diff) = abs(${"string$i"}[$k] - ${"string$j"}[$k]);
					if( ($LIMIT =~/L/i)&&($diff > 9) ){ push(@temp2, 9);
					}else{ push(@temp2, $diff); }
				}else{ push(@temp2, '.'); } }

			#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			#  Following if {} is for sorting output names to make  2aaa_6taa than 6taa_2aaa
			#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			if($names[$i] <= $names[$j]){
				$seqs_comp_in_pair{"$names[$i]\_$names[$j]"}=join(",", @temp2); }
			else{ $seqs_comp_in_pair{"$names[$j]\_$names[$i]"}=join(",", @temp2); }

			@temp2=();
		}
	 }
	 return(\%seqs_comp_in_pair);  # permutated
}



#___________________________________________________________________________________
# Title     : get_each_posi_diff_hash , next version is  get_residue_error_rate
# Usage     : %position_diffs =%{&get_each_posi_diff_hash(\@seq_position1, \@seq_position2)};
# Function  : This is the final step in error rate getting.
#             gets a ref. of a hash and calculates the position diffs.
# Example   :
# Warning   : split and join char is ',';
# Keywords  :
# Options   : 'L' for limitting the error rate to 9 to make one digit output
#  $LIMIT becomes 'L' by L, l, -l, -L
#
# Returns   : one ref. for an array of differences of input arrays. array context.
#             ---Example input (a hash with sequences); The values are differences after
#                                comparion with structural and sequential alignments.
#             %diffs =('seq1', '117742433441...000',   <-- input (can be speparated by '' or ','.
#                      'seq2', '12222...99999.8888',
#                      'seq3', '66222...44444.8822',
#                      'seq4', '12262...00666.772.');
#             example output;
#             seq3_seq4       '0,1,0,0,0,.,.,.,,.,0,,0,0,,0,0,,.,0,,0,0,.'
#             seq1_seq2       '0,1,0,1,1,.,.,.,,.,2,,2,2,,2,2,,.,.,,2,2,1'
#             seq1_seq3       '0,1,0,1,1,.,.,.,,.,1,,1,1,,0,.,,.,.,,1,1,1'
#             seq1_seq4       '0,1,0,,1,1,.,.,.,,.,1,,1,1,0,.,.,,.,1,,2,2'
#             seq2_seq3       '0,1,0,,0,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,0'
#             seq2_seq4       '0,0,0,,1,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,.'
# Argument  : Takes a ref. for hash which have positions of residues of sequences.
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------------
sub get_each_posi_diff_hash{
	my(%diffs)= %{$_[0]}; my(@names)= keys (%diffs);
	my(%seqs_comp_in_pair, @temp, @temp2,$split_char, $i);
	my($LIMIT)=${$_[1]} if ref($_[1]) eq 'SCALAR';
				$LIMIT= $_[1] unless ref($_[1]);
	for ($i=0; $i < @names; $i++){
		if($diffs{$names[$i]}=~/\,/){ $split_char =',';}else{ $split_char = ''; }
		(@{"string$i"}) = split(/$split_char/, $diffs{$names[$i]});   }
	for ($i=0; $i < @names; $i++){
		for ($j=$i+1; $j < @names; $j ++){
			for ($k=0; $k < @string0; $k++){
				if ((${"string$i"}[$k] =~ /[-\d+]/) && (${"string$j"}[$k] =~ /[-\d+]/)){
					my($diff) = abs(${"string$i"}[$k] - ${"string$j"}[$k]);
					if( ($LIMIT =~/L/i)&&($diff > 9) ){ push(@temp2, 9);
					}else{ push(@temp2, $diff); }
				}else{ push(@temp2, '.'); } }

			#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			#  Following if {} is for sorting output names to make  2aaa_6taa than 6taa_2aaa
			#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			if($names[$i] <= $names[$j]){
				$seqs_comp_in_pair{"$names[$i]\_$names[$j]"}=join(",", @temp2); }
			else{ $seqs_comp_in_pair{"$names[$j]\_$names[$i]"}=join(",", @temp2); }

			@temp2=();
		}
	 }
	return(\%seqs_comp_in_pair);  # permutated
}

#________________________________________________________________________
# Title     : get_posi_rates_hash_out (derived from 'get_posi_shift_hash' )
# Usage     : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
# Function  : This is to get position specific error rate for line display rather than
#             actual final error rate for the alignment.
#             Output >>
#             seq1_seq2  1110...222...2222
#             seq2_seq3  1111....10...1111
#             seq1_seq3  1111....0000.0000
#
# Example   :
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   :
# Returns   : \%final_posi_diffs;
# Argument  : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
#             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_posi_rates_hash_out{
	my(%array1)=%{$_[0]};
	my(%array2)=%{$_[1]};
	my(@string1,@string2,@seq_position1,@seq_position2,
	  $len_of_seq,@position_diffs, @position_corrected1,
	  @names, @whole_length, %array3, $name);
	%array1 = %{&hash_common_by_keys(\%array1, \%array2)};
	%array2 = %{&hash_common_by_keys(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)};
	%array2 = %{&remov_com_column(\%array2)};
	@names=  sort keys %array2;

	for $name (@names){
	  @string1 =split(//, $array1{$name});
	  @string2 =split(//, $array2{$name});
	  @seq_position1 = @{&get_posi_sans_gaps(\$array1{$name})};
	  @seq_position2 = @{&get_posi_sans_gaps(\$array2{$name})};
	  $len_of_seq = @seq_position2;
	  push(@whole_length, $len_of_seq);
	  @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
	  @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
	  $array3{$name}=join(",", @position_corrected1);
	}

	my(%final_posi_diffs)=%{&get_each_posi_diff_hash(\%array3)};
	@whole_length=();
	$len_of_seq='';
	return(\%final_posi_diffs);
}

#________________________________________________________________________
# Title     : get_posi_rates_hash_out_compact (derived from 'get_posi_shift_hash' )
# Usage     : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
# Function  : This is to get position specific error rate for line display rather than
#             actual final error rate for the alignment.
#             Output >>  something like below but, without gaps, so final one is;
#             seq1_seq2  1110...222...2222     seq1_seq2  11102222222
#             seq2_seq3  1111....10...1111  -> seq2_seq3  1111101111
#             seq1_seq3  1111....0000.0000     seq1_seq3  111100000000
#
# Example   :
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   :
# Returns   : \%final_posi_diffs_compact;  Compare with  'get_posi_rates_hash_out_jp'
# Argument  : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
#             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_posi_rates_hash_out_compact{
	my(%array1)=%{$_[0]};  my(%array2)=%{$_[1]};
	my(@string1,@string2,@seq_position1,@seq_position2,$len_of_seq,@position_diffs,
	  @position_corrected1,@names, @whole_length, %array3);
	%array1 = %{&hash_common_by_keys(\%array1, \%array2)};
	%array2 = %{&hash_common_by_keys(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)};
	%array2 = %{&remov_com_column(\%array2)};
	@names= keys %array2;
	for $name (@names){
	  @string1 =split('', $array1{$name});  @string2 =split('', $array2{$name});
	  @seq_position1 = @{&get_posi_sans_gaps(\$array1{$name})};
	  @seq_position2 = @{&get_posi_sans_gaps(\$array2{$name})};
	  $len_of_seq =(@seq_position2);  push(@whole_length, $len_of_seq);
	  @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
	  $array3{$name}=join(",", @position_diffs);
	}
	my(%final_posi_diffs_compact)=%{&get_each_posi_diff_hash(\%array3)};
	@whole_length=();
	$len_of_seq='';
	return(\%final_posi_diffs_compact);
}
#________________________________________________________________________
# Title     : get_posi_rates_hash_out_jp (derived from 'get_posi_shift_hash' )
# Usage     : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
# Function  : This is to get position specific error rate for line display rather than
#             actual final error rate for the alignment. get_posi_rates_hash_out_jp
#             results in jp template sequence, while get_posi_rates_hash_out_msf does
#             in msf template sequence.
#             Output >>
#             seq1_seq2  1110...222...2222   <--- the alignment template is JPO's
#             seq2_seq3  1111....10...1111        (ie structural)
#             seq1_seq3  1111....0000.0000
#
# Example   :
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   :
# Returns   : \%final_posi_diffs;
# Argument  : %{&get_posi_rates_hash_out_jp(\%msfo_file, \%jpo_file)};
#             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_posi_rates_hash_out_jp{ my(%array1)=%{$_[0]};  my(%array2)=%{$_[1]};
	my(@string1,@string2,@seq_position1,@seq_position2,$len_of_seq,@position_diffs,
	  @position_corrected1,@names, @whole_length, %array3);
	%array1 = %{&hash_common_by_keys(\%array1, \%array2)}; %array2 = %{&hash_common_by_keys(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)};              %array2 = %{&remov_com_column(\%array2)};
	@names= keys %array2;
	for $name (@names){
	  @string1 =split('', $array1{$name});  @string2 =split('', $array2{$name});
	  @seq_position1 = @{&get_posi_sans_gaps(\$array1{$name})}; @seq_position2 = @{&get_posi_sans_gaps(\$array2{$name})};
	  $len_of_seq =(@seq_position2);  push(@whole_length, $len_of_seq);
	  @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
	  @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
	  $array3{$name}=join(",", @position_corrected1);
	}
	my(%final_posi_diffs)=%{&get_each_posi_diff_hash(\%array3)};
	@whole_length=();
	$len_of_seq='';
	return(\%final_posi_diffs);
}



#________________________________________________________________________
# Title     : get_posi_rates_hash_out (derived from 'get_posi_shift_hash' )
# Usage     : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
# Function  : This is to get position specific error rate for line display rather than
#             actual final error rate for the alignment.
# Example   :
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   :
# Returns   : \%final_posi_diffs;
# Argument  : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
#             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
#             Output >>
#             seq1_seq2  1110...222...2222
#             seq2_seq3  1111....10...1111
#             seq1_seq3  1111....0000.0000
#
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_rates_hash_out_msf{
	my(%array1)=%{$_[0]};
	my(%array2)=%{$_[1]};
	my(@string1, @string2, @seq_position1, @seq_position2,
	  $len_of_seq,@position_diffs, @position_corrected1,
	  @names, @whole_length, %array3, $name);
	%array1 = %{&hash_common_by_keys(\%array1, \%array2)};
	%array2 = %{&hash_common_by_keys(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)};
	%array2 = %{&remov_com_column(\%array2)};
	@names= keys %array2;
	for $name (@names){
	  @string1 =split(/|\,/, $array1{$name});
	  @string2 =split(/|\,/, $array2{$name});
	  @seq_position1 = @{&get_posi_sans_gaps(\$array1{$name})};
	  @seq_position2 = @{&get_posi_sans_gaps(\$array2{$name})};
	  $len_of_seq =(@seq_position2);
	  push(@whole_length, $len_of_seq);
	  @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
	  @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
	  $array3{$name}=join(",", @position_corrected1);
	}
	my(%final_posi_diffs)=%{&get_each_posi_diff_hash(\%array3)};
    @whole_length=(); $len_of_seq='';
	# show_hash(\%final_posi_diffs);
	return(\%final_posi_diffs);
}


#__________________________________________________________________________
# Title     : normalize_columns
# Usage     : @out=@{&normalize_columns(\@input_line_array, <column num>)};
# Function  : normalize the columns specified by the given range information
#             It finds the min and max and scalces them to the ranges
#             given
# Example   : normalize_columns.pl 3 xxxx.msp
#               Above will sort the file xxxx.msp by its 3rd column(numerically)
#               small numbers will come to the top.
# Keywords  : normalize_by_2nd_column, normalize_by_second_column, normalize_by_e_values,
#             normalize_by_evalues, normalise_column scale_column_numbers
#             normalize_numbers_in_column
# Options   :
#   $column_to_use= by c=    # c=1
#   $Columns_to_use= by C=   # C=1,3,4
#   $given_range= by r=
#   $write_output_file=w by w
#   $write_sum_of_columns=S by S
#   $NO_write_on_SCREEN=q by q
#
# Version   : 1.0
#----------------------------------------------------------------------------
sub normalize_columns{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (%whole, $previous, @out, @v_keys, %sum_of_colmuns, @columns, $get_SUM_of_columns, $len,
        $file, $q, $x, $troubled_column, $max_column_number, $range, $given_range,
        $write_sum_of_columns );
    $len =4;
    @v_keys= sort keys %vars; ## To be able to exchange order of column.
    if($vars{'C'}=~/(\S+)/i){  @columns=split(/\W+/, $1);    }
    if($vars{'c'}=~/(\S+)/i){  @columns=$1;    }
    if($vars{'r'}=~/(\S+)/){  $given_range=$1; }

    unless($given_range){ die "\n !!! normalize_columns needs a given range to scale numbers in \n\n"; }

    $max_column_number=${&get_largest_element(\@columns)};

    if((@num_opt==0)&&(@file>1)){ $combine=1 }; # when no column num. is given assume $combine

    ###### File is given as input #######""""""""""""""""""""""""""""""""""""""
    if((@file >=1)&&(@array < 1)){
       for $file(@file){
         my ($line_num, $line_read, $line_counter, @all_lines);
         my $change=0.1;
         open(IN, "$file");
         @all_lines=<IN>;

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Initializing the MIN and MAX
         #_________________________________________________
         @splited_initial=split(/\s+/, $all_lines[0]);
         if($max_column_number > @splited_initial){
             die "\n There are columns less than \$max_column_number : $max_column_number\n\n";
         }
         for($i=0; $i< @splited_initial; $i++){
             $column_min_max{$i}{'MAX'}=-999999999999999999999;
             $column_min_max{$i}{'MIN'}= 999999999999999999999;
         }
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Get the max and min values in the columns
         #______________________________________________
         for($q=0; $q < @all_lines; $q++){ # This open is only for getting largest column width size
             @splited=split(/\s+/, $all_lines[$q]);
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # If you set column size 3 to parse and the file has only 2 columns, I remove the line
             #________________________________________________________________________________________
             if(@splited < $max_column_number){
                 splice(@all_lines, $q, 1);
                 next;
             }
             for($i=0; $i< @splited; $i++){
                 if($column_min_max{$i}{'MAX'} < $splited[$i]){
                    $column_min_max{$i}{'MAX'} = $splited[$i];
                 }
                 if($column_min_max{$i}{'MIN'} > $splited[$i]){
                    $column_min_max{$i}{'MIN'} = $splited[$i];
                 }
             }
             $l=${&get_longest_str_size(\@splited)};
         }                                          # consistency and stops after some
         close(IN);
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Initializing the MIN and MAX
         #_________________________________________________
         @splited_initial=split(/\s+/, $all_lines[0]);
         for($i=0; $i< @splited_initial; $i++){
             $column_min_max{$i}{'RANGE'}=abs($column_min_max{$i}{'MAX'}-$column_min_max{$i}{'MIN'});
         }

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Reverse LINE order if -r option is set
         #_____________________________________________
         if($reverse_line_order){    @all_lines=reverse(@all_lines);         }

         for($x=0; $x < @all_lines; $x++){
            if($all_lines[$x]=~/^[\t \#]*$/){ next }  # skipping blank line and comment lines
            if($all_lines[$x]=~/^ {1,2}#/){ next }  # skipping  comment lines
            $line_counter++;
            if(($char_opt=~/n/i)&&($line_counter==1)){ next } ## NO title #
            if(@M=$all_lines[$x]=~/(\S+)/g){
               if(@columns < 1){
                 for($n=0; $n< @M; $n++){  $columns[$n]=$n+1;    }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  unless($M[$col]=~/\S/){ next };
                  $normalized=$M[$col]/$column_min_max{$col}{'RANGE'} * $given_range;
                  #print "\n $M[$col] $normalized\n";
                  if( defined(${"max$col"}) and defined(${"min$col"}) ){ # when max or min is defined
                        if( ( ${"max$col"}  > $normalized)&&
                       ( ${"min$col"}  < $normalized) ){
                             printf "%-${len}s ",$normalized;
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $normalized ){
                             printf "%-${len}s ",$normalized;
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $normalized ){
                            printf "%-${len}s ",$normalized;
                        }else{
                            printf "%-${len}s ";
                        }
                  }else{
                        printf "%-${len}s ", $normalized;
                  }
                  $sum_of_colmuns{$col} +=$normalized;
              }
           }
           print "\n";
        } #for

      }
    }    ###### Array is given as input #######""""""""""""""""""""""""""""""""""
    elsif(@array>0){  # if input is ('x y xx y','k t yy zz',,,,)
      for($t=0; $t<@array; $t++){
         my @arr=@{$array[$t]};
         #print "\n Array input\n" if $debug ==1;
         for($i=0; $i<@arr;$i++){
           @splited=split(/\s+/,$arr[$i]);
           $l=${&get_longest_str_size(\@splited)};
           $len=$l if $l>$len;
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Reverse LINE order if r option is set
        #_____________________________________________
        if($reverse_line_order){
           @arr=reverse(@arr);
        }
        for($i=0; $i< @arr; $i++){
            if($arr[$i]=~/^\s*$/){ splice(@arr, $i, 1); $i--; next }
            if(($char_opt=~/n/i)&&($i==0)){ next } # skipping the first line
            if(@M=$all_lines[$x]=~/(\S+)/g){
               if(@columns < 1){
                 for($n=0; $n< @M; $n++){  $columns[$n]=$n+1;    }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  unless($M[$col]=~/\S/){ next };
                  $normalized=$M[$col]/$range * $given_range;
                  if( defined(${"max$col"}) and defined(${"min$col"}) ){ # when max or min is defined
                        if( ( ${"max$col"}  > $normalized)&&
                       ( ${"min$col"}  < $normalized) ){
                             printf "%-${len}s ",$normalized;
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $normalized ){
                             printf "%-${len}s ",$normalized;
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $normalized ){
                            printf "%-${len}s ",$normalized;
                        }else{
                            printf "%-${len}s ";
                        }
                  }else{
                        printf "%-${len}s ", $normalized;
                  }
                  $sum_of_colmuns{$col} +=$normalized;
              }
           }
           print "\n";
        }
      }
    }  ##### Hash is given as input #######""""""""""""""""""""""""""""""""""
    elsif(@hash>0){
      my @arr;
      for($h=0; $h<@hash; $h++){
          my @array=values %{$hash[$h]};
          my @keys =keys %{$hash[$h]};
          for($i=0; $i< @array; $i++){ # getting the longest str size
             @arr=split(/\s+/,$array[$i]);
             $l=${&get_longest_str_size(\@arr)};
             $len=$l if $l>$len;
          }

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Reverse LINE order if r option is set
          #_____________________________________________
          if($reverse_line_order){
             @array=reverse(@array);
          }
          for($i=0; $i< @array; $i++){
            if($array[$i]=~/^\s*$/){ splice(@array, $i, 1); $i--; next }
            if(($char_opt=~/n/i)&&($i==0)){ next } #  skipping the first line
            printf "%-10s", $keys[$i] if($char_opt=~/k/i); ## Option for key printing
            if(@M=$all_lines[$x]=~/(\S+)/g){
               if(@columns < 1){
                 for($n=0; $n< @M; $n++){  $columns[$n]=$n+1;    }
               }
               for($r=0; $r< @columns; $r++){ # columns is from num_opt which is given at prompt (like 3 2 1)
                  $col =$columns[$r]-1;  #
                  unless($M[$col]=~/\S/){ next };
                  $normalized=$M[$col]/$range * $given_range;
                  if( defined(${"max$col"}) and defined(${"min$col"}) ){ # when max or min is defined
                        if( ( ${"max$col"}  > $normalized)&&
                       ( ${"min$col"}  < $normalized) ){
                             printf "%-${len}s ",$normalized;
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"max$col"}) ){ #--- When max and min are not defined.----#
                        if(  ${"max$col"} > $normalized ){
                             printf "%-${len}s ",$normalized;
                        }else{
                             printf "%-${len}s ";
                        }
                  }elsif( defined(${"min$col"}) ){
                        if(  ${"min$col"} < $normalized ){
                            printf "%-${len}s ",$normalized;
                        }else{
                            printf "%-${len}s ";
                        }
                  }else{
                        printf "%-${len}s ", $normalized;
                  }
                  $sum_of_colmuns{$col} +=$normalized;
              }
           }
           print "\n";
         }
      }
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Writing down the SUM line
    #___________________________________________________
    if($write_sum_of_columns){
        print "The sum of the columns\' numbers only is:\n\n";
        for($r=0; $r< @columns; $r++){
           $col =$columns[$r]-1;  #
           printf "%-${len}s ", $sum_of_colmuns{$col};
        }
        print "\n\n";
    }
}



#________________________________________________________________________
# Title     : normalize_numbers_in_array ( from any numbers to  0 - 9 )
# Usage     : @output=@{&normalize_numbers(\@array, [(1, 9)])};
#             originally made to normalize the result of get_posi_rates_hash_out
#             in   'scan_compos_and_seqid.pl'
#             As an option you can give the scale range (in case where the
#              given elements do not have preffered MIN and MAX while you
#              have to scale them to the MIN and MAX.
# Function  :
#
# Example   :
# Warning   :
# Keywords  : normalize_array_elements, normalise_array_elements,
#             normalise_numbers_in_array
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub normalize_numbers_in_array{
    my(@in, @out, $min, $max, $abs_min, $normalized, @range_scale);
    $min=10000000000000;
    $max=-1000000000000;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Get the input array or string of digits. If it is string, the delimiter should be \W
    #__________________________________________________________________________________________
    if(ref($_[0]) eq 'ARRAY'){ @in=@{$_[0]};                      #  eg> (10, 30, 40, 41)
    }elsif(ref($_[0]) eq 'SCALAR'){ @in=split(/\W+/, ${$_[0]}) ;  #  eg>  '20 30 40 77'
    }else{ @in=split(/\W+/, $_[0]) }                                 #  eg>  '10 30 40 88'

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # You can specify the range min and max(range scale) as 2nd arg
    #_________________________________________________________________
    if(ref($_[1]) eq 'ARRAY'){ ($min, $max)=@{$_[0]};             # eg> (1, 100)
    }elsif(ref($_[1]) eq 'SCALAR' and ${$_[0]}=~/^([\-\d+]\s+[\-\d+])$/){
         ($min, $max)  =split(/\s+/, $1);                         # eg> '1 100' ref.
    }else{ ($min, $max)=split(/\s+/, $_[1]) }                     # eg> '1 100'

    for(@in){
       if($_ > $max){
          $max=$_;
       }elsif($_ <$min){
          $min=$_;
       }
    }
    if(($max-$min)==0){ $range = 1; $uniform_elements=1; } else { $range= ($max -$min) };
    if($uniform_elements){
        for ($i=0; $i<@in; $i++){
           $out[$i]=5; ### everything is 5 !
        }
    }else{
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # There are 2 cases. One is when min is negative. The other when it is positive
        #___________________________________________________________________________________
        $abs_min=abs($min);
        if($min < 0){
            for (@in){
               $each_digit_adjusted=$_ + $abs_min;
               $normalized = int( ($each_digit_adjusted / $range)* 9);
               push(@out, $normalized);
            }
        }else{
            for (@in){
               $each_digit_adjusted=$_ - $abs_min;
               $normalized = int( ($each_digit_adjusted / $range)* 9);
               push(@out, $normalized);
            }
        }
    }
    return(\@out);
}





#________________________________________________________________________
# Title     : normalize_numbers ( from any numbers to  0 - 9 )
# Usage     : %output=%{&normalize_numbers(\%hash1)};
#             originally made to normalize the result of get_posi_rates_hash_out
#             in   'scan_compos_and_seqid.pl'
# Function  : with given numbers in hashes, it makes a scale of 0-9 and puts
#             all the elements in the scale. Also returns the average of the numbs.
# Example   : intputhash>                   Outputhash>
#             ('1-2', '12,.,1,2,3,4',     ( '1-2',   '9,.,0,1,2,3',
#              '2-3', '12,.,1,5,3,4',       '2-3',   '9,.,0,4,2,3',
#              '4-3', '12,3,1,2,3,4',       '3-1',   '9,3,.,.,2,3',
#              '3-1', '12,4,.,.,3,4' );     '4-3',   '9,2,0,1,2,3' );
# Warning   :
# Keywords  :
# Options   :
# Returns   : (\%norm_hash1, \%norm_hash2, \%norm_hash3,.... )
#
# Argument  : (\%hash1, %hash2, \%hash3, ....)
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub normalize_numbers{
	my(@in)=@_;
	my($split_char)=',';
	my(@out_ref_of_hash, $min, $max, $name, $u,$sum, $av, $range, @num_array,%in);
	($min, $max, $sum, $av)=&main::hash_stat_for_all(@in);
	if(($max-$min)==0){ $range = 1} else { $range= ($max -$min) };
	for ($u=0; $u< @in ; $u++){
	  %in=%{$_[$u]};
	  my(@keys) = keys %in;
	  if($in{$keys[0]}=~/\,/){ $split_char=','; }  else { $split_char=''; };
	  for $name (@keys){  @num_array = split(/$split_char/, $in{$name});
		  for (@num_array){ $_ = int(($_ / $range)*8) if ($_ =~ /[\-]*\d+/); }
		  $in{$name}=join("$split_char", @num_array); }
	  push(@out_ref_of_hash, \%in);  }
	if( @out_ref_of_hash == 1)  {  return( $out_ref_of_hash[0]); }
	elsif( @out_ref_of_hash > 1){  return( @out_ref_of_hash   ); }
}


#________________________________________________________________________
# Title     : scan_windows_and_get_compos_seqid_rate
# Usage     : %out1 =%{&scan_windows_and_get_compos_seqid_rate(\%input, \$window_size)};
# Function  : scans input sequences(arg1) in a given(arg2) window size and gets
#             each composition and sequence identity rate of the window.
# Example   : input hash: ( seq1,  'ABCDEFG.HIK',    (2 or more sequences accepted)
#                           seq2,  'DFD..ASDFAFS',
#                           seq3,  'DDDDD..ASDFAFS' );
#             input winsize : 5;
#
#             output hash; (seq1seq2, 1,2,2,2,1,1,2,2); <-- joined by ',';
#                  The numbers are ratios(compos/seqid) with given
#                  window size.
# Warning   : when $seqid is zero  the rate becomes $compos_id/10   !!!
# Keywords  :
# Options   :
# Returns   : a reference of a hash.
# Argument  : One ref. for hash, one ref. for a scalar.
# Category  :
# Version   :
#--------------------------------------------------------------------
sub scan_windows_and_get_compos_seqid_rate{
	my($base_l)=1;
	my($scale)=1; # these are default params.
	my(%input)=%{$_[0]};
	my($window_size)=${$_[1]};
	if(defined(${$_[2]})){ $base_l=${$_[2]}; } ### <---$base_c is the baseline controller for sensitivity.
	if(defined(${$_[3]})){ $scale =${$_[3]}; } ### <---$base_c is the baseline controller for sensitivity.
	my(@sequences,@out_rate,$i,$title,$window_1,$window_2,$ratio_compos_vs_seqid,@array_of_2_seq,%out_hash );
	my(@keys)= keys %input;
	my($whole_rate, $whole_rate_ref ,$out_rate_arr_ref);
	for ($i=0; $i<=$#keys; $i++){
	 $sequences[$i]= $input{$keys[$i]};   }
	($out_rate_arr_ref,$whole_rate_ref)=&get_windows_compos_and_seqid_rate_array(\@sequences,\$window_size,\$base_l,\$scale);
	@out_rate=@{$out_rate_arr_ref};  $whole_rate=${$whole_rate_ref};
	$title="CS_rate\($whole_rate\)";
	$out_hash{$title}=join(",", @out_rate);
	return( \%out_hash );
}


#________________________________________________________________________
# Title     : get_windows_cs_rate_array
# Usage     : @out_rate = @{&get_windows_cs_rate_array(\@seq, \$win_size)};
# Function  : actual working part of scan_windows_and_get_compos_seqid_rate
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : \@ratio_array, \$ratio_whole_seq
# Argument  : (\@input, \$window_size);  @input => ('ABCDEFG.HIK', 'DFD..ASDFAFS', 'ASDFASDFASAS');
#             Input ar => ( 'ABCDEFG
#                'DFD..ASDFAFS'
#                'ASDFASDFASAS' )  as the name of  @sequences.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_windows_cs_rate_array{
	my(@input)=@{$_[0]};
	my($base_level)=1;
	my($scale)=1;
	my($window_size)=${$_[1]};

	if(defined(${$_[2]})){ $base_level =${$_[2]}; }   if(defined(${$_[3]})){ $scale  =${$_[3]}; }

	my(@ratio_array, @array_of_2_seq, $seq_id, $offset, $half_of_w_size, $t, $length, $w,
	  $compos_id, $seq_id, $window_2, $window_1, $compos_whole_seq, $seq_id_whole_seq,
	  $ratio_whole_seq, $win_rate_div_by_whole_rate, $normalizing_factor, $lowest_rate );

	for ($t=0; $t < @input; $t++){
	 $length=length($input[$t]) if (length($input[$t])>$length);   }

	if ($length < $window_size){  $window_size = $length;   }

	  #___________ getting ratio for the whole sequence ___________
	$compos_whole_seq=${&compos_id_percent_array(\@input)};
	$seq_id_whole_seq=${&seq_id_percent_array(\@input)};
	if ($seq_id_whole_seq == 0){  $ratio_whole_seq =$compos_whole_seq/10; }
	else{  $ratio_whole_seq =$compos_whole_seq/$seq_id_whole_seq;  }

	  #___________ getting ratio for each window sequence ___________
	for ($w=0; $w < $length; $w++){
	 $offset = $w - int($window_size/2);  # $offset starts from -5 when window_size is 10.
	 $offset=0 if ($offset < 0);
	 $window_1=substr($input[0], $offset, $window_size);  # window_1 is one segment
	 $window_2=substr($input[1], $offset, $window_size);  # of defined length(size)
	 @array_of_2_seq=($window_1, $window_2); # making an array like this = ('ABCDE', 'BDESA')
	 $compos_id=${&compos_id_percent_array(\@array_of_2_seq)};
	 $seq_id   =${&seq_id_percent_array(\@array_of_2_seq)};
	#print "\n offset = $offset Wind1 = $window_1  Wind2 = $window_2 ";
	#print " Compos1 = $compos_id  Seqid = $seq_id \n";

	 #______  Handle special case when $seqid is zero > the rate becomes $compos_id/10 ______
	 if (($seq_id == 0) && ($compos_id != 0)){ $ratio_compos_vs_seqid = $compos_id/10;   }
	 elsif(($seq_id == $compos_id)&&($seq_id == 0)){ $ratio_compos_vs_seqid = 0;}
	 elsif(($seq_id == $compos_id)&&($seq_id == 100)){ $ratio_compos_vs_seqid = 0;}
	 else{ $ratio_compos_vs_seqid=($compos_id/$seq_id); }
	 push(@ratio_array, $ratio_compos_vs_seqid);  }

	$lowest_rate = ${&min_elem_array(\@ratio_array)};

	if($lowest_rate ==0){ $normalizing_factor=1; $ratio_whole_seq=0; }else{
	 $normalizing_factor=($ratio_whole_seq/$lowest_rate);
	}

	for (@ratio_array){  # the minimum value becomes equal to the whole seq. rate.
	 $_ = int($scale*($_*$normalizing_factor - ($ratio_whole_seq*$base_level))); #<<<----
	 $_=  '^' if($_ > 9); $_=  '_' if($_ < 0);
	}

	$ratio_whole_seq=int($ratio_whole_seq);
	return( \@ratio_array, \$ratio_whole_seq);
}

#________________________________________________________________________
# Title     : read_any_seq_files
# Usage     : %out_seq=%{&read_any_seq_files(\$input_file_name)};
# Function  : Tries to find given input regardless it is full pathname, with or
#             without extension. If not in pwd, it searches the dirs exhaustively.
# Example   : (*out1,  *out2) =&read_any_seq_files(\$input1, \$input2);
#             : (@out_ref_array)=@{&read_any_seq_files(\$input1, \$input2)};
#             : (%one_hash_out) =%{&read_any_seq_files(\$input1)};
# Warning   :
# Keywords  : open_any_seq_files,
# Options   :
# Returns   : 1 ref. for a HASH of sequence ONLY if there was one hash input
#             1 array (not REF.) of references for multiple hashes.
# Argument  : one of more ref. for scalar.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub read_any_seq_files{
	my(@out_hash_ref_list, $sub, $o, $ext );
	my(@in)=@_;
	for($o=0; $o< @in; $o++){
	 my($found, %out, @file_ext_accepted, $found_file, $sub);
	 if(ref($_[$o])){
		 @file_ext_accepted=('msf', 'fasta','jp','aln','ali','pir',
								  'slx', 'dna','fas','pdb','rms','brk', 'dssp');
		 if( ! -e ${$in[$o]}  or -B ${$in[$o]} or -z ${$in[$o]}  ){
			 print "\n#SUB read_any_seq_files: ${$in[$o]} no seq file exists(or not passed at all) for $0 \n\n",
			 chr(7);
			 die;
		 }
		 $found_file=${&find_seq_files($in[$o])};
		 print "# in read_any_seq_files, \$found_file => $found_file\n";

		 for $ext(@file_ext_accepted){
			$sub ="open\_$ext\_files";
		    print "# Trying subroutine $sub\n";
			if($found_file =~/\.$ext$/){
			   %out=%{&{"$sub"}(\$found_file)} if (defined &{"$sub"}); $found =1;
			}
			if($found_file =~/\.$ext$/ and  ! defined &{"$sub"} ){
			   print "\n# $sub is not defined in $0. I want it!!\n\n";
			}
		 }
		 if($found==0){
		    my($sub)="open\_$ext\_files"; #<--- this is the last resort !!
			for $ext(@file_ext_accepted){
			   %out=(%out, %{&{"$sub"}(\$found_file)}) if (defined &{"$sub"});
			}
		 }
	  }elsif( !(ref($_[$o])) ){
	     print "\nread_any_seq_files in $0 files accepts only REFERENCES\n\n";
	     die;
	  }
	  push(@out_hash_ref_list, \%out);
	}
	if(@out_hash_ref_list == 1){  ### If only single hash output is,
	  return($out_hash_ref_list[0]);
	}elsif( @out_hash_ref_list > 1){
	  return(@out_hash_ref_list);   # <-- contains (\%out_seq0, \%out_seq1, \%out_seq2, .... )
	}
}



#________________________________________________________________________
# Title     : seq_to_regexp
# Usage     :
# Function  : given an array and a start and end length,
#              return an array of regular expressions, where each element of the original
#              array has been expanded to a set of regular expressions that match the
#              original exactly num times, for num between the start and end length
#
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub seq_to_regexp{
	my($num1,$num2,@seq) = @_;
	my($begin,$char,$num,$new,@output,$seen,$seq,@splitseq,$template);

	$template = '(BEGIN)(SEQUENCE){NUMBER}(END)';
	foreach $seq (@seq) {
	   @splitseq = reverse(split('',$seq));
	   $begin = '^';
	   $seen = '';
	   foreach $char (@splitseq) {
		  $begin =  $begin . '|[^' . $char . ']' . $seen;
		  $seen .= $char;
	   }
	   @splitseq = split('',$seq);
	   $end = '$';
	   $seen = '';
	   foreach $char (@splitseq) {
		  $end = $end . '|' . $seen . '[^' . $char . ']';
		  $seen .= $char;
	   }
	   for($num = $num1; $num <= $num2 ; $num++) {
		  $new = $template;
		  $new =~ s/BEGIN/$begin/e;
		  $new =~ s/END/$end/e;
		  $new =~ s/SEQUENCE/$seq/eg;
		  $new =~ s/NUMBER/$num/eg;
		  push(@output,$new);
	   }
	}
	return(\@output);
}

#______________________________________________________________________________
# Title     : separate_chain_domain_from_motif_domain
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub separate_chain_domain_from_motif_domain{
    my($input_PSDIP_file, $base, $chain_domain_file_name, $motif_domain_file_name,
       $combined_motif_domain_file,  $chain_domain, $motif_domain, $combined_motif_domain,
       $chain_motif_domain);

    $input_PSDIP_file=${$_[0]} || $_[0];
    $base=${&get_base_names($ARGV[0])};

    $chain_domain_file_name="$base\_chain_domain.psdip";
    $motif_domain_file_name="$base\_motif_domain.psdip";
    $chain_motif_domain_file="$base\_chain_motif_domain.psdip";
    $combined_motif_domain_file="$base\_combined_motif_domain.psdip";

    open(CHAIN_DOMAIN, ">$chain_domain_file_name") || die;
    open(MOTIF_DOMAIN, ">$motif_domain_file_name") || die;
    open(COMBINED_MOTIF_DOMAIN, ">$combined_motif_domain_file") || die;
    open(CHAIN_MOTIF, ">$chain_motif_domain_file") || die;

    open(PSDIP_file, "<$ARGV[0]") || die;
    while(<PSDIP_file>){
       if(/\S(\d\w\w\w\w_)\s+\S(\d\w\w\w\w_)/){
          print CHAIN_DOMAIN $_;
          $chain_domain++;
       }elsif(/\S(\d\w\w\w\w[^_])\s+\S(\d\w\w\w\w[^_])/){
          print MOTIF_DOMAIN $_;
          $motif_domain++;
       }elsif(/\S(\d\w\w\w_\d)\s+\S(\d\w\w\w_\d)/){
          print MOTIF_DOMAIN $_;
          $motif_domain++;
       }elsif(/\S(\d\w\w\w.\d)\s+\S(\d\w\w\w.\d)/){
          print COMBINED_MOTIF_DOMAIN $_;
          $combined_motif_domain++;
       }elsif(/\S(\d\w\w\w.\d)\s+\S(\d\w\w\w\w_)/){
          print COMBINED_MOTIF_DOMAIN $_;
          $combined_motif_domain++;
       }elsif(/\S(\d\w\w\w\w[^_])\s+\S(\d\w\w\w\w_)/ or /\S(\d\w\w\w\w_)\s+\S(\d\w\w\w\w[^_])/){
          print CHAIN_MOTIF $_;
          $chain_motif_domain++;
       }else{
          print;
       }
    }

    print "Created: $chain_domain_file_name\n";
    print "Created: $motif_domain_file_name\n";
    print "Created: $chain_motif_domain_file\n";
    print "Created: $combined_motif_domain_file\n\n";
    print "\$chain_domain $chain_domain, \$motif_domain $motif_domain, \$chain_motif_domain $chain_motif_domain\n";
    print "\$combined_motif_domain $combined_motif_domain\n";
}



#________________________________________________________________________
# Title     : strip_rotated_seq
# Usage     :
# Function  : remove all but one string of each set of rotations
#             (reverse of rotated_seq )
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. for
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub strip_rotated_seq{
	my(@input) = @_;
	my(@output,%output,@rotations,$string);
	foreach $string (@input) {
	 @rotations = @{&rotate_seq($string)};
	 if( ! grep($output{$_},@rotations) ) {
		push(@output,$string);
		$output{$string} = 1;
	 }
	}
	return(\@output);
}

#________________________________________________________________________
# Title     : rotate_seq
# Usage     : @out_array=@{&rotate_seq($string)};
# Function  : given a string, return all the rotations of that string
#             e.g. given 'abcd', return ('abcd','bcda','cdab','dabc')
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall   ##### RevCom
# Keywords  :
# Options   :
# Returns   : a ref. for reverse complement
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rotate_seq{
	my($string) = @_;
	my($i, $length, @rotations);

	$length = length($string);
	push(@rotations,$string);
	for($i = 1 ; $i < $length ; $i++ ) {
	 $string =~ s/^(.)(.*)/$2$1/;
	 push(@rotations, $string);
	}
	return(\@rotations);
}


#________________________________________________________________________
# Title     : make_anti_sense_strand
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall by Jong Park
# Keywords  :
# Options   : make_rev_complimentary_strand, get_complimentary_strand,
#             make_antisense_strand, get_anti_sense_strand,
#             make_prevcomp_seq, revcomp, convert_to_anti_sense_strand
#             get_revcomp_sequence, get_revcomp
# Returns   : a ref. for reverse complement
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub make_anti_sense_strand{
		my($i,$len, %out, $seq, $output, $codon, @keys);
		$seq = ${$_[0]} || $_[0];
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# It also revcomp [ ] so that reg exp can be used
		#______________________________________________________
		$seq =~ tr/\[\]acgtrymkswhbvdnACGTRYMKSWHBVDN/\]\[tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
		$seq= reverse $seq; # reversing it to make complimentary to the original
		return(\$seq);
}

#________________________________________________________________________
# Title     : revcomp
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   : make_rev_complimentary_strand, get_complimentary_strand,
#             make_antisense_strand, get_anti_sense_strand,
#             make_revcomp_seq, revcomp, convert_to_anti_sense_strand
#             get_revcomp_sequence, get_revcomp
# Returns   : a ref. for reverse complement
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub revcomp{
		my($i,$len, %out, $seq, $output, $codon, @keys);
		$seq = ${$_[0]} || $_[0];
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# It also revcomp [ ] so that reg exp can be used
		#______________________________________________________
		$seq =~ tr/\[\]acgtrymkswhbvdnACGTRYMKSWHBVDN/\]\[tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
		$seq= reverse $seq; # reversing it to make complimentary to the original
		return(\$seq);
}

#________________________________________________________________________
# Title     : make_complimentary_strand
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall by Jong Park
# Keywords  :
# Options   : make_complimentary_strand, get_complimentary_strand,
#             make_antisense_strand, get_anti_sense_strand, convert_to_anti_sense_strand
# Returns   : a ref. for reverse complement
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub make_complimentary_strand{
		my($i,$len, %out, $seq, $output, $codon, @keys);
		$seq = ${$_[0]} || $_[0];
		$seq =~ tr/acgtrymkswhbvdnACGTRYMKSWHBVDN/tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
		# $seq= reverse $seq; # reversing it to make complimentary to the original
		return(\$seq);
}

#________________________________________________________________________
# Title     : convert_rna_to_protein
# Usage     :
# Function  : translate RNA seq to protein seq.
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  : rna2protein, rna_2_protein, RNA2protein, translate_rna
#             dna2protein, convert_RNA_to_protein, RNA_2_PROTEIN, RNA_2_protein
# Options   :
# Returns   : a ref. of an array for protein translation
# Argument  : a scalar for RNA sequence data
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub convert_rna_to_protein{         ##### RnaToProtein
	my(%seq) = %{$_[0]} or @_;
	my($i,$len, $seq, %out, $output, $codon, @keys);
	@keys=keys %seq;

	for($i=0; $i < @keys ; $i++){
	 my $output;
	 $seq=$seq{$keys[$i]};
	 $len=length($seq);

	 for($j=0; $j < ($len-2) ; $j+=3){
		$codon = substr($seq,$j,3);
		if   ($codon =~ /^UC/i)     {$output .= 'S'; }  # Serine
		elsif($codon =~ /^UU[UC]/i) {$output .= 'F'; }  # Phenylalanine
		elsif($codon =~ /^UU[AG]/i) {$output .= 'L'; }  # Leucine
		elsif($codon =~ /^UA[UC]/i) {$output .= 'Y'; }  # Tyrosine
		elsif($codon =~ /^UA[AG]/i) {$output .= '_'; }  # Stop
		elsif($codon =~ /^UG[UC]/i) {$output .= 'C'; }  # Cysteine
		elsif($codon =~ /^UGA/i)    {$output .= '_'; }  # Stop
		elsif($codon =~ /^UGG/i)    {$output .= 'W'; }  # Tryptophan
		elsif($codon =~ /^CU/i)     {$output .= 'L'; }  # Leucine
		elsif($codon =~ /^CC/i)     {$output .= 'P'; }  # Proline
		elsif($codon =~ /^CA[UC]/i) {$output .= 'H'; }  # Histidine
		elsif($codon =~ /^CA[AG]/i) {$output .= 'Q'; }  # Glutamine
		elsif($codon =~ /^CG/i)     {$output .= 'R'; }  # Arginine
		elsif($codon =~ /^AU[UCA]/i){$output .= 'I'; }  # Isoleucine
		elsif($codon =~ /^AUG/i)    {$output .= 'M'; }  # Methionine
		elsif($codon =~ /^AC/i)     {$output .= 'T'; }  # Threonine
		elsif($codon =~ /^AA[UC]/i) {$output .= 'N'; }  # Asparagine
		elsif($codon =~ /^AA[AG]/i) {$output .= 'K'; }  # Lysine
		elsif($codon =~ /^AG[UC]/i) {$output .= 'S'; }  # Serine
		elsif($codon =~ /^AG[AG]/i) {$output .= 'R'; }  # Arginine
		elsif($codon =~ /^GU/i)     {$output .= 'V'; }  # Valine
		elsif($codon =~ /^GC/i)     {$output .= 'A'; }  # Alanine
		elsif($codon =~ /^GA[UC]/i) {$output .= 'D'; }  # Aspartic Acid
		elsif($codon =~ /^GA[AG]/i) {$output .= 'E'; }  # Glutamic Acid
		elsif($codon =~ /^GG/i)     {$output .= 'G'; }  # Glycine
		else {print "\n# convert_rna_to_protein: unrecognized codon $codon \n";}
	 }
	 $out{$keys[$i]}=$output;
	}
	return (\%out);
}


#________________________________________________________________________
# Title     : convert_dna_to_protein
# Usage     :
# Function  : translate DNA or RNA seq to protein seq.
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  : dna2protein, dna_2_protein, DNA2protein, translate_dna
#             dna2protein, convert_DNA_to_protein, translate_nucleic_acid
#             rna2protein, rna_2_protein, RNA2protein, translate_rna
#             dna2protein, convert_RNA_to_protein
#  $make_6_frame_translation=6 by 6
# Options   :
# Returns   : a ref. of an array for protein translation
# Argument  : a scalar for DNA sequence data
# Version   : 1.4
#--------------------------------------------------------------------
sub convert_dna_to_protein{         ##### RnaToProtein
	my(%seq) = %{$_[0]};
	my($make_6_frame_translation)=$_[1];
	my($seq, $i,$len, $j, $PY, %out, $codon, @keys, %dna_frame_seqs, $frame,
		 $frame_len, $protein_seq);
	@keys=keys %seq;
	$PY = '\[UT\]';

	for($i=0; $i < @keys ; $i++){
				 $seq=$seq{$keys[$i]};
				 $len=length($seq);
				 my %original_input_seq=($keys[$i], $seq);
				 if($make_6_frame_translation eq 6){
						print "\n# (i) \$make_6_frame_translation is SET \n";
						%dna_frame_seqs=%{&make_6_frame_dna_sequences(\%original_input_seq)};
				 }else{
						%dna_frame_seqs=%original_input_seq;
				 }
				 my @names=keys %dna_frame_seqs;

				 for($k=0; $k<@names; $k++){
						 $frame=$dna_frame_seqs{$names[$k]};
						 $frame_len=length($frame);

						 for($j=0; $j < ($frame_len-2) ; $j+=3){
										$codon = substr($frame, $j, 3);
										if   ($codon =~ /^[UT]C/i)         {$protein_seq .= 'S'; }  # Serine
										elsif($codon =~ /^[UT][UT][UTC]/i) {$protein_seq .= 'F'; }  # Phenylalanine
										elsif($codon =~ /^[UT][UT][AG]/i)  {$protein_seq .= 'L'; }  # Leucine
										elsif($codon =~ /^[UT]A[UTC]/i)    {$protein_seq .= 'Y'; }  # Tyrosine
										elsif($codon =~ /^[UT]A[AG]/i)     {$protein_seq .= '_'; }  # Stop
										elsif($codon =~ /^[UT]G[TUC]/i)    {$protein_seq .= 'C'; }  # Cysteine
										elsif($codon =~ /^[UT]GA/i)        {$protein_seq .= '_'; }  # Stop
										elsif($codon =~ /^[UT]GG/i)        {$protein_seq .= 'W'; }  # Tryptophan
										elsif($codon =~ /^C[UT]/i)         {$protein_seq .= 'L'; }  # Leucine
										elsif($codon =~ /^CC/i)            {$protein_seq .= 'P'; }  # Proline
										elsif($codon =~ /^CA[UTC]/i)       {$protein_seq .= 'H'; }  # Histidine
										elsif($codon =~ /^CA[AG]/i)        {$protein_seq .= 'Q'; }  # Glutamine
										elsif($codon =~ /^CG/i)            {$protein_seq .= 'R'; }  # Arginine
										elsif($codon =~ /^A[UT][UTCA]/i)   {$protein_seq .= 'I'; }  # Isoleucine
										elsif($codon =~ /^A[UT]G/i)        {$protein_seq .= 'M'; }  # Methionine
										elsif($codon =~ /^AC/i)            {$protein_seq .= 'T'; }  # Threonine
										elsif($codon =~ /^AA[TUC]/i)       {$protein_seq .= 'N'; }  # Asparagine
										elsif($codon =~ /^AA[AG]/i)        {$protein_seq .= 'K'; }  # Lysine
										elsif($codon =~ /^AG[TUC]/i)       {$protein_seq .= 'S'; }  # Serine
										elsif($codon =~ /^AG[AG]/i)        {$protein_seq .= 'R'; }  # Arginine
										elsif($codon =~ /^G[UT]/i)         {$protein_seq .= 'V'; }  # Valine
										elsif($codon =~ /^GC/i)            {$protein_seq .= 'A'; }  # Alanine
										elsif($codon =~ /^GA[TUC]/i)       {$protein_seq .= 'D'; }  # Aspartic Acid
										elsif($codon =~ /^GA[AG]/i)        {$protein_seq .= 'E'; }  # Glutamic Acid
										elsif($codon =~ /^GG/i)            {$protein_seq .= 'G'; }  # Glycine
										elsif($codon =~ /N/i)              {$protein_seq .= 'X';
												print "\n# \"$codon\" in $names[$k]: has unkown reside X\n"; }  # UNKNOWN
										else {print "\n# convert_dna_to_protein: $names[$k] : unrecognized codon $codon \n";}
						 }
						 $out{$names[$k]}=$protein_seq;  $protein_seq='';
				}
	}
	return (\%out);
}




#________________________________________________________________________
# Title     : write_staden_file
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for  STADEN formatted sequence record
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_staden_file {				##### PutStaden
	my($seq,$header,$id) = @_;
	my($i,$j,$len,@out);
	$i = 0;
	$len = length($seq);
	$out[$i] = ";\<------------------\>\n";
	substr($out[$i],int((20-length($ID))/2),length($ID)) = $ID;
	$i++;
	for($j=0; $j<$len ; $j+=60) {
	 $out[$i++]=sprintf("%s\n",substr($seq,$j,60));
	}
	return \@out;
}


#________________________________________________________________________
# Title     : write_primer_file
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for PRIMER formatted sequence record
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_primer_file {
    my($seq,$header,$id) = @_;
    my(@out,$len,$i,$j); $i = 0;
    $out[$i++] = sprintf("*seq: %8s\n", $id);
    $out[$i++] = sprintf("%s", length($header) > 8 ? "# ".$header."\n" : "");
    $out[$i++] = sprintf("%s", $id ? "# ". $id."\n" : "");
    $len = length($seq);
    for($j = 0 ; $j < $len ; ) {
          $out[$i] .= sprintf("%s", substr($seq,$j,10));
          $j += 10;
          if($j < $len && $j % 50 != 0 ) {  $out[$i] .= " ";}
          elsif($j % 50 == 0 ){ $out[$i++] .= "\n"; } }
    if($j % 50 != 0 ) { $out[$i] .= "\n"; }
    return (\@out);
}

#________________________________________________________________________
# Title     : write_gcg_genbank_file
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for GCG-Genbank formatted sequence record
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_gcg_genbank_file {			##### PutGcgGenbank
	my($seq,$header,$id) = @_;
	my(@out,$len,$sum,$cnt,$i,$j);
	$len = length($seq);
	for($i=0; $i<$len ;$i++) {
	 $cnt++;
	 $sum += $cnt * ord(substr($seq,$i,1));
	 ($cnt == 57) && ($cnt=0);
	}
	$sum %= 10000;
	push(@out,"LOCUS $id\n");
	push(@out,"DEFINITION $header\n");
	push(@out,"ACCESSION $Accession\n");
	push(@out,"ORIGIN\n\n");
	push(@out," $id Length: $len (today)  Type: N Check: $sum  ..\n\n");
	$len = length($seq);
	$i = $#out + 1;
	for($j = 0 ; $j < $len ; ) {
	 if( $j % 50 == 0) {
		$out[$i] = sprintf("%8d  ",$j+1);
	 }
	 $out[$i] .= sprintf("%s",substr($seq,$j,10));
	 $j += 10;
	 if( $j < $len && $j % 50 != 0 ) {
		$out[$i] .= " ";
	 }elsif($j % 50 == 0 ) {
		$out[$i++] .= "\n";
		$out[$i++] = "\n";
	 }
	}
	if($j % 50 != 0 ) {
	 $out[$i] .= "\n";
	}
	$out[$i] .= "\n";
	return \@out;
}
#________________________________________________________________________
# Title     : write_pir_file
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             from Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for PIR formatted sequence record
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_pir_file {				##### PutPir
	my($seq, $header) = @_;
	my(@out,$len,$i,$j,$cnt,$sum);
	$seq=~s/[\n ]//g;
	$len = length($seq);
	for($i=0; $i< $len ;$i++) {
	 $cnt++;
	 $sum += $cnt * ord(substr($seq,$i,1));
	 ($cnt==57) && ($cnt=0); }
	$sum %= 10000;  $i = 0;
	$out[$i++] = sprintf("ENTRY           %s\n",$id);
	$out[$i++] = sprintf("TITLE           %s\n",$header);
	#JDT ACCESSION out if defined
	$out[$i++] = sprintf("DATE            %s\n",'');
	$out[$i++] = sprintf("REFERENCE       %s\n",'');
	$out[$i++] = sprintf("SUMMARY         #Molecular-weight %d  #Length %d  #Checksum %d\n",0,$len,$sum);
	$out[$i++] = sprintf("SEQUENCE\n");
	$out[$i++] = sprintf("                5        10        15        20        25        30\n");
	for($j=1; $seq && $j < $len ; $j += 30) {
	 $out[$i++] = sprintf("%7d ",$j);
	 $out[$i++] = sprintf("%s\n", join(" ",split(//,substr($seq, $j - 1,length($seq) < 30 ? length($seq) : 30))) );
	}
	$out[$i++] = sprintf("///\n");
	return \@out;
}
#________________________________________________________________________
# Title     : write_genbank_file
# Usage     : @out =  @{&write_genbank_file($sequ, $header)};
# Function  : (This is DNA seq handling routine!)
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
#             stolen from Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for Genbank formatted sequence record
# Argument  : two scalars.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_genbank_file{	my($seq,$header,$id) = @_; my(@out,$len,$i,$j,$cnt,$sum);
	$seq =~ tr/A-Z/a-z/;  $seq =~s/[ \n]//g;  $len = length($seq);
	for($i=0; $i<$len ;$i++) {
	 $cnt++;
	 $sum += $cnt * ord(substr($seq,$i,1));
	 ($cnt == 57) && ($cnt=0);  }
	$sum %= 10000;
	$i = 0;
	$out[$i++] = sprintf("LOCUS       %s       %d bp\n",$id,$len);
	$out[$i++] = sprintf("DEFINITION  %s , %d bases, %d sum.\n", $header, $len, $sum);
	$out[$i++] = sprintf("ACCESSION  %s\n", $Accession);
	$out[$i++] = sprintf("ORIGIN\n");
	for($j = 0 ; $j < $len ; ) {
		if( $j % 60 == 0) {
		  $out[$i] = sprintf("%8d  ",$j+1);
		}
		$out[$i] .= sprintf("%s",substr($seq,$j,10));
		$j += 10;
		if( $j < $len && $j % 60 != 0 ) {
		  $out[$i] .= " ";
		}elsif($j % 60 == 0 ) {
		  $out[$i++] .= "\n";
		}
	}
	if($j % 60 != 0 ) { $out[$i] .= "\n"; }
	$out[++$i] = sprintf("//\n");
	return \@out;
}

#________________________________________________________________________
# Title     : write_gcg_file
# Usage     :
# Function  :
# Example   :
# Warning   : Copyright (C) 1993-1994 by James Tisdall
# Keywords  :
# Options   :
# Returns   : a ref. of an array for GCG formatted sequence record
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_gcg_file {
		my($seq, $header,$id) = @_;
		my(@out,$len,$i,$j,$cnt,$sum);
		$seq=~s/[ \n]//g;
		$len = length($seq);
		for($i=0; $i<$len ;$i++) {
				$cnt++;
				$sum += $cnt * ord(substr($seq,$i,1));
				($cnt == 57)&& ($cnt=0);
		}
		$sum %= 10000;
		$i = 0;
		$out[$i++] = sprintf("%s\n",$header);
		$out[$i++] = sprintf("    %s Length: %d (today)  Check: %d  ..\n", $id, $len, $sum);
		$len = length($seq);
		for($j = 0 ; $j < $len ; ) {
				if( $j % 50 == 0) {
						$out[$i] = sprintf("%8d  ",$j+1);
				}
				$out[$i] .= sprintf("%s",substr($seq,$j,10));
				$j += 10;
				if( $j < $len && $j % 50 != 0 ) {
						$out[$i] .= " ";
				}elsif ($j % 50 == 0 ) {
						$out[$i++] .= "\n";
				}
		}
		if($j % 50 != 0 ) {
				$out[$i] .= "\n";
		}
		return (\@out);
}
#________________________________________________________________________
# Title     : write_fasta_array
# Usage     : @output = @{&put_fasta($sequence, $name)};
# Function  : take Single sequence and produce single output array of fasta
# Example   : @out = (
#             $out[0] =>     ">name",
#             $out[1] =>     "ABCDEABCDEBCDEABCDEABCDEABCDEABCDEBCDEABCDE",
#             $out[2] =>     "TTTTTTTTDEBCDEABCDEABCDEABCDEABCDEBCDEABCDE",
#             $out[3] =>     "ABCDEABCDEBCDEABCDEABCDEABCDEABCDEBCDEABCDE",
#                 );
#
# Warning   : Copyright (C) 1993-1994 by James Tisdall
# Keywords  :
# Options   :
# Returns   : ref. for an array of FASTA formatted sequence record
#
# Argument  : \%input
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_fasta_array {
	 my(%input) = %{$_[0]}; my($seq)=values(%input);
	 my($key)=keys(%input); my(@out,$len, $i, $j); $seq=~s/\n//g; $i = 0;
	 $out[$i++] = ">" . $key . "\n";
	 for($j=0; $j< length($seq) ; $j += 60) {
	  $out[$i++]= sprintf("%.60s\n", substr($seq,$j,60));  }
	 return(\@out); # ref. is slightly faster  2.973 vs 2.985
}

#________________________________________________________________________
# Title     : find_seq_files
# Usage     : $found_file = ${&find_seq_files(\$input_file_name)};
# Function  : (similar to find.pl) used in 'read_any_seq_file.pl'
#             seeks given test file in pwd, specified dir, default path etc.
#             If not found yet, it looks at all the subdirectories of path and pwd.
#             PATH environment dirs, then returns full path file name.
# Example   : $found_file=${&find_seq_files(\$input_file_name)};
# Warning   :
# Keywords  : find_anyj_seq_files, find any seq files, find seq files
# Options   :
# Returns   : return( \$final );
# Argument  : (\$input_file_name) while $input_file_name can be  'xxx.xxx', or '/xxx/xxx/xxx/xxy.yyy'
#             or just directory name like 'aat' for  /nfs/ind4/ccpe1/people/A Biomatic /jpo/align/aat
#             then, it tries to find a file with stored seq file extensions like msf, jp, pir etc
#             to make aat.msf, aat.jp, aat.pir ... and searches for these files.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub find_seq_files{
	my($final, $no_ext_file, $result); my($in_file)=${$_[0]}; my($pwd)=`pwd`; chomp($pwd);
	my( $base, @ENV_dir, $ext, @probable_dir_list, $directory);
	my(@extension_db)=('sst','msf','fasta','jp','fas','aln','brk','pdb', 'rms', 'ent','slx','fa');
	@probable_dir_list=('JPO','ALIGN','PATH','HOME','PIRDIR','PWD','PDBSST','PDBENT','BLASTDB','PIRDIR','SWDIR','PDB');
	if(($in_file=~/\//)&&(-e $in_file)){ $final=$in_file; }
	elsif((-e $in_file)&&(-s $in_file)&&($in_file !~/\//)){ $in_file="$pwd\/$in_file"; $final=$in_file;}
	######## if it was like  '/nfs/ind4/ccpe1/people/A Biomatic /perl.msf'
	elsif($in_file =~ /\/([\w\-\.]+)$/){ $in_file = $1;
		  if(-e $in_file){ $final = "$pwd\/$in_file"; }
		  #### if it has xxxxxx.xxxx  file form. #######
		  elsif($in_file =~ /(([\w\-]+)\.([\w\-]+))$/){ $file=$1; $base=$2; $ext=$3;
				for (@extension_db){ if($_ eq $ext){ shift(@extension_db);}}
				unshift(@extension_db, $ext);
				for (@probable_dir_list){ if($ENV{$_}=~ /\/$/){chop($ENV{$_});}
					push( @ENV_dir, split(/:/, $ENV{$_}));}
					for $dir (@ENV_dir){ $in_file="$dir\/$file";
						if ((-e $in_file) && (-s $in_file)){  $final=$in_file; last;}
						else{
							 for $ext (@extension_db){ $in_file="$dir\/$base\.$ext";
								  if ((-e $in_file) && (-s $in_file)){
									  if ($file =~  /$in_file/){ $final = $in_file; last;}}}}}
					unless(defined ($final)){
						for $dir (@ENV_dir){ $in_file= ${&search_files_in_subdir(\$dir, \$file)};
							 if(-e $in_file){ $final=$in_file; last; }}}}

			### if it has  xxxxxx   file form, ie. not extension #######
			elsif($in_file =~/\/([\w_\-]+)$/){  $base = $1;
			  for (@extension_db){
				 if($_ eq $ext){ shift(@extension_db);  }
				 unshift(@extension_db, $ext);
				 for (@probable_dir_list){
					if ($ENV{$_} =~ /\/$/){  chop($ENV{$_}); }
					push( @ENV_dir, split(/:/, $ENV{$_}) );
					for $dir (@ENV_dir){ $no_ext_file="$dir\/$base";
						 if((-e $no_ext_file) && (-s $no_ext_file)){ $final=$no_ext_file; last;}
						 else{
							for $ext (@extension_db){ $in_file ="$dir\/$base\.$ext";
								if ((-e $in_file) && (-s $in_file)){ $final = $in_file; last;}}}}}}}}

	 #### when the input was like this  'perl.msf'  in any directory.
	 elsif($in_file =~ /^(([\w\-]+)\.([\w\-]+))$/){ $file=$1; $base=$2; $ext=$3;
		  for (@extension_db){ if($_ eq $ext){ shift(@extension_db);}}
		  unshift(@extension_db, $ext);
		  for (@probable_dir_list){ if($ENV{$_}=~ /\/$/){chop($ENV{$_});}
			  push( @ENV_dir, split(/:/, $ENV{$_}));}
			  for $dir (@ENV_dir){ $in_file="$dir\/$file";
				  if ((-e $in_file) && (-s $in_file)){ $final=$in_file; last;}
				  else{
						for $ext (@extension_db){ $in_file="$dir\/$base\.$ext";
							 if ((-e $in_file) && (-s $in_file)){
								 if ($file =~  /$in_file/){ $final = $in_file; last;}}}}}
			  unless(defined ($final)){
				  for $dir (@ENV_dir){ $in_file= ${&search_files_in_subdir(\$dir, \$file)};
						if(-e $in_file){ $final=$in_file; last; }}}}
	 #### when the input was like this  'hemocyan'  in any directory.
	 elsif($in_file =~ /^([\w\-]+)$/){ $file=$1;
		  for (@probable_dir_list){ if($ENV{$_}=~ /\/$/){chop($ENV{$_});}
			  push( @ENV_dir, split(/:/, $ENV{$_}));}
			  for $dir (@ENV_dir){ $in_file="$dir\/$file";
				  if ((-e $in_file) && (-T $in_file)){  $final=$in_file; last;}
				  else{
						for $ext (@extension_db){ $in_file="$dir\/$file\.$ext";
							 if ((-e $in_file) && (-s $in_file)){
								 if ($file =~  /$in_file/){ $final = $in_file; last;}}}}}
			  unless(defined ($final)){
				  for $dir (@ENV_dir){ $in_file= ${&search_files_in_subdir(\$dir, \$file)};
						if(-e $in_file){ $final=$in_file; last; }}}}
	END_POINT:
	return( \$final );
}
#________________________________________________________________________
# Title     : search_files_in_subdir
# Usage     :
#                     $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   :
# Warning   : the final var $found_from_search_files_in_subdir mustn't be 'my'ed.
# Keywords  :
# Options   :
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub search_files_in_subdir{
	package search_files_in_subdir;
	my $original_dir=${$_[0]}; my($target_file)=${$_[1]};
	my(@read_files)=@{&main::read_any_dir(\$original_dir)};
	print "\n Searching files... , wait or kill me !\n";
	for $file(@read_files){ $realfile1= "$original_dir\/$file";
	  if (-l $realfile1){ next; }
	  elsif (-d $realfile1){ &main::search_files_in_subdir(\$realfile1, \$target_file); }
	  elsif (-f $realfile1){ @split =split(/\//, $realfile1); my($f) = $split[$#split];
		  if($target_file eq $f){ $found_from_search_files_in_subdir =$realfile1;
		  print chr(007); last;}}
	  else{ next; }  }
	return(\$found_from_search_files_in_subdir);
	last;
	package main;
}

#________________________________________________________________________
# Title     : find_seq_file_old (similar to find.pl) used in 'read_any_seq_file.pl'
# Usage     : $found_file=${&find_seq_file_old(\$input_file_name)};
# Function  : seeks text file in pwd. If not found it looks at
#             PATH environment dirs
# Example   :
# Warning   : << This is READABLE old version of  find_seq_file
# Keywords  :
# Options   :
# Returns   : one ref. for SCALAR of a full path filename.
# Argument  : one ref. for SCALAR
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub find_seq_file_old{ # This returns full path file name.
	 my($in_file)=${$_[0]};      my($pwd)=`pwd`; chomp($pwd);
	 if ((-T $in_file) && (-s $in_file) && ($in_file=~/\//))
	 { # If Text, with Size and full path filename.
		  return (\$in_file);
	 }
	 elsif((-T $in_file)&&(-s $in_file)&&($in_file !~ /\//))
	 { # if it is a Text, with size and not full path filename,
		  $in_file="$pwd\/$in_file";
		  return (\$in_file);
	 }
	 elsif(($in_file =~ /\/([\w\-\.]+)$/) && (!(-e $in_file)))
	 {  # This is to handle when wrong full path filename is given, but the filename
		 $in_file=$1;                                            # exists in pwd
		 if ((-T $in_file) && (-s $in_file)){
			 $in_file="$pwd\/$in_file";
			 return (\$in_file);
		 }
	 }
	 #------- When the search fails in pwd with either fullpath and simple filename.
	 else{   # now STDOUT
		print "\n\n Your $in_file was not found in pwd, so I am searching it\n";
		print "\n To stop press Ctrl + c \n\n";
		print "This takes time as I search PATH with different extensions of the file\n";
		# 1. Search in the ENV directories
		# 2. change the extension and check if it is in.
		my($found_seq_file, $base, $ext, @ENV_dir, @probable_dir_list, $directory);
		if ($in_file =~/([\w_\-]+)\.([\w\-]+)$/){
		  $base = $1; $ext =$2;
		}elsif($in_file =~/([\w_\-]+)$/){
		  $base = $1;
		}
		my(@extension_db)=('msf','jp','jpo','aln','sst','fa','fasta','rms', 'mpfa', 'spfa',
											'slx','fas','pdb','brk','ent');
		for (@extension_db){
		  if($_ eq $ext){
		  shift(@extension_db);  last;
		}
	 }
	 unshift(@extension_db, $ext);
	 @probable_dir_list=('PATH', 'HOME', 'JPO', 'PIRDIR', 'PDB', 'PDBENT');
	 for (@probable_dir_list){
		 if ($ENV{$_} =~ /\/$/){  # if any dir ends with '/', chops if off
			chop($ENV{$_}); }
		 push( @ENV_dir, split(/:/, $ENV{$_}) );
	 }
	 for $dir (@ENV_dir){
		if ($dir=~/\//){
			for $ext (@extension_db){
			  $in_file ="$dir\/$base\.$ext";
			  print "Searching $in_file\n";
			  if ((-T $in_file) && (-s $in_file)){
				  print "\n\n I found $in_file in $dir \n\n"; print chr(7);
				  print "  If it is the file you want rerun $0 with it\n\n\n";
				  $found_seq_file = $in_file;
			  }
			}
		}#if($dir=~/\//)
	 }
	 return( \$found_seq_file);
	}#<< end of  else-------------------
}

#________________________________________________________________________
# Title     : open_sst_files_with_gap  (but reads jp file as an input, too!!!)
# Usage     : %out_sst_hash =%{&open_sst_files_with_gap(\$jp_file_dir_and_name)};
# Function  : gets the name of a file(jp file) with its absolute dir path
#             reads the sequence names in the jp file and looks up all
#             the sst files in the same directory. Puts sst sequences
#             in a hash with keys of sequence names.
#
# Example   : jp file  ==  seq1 ABDSF--DSFSDFS   <- true sequence
#                              seq2 T--kdf-GAGGGASF     (aligned)
#
#                 sst files ==> 'seq1.sst', 'seq2.sst' (in the same dir)
#
#             original sst format:  seq1 hHHHHHttEEEE  <-- No gaps!
#                                  seq2 hHHHHHHEEhh
#             After this sub ==>
#             (final out hash =   (  seq1 hHHHH--HttEEEE  <-- inserted
#                                  seq2 h--HHH-HHHEEEhh  )     gaps
#
# Warning   : $jp_file_dir_and_name should be absolute dir and file name
#             >> This gets JP file not SST file as input !!!!
# Keywords  :
# Options   :
# Returns   : a ref. for a hash
# Argument  : a ref. for scaler of "jp file name"
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_sst_files_with_gap{   # This automatically determines MSF or JP format
	my(%seq_file, $sst_file, %secondary_struc, @keys, $directory);
	%seq_file = %{read_any_seq_files($_[0])};
	######  Simple reading in of SST files ------------
	######  Simple reading in of SST files ------------
	for $seq_name (keys %seq_file){
	  $sst_file ="$seq_name\.sst";
	  print $sst_file;
	  %secondary_struc =( %secondary_struc, %{&read_any_seq_files(\$sst_file)});
	}
	print %secondary_struc;
	### Now we have  1. %jp_file  and  2. %out_sst_seq_hash  -------
	if (!(defined(%secondary_struc))){
	  return(\%seq_file);
	}else{
	 %gap_corrected_out=%{&put_gaps_in_hash(\%seq_file, \%secondary_struc)};
	 return( \%gap_corrected_out );
	}
}

#________________________________________________________________________
# Title     : put_gaps_in_hash  (The order of input hashes DOES matter, in the end)
# Usage     : %out=%{&put_gaps_in_hash(\%hash_with_gap, \%hash_sans_gap)};
#
#             %hash1=('1ctx',  '111111111111111',      <-- hash input without gaps
#                     '2ctx',  '2222222222222222',
#                     '3ctx',  '3333333333');
#
#             %hash2=('1ctx',  'AAA--AAAAAAAAAAAA-',   <-- hash input with template gaps
#                     '2ctx',  'BBBBBBBBBBBB-BBBB',
#                     '3ctx',  'CCCCCC----CCCC');
#
#             >> resulting out hash;
#
#             %hash3=('1ctx',     '111--111111111111-',
#                     '2ctx',     '222222222222-2222',
#                     '3ctx',     '333333----3333 );
#
# Function  :
# Example   :
# Warning   : The keys for hashes should be the same and the two sequences
#             should be identical.
# Keywords  :
# Options   :
# Returns   : one hash reference.
# Argument  : 2 hash references.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub put_gaps_in_hash{
	my($temp0)= values %{$_[0]};  # finds the hash with gaps
	my($temp1)= values %{$_[1]};  # and assigns to right input hash.
										  # above puts the first values to $temp0 & 1
	if (($temp0=~/\-/)||($temp0=~/\./)){  # compares the leng of the first
	 %hash_gap = %{$_[0]};               # values of hashes and assigns
			%hash_sans_gap=%{$_[1]};            # accordingly.
	}elsif(($temp1=~/\-/)||($temp1=~/\./)){
	 %hash_gap     =%{$_[1]};
	 %hash_sans_gap=%{$_[0]};
	}else{
	 %hash_gap     =%{$_[0]};  # If it can not determine input type, it assumes
	 %hash_sans_gap=%{$_[1]};  # that the first one was for gap, the 2nd for secondary.
	}                           # structure or whatever.
	my(@keys)=sort keys (%hash_gap);
	my($gap_char) = '-';  #  default gap_char is  '-'
	my(@string1, @string2, @gap_pos, %out_hash, $gapped_string, $res);

	if ($hash_gap{$keys[0]}=~/\-/){
	 $gap_char = '-';
	}elsif($hash_gap{$keys[0]}=~/\./){
	 $gap_char = '.';
	}
	########## Actual exchange part ############
	for (@keys){
	 @string1 = split('', $hash_gap{$_});
	 @string2 = split('', $hash_sans_gap{$_});
	 for ($t=0; $t <=$#string1; $t++){
		  $res=$string1[$t];
		  if(($res =~ /\-/)||($res =~ /\./)||($res =~ /\s/)){
			  splice(@string2, $t, 0, $gap_char);
		  }
	 }
	 $gapped_string = join("", @string2);
	 $out_hash{$_}= $gapped_string;
	}
	return(\%out_hash);
}

#________________________________________________________________________
# Title     : get_gap_positions
# Usage     : @gap_pos=@{&get_gap_positions(\@string1)}; <- ('A','C','D','E')
#             @gap_pos=@{&get_gap_positions(\$string1)}; <- ( ACDE )
# Function  : gets gap positions of seq. and stores in an array
# Example   : for a string '--iu--sdf-j--', it will output  -2 -1 2 3 7 9 10
# Warning   : uses References.
# Keywords  : get_gap_positions_in_seq, get_seq_gap_positions get_gap_positions_in_array
# Options   : p for all positive gaps numbering. No negatives for '---STRING--'
#
# Returns   : 1 ref. of array eg)=(2,3,7,8,10,100,122);
# Argument  : 1 ref. of array eg)=( ABCDE--EF--GH ) while '-' is for gap.
# Category  :
# Version   : 1.4
#--------------------------------------------------------------------
sub get_gap_positions{
	 my($res, @gap_posi, $all_positive, $i, @seq_array);
	 for($i=0; $i< @_; $i++){
	   if(ref($_[$i]) eq 'SCALAR'){      @seq_array=split(//, ${$_[$i]});
	   }elsif(ref($_[$i]) eq 'ARRAY'){   @seq_array=@{$_[$i]};
	   }elsif($_[$i]=~/^\s*p\s*$/){ $all_positive = p ;
	   }else{ print "\n# get_gap_positions: I take ref of a string or an array \n";
	   }
	 }
	 if($seq_array[0] =~ /[\-\. ]/ and !$all_positive ){
	   for ($i=0; $i < @seq_array; $i++){
		  if ( $seq_array[$i] =~ /^[\-\. ]$/){
			  push (@gap_posi, -$i-1);
		  }else{  @gap_posi= sort {$a<=>$b} @gap_posi; last;   }
	   }
	   splice(@seq_array, 0, (@gap_posi));
	   for ($i=0; $i <  @seq_array; $i++){
		  $res=$seq_array[$i];
		  if ( $res =~ /[\-\. ]/){  push (@gap_posi, $i);  }
	   }
	   return(\@gap_posi);

	 }
	 if($seq_array[0] !~ /[\-\. ]/ or  $all_positive) {
	   for ($i=0; $i <  @seq_array; $i++){
		  $res=$seq_array[$i];
		  if ( $res =~ /[\-\. ]/){  push (@gap_posi, $i);  }
	   }
	   return(\@gap_posi);
	 }
}


#________________________________________________________________________
# Title# Usage     : @output =@{&make_pairs_from_hash(\%input_sequence_hash);
#             Input example
#             %input =  seq1  ABCDEFAD
#              seq2  SDFSFSDF
#              seq3  SDFSFSDF
#
# Function  : returns all the possible pairs of a set of sequences in
#             an array of references;
#
# Example   : @output=($ref1, $ref2, ....$refn)
#             each $ref is the reference of a hash of a pair of sequence
#             >>  %pair1 = %{$ref1}; %pair2 = %{$ref2}; %pair3 = %{$ref3};
#
#             %pair1 is like;       %pair1 is like;       %pair3 is like;
#
#             seq1  ABCDEFAD     seq1  ABCDEFAD        seq2  SDFSFSDF
#             seq2  SDFSFSDF     seq3  SDFSFSDF        seq3  SDFSFSDF
#
# Warning   :
# Keywords  :
# Options   :
# Returns   : one ref. of array for references for hashes.
# Argument  : one ref. of hash
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub make_pairs_from_hash{  # making sub sequences from a mother sequence
	my(%input)=%{$_[0]};        # <-- actual sequence input
	### make all pairs from the input sequencs  ####
	my(@keys)= keys %input;
	my(@resultant_references);
	my(%temp_hash);
	for ($i=0; $i <=$#keys; $i++){
	 for ($j=$i+1; $j <=$#keys ; $j++){
		${"$keys[$i]\_$keys[$j]"}{$keys[$i]} =  $input{$keys[$i]};
		${"$keys[$i]\_$keys[$j]"}{$keys[$j]} =  $input{$keys[$j]};
		%temp_hash = %{${"$keys[$i]\_$keys[$j]"}{$keys[$j]}};
		push(@resultant_references, \%temp_hash);
	 }
	}
	return(\@resultant_references);  # the size of the array varies according to input
}

#________________________________________________________________________
# Title     : mail_it
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub mail_it{
#  open (MAIL, "|$sendmail_path $recipient") || die $!";
	#write (MAIL);
#
}


#________________________________________________________________________
# Title     : read_fssp_files
# Usage     : %anyarray = %{&read_fssp_files(\$any_sequence_file_fssp_form)};
# Function  : read hssp file and put sequences in a hash
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_fssp_files{
	 my($input_file)=${$_[0]};	 # $_[0]=>input eg. $dir.$out_seq_no.hssp
	 my(%out_hash, $no_of_seq, $seq_from, $seq_to, $char,
		 @names, $flag1, $flag, $original_string, $length_string,
		 @residues_in_the_line
	 );

	 unless (-e $input_file){
		 print chr(7);		     # beep warning for error
		 print "\n\n\t This is sub read_hssp_file  in th_lib.pl \n\n";
		 print "\n\n\t Fatal: The input file $file1 is not in the directory \n";
		 print "\n\n\t  !!! Program dies abnormally, bugs !!! \n";
		 &caller_info; print "\n"; die;  # &caller_info is in th_lib.pl
	 }

	 open(FILE_1, "$input_file"); # reading in (hssp)
	  ############## READING ######################
	  while(<FILE_1>){
		 if((/^\#\# SUMMARY/)||(/  NR. STRID1/)){
			 next;
		 }
		 if (/\d+: \w+\s+([\w_\-]+)\s+/){    # matching the structure names
			 push(@names, $1);         # @names are the names of structural sequences;
			 next;                     # do not need to look at further.
		 }
		 if(/\#\# ALIGNMENTS\s+(\d+)\s+\-\s+(\d+)/){
			 @residues_in_the_line=();
			 $seq_from=$1-1;  # to offset $seq_from to match array counting method later
			 $seq_to  =$2-1;
			 $flag2 =1;
			 next;
		 }
		 if((/^SeqNo PDBNo/)||(/^\s\s\s\s\s\s\s\s\s\s\s\s\s\s+/)){
			 next;
		 }
		 if(/^\#\# EQUIVALENCES/){
			 last;
		 }
		 $original_string=substr($_, 42) if ($flag2==1);  # assign from chars from 43(position) to the end
		 chomp($original_string);                         # removes new line at the end.
		 $length_string = length($original_string);
		 for ($i=0; $i < $length_string; $i+=3){   # note that >>> $i+=3;
			$char=substr( $original_string, $i, 1);
			push(@residues_in_the_line, $char) unless ($char=~/\s/);  # There was spaces in the last seq part.
		 }                                                              #  I am removing them.
		 for ($i=$seq_from; $i <= $seq_to; $i++){
			$out_hash{$names[$i]}.=shift(@residues_in_the_line);
		 }
	 }
	 \%out_hash;
}

#________________________________________________________________________
# Title     : get_posi_shift_rms_whole
# Usage     : just type   get_posi_shift_rms_whole.pl
# Function  :
# Example   : (0.284994272623139   0.166781214203895)
#             The first figure is for error rate with out rms consideration
#             The second is for after applying threshold.
# Warning   :
# Keywords  :
# Options   :
# Returns   : two refs. of scalar values (rates)
# Argument  : takes 2 refs. of scalars for dir name (protein group name)
#             and threshold for rms
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_shift_rms_whole{
	my($group)    =${$_[0]};  #<---- for group name
	my($threshold)=${$_[1]};  #<---- for threshold
	my($input1) = "/nfs/ind4/ccpe1/people/A Biomatic /jpo/align/$group/$group\.msf";
	my($input2) = "/nfs/ind4/ccpe1/people/A Biomatic /jpo/align/$group/$group\.jp";
	my($input3) = "/nfs/ind4/ccpe1/people/A Biomatic /jpo/align/$group/$group\.rms";
	if($#_ < 1){ $threshold = 6; } # default is $threshold = 6
	my($average_rate2, $average_rate1, %array3);
	my(%array1)=%{&open_msf_files(\$input1)}; my(%array2)=%{&open_jp_files(\$input2)}; my(%array3);
	if (!(-e $input3)){
		  $average_rate1 = ${&get_posi_shift_hash(\%array1, \%array2)};
		  $average_rate2=$average_rate1; }
	else{ %array3=%{&open_rms_files(\$input3)};
		  ($rate_ref_1, $rate_ref_2) = &get_posi_shift_rms_hash(\%array1, \%array2, \%array3, \$threshold);
		  $average_rate1=${$rate_ref_1};  $average_rate2=${$rate_ref_2};  }
	return(\$average_rate1, \$average_rate2);
}
#________________________________________________________________________
# Title     : write_jp  (essentially the same as print_seq_in_block)
# Usage     : &write_jp(\%input_hash1,\%input_hash2, \%input_hash3.... );
# Function  : gets a ref(s) for hash and prints the content in lines of 60 char
# Example   :
# Warning   : derived from  print_in_block
# Keywords  :
# Options   :
# Returns   : Nothing, i.e. STDOUT
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub write_jp{
	my(%input)=%{$_[0]};
	my(@names)=keys(%input);
	my($larg, $offset, $diff, $gap_char);
	$gap_char='-';  # <-- setting default gap character.
	for ($i=0; $i <=$#names; $i++){
	 $larg = length($input{$names[$i]}) if length($input{$names[$i]}) > $larg;
	 if ($input{$names[$i]} =~ /\-/){
		$gap_char='-';
	 }elsif($input{$names[$i]} =~ /\./){
		$gap_char='.';
	 }
	}
	#%input=%{fill_ending_space(\%input)};
		  ######====== filling the end part gaps in shorter sequences #####
	for ($i=0; $i <=$#names; $i++){
	  if (length($input{$names[$i]}) < $larg){
		 $offset=length($input{$names[$i]});
		 $diff=$larg-$offset;
		 substr($input{$names[$i]}, $offset, $larg)= "$gap_char" x $diff;
	  }
	}
## Using format is slower than using just print ######## 0.075 vs 0.070
##   An xxx.out example -->
##            1       10        20        30        40        50
## 1cdg       CGGDWqGIinkIndgYLtgMgVtAIWISQPVeNIysiInysgvnnTAYhG

format JP_FORMAT =
@<<<<<<<<<<@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$names,    $seq
.
	for ($k=0; $k < $larg; $k+=50){     # 50 residues interval
	 for($i=0; $i < @names; $i++){    # number of sequences
		$names =$names[$i];
		$input{$names[$i]}=~ s/\n//g;
		$seq = substr($input{$names[$i]}, $k, 50);
		$~='JP_FORMAT';
		write;
	 }
	 print "\n";                       # next block starts.
	}
}

#________________________________________________________________________
# Title     : convert_num_to_0_or_1_hash (opposite of convert_num_to_0_or_1_hash)
# Usage     : with a variable for threshold ->
#
#             %out = %{&convert_num_to_0_or_1_hash(\%input_hash, \$threshold, \%input_hash2..)};
#
# Function  : changes all the numbers into 0 or 1 according to threshold given.
#             convert_num_0_or_1_hash converts threshold and bigger nums. to
#             '0' while convert_num_0_or_1_hash_opposite converts to '1'.
# Example   : A hash =>  name1  10012924729874924792742749748374297
#                        name2  10012924729874924792710012924729874
#             A threshold => 4
#             !! if numbers are smaller than 4, they become 1 (or true).
#             Outputhash  =>  name1  11111011011111011111011011110101111
#                        name2  11111011010001011001011010010101100
#
#             ($ref1, $ref2)=&convert_num_to_0_or_1_hash(\%hash, \%hash, \$threshold);
#             above is the example when with more than 2 input hashes.
# Warning   : Threshold value is set to 0 as well as all values smaller than that.
# Keywords  :
# Options   :
# Returns   :
# Argument  : two references, one for hash one for scaler for threshold
#
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub convert_num_to_0_or_1_hash{
	my(@output_hash_refs, %input, $c, $i,
		@string, $name, @names, $threshold, %output_hash);
	for($c=0; $c < @_; $c++){
	 if(ref($_[$c]) eq 'SCALAR'){ $threshold =${$_[$c]};} }
	for($i=0; $i < @_; $i++){
	 if(ref($_[$i]) eq 'HASH'){ %input=%{$_[$i]};
		@names=keys (%input);
		my($split_char)=',';
		if ((@_ < 1)&&(ref($_[$a]) eq 'HASH')){  # if input argument is only one (= if no threshold given),
		  $threshold = 1; } # <---- put 1 to $threshold as a default
		for $name (@names){
		  if($input{$name}=~/\,/){  $split_char = ','; }else{ $split_char = ''; }
		  if ($input{$name} =~ /[\.\-\d]+/){ @string=split(/$split_char/, $input{$name});
			 for (@string){
				if(/\d+/){
				  if($_ >= $threshold){ $_=0; } # !! becomes 0 (or false)
				  else{  $_=1;               } # !! becomes 1 (or true)
				}
			 }
		  }
		  $output_hash{$name}=join("", @string);
		}
		push(@output_hash_refs, \%output_hash);
	 }
	}
	if(@output_hash_refs == 1){return($output_hash_refs[0]); }
	elsif(@output_hash_refs > 1){ return(@output_hash_refs) }
}
#________________________________________________________________________
# Title     : convert_num_0_or_1_hash_opposite (opposite of convert_num_to_0_or_1_hash)
# Usage     : with a variable for threshold ->
#
#               %out = %{&convert_num_0_or_1_hash_opposite(\%input_hash, \$threshold)};
#
# Function  : changes all the numbers into 0 or 1 according to threshold given.
#             convert_num_0_or_1_hash converts threshold and bigger nums. to
#             '0' while convert_num_0_or_1_hash_opposite converts to '1'.
# Example   : A hash =>  name1  10012924729874924792742749748374297
#                        name2  10012924729874924792710012924729874
#             A threshold => 4
#             !! if numbers are smaller than 4, they become 1 (or true).
#             Outputhash  =>  name1  11111011011111011111011011110101111
#                        name2  11111011010001011001011010010101100
#
#             ($ref1, $ref2)=&convert_num_to_0_or_1_hash(\%hash, \%hash, \$threshold);
#             above is the example when with more than 2 input hashes.
# Warning   : Threshold value is set to 0 as well as all values smaller than that.
# Keywords  :
# Options   :
# Returns   :
# Argument  : two references, one for hash one for scaler for threshold
#
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub convert_num_0_or_1_hash_opposite{
	my(@output_hash_refs, %input,$c, $i, $split_char,
	  @string, $name, @names, $threshold,%output_hash);
	for($c=0; $c < @_; $c++){
	 if(ref($_[$c]) eq 'SCALAR'){ $threshold =${$_[$c]};}
	 elsif( $_[$c] =~/^\d+$/){ $threshold = $_[$c];}
	}
	for($i=0; $i <=$#_; $i++){
	 if(ref($_[$i]) eq 'HASH'){
		%input=%{$_[$i]};
		#show_hash(\%input);
		@names=keys (%input);
		$split_char=',';
		if ((@_ == 1)&&(ref($_[$a]) eq 'HASH')){  # if input argument is only one (= if no threshold given),
		  $threshold = 1; } # <---- put 1 to $threshold as a default
		for $name (@names){
		  if($input{$name}=~/\,/){  $split_char = ',';
		  }else{ $split_char = ','; }
		  if ($input{$name} =~ /[\.\-\d]+/){
			 @string=split(/$split_char/, $input{$name});
			 for (@string){
				if(/\d+/){
				  if($_ >= $threshold){ $_ = 1; } # !! becomes 0 (or false)
				  else{  $_=0;               } # !! becomes 1 (or true)
				}
			 }
		  }
		  $output_hash{$name}=join(",", @string);
		}
		push(@output_hash_refs, \%output_hash);
	 }
	}
	if(@output_hash_refs == 1){return($output_hash_refs[0]); }
	elsif(@output_hash_refs > 1){ return(@output_hash_refs) }
}
#________________________________________________________________________
# Title     : convert_char_to_0_or_1_hash
# Usage     : with a variable for threshold ->
#
#               %out = %{&convert_char_0_or_1_hash(\%input_hash)};
#
# Function  : changes all the chars into 1, gaps are to 0
# Example   : A hash =>  name1  ABCDSSFDSF..ASDFSD.....ADFASDF...AA
#                        name2  ASDFSD.....ADFBCDSSFDSF..ASASDF...A
#
#             Outputhash  => name1  00000000001100000011111000000011100
#                            name2  00000011111000000000000110000001110
#
# Warning   :
# Keywords  : convert_char, translate_char, convert_char_to_digit,
#             convert_char_to_number
# Options   :
# Returns   : A ref. of a hash
# Argument  : one reference of HASH.
#
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub convert_char_to_0_or_1_hash{
	my(%input) =%{$_[0]};
	my(@string, $name, $elem, $i, %output_hash, $split_char);
	my(@names)=keys (%input);
	for $name (@names){
	  if($input{$name}=~/^\S\,\S/){
	     $split_char=',';
	     @string=split(',', $input{$name}); }
	  else{ $split_char="";
	     @string=split("", $input{$name}); }
	  for ($i=0; $i< @string; $i++){
		 if($string[$i]=~/^[\.\-\s]$/){  $string[$i] = 0 ;
	     }elsif($string[$i]=~/\w/){  $string[$i] = 1;   }
	  }
	  $output_hash{$name}=join("$split_char", @string);
	}
	return(\%output_hash);
}



#________________________________________________________________________
# Title     : digitize_char
# Usage     : with a variable for threshold ->
#
#               %out = %{&digitize_char(\%input_hash)};
#
# Function  : changes all the chars into 1, gaps are to 0
# Example   : A hash =>  name1  ABCDSSFDSF..ASDFSD.....ADFASDF...AA
#                        name2  ASDFSD.....ADFBCDSSFDSF..ASASDF...A
#
#             Outputhash  => name1  00000000001100000011111000000011100
#                            name2  00000011111000000000000110000001110
#
# Warning   :
# Keywords  : convert_char, translate_char, convert_char_to_digit,
#             convert_char_to_number, digitize_sequence, digitize_char
#             digitize_hash
# Options   :
# Returns   : A ref. of a hash
# Argument  : one reference of HASH.
#
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub digitize_char{
	my(%input) =%{$_[0]};
	my(@string, $name, $elem, %output_hash, $split_char);
	my(@names)=keys (%input);
	for $name (@names){
	  if($input{$name}=~/^\S\,\S/){ $split_char=','; @string=split(',', $input{$name}); }
	  else{ $split_char=""; @string=split("", $input{$name}); }
	  for (@string){  if($_ =~/[\.\-\s]/){  $_ = 0 ; } else{  $_ = 1;   } }
	  $output_hash{$name}=join("$split_char", @string);
	}
	return(\%output_hash);
}


#______________________________________________________________________________
# Titile   : dir
# Options  : -d is for directory only list
#           -e for extension names only (with occurances of file with it)
# Usage    : dir
# Example  : dir.pl -D
#           dir.pl /etc
#           dir.pl /Perl
#           dir.pl e=spfa          # for all spfa files
#           dir.pl e=spfa,mnfa,txt # show spfa, mnfa and txt files
#           dir.pl E               # show all the extension names
# Author   : jong@mrc-lmb.cam.ac.uk
# Keywords : list_directory, ls show_directory show_folder, show_dir, list_dir
#            ls_dir ls_folder
# Version  : 1.5
#-----------------------------------------------------------------------------
sub dir{
   my (@names, $var, @dir_list, $dir_names_only, $i, $x, $j, %all_ext_list, @arg,
       %extensions, @extensions,  $extension, $ext_name_only);

   if(ref($_[0]) eq 'ARRAY'){   @arg=@{$_[0]};
   }else{      @arg=@ARGV;   }

   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
   # @arg is for directory name and file names  targeted
   #_______________________________________________________
   if(@arg > 0){
        print "#(i) Hi, you put some arguments, \"@arg\" for $0\n";
        for($i=0; $i< @arg; $i++){
            if(-f $arg[$i]){ push(@names, $arg[$i]);  next;  }
            if($arg[$i]=~/^\-?D$/){
              $dir_names_only=1;
              if(@ARGV==1){ push(@dir_list, '.'); }; splice(@arg, $i, 1);  $i--;
            }elsif($arg[$i]=~/^\-?E$/){   $ext_name_only=1;
              if(@ARGV==1){ push(@dir_list, '.'); };  splice(@arg, $i, 1); $i--;
            }elsif($arg[$i]=~/^\-?e=(\S+)/){
              $extension=$1;
              print "#(i) $arg[$i] has extension name(s)\n";
              if($extension=~/\,/){ @extensions=grep { $extensions{$_}=$_ } split(/\,/, $extension)
              }else{   @extensions =grep { $extensions{$extension}=$extension} $extension }
              if(@ARGV==1){ push(@dir_list, '.'); }; splice(@arg, $i, 1);   $i--;
            }elsif(-d $arg[$i]){   push(@dir_list, $arg[$i]);   }
        }
   }else{ ## default pwd is read!
       push(@dir_list, '.');
   }
   print "#(i) Target dir => \"@dir_list\"\n";

   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # When certain files are sought after
   #______________________________________________
   if(@names > 0){
        @out= &read_any_dir_for_dir(\@dir_list, \@names);
        @names=@{$out[0]};
        %big_files=%{$out[1]};
        $size_sum=${$out[2]};
        @read_dirs=@{$out[3]};
        print "\n======= Result of reading =======\n$var \n";
        for($x=0; $x < @names; $x++){
           @stat=stat($names[$i]);
           $size_sum+=$stat[7];
           if($stat[7] > 1000000){ $big_files{$stat[7]} = $names[$i]; }
           if( ($names[$i]=~/^[\W]+$/)||($names[$i] =~ / +/)){
               splice( @names, $i, 1 ); $i--  }
           if( ($names[$i]=~/\.\.+/)||($names[$i] =~ /\#+/)||($names[$i]=~/\,+/)){
               splice( @names, $i, 1 ); $i-- }
           print "$names[$x]\n";
        }
        $numb_of_items=@names;
        print "#(i) >> Files over 1mb in size are-> \n";
        &show_hash_for_dir_subroutine(\%big_files);
        $numb_of_items=@names;
        print "\n(i)  $numb_of_items  items $size_sum bytes in the dir, ignoring weird ones\n\n";
    }elsif(@names < 1 and $dir_names_only){
        @all_dirs_list = @{&read_dir_names_only(\@dir_list)};
        &show_array_for_dir(\@all_dirs_list);
    }elsif(@names < 1 and $ext_name_only){
        %all_ext_list = %{&read_file_extension_names_only(\@dir_list)};
        &show_hash_for_dir_subroutine(\%all_ext_list);
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # If DIR is intended to be listed
    #______________________________________________________
    }elsif(@dir_list > 0){

        for($i=0; $i< @dir_list; $i++){
            $dir_name=$dir_list[$i];
            if($extension){
                @names= @{&read_file_names_only($dir_name, "e=$extension")};
            }else{
                @names= @{&read_file_names_only($dir_name)};
            }
            print &__GREEN__;
            print "\n#(i)======= Result of reading =====> @dir_list <\n";
            print &__WHITE__;
            for($x=0; $x < @names; $x++){
               if(-l $names[$x]){ next }
               if($extension and $names[$x] !~/$extension$/ ){ next }
               @stat=stat("$dir_name\/$names[$x]");
               $size_sum+=$stat[7];
               if($stat[7] > 1000000){ print &__YELLOW__ }else{  print &__WHITE__ }
               printf ("%-44s %-10s %s\n", $names[$x], $stat[7], $size_sum);
               if($stat[7] > 1000000){ $big_files{$stat[7]} = $names[$x]; }
               if( ($names[$x]=~/^[\W]+$/)||($names[$x] =~ / +/)){
                   splice( @names, $x, 1 ); $x--  }
               if( ($names[$x]=~/\.\.+/)||($names[$x] =~ /\#+/)||($names[$x]=~/\,+/)){
                   splice( @names, $x, 1 ); $x--;  }
            }
            $numb_of_items=@names;
            print &__BOLD__;
            print &__RED__;
            print "\n#(i) >> Files over 1mb in size are-> \n";
            &show_hash_for_dir_subroutine(\%big_files);
            print &__RESET__;
            if($extension){
               print "\n#(i) $numb_of_items items in all. $size_sum bytes in the dir for \"@extensions\" extension(s)\n\n";
            }else{
               print "\n#(i) $numb_of_items items in all. $size_sum bytes in the dir.\n\n";
            }
        }
    }
}



#________________________________________________________________________
# Title     : get_posi_diff_and_rms_hash
# Usage     : %position_diffs =\{&get_posi_diff_hash(\%diffs, \%rms_corrected)};
# Function  : gets two ref. of hashes and calculates the position diffs.
# Example   :
# Warning   : split and join char is ",";
# Keywords  :
# Options   :
# Returns   : one ref. for an array of differences of input arrays. array context.
#             ---Example input (a hash with numbers); The values are differences after comparion
#                                            with structural and sequential alignments.
#             %diffs =('seq1', '112342431111
#             'seq2', '12222...09011.1122',
#             'seq3', '13222...00011.1122',
#             'seq4', '12262...00011.112.');
#
#             %rms_corrected_0_or_1 => seq1_seq2  0111011111011101011110100101101010011
#                           seq1_seq3  01111.....111110111111111111100001011
#             example output;
#             seq3_seq4       01040...00000.000.
#             seq1_seq2       01012...1810...122
#             seq1_seq3       02012...1110...122
#             seq1_seq4       01032...1110...12.
#             seq2_seq3       01000...09000.0000
#             seq2_seq4       00040...09000.000.
#
# Argument  : Takes two ref. for hash
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_diff_and_rms_hash{                 # used in 'get_posi_shift_hash'
	my(%diffs)= %{$_[0]};
	my(%rms_corrected_0_or_1)=%{$_[1]};
	my(@names)= keys (%diffs);
	my(@names_rms)= keys (%rms_corrected_0_or_1);
	my(%seqs_compared_in_pair, %seqs_compared_in_pair_rms);
	my(@temp)=();
	my(@temp_rms)=();
	my(@temp2)=();
	for ($i=0; $i <= $#names; $i ++){
	  @temp = split(',', $diffs{$names[$i]});
	  (@{"string$i"})=@temp;
	}
	##########   getting differences for permutated pairs   ##############
	for ($i=0; $i <= $#names; $i++){  # permutation part for pairs
		for ($j=$i; $j <= $#names; $j ++){
			if ($j == $i){ next; } # avoiding seq1_seq1 type match.

			  for ($k=0; $k <= $#string0; $k ++){
				  if ((${"string$i"}[$k] =~ /[-\d+]/) && (${"string$j"}[$k] =~ /[-\d+]/)){

					  my($diff) = abs(${"string$i"}[$k] - ${"string$j"}[$k]);
					  push(@temp2, $diff);
				  }else{
					  push(@temp2, '.');  # @{"diffs$i$j"}
				  }
			  }
			if ( defined $rms_corrected_0_or_1{"$names[$i]\_$names[$j]"}){
			$seqs_compared_in_pair{"$names[$i]\_$names[$j]"}=join(",", @temp2);
		 }elsif(defined $rms_corrected_0_or_1{"$names[$j]\_$names[$i]"}){
			 $seqs_compared_in_pair{"$names[$j]\_$names[$i]"}=join(",", @temp2);
		 }
		 @temp2=();
	  }
	}

	for $pair_names (keys %seqs_compared_in_pair){
		my(@temp_string1)=split(',', $seqs_compared_in_pair{$pair_names});
		my(@temp_string2)=split('' ,  $rms_corrected_0_or_1{$pair_names});  # 0 or 1 values
		my(@final_residue)=();
		for ($i=0; $i <= $#temp_string1; $i++){
			if(($temp_string1[$i] =~ /\d+/) && ($temp_string1[$i] =~ /\d+/)){ # if both are numbers!
				$temp_string1[$i] = ($temp_string1[$i]*$temp_string2[$i]);  # multiplying part
			}
			push(@final_residue, $temp_string1[$i]);
		}
		$seqs_compared_in_pair_rms{$pair_names}=join(",", @final_residue);
	}
	return(\%seqs_compared_in_pair, \%seqs_compared_in_pair_rms);  # returns two refs
}
############

#________________________________________________________________________
# Title     : get_posi_shift_rms_hash
# Usage     : ($rate1_ref,$rate2_ref) =${&get_posi_shift_rms_hash(\%msf_hash, \%jp_hash,
#                                                                 \%rms_file_hash, \$threshold)};
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : two refs. for scalar values of shift rate of positions for proteins.
#              frirst scalar is rate without correcting rms deviation
#              second scalar is rate with    correcting rms deviation
#             >> example of xx
#
#             1cdg            APDTSVSNKQ NFSTDVIYQI FTDRFSDGNP ANNPTGAAFD GTC.TNLRLY
#             2aaa            ......LSAA SWRTQSIYFL LTDRFGR... ....TDNSTT ATCNTGNEIY
#
#             >> example of xx
#
#             2aaa       ------lsaasWrtqSIYFLLTDRFGrtdns-------ttatCntgneiy
#             1cdg       apdtsvsnkqnFSTDVIYQIFTDRFsdgnpannptgaafdgtCtn-lrly
#
#             >> example of xx
#
#             1cdg         APDTSVSNKQ NFSTDVIYQI FTDRFSDGNP ANNPTGAAFD GTCTN-LRLY
#             2aaa         ------LSAA SWRTQSIYFL LTDRFGRTDN S-------TT ATCNTGNEIY
#             1cdg_2aaa    ------7774 2221210000 0000000148 9-------99 41114-4000
#             1cdg_6taa    ------8674 2232220000 0000011059 9-------99 52114-3000
#
# Argument  : takes 4 hash REFERENCES for (one seq. and one struc. alignment(2nd arg)
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_shift_rms_hash{  # minimum sub of 'get_posi_shift_rate'
	my(%array1)  =%{$_[0]};  # sequential:  %array1 = seq1 BCC..D, seq2 DD..FD, seq3 ..LJK..KJLJ
	my(%array2)  =%{$_[1]};  # structural:  %array2 = seq1 B..CCD, seq2 DD..FD, seq3 KJ..LKKJL..J
	my(%rms_hash)=%{$_[2]};# from rms file (msarms resulting file)
	my($threshold)=${$_[3]};
	my(%array3)=();        # array3 has position differences between the same sequences
	my(@whole_length)=();  # %array2 is the structural alignments(from jp files)
	my(@string1, @string2, @seq_position1,
	  @seq_position2, $len_of_seq, @temp1, @temp2,
	  @position_diffs, @position_corrected1, @names );
	if($#_ < 3){  $threshold=6;  }
	@temp1= keys (%array1);  @temp2= keys (%array2);
	if ($#temp1 == $#temp2){   goto CALC;  };

	%array1 = %{&hash_common(\%array1, \%array2)}; # %array2 is from jp (structural)
	%array2 = %{&hash_common(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)}; # this removes wrong gaps(in '.' form, in MSF)
	%array2 = %{&remov_com_column(\%array2)};

	CALC:
	@names= keys %array2;
	for $name (@names){
	  @string1 =split('', $array1{$name});
	  @string2 =split('', $array2{$name}); # ! @string2 is the structural. ! (used)

			 @seq_position1  = @{&get_posi_sans_gaps(\$array1{$name})}; # positions after compacting.
			 @seq_position2  = @{&get_posi_sans_gaps(\$array2{$name})}; # @seq_position2 is structural

			  $len_of_seq =($#seq_position2+1);
					 push(@whole_length, $len_of_seq);

			 @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
			 @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
			 #print "@position_corrected1";
			 $array3{$name}=join(",", @position_corrected1); # array3 is for disply of seq.
	}                      # !! split and join char is ',';

	# %array3 has the form.  These numbers are position differences between the same sequences
	#                        one from str. one from seq.
	# seq1  1,1,2,3,.,2,3,.,1,.,0,0,0,1,1,1,1,1,2
	# seq2  1,1,2,1,.,1,3,.,1,.,0,0,1,0,1,1,1,3,2
	# seq3  1,1,2,3,.,2,3,.,1,.,1,1,0,0,1,1,1,3,2

	%rms_hash=%{&convert_num_to_0_or_1_hash(\%rms_hash, \$threshold)};

	($final_posi_diffs, $final_posi_diffs_rms)=&get_posi_diff_and_rms_hash(\%array3, \%rms_hash); # get_posi_diff_hash uses
	%final_posi_diffs=%{$final_posi_diffs};
	%final_posi_diffs_rms=%{$final_posi_diffs_rms};

	my($sum_of_posi_diffs)    =${&sum_hash(\%final_posi_diffs)};
	my($sum_of_posi_diffs_rms)=${&sum_hash(\%final_posi_diffs_rms)};

	my($av_of_posi_diffs)     =$sum_of_posi_diffs/($#names+1); # dividing by seq number.
	my($av_of_posi_diffs_rms) =$sum_of_posi_diffs_rms/($#names+1); # dividing by seq number.

	my($sum_seq_length)   =${&sum_array(\@whole_length)};
	my($av_rate)          =$av_of_posi_diffs/($sum_seq_length);
	my($av_rate_rms)      =$av_of_posi_diffs_rms/($sum_seq_length);
	#&print_seq_in_block(\%final_posi_diffs); # <--- leave this
	(\$av_rate, \$av_rate_rms);  #---------> returns two ref. for rates.
}

#________________________________________________________________________
# Title     : open_rms_files
# Function  : open rms files and put sequences in a hash
#             Example of rms (aa
#             1cdg         APDTSVSNKQ NFSTDVIYQI FTDRFSDGNP ANNPTGAAFD GTCTN-LRLY
#             2aaa         ------LSAA SWRTQSIYFL LTDRFGRTDN S-------TT ATCNTGNEIY
#             6taa         ------ATPA DWRSQSIYFL LTDRFARTDG S-------TT ATCNTADQKY
#             1cdg_2aaa    ------7774 2221210000 0000000148 9-------99 41114-4000
#             1cdg_6taa    ------8674 2232220000 0000011059 9-------99 52114-3000
#             2aaa_6taa    ------1000 0000000000 0000000010 0-------00 0000000000
#
#             Example output hash;
#             1nor        LECHNQQSSQPPTTKTCS-GETNCYKKWWSDH----RGTIIERGFFC--GCPKVK-PGVNLNCCRT-DRCNN-------
#             1cdg        APDTSVSNKQNFSTDVASISGLVTSLP-QGSYNDVLGGLLNGNTLSVGSGGAASNFTLAAGGTAVWQYTAATATPTIGH
#             1cdg_2aaa   ------777002112111-----343333---431127----5433234-72354541131211111176899999999
#
# Usage     : %anyarray = {&open_rms_files(\$any_sequence_file_msf_form)};
# Example   :
# Warning   : xxx.rms files are Tim Hubbard's 'msarms' program's output.
# Keywords  :
# Options   :
# Returns   : a ref. of a hash
# Argument  : takes one ref. for a file.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_rms_files{
	my(@names, $n, $s, $n2, $s2, $n3, $s3, %hash);
	unless (-e ${$_[0]}){
	  print chr(7);
	  print "\n\n\t This is sub open_rms_files in th_lib.pl \n\n";
	  print "\n\n\t Fatal: The input file $file1 is not in the directory \n";
	  die;
	}
	open(FILE_1,"${$_[0]}");  	# reading in (rms file)
	while(<FILE_1>){         	# file1 needs to be xxxx.rms for the moment, automatic later
	  if(/^(\w\w\w\w)[\t]*\s+([\-\w ]+)[\n]$/){ $n=$1;  $s=$2; $s =~s/ //g; $hash{$n}.= $s;
	  }elsif(/^(\w\w\w\w_\w\w\w\w+)[\t]*\s+([\-\d( )\-]+)[\n]$/){
		  $n2=$1; $s2=$2; $s2=~s/ //g; $hash{$n2}.= $s2;
	  }elsif(/^(\w\w\w\w\w)(\w\w\w\w+)[\t]*\s+([\-\d( )\-]+)[\n]$/){
		  $n3="$1_$2"; $s3=$3; $s3=~s/ //g;   $hash{$n3}.= $s3;
	  }
	}
	return( \%hash );
}
#________________________________________________________________________
# Title     : open_rms_files2
# Function  : same as open rms files but returns two hashes.
#             Example of rms (aa
#             1cdg         APDTSVSNKQ NFSTDVIYQI FTDRFSDGNP ANNPTGAAFD GTCTN-LRLY
#             2aaa         ------LSAA SWRTQSIYFL LTDRFGRTDN S-------TT ATCNTGNEIY
#             1cdg_2aaa    ------7774 2221210000 0000000148 9-------99 41114-4000
#             1cdg_6taa    ------8674 2232220000 0000011059 9-------99 52114-3000
#
#             Example output 2 hashes;
#             1nor        LECHNQQSSQPPTTKTCS-GETNCYKKWWSDH----RGTIIERGFFC--GCPKVK-PGVNLNCCRT-DRCNN-------
#             1cdg        APDTSVSNKQNFSTDVASISGLVTSLP-QGSYNDVLGGLLNGNTLSVGSGGAASNFTLAAGGTAVWQYTAATATPTIGH
#
#             1cdg_2aaa   ------777002112111-----343333---431127----5433234-72354541131211111176899999999
#             1cdg_2taa   ------777002112111-----343333---431127----5433234-72354541131211111176899999999
#
# Usage     : ($hash_for_jp, $hash_for_rms) = &open_rms_files(\$any_sequence_file_msf_form);
# Example   :
# Warning   : xxx.rms files are Tim Hubbard's 'msarms' program's output.
# Keywords  :
# Options   :
# Returns   : return(@out); while @out is (\%hash_rms, \%hash_jp)
# Argument  : takes one ref. for a file.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_rms_files2{
	my(@names, $n,$s,@out,$n2,$s2,$n3,$s3, %hash_jp,%hash_rms);
	unless (-e ${$_[0]}){   print chr(7);
	  print "\n\n\t This is sub open_rms_files in th_lib.pl \n\n";
	  print "\n\n\t Fatal: The input file $file1 is not in the directory \n"; die; }
	open(FILE_1,"${$_[0]}");  	# reading in (rms file)
	while(<FILE_1>){         	# file1 needs to be xxxx.rms for the moment, automatic later
	  if(/^(\w\w\w\w)[\t]*\s+([\-\w ]+)[\n]$/){ $n=$1; $s=$2; $s =~s/ //g; $hash_jp{$n}.= $s;}
	  elsif(/^(\w\w\w\w_\w\w\w\w+)[\t]*\s+([\-\d( )\-]+)[\n]$/){
		  $n2=$1; $s2=$2; $s2=~s/ //g; $hash_rms{$n2}.= $s2; }
	  elsif(/^(\w\w\w\w\w)(\w\w\w\w+)[\t]*\s+([\-\d( )\-]+)[\n]$/){
		  $n3="$1_$2"; $s3=$3; $s3=~s/ //g;   $hash_rms{$n3}.= $s3;  } }
	push(@out, \%hash_rms, \%hash_jp); return(@out);
}



#________________________________________________________________________
# Title     : steve_permute_array  (C) Steve Brenner, copyrighted.
# Usage     : %final_out_hash=%{&steve_permute_array(\@list, \2, \4)};
#                         Above is for pairs, 3 seqs, and 4 seqs.
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : a ref. of a hash.
# Argument  : upto 3 arg. 1st one is for the ref. of an array. 2nd for min
#             element no. 3rd for max element no. 2nd and 3rd are optional.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub steve_permute_array{
	my(@lst) =@{$_[0]};  my($from)=${$_[1]};  my($to)  =${$_[2]};
	if ($from > $to){
	 print "\n Error, you put higher \$from ($from) than \$to ($to). \$to must be equal or bigger\n
				  than \$from for right permuation\n";  }
	$from--;  # to make min and max numbers sensible.
	my($res, $com, $count, %final_out_hash, @res );
	@res = @{&CombinAll(\@lst, \$from, \$to)};
			#______________________________________________
			 sub CombinAll{
			 my (@lst) = @{$_[0]};
			 my ($from)= ${$_[1]};
			 my ($to)  = ${$_[2]};
			 my ($i, $res, @ret);
				for $i (1 .. $to){  # <<------------  change this to limit the maximum elements
				  push (@ret, @{&Combin(\@lst, $i)});
				  #_____________________________
				  sub Combin{
					 my ($lst)=$_[0];
					 my ($num)=$_[1];
					 my ($i,$elt, @newlst, $com, $res, @ret );
					 return [[]] if $num == 0;
					 foreach $i (0 .. (@$lst-1)) {
						$elt = $lst->[$i];  # the element of interest
						@newlst = @{$lst}[$i+1 .. (@{$lst}-1)];
						$res = &Combin(\@newlst, $num-1);
						foreach $com (@{$res}) {
						splice(@$com,0,0,$elt);
						  push (@ret,$com);
						}
					 }
					 \@ret;
				  }
				  #______________________________
				}
				\@ret;
			  }
			  #_____________________________________________
	foreach $com (@res) {
	 $count++;  my($entry_key)="$count$#{$com}";   # the output will be (eg)  (1 'abc,ccd', 2, 'ccd,efg',,,)
	 $final_out_hash{$entry_key}=join(",", @{$com}) if @{$com} > $from;  }
	\%final_out_hash;
}

#_______________________________________________________________________________
# Title     : concatenate_tandem_repeats_table_in_html
# Usage     : &concatenate_tandem_repeats_table_in_html (\$input_dir);
#             @included_files= &concatenate_tandem_repeats_table_in_html("d=$input_dir", "e=$file_extention");
# Function  : open dir and process all files in the dir if you wish,
#             This specifically handles html files under chr21 directory.
#             ~/DB/Genomes/Euk/Human/Chr21  concatenates html files with certain
#             information only
#
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something,
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
# Options   :
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
#    $file_extention= by e=
#    $input_dir= by d=
# Category  :
# Version   : 1.2
#---------------------------------------------------------------------------
sub concatenate_tandem_repeats_table_in_html{
	 my ($each_file, $file, $new_fasta_name, %pdb_seq, @included_files,
			 $min_seq_leng_accepted, @read_files, $original_dir, $file_extention,
			 $out_concatenated_fasta_seq_file, $copy_number, $temp_name,
			 $repeat, $repeat_leng);

	 if($_[0]=~/d=(\S+)/){ $original_dir=$1; }
	 if($_[1]=~/e=(\S+)/){ $file_extention=$1; }

	 @read_files=@{&read_any_dir_simple(\$original_dir)};
	 chomp($pwd=`pwd`);
	 foreach $file(@read_files){
				$each_file="$original_dir/$file";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the File read is DIR => Recurse
				#________________________________________________________
				if( -d "$each_file" ){  ## If it is a directory.
						$num=@included_files=(@included_files, &concatenate_tandem_repeats_table_in_html("d=$each_file", "e=$file_extention") );   # RECURSION occurrs here!!

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the File read is FILE => PROCESS!
				#________________________________________________________
				}elsif (-f $each_file){     #<<------ This is where things match
						@dir=split(/\//, $each_file);
						$dir=$dir[($#dir-1)];  # $dir is the name of directory in where you are.

						###  put any program which does something here #################################
						if($each_file=~/([^\/]+)\.$file_extention/){
						   $tandem_repeat_line_found=0;
							 $out_concatenated_file_name="./concatenated_file\.$file_extention";
							 $out_concatenated_fasta_seq_file="./concatenated_FASTA_file\.mnfa";
							 open(EACH_FILE, "<$each_file");
							 open(OUT_CONCATENATED, ">>$out_concatenated_file_name");
							 open(OUT_FASTA_SEQ, ">>$out_concatenated_fasta_seq_file");
							 while(<EACH_FILE>){
							    if(/(\<H1\>tandem\s+repeats.+)/){
											print OUT_CONCATENATED "<br>\n$1 in $each_file\n";
											$tandem_repeat_line_found=1;
									}elsif($tandem_repeat_line_found and /(\d+)\s+seq:\s+([atgc]+)\</){
											$copy_number=$1;
											$repeat=$2;
											$repeat_leng=length($repeat);
							        if($repeat_leng >= 12 and $copy_number >= 3){
													$temp_name=substr($repeat, 0, 12);
													print OUT_CONCATENATED $_;
													print OUT_FASTA_SEQ ">$temp_name $copy_number $repeat_leng\n$repeat\n";
							        }
							    }elsif($tandem_repeat_line_found and /^\s*$/){
							        print OUT_CONCATENATED "\<\/table\>\n";
											$tandem_repeat_line_found=0;
							    }else{
							        $tandem_repeat_line_found=0;
							    }
							 }
							 close(EACH_FILE);
							 close(OUT_CONCATENATED);
							 close(OUT_FASTA_SEQ);
							 push(@included_files, $each_file);
							 print "\n      (i) \$each_file: $each_file \t\t\t is added to \@included_files";
						}
						next;
				}elsif (-l $each_file){
						print "\n\n$each_file is linked, skipping. \n";
						next;
				}else{  print "\n# (i) ODD?? "; next;  }
		}
		return(@included_files);
}



#_______________________________________________________________________________
# Title     : concatenate_seq_files_in_subdir_to_db
# Usage     : &concatenate_seq_files_in_subdir_to_db(\$input_dir);
#                     $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something,
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
# Options   :
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
#    $file_extention= by e=
#    $input_dir= by d=
# Category  :
# Version   : 1.0
#---------------------------------------------------------------------------
sub concatenate_seq_files_in_subdir_to_db{
	 my ($each_file, $file, $new_fasta_name, %pdb_seq, @included_files,
			 $min_seq_leng_accepted, @read_files, $original_dir, $file_extention);

	 if($_[0]=~/d=(\S+)/){ $original_dir=$1; }
	 if($_[1]=~/e=(\S+)/){ $file_extention=$1; }

	 @read_files=@{&read_any_dir_simple(\$original_dir)};
	 chomp($pwd=`pwd`);
	 foreach $file(@read_files){
				$each_file="$original_dir/$file";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the File read is DIR => Recurse
				#________________________________________________________
				if( -d "$each_file" ){  ## If it is a directory.
						$num=@included_files=(@included_files, &concatenate_seq_files_in_subdir_to_db("d=$each_file", "e=$file_extention") );   # RECURSION occurrs here!!

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the File read is FILE => PROCESS!
				#________________________________________________________
				}elsif (-f $each_file){     #<<------ This is where things match
						@dir=split(/\//, $each_file);
						$dir=$dir[($#dir-1)];  # $dir is the name of directory in where you are.

						###  put any program which does something here #################################
						if($each_file=~/([^\/]+)\.$file_extention/){
							 $out_concatenated_file_name="./concatenated_file\.$file_extention";
							 open(EACH_FILE, "<$each_file");
							 open(OUT_CONCATENATED, ">>$out_concatenated_file_name");
							 while(<EACH_FILE>){
									print OUT_CONCATENATED $_;
							 }
							 close(EACH_FILE);
							 close(OUT_CONCATENATED);
							 push(@included_files, $each_file);
							 print "\n      (i) \$each_file: $each_file \t\t\t is added to \@included_files";
						}
						next;
				}elsif (-l $each_file){
						print "\n\n$each_file is linked, skipping. \n";
						next;
				}else{  print "\n# (i) ODD?? "; next;  }
		}
		return(@included_files);
}


#_______________________________________________________________________________
# Title     : opendir_and_go_in_and_do_something
# Usage     : @files=&opendir_and_go_in_and_do_something("d=$input_dir");
#                 $input_dir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something, open_subdir_and_gon_in_and_do_something
#             open_directory_and
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
#
#             ** Check out some subs derived from this:
#              concatenate_seq_files_in_subdir_to_db
#              opendir_and_go_in_and_make_pdb_db
# Options   :
#    $input_dir= by d=
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.7
#---------------------------------------------------------------------------
sub opendir_and_go_in_and_do_something{
    my ($each_file, $file, $new_fasta_name, %pdb_seq, @included_files,
        $min_seq_leng_accepted, @read_files, $original_dir);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Input argument processing and reading in all the files
    #______________________________________________________________
    if(ref($_[0]) eq 'SCALAR'){
        ${$_[0]}=~/d=(\S+)/){ $original_dir=$1;
    }elsif($_[0]=~/d=(\S+)/){ $original_dir=$1; }
		@read_files=@{&read_any_dir_simple(\$original_dir)};
		sub read_any_dir_simple { my($in_dir); $in_dir=${$_[0]} || $_[0]; opendir(DIR1,"$in_dir");
		    my(@read_files) = readdir(DIR1);closedir(DIR1);	splice(@read_files, 0, 2);  return(\@read_files);
	}

	chomp($pwd=`pwd`);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Processing each files and directories
    #_______________________________________________________________
	foreach $file(@read_files){
         $each_file="$original_dir/$file";

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If the File read is DIR => Recurse
         #________________________________________________________
         if( -d "$each_file" ){  ## If it is a directory.
              $num=@included_files=(@included_files, &opendir_and_go_in_and_do_something("d=$each_file") );   # RECURSION occurrs here!!

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If the File read is FILE => PROCESS!
         #________________________________________________________
         }elsif (-f $each_file){     #<<------ This is where things match
              @dir=split(/\//, $each_file);
              $dir=$dir[($#dir-1)];  # $dir is the name of the subdirectory in where you are.
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # If you need to write in the subdir, first you need to chdir
              #_______________________________________________________________
              chdir($dir);
              ###  put any program which does something here #################################
              chdir("..");

              next;
         }elsif (-l $each_file){
              print "\n\n$each_file is linked, skipping. \n";
              next;
         }else{  print "\n# (i) ODD?? "; next;  }
	}
	return(\@included_files);
}




#_______________________________________________________________________________
# Title     : opendir_and_go_in_and_make_pdb_db
# Usage     : &opendir_and_go_in_and_do_something(\$input_dir);
#                     $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something, process_file_in_subdirs,
#             do_recursive_job_in_subdir
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
# Options   :
#    $min_seq_leng_accepted= by m=
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.3
#---------------------------------------------------------------------------
sub opendir_and_go_in_and_make_pdb_db{
		my ($realfile1, $file, $new_fasta_name, %pdb_seq, @Big_PDB_DB,
			 $min_seq_leng_accepted);
		my $original_dir = ${$_[0]} || $_[0];  ## $dir[0] is a ref. $original_dir

		if($_[1]=~/m=(\d+)/){    $min_seq_leng_accepted=$1 }else{ $min_seq_leng_accepted=0 }

		print "\n# opendir_and_go_in_and_do_something: original dir is $original_dir";
		my @read_files=@{&read_any_dir_simple($original_dir)};
		chomp($pwd=`pwd`);

		sub read_any_dir_simple { my($in_dir); $in_dir=${$_[0]} || $_[0]; opendir(DIR1,"$in_dir");
				my(@read_files) = readdir(DIR1);closedir(DIR1);	splice(@read_files, 0, 2);  return(\@read_files);
		}

		foreach $file(@read_files){
				$realfile1="$original_dir/$file";
				#print "\n# (i) \$realfile1 is $realfile1";
				if( -d "$realfile1" ){  ## If it is a directory.
						print "\n     # (i) \$realfile1: $realfile1 is dir";
						$num=@Big_PDB_DB=(@Big_PDB_DB, &opendir_and_go_in_and_make_pdb_db($realfile1) );   # RECURSION occurrs here!!
						print "\n# (i) NUMBER of \@Big_PDB_DB elem is $num ---------\n";
				}elsif (-f $realfile1){     #<<------ This is where things match
						@dir=split(/\//, $realfile1);
						$dir=$dir[($#dir-1)];  # $dir is the name of directory in where you are.
						###  put any program which does something here ###
						print "\n          # (i) \$realfile1: $realfile1 is file";
						if($realfile1=~/\S\/(\d\w+)\.brk$/){
							 $new_fasta_name="$original_dir\/"."$1\.pfa";
							 if(-s "$original_dir\/"."$1\.fasta"){
									 unlink("$original_dir\/"."$1\.fasta"); # removing old style filename
							 }
							 print "\n# (i) Output fasta will be $new_fasta_name";
							 if(-s $new_fasta_name){
									 %pdb_seq=%{&open_fasta_files(\$new_fasta_name)};
							 }else{
									 %pdb_seq=%{&open_pdb_files(\$realfile1)};
									 &write_fasta(\%pdb_seq, \$new_fasta_name );
							 }
							 push(@Big_PDB_DB, {%pdb_seq});
						}
						system("uncompress $new_brk_name") if $new_brk_name =~/(\.Z)$/ and -s $new_brk_name;
						next;
				}elsif (-l $realfile1){
						print "\n\n$realfile1 is linked, skipping. \n";
						next;
				}else{  print "\n# (i) ODD?? "; next;  }
		}
		return(@Big_PDB_DB);
}



#_______________________________________________________________________________
# Title     : open_subdir_and_go_in_and_do
# Usage     : &open_subdir_and_go_in_and_do(\$input_dir);
#                     $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something,
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
# Options   :
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.3
#---------------------------------------------------------------------------
sub open_subdir_and_go_in_and_do{
	 my ($realfile1, $file, $new_fasta_name, %pdb_seq, @Big_PDB_DB,
			 $min_seq_leng_accepted, @read_files, $original_dir);
	 $original_dir = ${$_[0]} || $_[0];  ## $dir[0] is a ref. $original_dir

		if($_[1]=~/m=(\d+)/){    $min_seq_leng_accepted=$1 }else{ $min_seq_leng_accepted=0 }

		@read_files=@{&read_any_dir_simple(\$original_dir)};
		chomp($pwd=`pwd`);
		foreach $file(@read_files){
				$realfile1="$original_dir/$file";
				if( -d "$realfile1" ){  ## If it is a directory.
						$num=@Big_PDB_DB=(@Big_PDB_DB, &opendir_and_go_in_and_do_something(\$realfile1) );   # RECURSION occurrs here!!
				}elsif (-f $realfile1){     #<<------ This is where things match
						@dir=split(/\//, $realfile1);
						$dir=$dir[($#dir-1)];  # $dir is the name of directory in where you are.

						###  put any program which does something here #################################
						print "\n          # (i) \$realfile1: $realfile1";
						if($realfile1=~/\S+\.html$/){
							 &add_adverts_in_html_files(\$realfile1);
						}
						next;
				}elsif (-l $realfile1){
						print "\n\n$realfile1 is linked, skipping. \n";
						next;
				}else{  print "\n# (i) ODD?? "; next;  }
		}
		return(@Big_PDB_DB);
}


#________________________________________________________________________
# Title     : get_occurances_of_shift_type_hash
# Usage     : for single protein group
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one reference  of hash. (eg, 0=>1000, 1=>888, 2=>83, ...
#                                          0,1,2... are position shift types
#                                          1000, 888, 83... are occurances in
#                                          the comparision between str. and seq.
#                                          alignments.)
# Argument  : Two references of hashes.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_occurances_of_shift_type_hash{  # minimum sub of 'get_posi_shift_rate'
	my(%array1)=%{$_[0]};   # %array1 = seq1 BCC..D, seq2 DD..FD, seq3 ..LJK..KJLJ
	my(%array2)=%{$_[1]};   # %array2 = seq1 B..CCD, seq2 DD..FD, seq3 KJ..LKKJL..J
	my(@whole_length)=();    # %array2 is the structural alignments(from jp files)
	my(%array3)=();
	my(@string1, @string2, @seq_position1,
	  @seq_position2, $len_of_seq,
	  @position_diffs, @position_corrected1, @names
	);
	%array1 = %{&hash_common(\%array1, \%array2)};
	%array2 = %{&hash_common(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)}; # this removes wrong gaps(in '.' form, in MSF)
	%array2 = %{&remov_com_column(\%array2)};

	@names= keys %array2;
	for $name (@names){
	  @string1 =split('', $array1{$name});
	  @string2 =split('', $array2{$name}); # ! @string2 is the structural. ! (used)

			 @seq_position1  = @{&get_posi_sans_gaps(\$array1{$name})};
			 @seq_position2  = @{&get_posi_sans_gaps(\$array2{$name})}; # @seq_position2 is structural

			  $len_of_seq =($#seq_position2+1);
					 push(@whole_length, $len_of_seq);

			 @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
			 @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
			 #print "@position_corrected1";
			 $array3{$name}=join(",", @position_corrected1); # array3 is for disply of seq.
	}                      # !! split and join char is ',';

	# %array3 has the form.  These numbers are position differences between the same sequences
	#                        one from str. one from seq.
	# seq1  1,1,2,3,.,2,3,.,1,.,0,0,0,1,1,1,1,1,2
	# seq2  1,1,2,1,.,1,3,.,1,.,0,0,1,0,1,1,1,3,2
	# seq3  1,1,2,3,.,2,3,.,1,.,1,1,0,0,1,1,1,3,2
	my(%final_posi_diffs) =%{&get_posi_diff_hash(\%array3)};
	my($sum_of_posi_diffs)=${&sum_hash(\%final_posi_diffs)};
	my($av_of_posi_diffs) =$sum_of_posi_diffs/($#names); # dividing by seq number.
	my($sum_seq_length)   =${&sum_array(\@whole_length)};
	my($av_rate)          =$av_of_posi_diffs/($sum_seq_length);
	&print_seq_in_block(\%final_posi_diffs); # <--- leave this
	for (values %final_posi_diffs){
	 my(@splited) = split(',', $_);
			for (@splited){
			  $out{$_}++ if ($_ =~ /\d+/);
			}
	}
	return(\%out);
}

#________________________________________________________________________
# Title     : get_occurances_of_shift_type_hash_all
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_occurances_of_shift_type_hash_all{  # minimum sub of 'get_posi_shift_rate'
	my(%array1)=%{$_[0]};   # %array1 = seq1 BCC..D, seq2 DD..FD, seq3 ..LJK..KJLJ
	my(%array2)=%{$_[1]};   # %array2 = seq1 B..CCD, seq2 DD..FD, seq3 KJ..LKKJL..J
	my(@whole_length)=();    # %array2 is the structural alignments(from jp files)
	my(%array3)=();
	my(@string1, @string2, @seq_position1,
	  @seq_position2, $len_of_seq,
	  @position_diffs, @position_corrected1, @names
	);
	%array1 = %{&hash_common(\%array1, \%array2)};
	%array2 = %{&hash_common(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)}; # this removes wrong gaps(in '.' form, in MSF)
	%array2 = %{&remov_com_column(\%array2)};

	@names= keys %array2;
	for $name (@names){
	  @string1 =split('', $array1{$name});
	  @string2 =split('', $array2{$name}); # ! @string2 is the structural. ! (used)

			 @seq_position1  = @{&get_posi_sans_gaps(\$array1{$name})};
			 @seq_position2  = @{&get_posi_sans_gaps(\$array2{$name})}; # @seq_position2 is structural

			  $len_of_seq =($#seq_position2+1);
					 push(@whole_length, $len_of_seq);

			 @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
			 @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
			 #print "@position_corrected1";
			 $array3{$name}=join(",", @position_corrected1); # array3 is for disply of seq.
	}                      # !! split and join char is ',';

	# %array3 has the form.  These numbers are position differences between the same sequences
	#                        one from str. one from seq.
	# seq1  1,1,2,3,.,2,3,.,1,.,0,0,0,1,1,1,1,1,2
	# seq2  1,1,2,1,.,1,3,.,1,.,0,0,1,0,1,1,1,3,2
	# seq3  1,1,2,3,.,2,3,.,1,.,1,1,0,0,1,1,1,3,2
	my(%final_posi_diffs) =%{&get_posi_diff_hash(\%array3)};
	my($sum_of_posi_diffs)=${&sum_hash(\%final_posi_diffs)};
	my($av_of_posi_diffs) =$sum_of_posi_diffs/($#names); # dividing by seq number.
	my($sum_seq_length)   =${&sum_array(\@whole_length)};
	my($av_rate)          =$av_of_posi_diffs/($sum_seq_length);
	&print_seq_in_block(\%final_posi_diffs); # <--- leave this
	for (values %final_posi_diffs){
	 my(@splited) = split(',', $_);
			for (@splited){
			  $out{$_}++ if ($_ =~ /\d+/);	 }
	}
	# the final result is %out which has accumulated entries with occurances
}

#________________________________________________________________________
# Title     : get_occurance_frequency_of_char
# Usage     : %occu=%{&get_occurance_frequency_of_char(\%in, $percentage_out,
#                          $return_freq_ratio, $name_attached,
#                          "s=$split_char_size")};
#
# Function  : gets the numbers/ratio of occurances for any char given in
#              strings, array, hash etc.
#             If hash is given, it only looks at the values.
#             If multiple string, array, hash or combinations of these
#              are given, it will add up to one single result
# Example   :
# Warning   :
# Keywords  : composition of chars, composition table making,
#             make_composition, make composition table
#             occurances_of_char, get_char_occurances, occurances
#             get_percentage_occurances_of_char, percentage_occurances_of_char
# Options   :
#   $percentage_out=p by p     'p' for percentage output of the char among others
#   $name_attached=n by n            'n' for NO name option when HASH input is given
#   $return_freq_ratio=r by r  'r' for RATIO  One_aa_frq/total_residue
#   $split_char_size= by s=          This is the char size, 1, 2<- ('AB'), 3<- ('ABC')
# Returns   : one ref. of hash  (a =>5, b=>6, c=>4,,,,,)
# Argument  : one ref. of hash (seq1 alsdfjlsj
#                               seq2 asldfjsld
#                               seq3 owiurouou);
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------
sub  get_occurance_frequency_of_char{
		 my ($i, $j, %H, $name_attached, @fragments, $N,@splited, $val,$percentage_out,
				 $split, $sum, %frquency_hash, $sequence, $char_size, @sizes_of_char,
				 @keys, %percent, $total_fragment_count, $return_freq_ratio, $split_char_size,
				 %freq_ratio, $char_size, $temp);
		 $split_char_size=1;

		 for($i=0; $i< @_; $i++){
					 if($_[$i]=~/^[\-]?p$/i){
							$percentage_out='p';   splice(@_, $i, 1);         $i--;
					 }elsif($_[$i]=~/^[\-]?n$/i){
							$name_attached='n';          splice(@_, $i, 1);         $i--;
					 }elsif($_[$i]=~/^[\-]?r$/i){
							$return_freq_ratio='r'; $percentage_out=''; splice(@_, $i, 1);        $i--;
					 }elsif($_[$i]=~/s=(\d*)$/i){
							$temp=$1;
							splice(@_, $i, 1);        $i--;
							if($temp=~/\S/){  $split_char_size=$temp; push(@sizes_of_char, $split_char_size); }
					 }elsif($_[$i]=~/^(\d+)$/i){
							$split_char_size=$1; splice(@_, $i, 1);        $i--;
							push(@sizes_of_char, $split_char_size);
					 }
		 }

		 unless(@sizes_of_char > 0){ push(@sizes_of_char,$split_char_size) }

		 for($i=0; $i< @_; $i++){
						my(@fragments);
						if(  ref($_[$i]) eq 'HASH'){
								my %H=%{$_[$i]};
								my @names=keys %H;
								splice(@_, $i, 1);  $i--;
								for $key (@names){
										my $sequence=$H{$key};
										for($j=0; $j< @sizes_of_char; $j++){
											 $split_char_size=$sizes_of_char[$j];
											 for($s=0; $s < $split_char_size; $s++){
													if(length($sequence) < $split_char_size){ last }
													@fragments=$sequence=~/(\S{$split_char_size})/g;
													print  "\n# @fragments #\n";
													$sequence=substr($sequence, 1, );
													if($name_attached){
															for($k=0; $k<@fragments; $k++){
																 $frquency_hash{ "$key\_$fragments[$k]"}++;
																 $total_fragment_count++;
															}
													}else{
															for($k=0; $k<@fragments; $k++){
																 $frquency_hash{$fragments[$k]}++;
																 $total_fragment_count++;
															}
													}
											 }
										}
								}
						}elsif(ref($_[$i]) eq 'ARRAY'){
								@splited=@{$_[$i]};
								for $split (@splited){  $frquency_hash{$split}++; $sum++ }
								splice(@_, $i, 1);                $i--;
						}elsif(ref($_[$i]) eq 'SCALAR'){
										splice(@_, $i, 1);                $i--;
										$sequence=${$_[$i]};
										for($j=0; $j< @sizes_of_char; $j++){
											 $split_char_size=$sizes_of_char[$j];
											 for($s=0; $s < $split_char_size; $s++){
													push(@fragments, $sequence=~/(\S{$split_char_size})/g);
													$sequence=substr($sequence, $s+1, );
													if(length($sequence) < $split_char_size){ last }
											 }
											 if($name_attached){
													 for($k=0; $k<@fragments; $k++){
															$frquency_hash{ "$key\_$fragments[$k]"}++;
															$total_fragment_count++;
													 }
											 }else{
													 for($k=0; $k<@fragments; $k++){
															$frquency_hash{ $fragments[$k]}++;
															$total_fragment_count++;
													 }
											 }
										}
						}elsif( !(ref($_[$i])) and $_[$i]=~/\S/){
								$sequence=$_[$i];
								$seq_length=length($sequence);
								for($j=0; $j< @sizes_of_char; $j++){
									 $split_char_size=$sizes_of_char[$j];
									 for($s=0; $s < $split_char_size; $s++){
											push(@fragments, $sequence=~/(\S{$split_char_size})/g);
											$sequence=substr($sequence, 1, );
											if(length($sequence) < $split_char_size){ last }
									 }
									 if($name_attached){
											 for($k=0; $k<@fragments; $k++){
													$frquency_hash{ "Reside\_$fragments[$k]"}++;
													$total_fragment_count++;
											 }
									 }else{
											 for($k=0; $k<@fragments; $k++){
													$frquency_hash{ $fragments[$k]}++;
													$total_fragment_count++;
											 }
									 }
								}
								splice(@_, $i, 1);                $i--;
						}
	}
	if($percentage_out){
						@keys=keys %frquency_hash;
						%percent;
						for($i=0; $i< @keys; $i++){
									 $percent{$keys[$i]} = $frquency_hash{$keys[$i]}/$total_fragment_count*100;
						}
						return(\%percent);
	}elsif($return_freq_ratio){
						@keys=keys %frquency_hash;
						for($i=0; $i< @keys; $i++){
								$freq_ratio{$keys[$i]} = $frquency_hash{$keys[$i]}/$total_fragment_count;
						}
						return(\%freq_ratio);
	}else{
						return(\%frquency_hash);
	}
}



#________________________________________________________________________
# Title     : get_occurances_of_char
# Usage     : %occurances_shft_type=%{&get_occurances_of_char(\%final_posi_diffs)};
#             %char_occur=%{&get_occurances_of_char(\@ref_array_of_chars)};
#             %char_occur=%{&get_occurances_of_char(\$ref_string_of_chars)};
#             %char_occur=%{&get_occurances_of_char($string_of_chars)};
#
# Function  : gets the numbers of occurances for 1, 2, 3 ... position shifts.
#             If hash is given, it only looks at the values.
#             If multiple string, array, hash or combinations of these
#              are given, it will add up to one single result
# Example   :
# Warning   :
# Keywords  : composition of chars, composition table making,
#             make_composition, make composition table
#             occurances_of_char, get_char_occurances, occurances
#             get_percentage_occurances_of_char, percentage_occurances_of_char
# Options   : 'p' for percentage output of the char among others
#             'n' for NO name option when HASH input is given
# Returns   : one ref. of hash  (a =>5, b=>6, c=>4,,,,,)
# Argument  : one ref. of hash (seq1 alsdfjlsj
#                               seq2 asldfjsld
#                               seq3 owiurouou);
# Category  :
# Version   : 1.4
#--------------------------------------------------------------------
sub  get_occurances_of_char{
		my ($i, %H, $no_name, %out, $N,@splited, $val,$percentage_out,
		 $split, $sum);
		for($i=0; $i< @_; $i++){
		if($_[$i]=~/^[\-]?p$/i){
			 $percentage_out=1;   splice(@_, $i, 1);         $i--;
		}elsif($_[$i]=~/^[\-]?n$/i){
			 $no_name=1;          splice(@_, $i, 1);         $i--;
		}
		}

		for($i=0; $i< @_; $i++){
		if(  ref($_[$i]) eq 'HASH'){
			my %H=%{$_[$i]};
			my @names=keys %H;
			for $key (@names){
						 for $split ( split(//, $H{$key}) ){
										if($no_name==1){ $N=$split
										}else{ $N="$key\_$split"; }
								$out{$N}++; $sum++
						 }
			}
		}elsif(ref($_[$i]) eq 'ARRAY'){
			@splited=@{$_[$i]};
			for $split (@splited){  $out{$split}++; $sum++ }
		}elsif(ref($_[$i]) eq 'SCALAR'){
			 @splited = split(//, ${$_[$i]});
			 for $split (@splited){  $out{$split}++; $sum++ }
		}elsif( !(ref($_[$i])) ){
			 @splited = split(//, $_[$i]);
			 for $split (@splited){  $out{$split}++; $sum++ }
		}
		}
		if($percentage_out==1){
		 my @keys=keys %out;
		 my %percent;
		 for($i=0; $i< @keys; $i++){
						$percent{$keys[$i]} = $out{$keys[$i]}/$sum*100;
		 }
		 return(\%percent);
		}else{
		 return(\%out);
		}
}


#________________________________________________________________________
# Title     : make_composition_table
# Usage     : %occurances=%{&make_compos_table(\%key_and_value_for_seq)};
# Function  : gets the numbers of occurances for 1, 2, 3 ... position shifts.
# Example   :
# Warning   :
# Keywords  : composition of chars, composition table making, make composition table
#             make_composition_table, get_composition, get_amino_acid_composition
#             protein_composition, make_aa_composition_tablem, aa_composition
# Options   :
# Returns   : one ref. of hash  (a =>5, b=>6, c=>4,,,,,)
# Argument  : one ref. of hash (seq1 alsdfjlsj
#                               seq2 asldfjsld
#                               seq3 owiurouou);
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub  make_composition_table{
		 my %input = %{$_[0]};
		 my (@splited, $split, %out );
		 for (values %input){
				@splited = split(//, $_);
				for $split (@splited){  $out{$split}++; }
		 }
		 return(\%out);
}

#________________________________________________________________________
# Title     : make_composition_ratio_table_simple
# Usage     : %occurances=%{&make_compos_ratio_table(\%final_posi_diffs)};
# Function  : gets ratio of the numbers of occurances for any chars.
# Example   :
# Warning   : This pools all the sequences, to not distinct seq composition if
#              you put more than one seq.
# Keywords  : composition table, composition of chars, composition table making,
#             make composition table, make_composition_table
# Options   :
# Returns   : one ref. of hash  (a =>0.05, b=>0.06, c=>0.04,,,,,)
# Argument  : one ref. of hash (seq1 alsdfjlsj
#                               seq2 asldfjsld
#                               seq3 owiurouou);
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub  make_composition_ratio_table_simple{
	my %input = %{$_[0]};
	my %out;
	my (@keys, $i, %ratio_out, $each_char_occur, @splited, $split, $all_occur );
	for (values %input){
	 @splited = split(//, $_);
	 for $split (@splited){  $out{$split}++; $all_occur ++; }
	}
	@keys = keys %out;
	for ($i=0; $i < @keys; $i ++){
	 $each_char_occur = $out{$keys[$i]};
	 $ratio_out{$keys[$i]} = $each_char_occur/$all_occur;
	}
	return(\%ratio_out);
}

#________________________________________________________________________
# Title     : make_composition_ratio_table
# Usage     : %rate=%{&make_compos_ratio_table(\%hash1, \%hash2, ,,,)};
# Function  : gets ratio of the numbers of occurances for any chars.
# Example   :
# Warning   : This produces each composition ration table for each seq
# Keywords  : composition table, composition of chars, composition table making,
#             make composition table, make_composition_table
#             aa_composition_ratio, composition_ratio, protein_composition,
#             get_composition_ratio, get_aa_composition_ratio
# Options   :
# Returns   : one ref. of hash  ('seq_name', { a =>0.05, b=>0.06, c=>0.04,,,,, } )
# Argument  : one or more ref. of hash (seq1 alsdfjlsj
#                                       seq2 asldfjsld
#                                       seq3 owiurouou);
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub  make_composition_ratio_table{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my %final_out, %ratio_out;

	for($i=0; $i < @hash; $i ++){ ## @hash has [\%seq1, \%seq2,....]
	 my %input = %{$hash[$i]};      ## taking single hash
	 print "\n",__LINE__, " \%input has ", %input, "\n" if ($debug == 1);
	 my (%out, $all_occur);
	 my @seq_names = keys %input;     ## taking Seq names from each hash input.
	 print "\n",__LINE__, " \@seq_names has ", @seq_names, "\n" if ($debug == 1);
	 for( $j=0; $j < @seq_names; $j++){
		 %ratio_out=();
		 my $split;
		 my $name = $seq_names[$j];
		 my $seq = $input{$seq_names[$j]};
		 my @splited = split(//, $seq);
		 for $split (@splited){  $out{$split}++; $all_occur ++; }
		 my @amino_residue = keys %out;
		 print "\n",__LINE__, " \@amino_residue ", @amino_residue , "\n" if ($debug == 1);
		 for ($k=0; $k < @amino_residue; $k ++){
	      my $each_char_occur = $out{$amino_residue[$k]};
	      $ratio_out{$amino_residue[$k]} = $each_char_occur/$all_occur;
		 }
		 $final_out{$name}=\%ratio_out;
	 }
	}
	if(@hash==1){ return(\%ratio_out); }
	else{ \%final_out } #  \%final_out has ('seqname', \%hash_of_ratio_of_amino_acids )
}

#________________________________________________________________________
# Title     : get_position_shift_rate (derived from 'get_posi_shift_hash' )
# Usage     : %rate_hash = %{&get_position_shift_rate(\%hash_msf, \%hash_jp)};
# Function  : This is to get position specific error rate for line display rather than
#             actual final error rate for the alignment. Takes two file names of seq.
#             Output >>
#             seq1_seq2  1110...222...2222
#             seq2_seq3  1111....10...1111
#             seq1_seq3  1111....0000.0000
#
# Example   : my(%error_rate)=%{&get_position_shift_rate(\%input, \%input2)};
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   : 'ss' for secture regions(Helix and Beta region only
#                 calculation for error rate). There is specialized sub called
#              get_segment_shift_rate for sec. str. only handling.
#
#    $ss_opt            becomes    ss by  ss, SS, -ss, -SS     #  for secture only
#    $H                 =         'H' by   -H or -h or H       # to retrieve only H segment
#    $S                 becomes   'S' by   -S or  S            # to retrieve only S segment
#    $E                 becomes   'E' by   -E or  E            # to retrieve only E segment
#    $T                 becomes   'T' by   -T or -t or T or t  # to retrieve only T segment
#    $I                 becomes   'I' by   -I or  I            # to retrieve only I segment
#    $G                 becomes   'G' by   -G or -g or G or g  # to retrieve only G segment
#    $B                 becomes   'B' by   -B or -b or B or b  # to retrieve only B segment
#    $HELP              becomes    1  by   -help   # for showing help
#    $simplify          becomes    1  by   -p or P or -P, p
#    $simplify          becomes    1  by   -simplify or simplify, Simplify SIMPLIFY
#    $comm_col          becomes   'C' by   -C or C or common
#    $LIMIT             becomes    L  by   -L, L               # to limit the error rate to 9 .
#
# Returns   : \%final_posi_diffs;
# Argument  : %{&get_position_shift_rate(\%msfo_file, \%jpo_file)};
#             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------
sub get_position_shift_rate{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	print __LINE__," \$char_opt is  \"$char_opt\" in get_position_shift_rate\n" if $debug eq 1;
	print __LINE__," \@string is  \"@string\" in get_position_shift_rate\n" if $debug eq 1;
	print __LINE__," \$LIMIT is  \"$LIMIT\" in get_position_shift_rate\n" if $debug eq 1;

	my(%arraySEQ)=%{$hash[0]};
	my(%arraySTR)=%{$hash[1]};
	my($gap_char, %final_posi_diffs, @stringSTR,@stringSEQ,@seq_positionSEQ,
		@seq_positionSTR,$len_of_seq, @position_diffs, @position_corrected1,
		@names, @whole_length, %array3, @keys_common, %DSSP_common, @stringDSSP_common);

	$gap_char='.';

	%arraySTR = %{&hash_common_by_keys(\%arraySTR, \%arraySEQ)};
	%arraySEQ = %{&hash_common_by_keys(\%arraySEQ, \%arraySTR)};
	%arraySEQ = %{&remov_com_column(\%arraySEQ)};
	%arraySTR = %{&remov_com_column(\%arraySTR)};

	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if($debug eq 1){
		print __LINE__,
		" ## sorting sequence names. To make things constant. \n\n";  }
	@names= sort keys %arraySTR;
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#  If common column of secture representation option $comm_col is set
	#  open_dssp_files sub routine will get the common seq parts of all the sequences.
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if($comm_col =~ /C/i){
		%DSSP_common=%{&open_dssp_files( @names, $H, $S, $E, $T, $I, $G, $B, $simplify, 'C')};
		@keys_common= keys %DSSP_common;
		@stringDSSP_common = split(/|\,/, $DSSP_common{$keys_common[0]});
		if($debug2 eq 1){ print __LINE__," \$comm_col is set to: $comm_col \n";
			print __LINE__," \@stringDSSP_common is :@stringDSSP_common \n";
		}
	}

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	# Comparing two hashes
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	for $name (@names){
		#"""""""""""""""" Splitting the sequence string
		if($arraySEQ{$name}=~/\,\S+\,/){
			@stringSEQ =split(/\,/, $arraySEQ{$name});
			@stringSTR=split(/\,/, $arraySTR{$name});  }
		else{
			@stringSEQ =split(//, $arraySEQ{$name});
			@stringSTR=split(//, $arraySTR{$name});
		}
		print "\n",__LINE__, " \@stringSEQ  is  @stringSEQ \n" if $debug2 eq 1;
		print "\n",__LINE__, " \@stringSTR  is  @stringSTR \n" if $debug2 eq 1;

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#   Contracting  the SEQ.
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		@seq_positionSEQ = @{&get_posi_sans_gaps(\$arraySEQ{$name})};
		@seq_positionSTR = @{&get_posi_sans_gaps(\$arraySTR{$name})};

		#"""""""""""""""" To get secture only calc  """"""""""""""""""""""""""""
		# It superposes the NON sec. region on  @seq_positionSTR to nullify positions.
		#  get_posi_diff ignores non char positions in calc.
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		if( ($ss_opt =~ /ss$/i) && ($comm_col !~ /C/i) ){
			%DSSP=%{&open_dssp_files($name, $H, $S, $E, $T, $I, $G, $B, $simplify, $comm_col)};
			if($debug1 eq 1){
			   print "\n",__LINE__," open_dssp_files has options \$H ->$H \$S->$S \$E->$E \n";
			   print "\n",__LINE__," \$T->$T \$I->$I \$G->$B \$simplify->$simplify \$comm_col ->$comm_col\n";
			   &show_hash( \%DSSP );
			}
			if(ref(\%DSSP) eq 'HASH'){ # to check it %DSSP was valid, If not it skips overlaying
				@stringDSSP = split(/|\,/, $DSSP{$name});
				$size_of_stringDSSP = @stringDSSP;
				$size_of_seq_positionSTR = @seq_positionSTR;
				if($debug2 eq 1){
					  print "\n",__LINE__," \@stringDSSP is \n @stringDSSP\n";
					  print "\n",__LINE__," Size of \@stringDSSP      is $size_of_stringDSSP\n" ;
					  print "\n",__LINE__," Size of \@seq_positionSTR is $size_of_seq_positionSTR\n";
					  print "\n",__LINE__," \$gap_char is \"$gap_char\" \n" ;
				}
				#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
				#   When the sec. str is not defined in DSSP, I delete the position of
				#   @stringDSSP to gap(ie. make it blank to exclude error rate calc)
				#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
				for($i=0; $i < @stringDSSP; $i++){
					if($stringDSSP[$i] =~ /\W/){ $seq_positionSTR[$i]= $gap_char;}
				}
			}
		}elsif( $comm_col =~ /C/i){
				print __LINE__, " Replacing position with \gap_char \"$gap_char\"\n" if $debug2 eq 1;
				$ss_opt = 'ss'; # whether it was set or not, make it 'ss'
				for($i=0; $i < @stringDSSP_common; $i++){
					if($stringDSSP_common[$i] =~ /\W/){ $seq_positionSTR[$i]= $gap_char;}
				}
		}

		if($debug2 eq 1){
			print __LINE__,
			print " \@seq_positionSTR is  @seq_positionSTR\n";
		}

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#   getting Position differences.
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		@position_diffs  = @{&get_posi_diff(\@seq_positionSEQ, \@seq_positionSTR)};

		if($debug2 eq 1){
			print __LINE__,
			print " \@position_diffs is  @position_diffs\n";
		}

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#  You can have two types of output according to which alignment you compare your
		#   error rates. (1) Compare to @stringSEQ   (2) @stringSTR
		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		@position_corrected1 = @{&put_position_back_to_str_seq(\@stringSEQ, \@position_diffs)};
		$array3{$name}=join(",", @position_corrected1);

	}
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	# The final Step for error rate, $LIMIT is to confine error rate in one digit (ie, less than 10)
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	%final_posi_diffs =%{&get_residue_error_rate(\%array3, $LIMIT)};

    @whole_length=(); $len_of_seq='';
	return(\%final_posi_diffs);
}

#________________________________________________________________________
# Title     : get_posi_rates_hash_out (derived from 'get_posi_shift_hash' )
# Usage     : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
# Function  : This is to get position specific error rate for line display rather than
#             actual final error rate for the alignment.
#             Output >>
#             seq1_seq2  1110...222...2222
#             seq2_seq3  1111....10...1111
#             seq1_seq3  1111....0000.0000
#
# Example   :
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   :
# Returns   : \%final_posi_diffs;
# Argument  : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
#             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_rates_hash_out{
	my(%array1)=%{$_[0]};
	my(%array2)=%{$_[1]};
	my(@string1, @string2, @seq_position1, @seq_position2,
	  $len_of_seq,@position_diffs, @position_corrected1,
	  @names, @whole_length, %array3);
	%array1 = %{&hash_common_by_keys(\%array1, \%array2)};
	%array2 = %{&hash_common_by_keys(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)};
	%array2 = %{&remov_com_column(\%array2)};
	@names= keys %array2;
	for $name (@names){
	  @string1 =split('', $array1{$name});
	  @string2 =split('', $array2{$name});
	  @seq_position1 = @{&get_posi_sans_gaps(\$array1{$name})};
	  @seq_position2 = @{&get_posi_sans_gaps(\$array2{$name})};
	  $len_of_seq =(@seq_position2);
	  push(@whole_length, $len_of_seq);
	  @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
	  @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
	  $array3{$name}=join(",", @position_corrected1);  }
	my(%final_posi_diffs)=%{&get_each_posi_diff_hash(\%array3)};
    @whole_length=(); $len_of_seq='';
	return(\%final_posi_diffs);
}

#________________________________________________________________________
# Title     : get_posi_diff_hash
# Usage     : %position_diffs =\{&get_posi_diff_hash(\@seq_position1, \@seq_position2)};
# Function  : gets a ref. of a hash and calculates the position diffs.
# Example   :
# Warning   : split and join char is ',';    # used in 'get_posi_shift_hash'
# Keywords  :
# Options   :
# Returns   : one ref. for an array of differences of input arrays. array context.
#             ---Example input (a hash with sequences); The values are differences after comparion
#                                            with structural and sequential alignments.
#             %diffs =('seq1', '112342431111
#             'seq2', '12222...09011.1122',
#             'seq3', '13222...00011.1122',
#             'seq4', '12262...00011.112.');
#             example output;
#             seq3_seq4       01040...00000.000.
#             seq1_seq2       01012...1810...122
#             seq1_seq3       02012...1110...122
#             seq1_seq4       01032...1110...12.
#             seq2_seq3       01000...09000.0000
#             seq2_seq4       00040...09000.000.
# Argument  : Takes a ref. for hash which have positions of residues of sequences.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_diff_hash{
	if(ref($_[0]) ne 'HASH' ){
		print "\n Arg not not hash ref in get_posi_diff_hash \n\n";print chr(7);die;}
	else{   my(%diffs)= %{$_[0]};  my(@names)= keys (%diffs);
	  my(%seqs_compared_in_pair)=();  my(@temp, @temp2);
	  for ($i=0; $i < @names; $i ++){
		 if($diffs{$names[$i]} =~/\,/){  @temp = split(',', $diffs{$names[$i]});}
		 else{ @temp = split('', $diffs{$names[$i]}); }  (@{"string$i"})=@temp; }
		 for ($i=0; $i < @names; $i++){
			for ($j=$i+1; $j < @names; $j ++){
			for ($k=0; $k < @string0; $k ++){
			  if ((${"string$i"}[$k] =~ /[-\d+]/) && (${"string$j"}[$k] =~ /[-\d+]/)){
				  my($diff) = abs(${"string$i"}[$k] - ${"string$j"}[$k]);
				  push(@temp2, $diff); }
			  else{  push(@temp2, '.'); }    }
			$seqs_compared_in_pair{"$names[$i]\_$names[$j]"}=join(",", @temp2) if $names[$i] < $names[$j];
			$seqs_compared_in_pair{"$names[$j]\_$names[$i]"}=join(",", @temp2) if $names[$i] > $names[$j];
			@temp2=();     }    }
	 \%seqs_compared_in_pair; }
}

#________________________________________________________________________
# Title     : get_posi_shift_hash  (bug free!!)
# Usage     : $rate_final = ${&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
# Function  :
# Example   :
# Warning   : split and join char is ','; (space)
# Keywords  :
# Options   :
# Returns   : One scalar value of shift rate of position for proteins.
# Argument  : takes two hash REFERENCES for (one seq. and one struc. alignment(2nd arg)
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_posi_shift_hash{
	my(%array3, @whole_length);
	my(%array1)=%{$_[0]};   # %array1 = seq1 BCC..D, seq2 DD..FD, seq3 ..LJK..KJLJ
	my(%array2)=%{$_[1]};   # %array2 = seq1 B..CCD, seq2 DD..FD, seq3 KJ..LKKJL..J
	my(@string1, @string2, @seq_position1, @seq_position2, $len_of_seq, @names,
	  @position_diffs, @position_corrected1 );
	%array1 = %{&hash_common(\%array1, \%array2)}; # %array2 is from jp (structural)
	%array2 = %{&hash_common(\%array2, \%array1)};
	%array1 = %{&remov_com_column(\%array1)};
	%array2 = %{&remov_com_column(\%array2)};  @names= keys %array2;

	for $name (@names){
	  @string1 =split('', $array1{$name});
	  @string2 =split('', $array2{$name}); # ! @string2 is the structural. ! (used)

	  @seq_position1  = @{&get_posi_sans_gaps(\$array1{$name})};
	  @seq_position2  = @{&get_posi_sans_gaps(\$array2{$name})}; # @seq_position2 is structural

	  $len_of_seq = @seq_position2;
	  push(@whole_length, $len_of_seq);

	  @position_diffs = @{&get_posi_diff(\@seq_position1, \@seq_position2)};
	  @position_corrected1 = @{&put_position_back_to_str_seq(\@string2, \@position_diffs)};
	  $array3{$name}=join(",", @position_corrected1); # array3 is for disply of seq.
	}                      # !! split and join char is ',';

	# %array3 has the form.  These numbers are position differences between the same sequences
	#                        one from str. one from seq.
	# seq1  1,1,2,3,.,2,3,.,1,.,0,0,0,1,1,1,1,1,2
	# seq2  1,1,2,1,.,1,3,.,1,.,0,0,1,0,1,1,1,3,2
	# seq3  1,1,2,3,.,2,3,.,1,.,1,1,0,0,1,1,1,3,2
	my(%final_posi_diffs) =%{&get_posi_diff_hash(\%array3)};
	my($sum_of_posi_diffs)=${&sum_hash(\%final_posi_diffs)};
	my($av_of_posi_diffs) =$sum_of_posi_diffs/(@names); # dividing by seq number.
	my($sum_seq_length)   =${&sum_array(\@whole_length)};
	my($av_rate)          =$av_of_posi_diffs/($sum_seq_length);
	return(\$av_rate);
}



#________________________________________________________________________
# Title     : print_seq_in_block_with_print
# Usage     : &print_seq_in_block (\%input_hash1,\%input_hash2, \%input_hash3.... );
# Function  : gets a ref(s) for hash and prints the content in lines of 60 char
# Example   :
# Warning   : derived from  print_in_block
# Keywords  :
# Options   :
# Returns   : Nothing, STDOUT
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub print_seq_in_block_with_print{
	my(%input)=%{$_[0]};
	my(@names)=keys(%input);
	my($larg, $offset, $diff, $gap_char);
	my($seq)=0;
	$gap_char='.';  # <-- setting default gap character.
	for ($i=0; $i <=$#names; $i++){
	 $larg = length($input{$names[$i]}) if length($input{$names[$i]}) > $larg;
	 if ($input{$names[$i]} =~ /\-/){
		$gap_char='-';
	 }elsif($input{$names[$i]} =~ /\./){
		$gap_char='.';
	 }
	}

		  ######====== filling the end part gaps in shorter sequences #####
	for ($i=0; $i <=$#names; $i++){
	  if (length($input{$names[$i]}) < $larg){
				$offset=length($input{$names[$i]});
					  $diff=$larg-$offset;
					  substr($input{$names[$i]}, $offset, $larg)= "$gap_char" x $diff;
			 }
	}
		  ######====== filling the end part gaps in shorter sequences #####

	for ($k=0; $k < $larg; $k+=60){     # 60 residues interval
	 for($i=0; $i <=$#names; $i++){    # number of sequences
		print $names[$i], "  \t";       # 2 spaces and tab between the names and sequences.
		$input{$names[$i]}=~ s/\n//g;
		$seq = substr($input{$names[$i]}, $k, 60);
		print $seq;
		print "\n";                     # put a new line.
	 }
	 print "\n";                       # next block starts.
	}
}

#________________________________________________________________________
# Title     : fill_ending_space
# Usage     : (*out, *out2, *out3)=&fill_ending_space(\%input1, \%input2, \%input3);
#             &print_seq_in_block(\%out,\%out2,\%out3); <-- if you want printout.
# Function  : fills the ending gaps or space of sequences (shorter ones)
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : (\%hash1,..... )
# Argument  : (\%input1, \%input2, \%input3.....);
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fill_ending_space{
	my(@out_hash_list);
	my($gap_char,$larg);
	for($a=0; $a<@_; $a++){
	 my(%hash)=%{$_[$a]};
	 my(@names)=keys(%hash); $gap_char='.';
		for ($i=0; $i < @names; $i++){
		  if (length($hash{$names[$i]}) > $larg){ $larg =length($hash{$names[$i]});}
		  if($hash{$names[$i]} =~ /\-/){  $gap_char='-'; }
		  elsif($hash{$names[$i]} =~ /\./){ $gap_char='.'; }
		  $hash{$names[$i]}=~s/\s/$gap_char/g;  }
		for ($i=0; $i < @names; $i++){
		  if (length($hash{$names[$i]}) < $larg){ $offset=length($hash{$names[$i]});
				$diff=$larg-$offset;
				if ($diff == 0){ next; }
				substr($hash{$names[$i]}, $offset, $larg)= "$gap_char" x $diff; } }
		push(@out_hash_list, \%hash);  }
	if($#_ == 0){ return(\%hash); }
	elsif($#_ > 0){ return(@out_hash_list); } # <-- contains (\%out_seq0, \%out_seq1, \%out_seq2, .... )
}

#________________________________________________________________________
# Title     : print_seq_in_block_old
# Usage     : &print_seq_in_block_old (\%input_hash1,\%input_hash2, \%input_hash3.... );
# Function  : gets a ref(s) for hash (single key and value)
#             and prints the content in lines of 60 char
# Example   :
# Warning   : This is more or less for debugging. Use  print_seq_in_block
# Keywords  :
# Options   :
# Returns   : Nothing, STDOUT
# Argument  : one or more refs. for hash
#               if there are more than one array input it makes such outputs
#
#             Name1    THIS.IS.from.hash.one
#             Name2    This
#
#             Name1    THIS
#             Name2    This.is.from.hash.two
#
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub print_seq_in_block_old{
	for ($i=0; $i <=$#_; $i++){
	 (${"name$i"}, ${"seq$i"}) = each (%{$_[$i]});
	 ${"seq$i"}=~ s/\n//g;               # rid of new line.
			@{"seq_array$i"}= split('', ${"seq$i"});
	 $larg = $#{"seq_array$i"} if ($#{"seq_array$i"} > $larg);
	}    # results = %hash1, %hash2, %hash3, ...
	for ($k=0; $k<=$larg; $k+=60){        # 60 residues interval
	 for($i=0; $i <=$#_; $i++){          # number of sequences
		print ${"name$i"}, "  \t";        # space between the names and sequences.
		for ($j=$k; $j<=($k+59); $j++){   # 1 to 60 and 61 to 120 etc...
		  print ${"seq_array$i"}[$j];     # prints one line
		}
		print "\n";                       # put a new line.
	 }
	 print "\n";                         # next block starts.
	}
}
#________________________________________________________________________
# Title     : print_in_block   (look at print_seq_in_block !!)
# Usage     : &print_in_block (\@input_array,\@input_array2, \@input_array3.... );
# Function  : gets a ref(s) for array and prints the content in lines of 60 char
# Example   :
# Warning   : This is more or less for debugging. Use  print_seq_in_block
# Keywords  :
# Options   :
# Returns   : Nothing, STDOUT
# Argument  : one or more refs. for array
#               if there are more than one array input it makes such outputs
#             Example out)
#               THIS.IS.from.array.one
#             This.is.from.array.two
#
#              THIS.IS.from.array.one
#               This.is.from.array.two
#
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub print_in_block{
	for ($i=0; $i <=$#_; $i++){
	 @{"arr$i"}= @{$_[$i]}; my($larg) = $#{"arr$i"} if ($#{"arr$i"}>$larg);}
	for ($k=0; $k <=$larg; $k+=60){       # 60 residues interval
	 for($i=0; $i <=$#_; $i++){  print "name$i", "  \t";
		for ($j=$k; $j <=($k+59); $j++){ print ${"arr$i"}[$j]; }
		  print "\n";  } print "\n"; }
}

#______________________________________________________________________________
# Title     : process_whole_dir_with_merge_sequence_alignments
# Usage     :
# Function  :
# Example   :  &process_whole_dir_with_merge_sequence_alignments(@ARGV,
#                     "l=$block_length", $sort_seq_names, $truncate_name,
#											"t=$trunc_name_to", "r=$block_range");
# Keywords  :
# Options   :
#    l=  for sequence block length by print_seq_in_block subroutine
#    t=  for specifying the length of seq names shown.
#    t   for truncating the seq names in printing out.
#    s   for sorting the final output lines (default anyway for print_seq_in_block)
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub process_whole_dir_with_merge_sequence_alignments{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($i, @files, @msso_interms, %msso_files, @msf_interms,
		   $query1, $query2, $interm, @seq, $block_length, $truncate_name_to_10_char,
		   $trunc_name_to, $sort_seq_names, $block_range);

		if($vars{'l'}=~/\d+/){  $block_length=$vars{'l'}; }
		if($char_opt=~/t/){    $truncate_name_to_10_char='t' }
		if($vars{'t'}=~/\d+/){ $trunc_name_to=$vars{'t'}; }
		if($char_opt=~/s/){    $sort_seq_names='s' }
		if($vars{'r'}=~/(\d+\-\d+)/){ $block_range= $1 };

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# If NO prompt args or Directory is give as an arg, process the whole dir
		# The file names should be like: XXXX_1-20_YYYY_1-30.msso or
		#                                XXXX_1-20_YYYY_1-30.msf  while YYYY is interm seq
		#___________________________________________________________________________
		if(@ARGV == 0 or -d $ARGV[0]){
				&parse_arguments(1);
				@files=@{&read_file_names_only('.')};
				for($i=0; $i< @files; $i++){
					 if($files[$i]=~/(\S+_\d+\-\d+)_(\S+_\d+\-\d+)\.msf$/){
							push(@{$msf_files{$2}}, $1);

					 }elsif($files[$i]=~/(\S+_\d+\-\d+)_(\S+_\d+\-\d+)\.msso$/){
							push(@{$msso_files{$2}}, $1);
					 }
				}
				@msso_interms=keys %msso_files;
				@msf_interms=keys %msf_files;

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# Handling MSSO files
				#_________________________________________________________________
				for($i=0; $i< @msso_interms; $i++){
					 unless(${$msso_files{$msso_interms[$i]}}[1]=~/\S/){ next }
					 $query1=${$msso_files{$msso_interms[$i]}}[0];
					 $query2=${$msso_files{$msso_interms[$i]}}[1];
					 $interm=$msso_interms[$i];
					 @msso_files=("$query1\_$interm\.msso", "$query2\_$interm\.msso");
					 @seq=@{&open_sso_files(@msso_files, 'a')};
					 &merge_sequence_alignments(@seq, "l=$block_length", $sort_seq_names, $truncate_name,
													"t=$trunc_name_to", "r=$block_range");

				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# Handling MSF files
				#_________________________________________________________________
				for($i=0; $i< @msf_interms; $i++){
					 unless(${$msf_files{$msf_interms[$i]}}[1]=~/\S/){ next }
					 $query1=${$msf_files{$msf_interms[$i]}}[0];
					 $query2=${$msf_files{$msf_interms[$i]}}[1];
					 $interm=$msf_interms[$i];
					 @msf_files=("$query1\_$interm\.msf", "$query2\_$interm\.msf");
					 @seq=@{&open_sso_files(@msf_files, 'a')};
					 &merge_sequence_alignments(@seq, "l=$block_length", $sort_seq_names, $truncate_name,
													"t=$trunc_name_to", "r=$block_range");

				}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# If file args (MSSO files) are given, process the 2 files
		#___________________________________________________________________________
		}elsif(@ARGV==2 and -f $ARGV[0]){
				my @files=@{&parse_arguments(1)};
				if($files[0]=~/msf$/){
					 @seq=&open_msf_files(@files);
				}elsif($files[0]=~/sso$/){
					 @seq=@{&open_sso_files(@files, 'a')}; ## a is for 'alignment'
				}
				print "\n# number of elements in \@seq ",scalar(@seq), "\n";

				if(@seq < 2){ print "\n \"\@seq\" has too few number of elements, dying !!!!!!\n\a\a\n\n"; }

				$sort_seq_names='s';

				print "# \$sort_seq_names is set to s  as default for $0 \n\n\n";
				&merge_sequence_alignments(@seq, "l=$block_length", $sort_seq_names, $truncate_name,
											 "t=$trunc_name_to", "r=$block_range");
		}else{
		    print "\n $0 needs either NO arg, ONE dir arg or 2 MSSO files \n\n";
		    die;
		}
}



#________________________________________________________________________
# Title     : get_posi_diff    # used in 'get_posi_shift_hash'
# Usage     : @position_diffs =&get_posi_diff(\@seq_position1,\@seq_position2);
# Function  :
# Example   : @compacted_posi_dif =(1 ,2, 1, 1, '.' ,2,  1,  1, '.');
#             @compacted_posi_dif2=(4 ,2, 1, 1, ,2,  1, '.' ,3,  1);
#             output ==> ( 3 0 0 0 . 1 . 2 .)   (it ignores positions which have non digits.
#             output ==> (-3 0 0 0 . 1 .-2 .) when abs is not used.
# Warning   :
# Keywords  :
# Options   :
# Returns   : one ref. for an @array of differences of input arrays. array context.
# Argument  : Takes two ref. for arrays which have positions of residues.
# Category  :
# Version   : 1.4
#--------------------------------------------------------------------
sub get_posi_diff{
	my(@positions1)=@{$_[0]};
	my(@positions2)=@{$_[1]};
	my(@num_diffs_between_str_and_ali, $diff, $z, $gap_char);
	if($debug eq 1){
	  print __LINE__, " # get_posi_diff : \n";
	}
	$gap_char = '.';
	for ($z=0; $z < @positions2; $z++){
	  if (($positions1[$z] =~ /\d+/) && ($positions2[$z] =~ /\d+/)){
		  $diff=($positions1[$z] - $positions2[$z]);
		  push(@num_diffs_between_str_and_ali, $diff );
	  }else{
		  push(@num_diffs_between_str_and_ali, $gap_char);
	  }
	}
	\@num_diffs_between_str_and_ali;
}

#________________________________________________________________________
# Title     : get_posi_diff_abs    # used in 'get_posi_shift_hash'
# Usage     : @position_diffs =&get_posi_diff_abs(\@seq_position1,\@seq_position2);
# Function  :
# Example   : @compacted_posi_dif =(1 ,2, 1, 1, '.' ,2,  1,  1, '.');
#             @compacted_posi_dif2=(4 ,2, 1, 1, ,2,  1, '.' ,3,  1);
#             output ==> ( 3 0 0 0 . 1 . 2 .)   (it ignores positions which have non digits.
#             output ==> (-3 0 0 0 . 1 .-2 .) when abs is not used.
# Warning   :
# Keywords  :
# Options   :
# Returns   : one ref. for an @array of differences of input arrays. array context.
# Argument  : Takes two ref. for arrays which have positions of residues.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_diff_abs{
	 my(@positions1)=@{$_[0]};  my(@positions2)=@{$_[1]};
	 my(@num_diffs_between_str_and_ali, $diff);
	 for ($z=0; $z<=$#positions2; $z++){
	  if (($positions1[$z] =~ /\d+/) && ($positions2[$z] =~ /\d+/))
	  {  # following abs is important for the behaviour of the output.
		  #push(@num_diffs_between_str_and_ali, (($positions1[$z] - $positions2[$z])) );
		  push(@num_diffs_between_str_and_ali, (abs($positions1[$z] - $positions2[$z])) );
	  }
 }
 return(\@num_diffs_between_str_and_ali);
}


#________________________________________________________________________
# Title     : put_position_back_to_str_seq ( put_posi_back_to_str_seq )
# Usage     : @result =@{&put_position_back_to_str_seq(\@string_from_struct, \@compacted_posi_dif)};
# Function  :
# Example   : @string_from_struct=('X', 'T', 'A' ,'B' , '.' ,'F',  'G', '.' , 'O' ,'P', '.');
#             @compacted_posi_dif=(1 ,2, 1, 1, ,2, 1, 1, 1);
# Warning   :
# Keywords  :
# Options   :
# Returns   : a ref. for an array
# Argument  : takes two refs for arrays (one for char the other for digits
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub put_position_back_to_str_seq{
	my(@string_from_struct)=@{$_[0]};
	my(@compacted_posi_dif)=@{$_[1]};
	my($j)=0; my($char)=0; my($i);
	for ($i=0; $i < @string_from_struct; $i++){
	 $char = $string_from_struct[$i];
	 if ($char =~ /\w/){
		 $string_from_struct[$i] = $compacted_posi_dif[$i-$j];
	 }else{ $j++; }
	}
	return(\@string_from_struct);
}


#________________________________________________________________________
# Title     : get_posi_shift_hash_rms
# Usage     : $result=${&get_posi_shift_hash_rm(\%h1, \%h2, \%h3)};
# Function  : caculates the error rate of seq after filtering according to
#                rms deviation.
# Example   :
# Warning   : Not complete yet.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_posi_shift_hash_rms{  # minimum sub of 'get_posi_shift_rate'
	my(%array1)=%{$_[0]};
	my(%array2)=%{$_[1]};
	my(%array3)=%{$_[2]};
	my($string1, $string2, $av_rate, $rate,$sum_rate,
	  $sum_of_diff, $rate2);
	my(@seq_position1, @rates, @rates2,@seq_position2, @names, @position_diffs)=();
	%array1 = %{&hash_common(\%array1, \%array2)};
	%array2 = %{&hash_common(\%array2, \%array1)};
	%array3 = %{&hash_common(\%array3, \%array1)};
	%array1 = %{&remov_com_column(\%array1)}; # this removes wrong gaps(in '.' form, in MSF)
	%array2 = %{&remov_com_column(\%array2)};
	&show_hash(\%array1);
	&show_hash(\%array2);
	@names=sort keys %array1;
	for($j=0; $j<= $#names ; $j++){  # nf1 is the number of seq.
	 my($name)=$names[$j];
	 $string1=$array1{$name};
	 $string2=$array2{$name};
	 @seq_position1 = @{&get_posi_sans_gaps(\$string1)};
	 @seq_position2 = @{&get_posi_sans_gaps(\$string2)};
	 @position_diffs =@{&get_posi_diff(\@seq_position1, \@seq_position2)};
	 $sum_of_diff = ${&sum_array(\@position_diffs)};
	 print "sum of diff  $sum_of_diff";&n;
	 print "positions  $#position_diffs"; &n;
	 $rate2=$sum_of_diff/($#position_diffs+1);
	 push(@rates2, $rate2);
	}
	$av_rate = ${&array_average(\@rates2)};
	return(\$av_rate);
}

#________________________________________________________________________
# Title     : open_fil_file (fil file meant to be rms file)
# Usage     : %out = %{&open_fil_file(\$input_seq_file)};
# Function  : reads xxx.fil file which shows whether I have to discard
#             regions of sequences due to too big RMS deviation.
# Example   :
# Warning   : !!! not yet complete !!!
# Keywords  :
# Options   :
# Returns   : a ref. for a hash(associative array).
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_fil_file{   # opening msf files. input is a file name.
	my($nf1)=-1;
	my($input_file)=${$_[0]};							# $_[0]=>input eg. $dir.$out_seq_no.msf
	my(@names, %arr);
	unless (-e $input_file){ print chr(007);  # beep warning for error
			print "\n\n\t This is sub open_fil_files in th_lib.pl \n\n";
			print "\n\n\t Fatal: The input file $file1 is not in the directory \n";
			print "\n\n\t  !!! Program dies abnormally, bugs !!! \n";
			&caller_info; &n; die;
	}
	open(FILE_1,"$input_file");  			# reading in (MSF)
	while(<FILE_1>){         				# file1 needs to be xxxx.msf for the moment, automatic later
			if(/^\s.+/){ next; }
			if(/\-+/)  { next; }				# to prevent lines with '-' as in hmm Sean's output
			if(/^([\w_]+)[\t]*\s+(\d+)$/){ 		# matching patterns (including tab space)
					 &caller_info if (($1 !=1) || ($1 !=0));
					 my($temp1)=$1;
					 my($temp2)=$2;
					 $temp2=~s/ //g;				   # removing all the spaces in $2
					 if( ! $arr{$temp1}){     		# if hash %array1 is not defined,
								$names[++$nf1]=$temp1; 	# with first set (names for seq.)
					 }
					 $arr{$temp1}.= $temp2;   		# maay and concatenate second set to first set(name)
			}
	}
	\%arr;
}

#________________________________________________________________________
# Title     : send_mail
# Usage     :
# Function  : mail a bunch of @lines to a user
# Example   :
#             send_mail ( $to, $subject, $from, @lines );
#             #-# i -- $to      = email address
#             #-# i -- $subject = string to be put in the Subject: line
#             #-# i -- @lines   = lines to be mailed - must not have \n
#             -- DISCUSSION:
#
#             Uses /usr/lib/sendmail to mail a bunch of lines to the email address
#             specified. The @lines should not have terminating \n characters: they
#             will be supplied.
#
#             -- EXAMPLE:
#             &P10::mail ( 'schip@lmsc.lockheed.com', 'Test 34', @mylines );
#             -- END
#             : Could some one share their knowledge of how to mail a message from
#             :  within a Perl script with a novice Perl user?
# Warning   :
# Keywords  : send_email
# Options   :
# Returns   :
# Argument  :
# Version   : 1.2
#--------------------------------------------------------------------
sub send_mail{
    my($pipe, $to, $subject, $from, @lines );
    ( $to, $subject, $from, @lines ) = @_;
    if(-s  "/usr/lib/sendmail"){
       $pipe = '|/usr/lib/sendmail -t';
    }elsif(-s  "/usr/bin/sendmail"){
       $pipe = '|/usr/bin/sendmail -t';
    }elsif(-s  "/usr/local/bin/sendmail"){
       $pipe = '|/usr/local/bin/sendmail -t';
    }
	open ( MAIL, $pipe ) || die "Cannot open: '$pipe'\n";
	print MAIL "To: $to\n";
	print MAIL  "Subject: $subject\n";
	print MAIL "From: $from\n";
	print MAIL "\n";
	print MAIL join("\n",@lines),"\n";
	close MAIL;
}


#________________________________________________________________________
# Title     : send_mail_to_me
# Usage     :
# Function  : mail a bunch of @lines to a user
# Example   :
#             send_mail ( $to, $subject, $from, @lines );
#             #-# i -- $to      = email address
#             #-# i -- $subject = string to be put in the Subject: line
#             #-# i -- @lines   = lines to be mailed - must not have \n
#             -- DISCUSSION:
#
#             Uses /usr/lib/sendmail to mail a bunch of lines to the email address
#             specified. The @lines should not have terminating \n characters: they
#             will be supplied.
#
#             -- EXAMPLE:
#             &P10::mail ( 'schip@lmsc.lockheed.com', 'Test 34', @mylines );
#             -- END
#             : Could some one share their knowledge of how to mail a message from
#             :  within a Perl script with a novice Perl user?
# Warning   :
# Keywords  : send_email send_email_to_me send_email_to_user send_mail_to_self
#             send_email_to_self
# Options   :
# Returns   :
# Argument  :
# Version   : 1.2
#--------------------------------------------------------------------
sub send_mail_to_me{
    my($pipe, $to, $subject, $from, @lines );
    (@lines) = @_;
    $subject="Message from $0";
    $user_name=getpwuid($>);
    $from="$user_name";
    if(-s  "/usr/lib/sendmail"){
       $pipe = '|/usr/lib/sendmail -t';
    }elsif(-s  "/usr/bin/sendmail"){
       $pipe = '|/usr/bin/sendmail -t';
    }elsif(-s  "/usr/local/bin/sendmail"){
       $pipe = '|/usr/local/bin/sendmail -t';
    }
	open ( MAIL, $pipe ) || die "Cannot open: '$pipe'\n";
	print MAIL "To: $user_name\n";
	print MAIL "Subject: $subject\n";
	print MAIL "From: $from\n";
	print MAIL "\n";
	print MAIL join("\n",@lines),"\n";
	close MAIL;
}

#________________________________________________________________________
# Title     : send_email
# Usage     :
# Function  : mail a bunch of @lines to a user
# Example   :
#             send_email ( $to, $subject, $from, @lines );
#             #-# i -- $to      = email address
#             #-# i -- $subject = string to be put in the Subject: line
#             #-# i -- @lines   = lines to be mailed - must not have \n
#             -- DISCUSSION:
#
#             Uses /usr/lib/sendmail to mail a bunch of lines to the email address
#             specified. The @lines should not have terminating \n characters: they
#             will be supplied.
#
#             -- EXAMPLE:
#             &P10::mail ( 'schip@lmsc.lockheed.com', 'Test 34', @mylines );
#             -- END
#             : Could some one share their knowledge of how to mail a message from
#             :  within a Perl script with a novice Perl user?
# Warning   :
# Keywords  : send_mail
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub send_email{
		my ( $to, $subject, $from, @lines ) = @_;
		my $pipe;
		$pipe = '|/usr/lib/sendmail -t';
		open ( MAIL, $pipe ) || die "Cannot open: '$pipe'\n";
		print MAIL "To: $to\n";
		print MAIL  "Subject: $subject\n";
		print MAIL "From: $from\n";
		print MAIL "\n";
		print MAIL join("\n",@lines),"\n";
		close MAIL;
}


#________________________________________________________________________
# Title     : rand_word
# Usage     : $word = ${&rand_word(7)};
#             print "sub rand_word gives $word\n";
# Function  : This sub routine should return an alphabet string of
#             length specified by  an argument.
# Example   :
# Warning   :
# Keywords  : randomize words, makes random words, scramble_word,
#              shuffle_words,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rand_word {
    my($length) = $_[0];
    my($word, $letter);
    srand(((time/$$)^($>*time))/(time/(time^$$)));

    foreach (1..$length){
         $letter = pack("c", rand(128));
         redo unless $letter =~ /[a-zA-Z]/;   # I just don't like \w, okay?
         $word .= $letter;
    }
    return(\$word);
}

#________________________________________________________________________
# Title     : opendir_and_go_rand_fasta_and_clustal
# Usage     : &opendir_and_go_rand_fasta_and_clustal(\$input_dir); #$inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files if you wish, and then go in any sub
#             dir of it. Using recursion. created by A Biomatic
#             if any file is linked, it skips that file.
# Example   : $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
#             &opendir_and_go($inputdir);
# Warning   : Seems to work fine.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub opendir_and_go_rand_fasta_and_clustal{
	 my($original_dir)=${$_[0]};
	 my(@read_files)=@{&read_any_dir(\$original_dir)};
	 foreach $file(@read_files){
		my($realfile1)=$original_dir.'/'.$file;
		if (-l $realfile1){
				print "\n\n$realfile1 is linked, skipping. \n";
				next;
		}elsif (-d $realfile1){
				&opendir_and_go_rand_fasta_and_clustal(\$realfile1);
		}elsif (-f $realfile1){ #<<------ This is where things match
				chdir($original_dir);
				$chk_file ='1-2-rev.fasta';
				if (-e $chk_file){
					last;
				}elsif($file =~/(\d+\-2)\.fasta$/){
					$out_file = "$1\-rand\.fasta";
					system("rand-fasta.pl $file $out_file");
					system("clustalw $out_file");
				}
		}else{
				next;
		}
	 }
}

#________________________________________________________________________
# Title     : opendir_and_go_rand_fasta
# Usage     : &opendir_and_go_rand_fasta(\$input_dir); #$inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files if you wish, and then go in any sub
#             dir of it. Using recursion. created by A Biomatic
#             if any file is linked, it skips that file.
# Example   : $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
#             &opendir_and_go($inputdir);
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub opendir_and_go_rand_fasta{
	 my($original_dir)=${$_[0]};
	 my(@read_files)=@{&read_any_dir(\$original_dir)};
	 foreach $file(@read_files){
		   my($realfile1)=$original_dir.'/'.$file;
		   if (-l $realfile1){
					  print "\n\n$realfile1 is linked, skipping. \n";
					  next;
		   }elsif (-d $realfile1){
			   &opendir_and_go_rand_fasta(\$realfile1);
		   }elsif (-f $realfile1){ #<<------ This is where things match
					  chdir($original_dir);

						$chk_file ='1-2-rev.fasta';
						if (-e $chk_file){
						   last;
						}elsif($file =~/(\d+\-2)\.fasta$/){
						   $out_file = "$1\-rand\.fasta";
								  system("rand-fasta.pl $file $out_file");
						}
		   }else{
					  next;
		   }
	 }
}

#________________________________________________________________________
# Title     : reverse_sequences
# Usage     : %out = %{&rev_sequence_one_hash(\%input_seq_hash, \%hash2,...)};
# Function  : gets ref. of strings, reverses the elems.
# Example   :
# Warning   :
# Keywords  : reverse_sequence, reverse_sequence_hash, rev_sequence_hash
# Options   :
# Returns   : one or more hash references.
# Argument  : hash, eg(1, 'skdfj', 2, 'kdfjkdj', 3, 'kdfjk');
#             Input example:
#             ..
#             >HI0256
#             FLSANVLPIAPIINGGRTAVDNITQSVSDKPFVKDIGTKIKEAIALSKYSTQPQYISTTN
#             >HI0094
#             DILRTFVKMETGLKFPKKFKLKANLALFMNRRNKRPDTIMTAVADAGQKISEAKLNTTAK
#             ..
#
#             Output example: (Reversed :-)
#             ..
#             >HI0256_rv   <<-- note the added extension
#             ALDJFLKAJFJALSDJFLAJSLFJAKLSDFJLASJDFLAJSLDFJASJDFLJSDFJSDLJ
#             >HI0094_rv
#             LASJDFLKAJFJALSDJFLKSDJLFAJLKDJFLASJDFLKDFJKDJFKDJFKDJFKJDLJ
#             ..
#
# Version   : 1.4
#--------------------------------------------------------------------
sub reverse_sequences{
		my(%rev_hash, @rev_hash_refs, $name, $name_short, $region,
			 $name_with_ext, $i);
		for($i=0; $i < @_; $i++){
				my %in_hash = %{$_[$i]};
						my @keys    = keys %in_hash;
						for $name (@keys ){
								if($name=~/(\S+)_(\d+\-\d+)/){
										$name_short=$1;  $region=$2;
										$name_with_ext = "$name_short\_$region\_rv";
								}else{
										$name_with_ext = "$name\_rv";
								}
								$rev_hash{$name_with_ext} = reverse($in_hash{$name});
						}
						push(@rev_hash_refs, \%rev_hash);
		}
		if(@rev_hash_refs ==1){ return($rev_hash_refs[0]);}
		else{ return(@rev_hash_refs);}
}




#________________________________________________________________________
# Title     : rev_sequence_mul_array
# Usage     : @out = @{&rev_sequence_mul_array(\@input_mul_seq_array)};
# Function  : gets a ref. of an string, reverses the elems.
# Example   :
# Warning   : This reverses sequences!
# Keywords  :
# Options   :
# Returns   : one ref. of  mul_array, eg. ('jfkdj', 'kdfjsdj', 'jjjkk')
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rev_sequence_mul_array{
	my(@in_array)=@{$_[0]};
	my(@rev_array, $reversed);
	for ($i = 0; $i <=$#in_array ; $i++){ $reversed =reverse($in_array[$i]);
	  push(@rev_array,$reversed);  }
	return(\@rev_array);
}



#________________________________________________________________________
# Title     : scramble_sequences
# Usage     : %out = %{&scramble_seq_hash(\%input_seq_hash)};
# Function  : gets ref. of strings, scambles the elems.
# Example   :
# Warning   :
# Keywords  : make_scrambled_seq, make_scrambled_sequence, scramble_seq_hash,
#              scramble_sequences, shuffle_sequences, shuffle_seq
# Options   :
# Returns   : (\%hashout), or (\%hash1, \%hash2,,,,,)
# Argument  : ref. of hash, eg(1, 'skdfj', 2, 'kdfjkdj', 3, 'kdfjk');
#
#             Input example:
#             ..
#             >HI0256
#             FLSANVLPIAPIINGGRTAVDNITQSVSDKPFVKDIGTKIKEAIALSKYSTQPQYISTTN
#             >HI0094
#             DILRTFVKMETGLKFPKKFKLKANLALFMNRRNKRPDTIMTAVADAGQKISEAKLNTTAK
#             ..
#
#             Output example: (scrambled :-)
#             ..
#             >HI0256_sc   <<-- note the added extension
#             ALDJFLKAJFJALSDJFLAJSLFJAKLSDFJLASJDFLAJSLDFJASJDFLJSDFJSDLJ
#             >HI0094_sc
#             LASJDFLKAJFJALSDJFLKSDJLFAJLKDJFLASJDFLKDFJKDJFKDJFKDJFKJDLJ
#             ..
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------
sub scramble_sequences{
	 my($gap_char)='';
	 my(@ran_hash_ref, $i, $j);
	 for($i=0; $i< @_; $i++){
		my(%in_hash)=%{$_[$i]};
		my(@names)  =keys %in_hash;
		my( @input, @random, %ran_hash );
        srand(time()|$$);  # or use srand(time^$$);
		for ($j=0; $j < @names; $j++){
			if($in_hash{$names[$j]} =~ /\w\,\w\,/){
			   $gap_char=',';
			}else{ $gap_char='';    }
			@input =split(/$gap_char/, $in_hash{$names[$j]});
			undef(@random);
			while (@input){
			   push(@random, splice(@input, int(rand(@input)) , 1) );
			}
			$ran_hash{"$names[$j]\_sc"}= join("$gap_char", @random);
		}
		push(@ran_hash_ref, \%ran_hash);
	}
	if(@ran_hash_ref ==1){
	return($ran_hash_ref[0]);
	}else{ return(@ran_hash_ref);}
}



#________________________________________________________________________
# Title     : scramble_string
# Usage     : $out = ${&scramble_seq_hash(\$input_seq_string)};
# Function  : gets ref. of strings, scambles the elems.
# Example   :
# Warning   :
# Keywords  : make_scrambled_str, make_scrambled_string, scramble_string_hash,
#              scramble_sequences, shuffle_strings, shuffle_str
# Options   :
# Returns   : (\$hashout), or (\$hash1, \$hash2,,,,,)
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub scramble_string{
    srand(time()|$$);
    my(@ran_hash_ref, $i, $j, @random, $output_string, $input_string);
    $input_string=${$_[0]} || $_[0];
    @input=split(//, $input_string);
    while (@input){
        push(@random, splice(@input, int(rand(@input)) , 1) );
    }
    $output_string=join('', @random);
    return(\$output_string);
}


#___________________________________________________________________
# Title     : scramble_array
# Usage     : @in=@{&scramble_array(\@in)};
# Function  : shuffles the elements of array
# Example   :
# Keywords  : randomise_array, randomize_array, shuffle_array
# Options   :
# Category  :
# Version   : 1.4
#---------------------------------------------------------------
sub scramble_array{
	srand(time()|$$);  # or use srand(time^$$);
	my ($i, @scrambled, @out, @each_array);

	for($i =0; $i< @_; $i++){
	   my @each_array = @{$_[$i]};
	   while (@each_array) {
		   push @scrambled, splice @each_array, int(rand(@each_array)), 1;
	   }
	   push(@out, \@scrambled);
	}
	if(@out > 1){
	   return(@out);
	}else{
	   return($out[0]);
	}
}


#________________________________________________________________________
# Title     : rand_sequence_mul_array  (not hash!)
# Usage     : @out = @{&rand_sequence_mul_array(\@input_mul_seq_array)};
# Function  : gets a ref. of an string, scambles the elem.
# Example   :
# Warning   : This scrambles sequences!!
# Keywords  : scramble_sequence_mul_array, shuffle_sequence_mul_array
# Options   :
# Returns   : one ref. of  mul_array, eg. ('jfkdj', 'kdfjsdj', 'jjjkk')
# Argument  : one ref. of mul_array, eg. ('lsjdfj', 'kdfjsdj', 'jjjkk')
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub rand_sequence_mul_array{
	my(@in_array)=@{$_[0]};
	my(@ran_array, $random);
	srand(time()|$$);
	for ($i = 0; $i < @in_array ; $i++){
	my(@input)=split(//,$in_array[$i]);
	 my($len1)=@input;
	 my($len2)=$len1;
	 my($ran_pos, $ran_num, $random, @random);
	 for ($k=$len1; $k > 0 ; $k--){ $ran_pos = int(rand($k));
		$ran_num=splice(@input, $ran_pos, 1); push(@random, $ran_num);  }
	 $random=join("",@random);
	 $ran_array[$i]=$random; }
	return(\@ran_array);
}

#________________________________________________________________________
# Title     : rand_sequence_one_string
# Usage     : @out = @{&rand_sequence_one_string(\$input_seq_string)};
# Function  : gets a ref. of a  string, scambles the elem.
# Example   :
# Warning   : This scrambles sequences!!
# Keywords  :
# Options   :
# Returns   : one ref. of string,
# Argument  : one ref. of string, eg ( 'ldkfjlsdjfsdjflj' )
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rand_sequence_one_string{
	my($input)=${$_[0]};
	my(@input)=split(//,$input);
	my($len1)=$#input+1;
	my($len2)=$len1;
	my($ran_pos, $ran_num, @random, $random);
	srand(time()|$$);
	for ($i=$len1; $i > 0 ; $i--){    $ran_pos = int(rand($i));
	 $ran_num=splice(@input, $ran_pos, 1);   push(@random, $ran_num); }
	$random=join("",@random);
	return(\$random);
}

#________________________________________________________________________
# Title     : rand_sequence_one_array
# Usage     : @out = @{&rand_sequence_one_array(\@input_seq_array)};
# Function  : gets a ref. of an array, scambles the elem.
# Example   :
# Warning   : This scrambles sequences!!
# Keywords  :
# Options   :
# Returns   : one ref. of array,
# Argument  : one ref. of array, eg ('e', 'b', 'c', 'd')
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rand_sequence_one_array{
	my(@input)=@{$_[0]};
	my($len1)=@input;
	my($len2)=$len1;
	my($ran_num,@random,$ran_pos);
	srand(time()|$$);
	for ($i= $len1; $i > 0 ; $i--){   $ran_pos = int(rand($i));
	 $ran_num=splice(@input, $ran_pos, 1); push(@random, $ran_num); }
	return(\@random);
}

#________________________________________________________________________
# Title     : make_random_sequence
# Usage     : $protein = ${&make_random_sequence(1, 400)};
# Function  : gets one or more numbers for seq length and makes random sequences
#             It can handle proportional random sequenes according to the
#             amino acid occurance matrix.
# Example   : $out=${&make_random_sequence(@ARGV)};  While @ARGV can be '1 200 -p'
# Warning   :
# Keywords  : scramble_sequence, make_scrambled_sequence, shuffle_sequence
#             random_sequence, make_random_sequence, generate_random_protein_seq
#             create_random_sequene create_random_aa_sequence, pick_random_sequence
#             generate_randomly_picked_sequence, get_random_sequence,
# Options   : 'p' for proportional random sequence option
#             'f' for fastsa format output (returns one ref. of HASH)
# Returns   : one or more scalar references according to the input numbers.
# Argument  : 1 200 [-p] [@array_of_array_refs]
#             1 = num of seq, 200=leng of seq, -p =option, @arr.. = option
#             You can optionally give amino acid matrices
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------
sub make_random_sequence{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($seq_length, $residue, @out_seq_ref);
	if(@num_opt==1){
		$num_of_seq=1;
		$seq_length=$num_opt[0];
	}elsif(@num_opt ==2){
		$num_of_seq=$num_opt[0];
		$seq_length=$num_opt[1];
	}
	srand(time());
	if($char_opt=~/p/i){ ####### PROPORTIONAL random #####
	  my ($rand_protein_seq, $sum, $random);
	  if(@array>0){  # when matrices are given in @hash
         @array1=@{$array[0]};
         if($array1[0]=~/\d+/){
            @aafq  =@array1;
            @aminos=@{$array[1]};
         }else{
            @aminos=@array1;
            @aafq  =@{$array[1]};
         }
	  }else{
         @aafq = (.08713, .03347, .04687, .04953, .03977,
                  .08861, .03362, .03689, .08048, .08536,
                  .01475, .04043, .05068, .03826, .04090,
                  .06958, .05854, .06472, .01049, .02992);

         @aminos=("A",   "C",     "D",    "E",    "F",
                  "G",     "H",     "I",    "K",    "L",
                  "M",     "N",     "P",    "Q",    "R",
                  "S",     "T",     "V",    "W",    "Y");
	  }
	  if($debug==1){
		  printf("> rand%d random, from $0, len %d\n",
		  $i+1, $num_opt[0]);
	  }
	  for($j=0; $j<$num_of_seq; $j++){
		  my ($rand_protein_seq, $random, $sum);
		  for($i=1; $i <= $seq_length; $i++){
			 $random=rand;
			 print "\n$random " if $debug ==1;
			 $sum =0;
			 for($x=0; $x< 20; $x++){
				$sum+=$aafq[$x];
				if( $sum >= $random){
					if($char_opt=~/f/i){
						$fasta{"rand${j}"} .=$aminos[$x]; last;
					}else{
						$rand_protein_seq .= $aminos[$x];
						last;
					}
				}
			 }
			 if($random > $sum){ $rand_protein_seq .= $aminos[19]; }
			 if( (!($i%60)) && ($char_opt=~/f/i) ){ $fasta{"rand${j}"} .= "\n" }
			 elsif( !($i%60) ){ $rand_protein_seq .= "\n" }
		  }
		  print "\nProportionasl Rand SEQ\n : $rand_protein_seq \n" if $debug ==1;
		  if($char_opt=~/f/i){ push(@fasta_out_ref, \%fasta) }
		  else{ push(@out_seq_ref, \$rand_protein_seq) }
	  }
	}else{
	  for($j=0; $j<$num_of_seq; $j++){
		 my $rand_protein_seq, $residue;
		 for $i (1..$seq_length) {
			$residue = pack("c", rand(128));
												redo unless $residue =~ /[ACDEFGHIKLMNPQRSTVWY]/i;
			if($char_opt=~/f/i){
				$fasta{"rand${j}"} .=$residue;
			}else{
				$rand_protein_seq .= $residue;
			}
			if( (!($i%60)) && ($char_opt=~/f/i) ){ $fasta{"rand${j}"} .= "\n" }
			elsif( !($i%60) ){ $rand_protein_seq .= "\n" }
		 }
		 $rand_protein_seq=~tr/a-z/A-Z/;
		 $fasta{"rand${j}"}=~tr/a-z/A-Z/;
		 if($char_opt=~/f/i){ push(@fasta_out_ref, \%fasta) }
		 else{ push(@out_seq_ref, \$rand_protein_seq) }
	  }
	}
	if($debug==1){ print "\n",%fasta, "\n" }
	if($char_opt=~/f/i){ return(@fasta_out_ref) }
	elsif(@out_seq_ref == 1){ return($out_seq_ref[0]); }
	elsif(@out_seq_ref > 1){ return(@out_seq_ref); }

}




#________________________________________________________________________
# Title     : rand_DNA_seq_generate  (produces randomized sequences)
# Usage     : $DNA = ${&rand_DNA_seq_generate(400)};
# Function  : gets one or more numbers for seq length and makes random sequences
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more scalar references according to the input numbers.
# Argument  : (343) or (\$length)
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rand_DNA_seq_generate { my($seq_length,$rand_DNA_seq, @out_seq_ref,$i,$residue);
	for($i=0; $i<@_; $i++){
	 if( ref($_[$i]) && (ref($_[$i]) eq 'SCALAR') ){
		if(${$_[$i]} =~/\d+/){ $seq_length = ${$_[$i]}; }    }
	 elsif( !ref($_[$i]) ){ if($_[$i] =~/\d+/){ $seq_length = $_[$i]; }}
	 else{ print "\n rand_DNA_generate in $0 gets number\(s\) \n"; die; }
	 srand(time()|$$);
	 for (1..$seq_length) {
		 $residue = pack("c", rand(128));  redo unless $residue =~ /[ACGT]/;
		 $rand_DNA_seq .= $residue;   }
	 push(@out_seq_ref, \$rand_DNA_seq);  }
	if(@out_seq_ref == 1){ return($out_seq_ref[0]); }
	elsif(@out_seq_ref > 1){ return(@out_seq_ref); }
}


#________________________________________________________________________
# Title     : rand_RNA_seq_generate  (produces randomized sequences)
# Usage     : $DNA = ${&rand_RNA_seq_generate(400)};
# Function  : gets one or more numbers for seq length and makes random sequences
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more scalar references according to the input numbers.
# Argument  : (343) or (\$length)
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rand_RNA_seq_generate { my($seq_length,@out_seq_ref,$rand_RNA_seq, $i,$residue);
	for($i=0; $i<@_; $i++){
	 if( ref($_[$i]) && (ref($_[$i]) eq 'SCALAR') ){
		if(${$_[$i]} =~/\d+/){ $seq_length = ${$_[$i]}; }   }
	 elsif( !ref($_[$i]) ){ if($_[$i] =~/\d+/){ $seq_length = $_[$i]; } }
	 else{ print "\n rand_RNA_generate in $0 gets number\(s\) of them\n"; die; }
	 srand(time()|$$);
	 for (1..$seq_length) {
		 $residue = pack("c", rand(128));  redo unless $residue =~ /[ACGU]/;
		 $rand_RNA_seq .= $residue;    }
	 push(@out_seq_ref, \$rand_RNA_seq);  }
	if(@out_seq_ref == 1){ return($out_seq_ref[0]); }
	elsif(@out_seq_ref > 1){ return(@out_seq_ref); }
}


#________________________________________________________________________
# Title     : replace_text
# Usage     : &replace_text(\@input_array_of_filenames);
# Function  : finds patterns of text and replaces them in multiple input files
# Example   :
# Warning   : This produces a temporary file and rename it...
# Class     :
# Keywords  :
# Options   :
# Package   :
# Reference :
# Returns   : nothing
# Tips      :
# Argument  : reference of one array of file names in pwd
# Todo      :
# Author    : jong
# Version   : 1.5
#--------------------------------------------------------------------
sub replace_text{
  my ($file, @input_files, $each_line );
  $|=1;
  my $old=shift ;
  my $new=shift;
  print "\n# $0: OLD pattern-> \"$old\", NEW pattern-> \"$new\", \n";
  @input_files=@_;

  for $file(@input_files){
     open (IN, "$file");
     my @lines=<IN>;
     close(IN);
     open (OUT, ">$file") or warn "\n# $0: ERROR opening $file, check permission!\n";
     for $each_line (@lines){
        if($each_line=~/(.*)($old)(.*)/){
            $temp="$1${new}$3\n";
            print "\nmatched $each_line in $file, becomes: $temp\n";
            print OUT $temp;
        }else{
            print OUT $each_line;
        }
     }
     close OUT;
     if($file =~/\.pl$/){ chmod 0755, $file; } # this makes it execu..
  }
  return(\@input_files); # returning the changed files
}





#________________________________________________________________________
# Title     : get_av_seq_length
# Usage     : $std_devi_of_lengths = &get_av_seq_length(\%hash_ref);
# Function  : gets hash of sequence, compares lengths, and outs av.
# Example   :
# Warning   : uses a sub  &array_average(\@lengths);
# Keywords  :
# Options   :
# Returns   : one ref. for scaler digit.
# Argument  : one hash reference for sequences.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_av_seq_length{
	my(%hash1)= %{$_[0]};
	my(@names)=keys %hash1;
	my($sequence, $len, @lengths, $av_seq_length);
	for $name (@names){  $sequence = $hash1{$name}; $sequence =~s/\W//g;
	 $len =length($sequence);  push(@lengths,$len); }
	$av_seq_length=&array_average(\@lengths);
	return(\$av_seq_length);
}

#________________________________________________________________________
# Title     : get_sd_of_length_diff
# Usage     : $result = &get_sd_of_length_diff(\%input);
# Function  :
# Example   :
# Warning   : removes all non-char(.-, space....) in the input string
# Keywords  :
# Options   :
# Returns   : one scaler digit
# Argument  : gets one hash reference,
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_sd_of_length_diff{
	my(%hash1)= %{$_[0]};
	my(@names)=keys %hash1;
	my($sequence, $len, @lengths, $std_devi);
	for $name (@names){ $sequence = $hash1{$name};
	 $sequence =~s/\W//g; $len =length($sequence);
	 push(@lengths,$len); }
	$std_devi=&sd(\@lengths);
	\$std_devi;
}
#________________________________________________________________________
# Title     : get_av_and_sd_seq_length
# Usage     : $get_av_and_sd_seq_length= &get_av_seq_length(\%hash_ref);
# Function  : gets ref of hash of sequence, compares lengths, and outs av.
# Example   :
# Warning   : uses a sub  &array_average(\@lengths);
# Keywords  :
# Options   :
# Returns   : Two scaler digit.
# Argument  : Two hash references for sequences.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_av_and_sd_seq_length{
	my(%hash1)= %{$_[0]};
	my(@names)=keys %hash1;
	my($sequence, $len, @lengths, $av_seq_length);
	for $name (@names){
	 $sequence = $hash1{$name}; $sequence =~s/\W//g; $len =length($sequence);
	 push(@lengths,$len); }
	$av_seq_length=${&array_average(\@lengths)};
	$std_devi=${&sd(\@lengths)};
	@av_seq_length_and_std_devi=($av_seq_length, $std_devi);
	return(\@av_seq_length_and_std_devi);
}

#________________________________________________________________________
# Title     : get_seq_hash_sans_gaps.pl
# Usage     : ($ref_out1, $ref_out2)=&get_seq_hash_sans_gaps(\%hash, \%hash);
#              %out=%{&get_seq_hash_sans_gaps(\%hash)};
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_seq_hash_sans_gaps{ my(@in)=@_; my(%in, @keys); my(@out_hash_ref, $k,%out_hash);
	for($k=0; $k<=$#in; $k++){  %in=%{$in[$k]}; @keys=keys %in;
	 for(@keys){ $in{$_}=~ s/[-.]//g;  $out_hash{$_}=$in{$_};  }
	 push(@out_hash_ref, \%out_hash);  }
	if($#out_hash_ref == 0){ return($out_hash_ref[0]); }
	elsif($#out_hash_ref > 0){  return(@out_hash_ref); }
}


#________________________________________________________________________
# Title     : get_posi_sans_gaps (get positions without after removing gaps)
# Usage     : @seq_position1 = &get_posi_sans_gaps($string1);
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : the positions of residues after removing gaps(but keeps pos).
#               used for analysis of shifted positions of seq. comparison.
# Argument  : one scalar variable input of sequence string.
# Category  :
# Version   : 1
#--------------------------------------------------------------------
sub get_posi_sans_gaps{
	 my($string) = ${$_[0]};
	 my($char, @positions, $i);
	 for($i=0; $i < length($string); $i++){
	  $char=substr($string,$i,1);
	  if(($char eq '-')||($char eq '.')){  next; }else{ push(@positions, $i); } }
	 return(\@positions);
}

#________________________________________________________________________
# Title     : get_posi_shift_rate
# Usage     : $rate_final = &get_posi_shift_rate("perl.msf", "perl.jp");
# Function  :
# Example   :
# Warning   : sub  hash_common was unstable.
# Keywords  :
# Options   :
# Returns   : one ref. for scalar value of shift rate of position for proteins.
# Argument  : takes two file names for seq. and struc. alignment.
#             : Assumes the files are in the pwd.
# Category  :
# Version   : 1
#-------------------------------------------------------------------
sub get_posi_shift_rate{
	my($test_seq_file, $struc_seq_file)=@_;
	my($string1, $string1, $av_rate, @rates, $rates_ref);
	$pwd = &pwd_path;
	$file1=$pwd.'/'.$test_seq_file;	# for clustalw alignment (usu, xxxx.msf)
	$file2=$pwd.'/'.$struc_seq_file;	# JPO's structural alignment (usu, xxxx.jp)
	if((-e $file1) && (-e $file2)){
		  %array1=&open_msf_files($file1);	# results are : %array1, %array2, @names1, @names2
		  %array2=&open_jp_files ($file2);
		  $ref_hash_1 = \%array1;
		  $ref_hash_2 = \%array2;
		  %array1 = &hash_common($ref_hash_1, $ref_hash_2);
		  %array2 = &hash_common($ref_hash_2, $ref_hash_1);
		  %array1 = &remov_com_column($ref_hash_1); # this removes wrong gaps(in '.' form, in MSF)
		  %array2 = &remov_com_column($ref_hash_2);
		  @names=sort keys %array1;print "\n\n";
		  $num_of_seq = $#names+1;  # <- this is true number of seq.
		  for($j=0; $j< $num_of_seq ; $j++){  # nf1 is the number of seq.
					  $name=$names[$j];
					  $string1=$array1{$name};
					  $string2=$array2{$name};
					  $ls=length($string1); 	# $ls is the whole length -1.
					  $ls2=length($string2);			# $string1 has the whole seq
					  $sum1=0; 		# $sum is for accumulating position difference
					  @seq_position1 = &get_posi_sans_gaps($string1);
					  @seq_position2 = &get_posi_sans_gaps($string2);
					  @position_diffs =&get_posi_diff(\@seq_position1, \@seq_position2);
					  $rate = &sd(@position_diffs);
					  push(@rates, $rate);
			}
			$rates_ref=\@rates;
			$av_rate = &array_average($rates_ref);
	}
	return(\$av_rate);
}

#________________________________________________________________________
# Title     : read_hssp_no_inserts
# Usage     : %anyarray = &read_hssp_no_inserts ($any_sequence_file_hssp_form);
# Function  : read hssp file and put sequences in a hash
# Example   :
# Warning   : It produces incomplete sequences when hssp seqs. have insertions.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Authors   :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_hssp_no_inserts {    								# reading hssp files. input is a file name.
	 my($input_file)=${$_[0]};	 # $_[0]=>input eg. $dir.$out_seq_no.hssp
	 my($whole_sequence,@names,%gaps,%second_hash,@chars);
	 my($c,$Sequence,$char,$no_of_seq, $AliNo, $first_part);
	 my($diff, $attachment, $second_part, $len_2nd_part);
	 unless (-e $input_file){
		 print chr(7);		     # beep warning for error
		 print "\n\n\t This is sub read_hssp_file  in th_lib.pl \n\n";
		 print "\n\n\t Fatal: The input file $file1 is not in the directory \n";
		 print "\n\n\t  !!! Program dies abnormally, bugs !!! \n";
		 &caller_info; print "\n"; die;
	 }
	 open(FILE_1,"$input_file"); # reading in (hssp)
	 while(<FILE_1>){   		# file1 needs to be xxxx.hssp for the moment, automatic later
			 if (/PDBID\s+([\d\w]+)/){    # to get the test sequence file (mother sequence)
				 $names[0] = $1;           # put in an array as the first element.
				 next;                     # do not need to look at further.
			 }
			 if(/^\s+\d+ : ([\w_\d]+)\s+/){  # matching names part.
				 push(@names, $1);       # getting all other names of sequences.
				 next;                   # do not need to look at further.
			 }
			 $no_of_seq = $#names+1;        # true num. of seq. inc. mother sequence.
			 if(/^\s+\d+\s+\d+\s+([\w ]).+\d+\s+\d+\s+\d+  ([\w\t\s\.]+)$/){
				 $first_part  = $1;  # somehow this step is necessary(?)
				 $second_part = $2;  #
				 chomp($second_part);  # hssp has new line at the end. !! essential !!
				 $second_part =~ s/ /./g;  # converting all space to dots.
				 $len_2nd_part = length($second_part);
				 if ($len_2nd_part < $no_of_seq ){
						  $diff = ( $#names - $len_2nd_part);
						  $attachment = "."x($diff);  # filling spaces.
						  $second_part.=$attachment;
				 }
				 $whole_sequence .= $first_part.$second_part; # very long sequence.
				 $c+=1;             # counter for the whole lines
				 next;              # do not need to look at further.
			 } # <----the result of this if{} is a long string  $whole_sequence
			 if (/## SEQUENCE PROFILE AND ENTROPY/){
				 last;   # do not need to look at further.
			 }
	 }
	 @chars = split(//, $whole_sequence);  # putting into an array to handle
	 for ($i=0; $i < $c ; $i++){
		for ($k=0; $k<=$#names; $k++){
				  $char = shift( @chars);
				  $second_hash{$names[$k]} .= $char;
		}
	}
	return(\%second_hash); # this is the final output.
}


#________________________________________________________________________
# Title     : open_pdbg_files
# Usage     : %seq=%{&open_pdbg_files($tim_seq_file, ['1fcdc1'], [s] )};
#             if you put additional seq name as 1fcdc1 it will
#             fetch that scopclass only in the database file.
#             Any digit will be used as minimum seq size to be fetched.
# Function  : open pdb group files and put scopclass in a hash.
#             PDB group file format is like this;
#
#  >d1bia_1 1.4.3.1.1 (1-63) Biotin repressor, N-terminal domain [Escherichia coli]
#  >d1baba_ 1.1.1.1.15 Hemoglobin, alpha-chain [human (Homo sapiens)]
#  >d1cpcb_ 1.1.1.2.1 C-phycocyanin [cyanobacterium (Fremyella diplosiphon)]
#  >d1fcdc2 1.3.1.3.1 (81-174) Flavocytochrome c sulfide dehydrogenase, FCSD, cytochrome subunit [Purple phototrophic bacterium (Cromatium vinosum)]
#
#             This can also return the sizes of sequences rather than seqs.
# Example   : %out = %{&open_pdbg_files(@ARGV)};
#             while @ARGV at prompt was: 'pdb_40.pdbg'
#  OUTPUT HASH will look like this>>>
#
#        1pvuA  3.38.1.4.1
#        1fjlA  1.4.1.1.11
#        1ral   3.1.5.1.3
#
# Warning   :
# Keywords  : open_pdbg_files, open_pdb_group_files
# Options   : any digit for the minimum seq length
#    $pdb_style_name =p by p  # for simple style PDB file name (like 1tfs, or 1mhyG rather than d1tfs__, d1mhyg1 ..)
#    $NO_chain_number=C by C  # for simple style PDB file name (like 1tfs, or 1mhyG rather than d1tfs__, d1mhyg1 ..)
#    $NO_range=R by R
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1
#--------------------------------------------------------------------
sub open_pdbg_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    my (%sequence, $S_start, $pdb_name, $range, $S_end, @seq_Names, %Sizes,
            $domain, $pdb_name, $domain_num, $scop_class, $sequence,
            $pdb_style_name, $NO_range, $NO_chain_number);
    my $min_size=$num_opt[0];

    if(@file<1){ print "\n# open_pdbg_files: There is no fileinput for open_pdbg_files\n"; die}

    if($char_opt=~/p/){  $pdb_style_name='p'; }
    if($char_opt=~/C/){  $NO_chain_number='C'; }
    if($char_opt=~/R/){  $NO_range='R'; }

    for($i=0; $i< @file; $i++){
	  my($input_file) = ${$file[$i]} || $file[$i];

	  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  # Checking if file is there
	  #_________________________________
	  if($debug eq 1){ print "\n open_pdbg_files: Inputfile is $input_file\n" };
	  unless (-e $input_file){
           print chr(7);
           print "\n\n\t This is sub open_pdbg_files in $0  \n\n";
           print "\t Fatal: The input file $input_file is not in the directory \n";
	  }
	  open(FILE_1,"$input_file");
	  if(@hash >=1){
            for($h=0; $h< @hash; $h++){
                     push(@string, keys %{$hash[$h]});
            }
	  }

      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # THIs IS NOT default
      #_________________________________________________
	  if( (@_ > 1)&&(@string > 0) ){  # when seq to fetch is given
              if($pdb_style_name){  # to make 1tcoB like instead of d1tcob
                       while(<FILE_1>){
                               for($j=0; $j<= @string; $j++){
                                          if(/^ *\>\s*[cde]($string[$j])_*\s+([\d\.]+)\s*\(?(\d*\-?\d*)\)?/i){
                                                   $pdb_name=$1;
                                                   if($NO_chain_number and length($pdb_name) > 4){ chop($pdb_name); }
                                                   $range=$3;
                                                   $scop_class=$2;
                                                   if($char_opt=~/R/ and $range !~/\d+\-\d+/){ $range='' }else{ $range="_$range" }
                                                   splice(@string, $j, 1); ## for optimization
                                                   $sequence{"${pdb_name}${range}"} = $scop_class;
                                                   return(\%sequence) if(@string < 1);
                                          }
                               }
                       }
		}else{
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 #  Simplified style reading
                 #_______________________________________________
                 while(<FILE_1>){
                        if(/^\s*\>\s*($string[$j])\s+([\d\.]+)\s*\(?(\d*\-?\d*)\)?/){
                                $pdb_name=$1;
                                if($NO_chain_number and length($pdb_name) > 4){ chop($pdb_name); }
                                $range=$3;
                                $scop_class=$2;
                                if($NO_range){ $range='' }elsif($range=~/\d+\-\d+/){ $range="_$range" }
                                $sequence{"${pdb_name}${range}"} = $scop_class;
                        }
                 }
		}
	  }else{ # getting all seq in the given file(s)

          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          #  Simplified style reading
          #_______________________________________________
          if($pdb_style_name){
               while(<FILE_1>){
                       if(/^\s*\>\s*[cd](\S\S\S\S)(\S)(\S)\s+([\d\.]+)\s*\(?(\d*\-?\d*)\)?/){
                               $pdb_name=$1;
                               if($NO_chain_number and length($pdb_name) > 4){ chop($pdb_name); }
                               $range=$5;
                               $domain=$2;     #<-- like A or B or C
                               $domain_num=$3;
                               $scop_class=$4;
                               if($range !~/\d+\-\d+/){ $range='' }else{ $range="_$range" }
                               if($domain !~ /^_$/){
                                              $domain="\U$domain";
                               }else{ undef($domain) }
                               if($domain_num !~/^_$/){
                                              $domain_num=$3;
                               }else{ undef($domain_num) }
                               $sequence{"${pdb_name}${domain}${range}"} = $scop_class;
                       }else{ next }
               }

          }else{ #### This takes only the real names rather than dxxxx__ style
               while(<FILE_1>){
                       if(/^\s*\>\s*(\S+)\s+([\d\.]+)/){
                               $pdb_name=$1;
                               if($NO_chain_number and length($pdb_name) > 4){ chop($pdb_name); }
                               $scop_class=$2;
                               $sequence{"${pdb_name}"} = $scop_class;
                       }
               }
          }
	  }
	  close FILE_1;
   }

   if(defined(@range)){
        %seq_fragments=%{&get_seq_fragments(\%sequence, \@range)};
        return(\%seq_fragments);
   }elsif($char_opt=~/s/i){ # when SIZE return only option is set
        @seq_Names=keys %sequence;
        for($i=0; $i < @seq_Names; $i++){
                       $Sizes{$seq_Names[$i]}=length($sequence{$seq_Names[$i]});
        }
        return(\%Sizes);
   }elsif(@hash >=1){
        for($h=0; $h< @hash; $h++){
                my %hash=%{$hash[$h]};
                my @Keys=keys %hash;
                for($k=0; $k<@Keys; $k++){
                        if(defined($hash{$Keys[$k]})){
                                ($S_start, $S_end)=($hash{$Keys[$k]}=~/(\d+)\-(\d+)/);
                                $sequence{$Keys[$k]}=substr($sequence{$Keys[$k]}, ($S_start-1), ($S_end-$S_start));
                        }
                }
        }
        return(\%sequence);
   }else{
        return(\%sequence);
   }
}


#________________________________________________________________________
# Title     : open_cel_files
# Usage     :
# Function  :
# Example   :
#  Example INPUT file:
#  #  Tabl delimited data file
#   X       Y	    MeanIn  STDEV  Pixel num
#
#   0       0       200.0   15      16      1.24343
#   1       0       200.0   15      16      1.24343
#   2       0       200.0   15      16      1.24343
#   3       0       200.0   15      16      1.24343
#
# Warning   :
# Keywords  :
# Options   :
# Returns   : 3D array =( [X][Y][0], [X][Y][1], [X][Y][2], [X][Y][3])
# Argument  :
# Version   : 1
#--------------------------------------------------------------------
sub open_cel_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		my($X_axis, $Y_axis, $intensity, $stdev_of_intensity, $pixel_number,
			 $temp, @out_3D_array, @out_3D_array_ref_list);
		for($i=0; $i< @file; $i++){
				open(FILE_1, "$file[$i]");
				print "\n# (INFO) open_cel_files: opening $file[$i]\n";
				my(@out_3D_array);
				while(<FILE_1>){      # file1 needs to be xxxx.cel
						if(/^\s*(\d+)\s+(\d+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)/){
								$X_axis=$1;
								$Y_axis=$2;
								$intensity=$3;
								$stdev_of_intensity=$4;
								$pixel_number=$5;
								$temp=$6;
								$out_3D_array[$X_axis][$Y_axis][0]=$intensity;
								$out_3D_array[$X_axis][$Y_axis][1]=$stdev_of_intensity;
								$out_3D_array[$X_axis][$Y_axis][2]=$pixel_number;
								$out_3D_array[$X_axis][$Y_axis][3]=$temp;
						}
				}
				push(@out_3D_array_ref_list, \@out_3D_array);
				close(FILE_1);
		}
		if(@out_3D_array_ref_list  == 1 ){  ## when only one file input was given
				print "\n# open_cel_files: returning 1 array output \n";
				return($out_3D_array_ref_list[0]); }
		elsif(@out_3D_array_ref_list > 1){  ## when multiple files were given
				print "\n# open_cel_files: returning multiple array output \n";
				wantarray ? return(@out_3D_array_ref_list) : return(\@out_3D_array_ref_list);
		}
}


#______________________________________________________________________________
# Title     : open_stride_dat_files
# Usage     : @out=@{&open_stride_dat_files(@ARGV)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1
#------------------------------------------------------------------------------
sub open_stride_dat_files{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my( @residues, @sec_str, $seq_name, $seq, %stride_sec_str_hash,
				$stride_dat_file, @stride_sec_str_hash_final);

		 for($i=0; $i< @file; $i++){
				 my $stride_dat_file=$file[$i];
				 print "\n# (INFO) \$stride_dat_file $stride_dat_file is being opened\n";
				 open(STRIDE_DAT_FILE, $stride_dat_file);
				 while(<STRIDE_DAT_FILE>){
						if(/^NM\s+(\S+)/){
								$seq_name=$1;
						}elsif(/^\s*SQ\s+(\S+)/){
								$seq=$1;
						}elsif(/^\s*SS\s+(\S+)/){
								$sec_str=$1;
								my %stride_sec_str_hash;
								@residues=split(//, $seq);
								@sec_str=split(//, $sec_str);
								for($j=0; $j < @residues; $j++){
										$stride_sec_str_hash{$j}=[$residues[$j], $sec_str[$j], '1.0',  "$seq_name"];
								}
								push(@stride_sec_str_hash_final, \%stride_sec_str_hash);
						}
				 }
				 close(STRIDE_DAT_FILE);
		 }
		 if(@stride_sec_str_hash_final > 1){
				 return(\@stride_sec_str_hash_final);
		 }elsif(@stride_sec_str_hash_final==1){
				 return(\%stride_sec_str_hash);
		 }
}


#________________________________________________________________________
# Title     : open_genbank_files
# Usage     : %fasta_seq=%{&open_genbank_files($genbank_file)};
# Function  : open genbank files and put sequences in a hash
#
#              GENBANK sequence file format is like this;
#
#   LOCUS       BNAESTAY      309 bp    mRNA            EST       31-OCT-1994
#   DEFINITION  Brassica campestris (clone F0574) expressed sequence tag (EST)
#               mRNA, mRNA sequence.
#   ACCESSION   L35823
#   NID         g562216
#   KEYWORDS    EST; expressed sequence tag.
#   SOURCE      Brassica campestris (sub_species pekinensis) flower bud cDNA to
#               mRNA.
#     ORGANISM  Brassica campestris
#               Eukaryotae; mitochondrial eukaryotes; Viridiplantae;
#               Charophyta/Embryophyta group; Embryophyta; Magnoliophyta;
#               Magnoliopsida; Capparales; Brassicaceae; Brassica.
#   REFERENCE   1  (bases 1 to 309)
#     AUTHORS   Lim,C.O., Hwang,I. and Cho,M.J.
#     TITLE     Generation of expressed sequence tags from random sequencing of
#               Chinese Cabbage (Brassica campestris L. ssp. pekinensis) Flower Bud
#               cDNA Clones
#     JOURNAL   Unpublished (1994)
#   FEATURES             Location/Qualifiers
#        source          1..309
#                        /organism="Brassica campestris"
#                        /sub_species="pekinensis"
#                        /db_xref="taxon:3706"
#                        /dev_stage="flower bud"
#        mRNA            1..309
#                        /standard_name="expressed sequence tag"
#   BASE COUNT       61 a     86 c     89 g     73 t
#   ORIGIN
#           1 aaacctcgcc gtcgttagaa gaagaaaatg ggagtattca catttgtttg caaaagcaaa
#          61 ggcggagaat ggaccgctaa gcaacacgag ggagacctcg aaggctccgc ttcttccacc
#         121 tacgatctcc agcgcaagtt gttcagactg ctctctccgc cgattcctcc ggtggcgttc
#         181 agtcttcctt ctccctcgtc tcccctacct ccgccgtctt ccaggtgatc atcggtggtg
#         241 gttcaggagg aggatttgct gccggttgag gtgcagcagc tggaggccgg ttgtggaggt
#         301 gaggctgcc
#   //
# Reference : http://cyrah.med.harvard.edu/Bioperl/Howto/howto_open_embl_files.answer
#
# Example   : %out = %{&open_genbank_files(@ARGV)};
# Keywords  :
# Options   : Seq name to fetch the specified seq only.
#             as open_genbank_files.pl MY_SEQ_NAME Swissprot.fasta
#            -d  for giving back desc as well as the name. so it
#                gives  'HI0002 This is the description part'
#                as the key
#             If you put hash which is like('seq_name', ['20-30', '30-44',..])
#              it will produce hash which has got:
#              ( seq_name_20-30 'asdfasdfasdfasdfasd',
#                seq_name_30-44 'kljkljkjkjljkjljkll',
#                ....           .... )
#            -s for returning sequence size only
#   $reverse_seq=r by r ## to reverse seq.
# Category  :
# Version   : 1
#--------------------------------------------------------------------
sub open_genbank_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		my (%GENBANK_ALL_ENTRY, %sequence, %na_sequence, %HASH, @Keys, $seq_found1,
			 $S_start, $S_end, $seq_found,
			 $present_seq, @seq_Names, %Sizes, $bare_seq_name, $fasta_seq_idx_file,
			 %seq_fragments, $get_protein_seq, $reverse_seq, $translation_found);

		$get_nucleic_acid_seq='n';

		if($char_opt=~/r/){ $reverse_seq='r' }

		if(@file<1){
				print "\n \@file has less than 1 elem. There is no fileinput for open_genbank_files\n";
				die
		}

		print "\n# \@file are @file\n" if $verbose;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# (1) opening genbank files (NORmal, when no perl index pos number is given)
		#_______________________________________________________________________
		for($i=0; $i< @file; $i++){
			 unless(-s $file[$i]){ print "\n# (E) File not found $file[$i]\n"; next; } ## this is essential as handle_arguments has a problem
			 my($entry_found, $name, $matched);
			 my($input_file) = ${$file[$i]} || $file[$i];

			 if($debug eq 1){ print "\n open_genbank_files: Inputfile is $input_file\n" };
			 unless (-e $input_file){
						print chr(7);
						print "\n\n\t This is sub open_fas_files in $0  \n\n";
						print "\t Fatal: The input file $input_file is not in the directory \n";
			 }
			 open(FILE_1,"$input_file") or die "\n# (E) failed to open $input_file\n";
			 if(@hash >=1){  ## if seq names are given in hash
						for($h=0; $h< @hash; $h++){
								@string=(@string, keys %{$hash[$h]});
						}
			 }
			 @string=sort @string;
			 $num_of_seq_to_fetch=@string;
			 if(@string > 0){
						print "\n# open_genbank_files(normal genbank fetch): \$num_of_seq_to_fetch is $num_of_seq_to_fetch\n";
			 }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			 #  (2.1) when seq to fetch is given by \@sequences  format
			 #_______________________________________________________________________
			 if( @_ > 1  and  @string > 0 ){
							 print "\n#  open_genbank_files is fetching sequences from \$input_file= $input_file\n";
							 %sequence=%{&fetch_sequence_from_db($input_file, \@string)};
							 print "\n# $fasta_seq_idx_file file is made by open_genbank_files(fetch_sequence_from_db), you may remove it\n";
			 }
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			 #  (2.2) When seq names NOT given, fetches all (THE DEFAULT)
			 #____________________________________________________________
			 else{
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # Just initializing some vars to prevent making huge arrays
					 #_____________________________________________________________
					 my(%genbank_eash_entry, $sub_field_found, $origin_entry_found,
					 %final_each_genbank, $key, $value, $features_entry_found,
					 $first_line_matched);
					 while(<FILE_1>){
							 if(/^(\w+)\s*(.*)/){
									 $first_line_matched=1;
									 $subfield_key=$sub_field_found=$features_subfield=$features_entry_found='';
									 $key=$1; $value=$2;

									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									 # Parsing LOCUS line as it has more than one item to take care of
									 #_________________________________________________________________
									 if($1 eq 'LOCUS' and $value=~/^(\w+)\s+(\d+)\s+bp\s+(\w+)\s+(\S+)\s+(\S+)$/){
											 $genbank_each_entry{'seq_size'}=$2;
											 $genbank_each_entry{'mol_type'}=$3;
											 $genbank_each_entry{'date'}=$5;
									 }elsif(/ACCESSION\s+(\S+)/){
											 $accession_number=$1;
											 $genbank_each_entry{"seq_name"}=$accession_number;
											 $genbank_each_entry{"name"}=$accession_number;
									 }elsif(/FEATURES\s+(\S.+)/){
											 $genbank_each_entry{"FEATURES"}=$1;
											 $features_entry_found=1;
											 $sub_field_found=0;
									 }elsif(/^ORIGIN/){
											 $origin_entry_found=1;
											 $key=$value='';
											 next;
									 }
									 $genbank_each_entry{$key}="$value " if $value;

							 }elsif($first_line_matched and /^\s{9,50}(\S.+)/){ # if '            mRNA, mRNA sequence.' is matched
									 if($sub_field_found){
											 $genbank_each_entry{$subfield_key}.="$1 ";
									 }elsif($features_entry_found){
											 $genbank_each_entry{"FEATURES\_$features_subfield"}.="$1 ";
									 }else{
											 $genbank_each_entry{$key}.="$1 " if $key;
									 }
							 }elsif($first_line_matched and /^\s{2,3}(\S+)\s+(\S.+)/){ ## sub field
									 $sub_field_found=1;
									 $subfield_key=$1;
									 $genbank_each_entry{"$key\_$1"}.="$2 ";
									 $genbank_each_entry{"$1"}.="$2 ";
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # Matching  sub field (like 'source' in FEATURES entry)
							 #__________________________________________________________
							 }elsif($features_entry_found and /^\s{5,6}(\S+)\s+(\S.+)/){ ## sub field
									 $features_subfield=$1;
									 $sub_field_found=0;
									 $genbank_each_entry{"FEATURES\_$1"}.="$2 ";

							 }elsif($first_line_matched and /^(\S{1,7} \S{1,6})\s+(\S.+)/){  # BASE COUNT       61 a     86 c     89 g     73 t
									 $genbank_each_entry{"$1"}=$2;
							 }elsif($origin_entry_found and /^\s+\d{1,7}\s(\S.+)/){ ##         1 aaacctcgcc gtcgttagaa gaagaaa
										$genbank_each_entry{"sequence"}.="$1 ";
										$genbank_each_entry{"ORIGIN"}.="$1 ";
							 }elsif($first_line_matched and (/^\s*\/\// or eof)){
									 %final_each_genbank=%genbank_each_entry;

									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									 # Assigning %final_each_genbank to a bigger final HASH.
									 #__________________________________________________________
									 $GENBANK_ALL_ENTRY{$accession_number}={%final_each_genbank};
									 $first_line_matched=0;
									 %genbank_eash_entry=();
									 $key=$value=$accession_number=$origin_entry_found='';
							 }

					 }# end of while
			 }
			 close FILE_1;
		 }

		 return(\%GENBANK_ALL_ENTRY);
}



#________________________________________________________________________
# Title     : open_embl_files
# Usage     : %fasta_seq=%{&open_embl_files($fasta_file, ['MJ0084'])};
#             if you put additional seq name as MJ0084 it will
#             fetch that sequence only in the database file.
#
#             %out=%{&open_embl_files(@ARGV, \%index)};
#               while  %index has (seq indexpos seq2 indexpos2,,,)
#               In this case, the fasta file should have xxxx.fasta format
#
# Function  : open embl files and put sequences in a hash
#              If hash(es) is put which has sequence names and seek position
#              of the index file, it searches the input FASTA file to
#              fetch at that seek position. This is useful for Big fasta DBs
#             If the seq name has ranges like  XXXXXX_1-30, it will only
#              return 1-30 of XXXXXX sequence. EMBL file is from SANGER
#             Centre for genome seq.
#
#             FASTA sequence file format is like this;
#
# FT         /db_xref="PID:e322131"
# FT         /db_xref="SPTREMBL:O00531"
# FT         /product="tenascin-R (restrictin)"
# FT         /translation="CLFLHPLIDLVPGTEYGVGISAVMNSQQSVPATMNARTELDSPRD
# FT         IISVTAERGRQQSLESTVDAFTGFRPISHLHFSHVTSSSVNITWSDPSPPADRLILNYS
# FT         PRDEEEEMMEVSLDATKRHAVLMGLQPATEYIVNLVAVHGTVTSEPIVGSITTGIDPP"
#
# SQ   Sequence 106319 BP; 33624 A; 23004 C; 22373 G; 27318 T; 0 other;
#     gatcatttta ccttgtacgt atcaaaacat cactgtgtac cccatacata tgtacaatta        60
#     ttattcatca tttagaaaat aaaattaaaa aataaataaa tctctactca cccaggccct       120
#     tacacagtgg catttctaga accttatttc cttttgccaa cggagcctcc attccaggct       180
#
#             This can also return the sizes of sequences rather than seqs.
#
#             This ignores any dup entrynames coming later.
#
# Example   : %out = %{&open_embl_files(@ARGV)};
#             %out2=%{&open_embl_files('seq.fasta', \%index)};
#             %out3=%{&open_embl_files('seq.fasta', \%range)};
#             %seq=%{&open_embl_files($PDB40_FASTA, \@seq_to_fetch)};
#
#             while @ARGV at prompt was: 'GMJ.pep MJ0084'
#
# Keywords  : open_genbank_files
# Options   : Seq name to fetch the specified seq only.
#             as open_embl_files.pl MY_SEQ_NAME Swissprot.fasta
#            -d  for giving back desc as well as the name. so it
#                gives  'HI0002 This is the description part'
#                as the key
#             If you put hash which is like('seq_name', ['20-30', '30-44',..])
#              it will produce hash which has got:
#              ( seq_name_20-30 'asdfasdfasdfasdfasd',
#                seq_name_30-44 'kljkljkjkjljkjljkll',
#                ....           .... )
#            -s for returning sequence size only
#   $reverse_seq=r by r ## to reverse seq.
# Category  :
# Version   : 5
#--------------------------------------------------------------------
sub open_embl_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		my (%sequence, %na_sequence, %HASH, @Keys, $seq_found1,
			 $S_start, $S_end, $seq_found,
			 $present_seq, @seq_Names, %Sizes, $bare_seq_name, $fasta_seq_idx_file,
			 %seq_fragments, $get_protein_seq, $reverse_seq, $translation_found);

		$get_nucleic_acid_seq='n';

		if($char_opt=~/r/){ $reverse_seq='r' }

		if(@file<1){
				print "\n \@file has less than 1 elem. There is no fileinput for open_embl_files\n";
				die
		}

		print "\n# \@file are @file\n" if $verbose;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# (1) opening FASTA files (NORmal, when no perl index pos number is given)
		#_______________________________________________________________________
		for($i=0; $i< @file; $i++){
			 unless(-s $file[$i]){ print "\n# (E) File not found $file[$i]\n"; next; } ## this is essential as handle_arguments has a problem
			 my($entry_found, $name, $matched);
			 my($input_file) = ${$file[$i]} || $file[$i];

			 if($debug eq 1){ print "\n open_embl_files: Inputfile is $input_file\n" };
			 unless (-e $input_file){
						print chr(7);
						print "\n\n\t This is sub open_fas_files in $0  \n\n";
						print "\t Fatal: The input file $input_file is not in the directory \n";
			 }
			 open(FILE_1,"$input_file");
			 if(@hash >=1){  ## if seq names are given in hash
						for($h=0; $h< @hash; $h++){
								@string=(@string, keys %{$hash[$h]});
						}
			 }
			 @string=sort @string;
			 $num_of_seq_to_fetch=@string;
			 if(@string > 0){
						print "\n# open_embl_files(normal fasta fetch): \$num_of_seq_to_fetch is $num_of_seq_to_fetch\n";
			 }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			 #  (2.1) when seq to fetch is given by \@sequences  format
			 #_______________________________________________________________________
			 if( @_ > 1  and  @string > 0 ){
							 print "\n#  open_embl_files is fetching sequences from \$input_file= $input_file\n";
							 %sequence=%{&fetch_sequence_from_db($input_file, \@string)};
							 print "\n# $fasta_seq_idx_file file is made by open_embl_files(fetch_sequence_from_db), you may remove it\n";
			 }
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			 #  (2.2) When seq names NOT given, fetches all (THE DEFAULT)
			 #____________________________________________________________
			 else{
					 $translation_found=0;
					 while(<FILE_1>){
							 if(/^\s*ID\s+(\S+)/){
									 $seq_name=$1;
							 }elsif($get_protein_seq and /^\s*FT\s+\/translation\=\"(\w+)/){
									 $translation_found=1;
									 $seq .=$1;
							 }elsif($get_protein_seq and $translation_found and /^\s*FT\s+(\w+)\s*$/){
									 $seq .=$1;
							 }elsif($get_protein_seq and $translation_found and /^\s*FT\s+(\w*)\"/){
									 $seq .=$1;
									 $translation_found=0;
							 }elsif($get_nucleic_acid_seq and /^\s*SQ\s+/){
									 $nucleic_acid_found=1;
							 }elsif($nucleic_acid_found and /^\s+([\S+ ]+)\s+\d*/){ # \d*  NOT \d+ as some don't have digits
									 $na_seq.=$1;
							 }elsif($nucleic_acid_found and /^\s*\/\//){
									 last;
							 }

					 }# end of while
					 $sequence{$seq_name}=$seq;
					 $seq=~s/\s+//g;
					 $na_seq=~s/\s+//g if $get_nucleic_acid_seq;
					 $na_seq=~tr/[a-z]/[A-Z]/;
					 $na_sequence{$seq_name}=$na_seq if $get_nucleic_acid_seq;
					 $seq=$na_seq='';
			 }
			 close FILE_1;
		 }


		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~`
		 # (3) When ranges information is given(via \@range), seq in those ranges are returned
		 #______________________________________________________________________________________
		 if(defined(@range)){
				%seq_fragments=%{&get_seq_fragments(\%sequence, \@range)};
				if($reverse_seq){
						%seq_fragments=%{&reverse_sequences(\%seq_fragments)};
				}
				return(\%seq_fragments);
		 }
		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		 # (4) When only size is asked with -s option
		 #_____________________________________________________________________________
		 elsif($char_opt=~/s/){ # when SIZE(length of seq) return only option is set
			 #@seq_Names=keys %sequence;
			 #for($i=0; $i<@seq_Names; $i++){
			 #      $Sizes{$seq_Names[$i]}=length($sequence{$seq_Names[$i]});
			 # }
			 return(\%Sizes);
		 }
		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		 # (5) when hash which has range info is given(@range should not be defined)
		 #_____________________________________________________________________________
		 elsif(@hash >=1){
				for($h=0; $h< @hash; $h++){
						my %hash=%{$hash[$h]};
						my @Keys=keys %hash;
						for($k=0; $k<@Keys; $k++){
								if(defined($hash{$Keys[$k]})){
										($S_start, $S_end)=$hash{$Keys[$k]}=~/(\d+)\-(\d+)/;
										$sequence{$Keys[$k]}=substr($sequence{$Keys[$k]}, ($S_start-1), ($S_end-$S_start));
								}
						}
				}
				if($reverse_seq){  %sequence=%{&reverse_sequences(\%sequence)};   }
				if($get_nucleic_acid_seq){
					 return(\%na_sequence);
				}else{
					 return(\%sequence);
				}
		 }else{
				if($reverse_seq){  %sequence=%{&reverse_sequences(\%sequence)};   }
				if($get_nucleic_acid_seq){
					 return(\%na_sequence);
				}else{
					 return(\%sequence);
				}
		 }
}


#________________________________________________________________________
# Title     : open_fasta_files
# Usage     : %fasta_seq=%{&open_fasta_files($fasta_file, ['MJ0084'])};
#             if you put additional seq name as MJ0084 it will
#             fetch that sequence only in the database file.
#
#             %out=%{&open_fasta_files(@ARGV, \%index)};
#               while  %index has (seq indexpos seq2 indexpos2,,,)
#               In this case, the fasta file should have xxxx.fasta format
#
# Function  : open fasta files and put sequences in a hash
#              If hash(es) is put which has sequence names and seek position
#              of the index file, it searches the input FASTA file to
#              fetch at that seek position. This is useful for Big fasta DBs
#             If the seq name has ranges like  XXXXXX_1-30, it will only
#              return 1-30 of XXXXXX sequence.
#
#             FASTA sequence file format is like this;
#
#             > 1st-seq
#             ABCDEFGHIJKLMOPABCDEFGHIJKLMOPABCDEFGHIJKLMOPABCDEFG
#             > 2nd.sequ
#             ABCDEFGHIJKLMOYYUIUUIUIYIKLMOPABCDEFGHIJKLMOPABCDEFG
#             >owl|P04439|1A03_HUMAN HLA CLASS I HISTOCOMPATIBILITY ANTIGEN, A-3 ALPHA CHAIN PRECURSOR....
#             MARGDQAVMAPRTLLLLLSGALALTQTWAGSHSMRYFFTSVSRPGRGEPRFIAVGYVDDT
#
#             This can also return the sizes of sequences rather than seqs.
#
#             This ignores any dup entrynames coming later.
#
# Example   : %out = %{&open_fasta_files(@ARGV)};
#             %out2=%{&open_fasta_files('seq.fasta', \%index)};
#             %out3=%{&open_fasta_files('seq.fasta', \%range)};
#             %seq=%{&open_fasta_files($PDB40_FASTA, \@seq_to_fetch)};
#
#             while @ARGV at prompt was: 'GMJ.pep MJ0084'
#
# Keywords  : open_fasta, open_fa_files, open_FASTA_files,
# Options   : Seq name to fetch the specified seq only.
#             as open_fasta_files.pl MY_SEQ_NAME Swissprot.fasta
#            -d  for giving back desc as well as the name. so it
#                gives  'HI0002 This is the description part'
#                as the key
#             If you put hash which is like('seq_name', ['20-30', '30-44',..])
#              it will produce hash which has got:
#              ( seq_name_20-30 'asdfasdfasdfasdfasd',
#                seq_name_30-44 'kljkljkjkjljkjljkll',
#                ....           .... )
#            -s for returning sequence size only
#   $min_seq_leng_accepted=       by m=
#   $No_gap_char_allowed=N        by N  # removes all \W
#   $remove_strange_and_masked_residues=R by R  # removes X, B, Z etc
#   $make_Upper_case_seq=U        by U
#   $keep_special_char_in_names=k by k
#   $get_description_of_seq=d by d
#
# Version   : 7.2
#--------------------------------------------------------------------
sub open_fasta_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    my (%sequence, %HASH, @Keys, $seq_found1, $S_start, $S_end, $seq_found,
        $present_seq, @seq_Names, %Sizes, $bare_seq_name, $fasta_seq_idx_file,
        %seq_fragments, $min_seq_leng_accepted, $No_gap_char_allowed, %wanted_seq_list,
        $remove_strange_and_masked_residues, $make_Upper_case_seq, $PDB_seq_name, $PDB_chain_name,
        $DC_fold_type, $DDD_seq_range, $DDD_seq_size, $keep_special_char_in_names,
        $get_description_of_seq);
    $min_seq_leng_accepted=0;

    if(@file<1){  print "\n open_fasta_files: \@file has less than 1 elem. There is no fileinput for open_fasta_files\n"; die }
    if($vars{'m'}=~/(\d+)/){ $min_seq_leng_accepted=$1; }
    if($char_opt=~/N/){  $No_gap_char_allowed='N'; }
    if($char_opt=~/R/){  $remove_strange_and_masked_residues='R'; }
    if($char_opt=~/U/){  $make_Upper_case_seq='U'; }
    if($char_opt=~/k/){  $keep_special_char_in_names='k'; }
    if($char_opt=~/d/){  $get_description_of_seq='d' }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  (1) When perl file INDEX pos info is given in hash, this speeds up
    #_________________________________________________________________________________
    for($d=0; $d < @hash; $d++){
	   my (@Keys, $sequence, $NAME, $range_start, $range_leng);
	   %HASH=%{$hash[$d]};
       @Keys=keys %HASH;  ## <<< NOTE it is @Keys, not @keys

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Check if the hash is for LIST or Position index
       #________________________________________________
       if($HASH{$Keys[0]} !~/^\d+$/){ %wanted_seq_list=%HASH; next }

	   for($f=0; $f< @file; $f++){
		  #====== It must be xxxx.fasta format =======
          unless($file[$f]=~/\S\.[mpsn]{0,2}fa[sta]?$/){
			  print "\n# open_fasta_files: \$file\[\$f\] does not have fasta extension, skipping"; next; }
		  open(FASTA, $file[$f]);
		  F0: for($e=0; $e< @Keys; $e++){
			 my $sequence;
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # When seq name has range attachment, it handles
			 #________________________________________________
			 if($Keys[$e]=~/^(\S+)_(\d+)\-(\d+)/){
			      $NAME=$1;
			      $range_start=$2-1;    ## to fit in substr function
			      $range_leng =$3-$2+1; ## to fit in substr
			 }else{
			      $NAME=$Keys[$e];
			 }
			 if($HASH{$Keys[$e]}=~/^(\d+)$/){
                  splice(@hash, $d, 1);
                  $d--;
                  splice(@file, $f, 1);
                  $f--;
                  seek(FASTA, $1-220, 0);  # -220 is necessary
                  while(<FASTA>){
                     if( /^\>\s*$NAME/  or
                             /^\>\s*\S+$NAME/){  # to handle ">owl|P04439|1A03_HUMAN HLA CLASS I HISTOCOMPATIBILITY
                            $seq_found1=1;
                     }elsif(/^(\w+)$/ and $seq_found1==1){   $sequence .=$1;
                     }elsif(/^\>\s*\S+/ and $seq_found1==1 and length($sequence) > $min_seq_leng_accepted){
     # Filtering by seq size
                         if($No_gap_char_allowed){
                                  $sequence=~s/\W+[0-9]//g;
                         }
                         if($remove_strange_and_masked_residues){
                                  $sequence=~s/[oOjJxXzZbB\W0-9]+//g;
                         }
                         if($make_Upper_case_seq){
                                  $sequence="\U$sequence";
                         }
                         if($range_start =~/\d+/){
                                         $sequence{$Keys[$e]}=substr($sequence, $range_start, $range_leng);
                         }else{         $sequence{$Keys[$e]}=$sequence; }
                         $range_start='';
                         $sequence='';
                         $seq_found1=0; next F0;
                     }
                  }
			  }
		  }
	  }
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	# !(2)! -- opening FASTA files (NORmal, when no perl index pos number is given)
	#_______________________________________________________________________
	for($i=0; $i< @file; $i++){
	   unless(-s $file[$i]){ next; } ## this is essential as handle_arguments has a problem
       my($entry_found, $input_file, $redundant_entry_count, $matched_FASTA_seq_name, $matched_seq);
	   if(ref( $file[$i] ) eq 'SCALAR' ){  $input_file = ${$file[$i]};
	   }else{  $input_file=$file[$i];  }

	   unless (-e $input_file){  print chr(7);  print "\n\n\t This is sub open_fasta_files in $0  \n\n";
           print "\t Fatal: The input file $input_file is not in the directory \n"; die;
	   }
	   open(FILE_1,"$input_file");
	   if(@hash >=1){  ## if seq names are given in hash
           for($h=0; $h< @hash; $h++){
                 @string=(@string, keys %{$hash[$h]});
           }
	   }

	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	   # (2.1) Not default. when seq to fetch is given by \@sequences  format
	   #_______________________________________________________________________
       if( @_ > 1  and  @array > 0  and !%wanted_seq_list){
	       $num_of_seq_to_fetch=@array;
		   print "\n#  open_fasta_files is fetching sequences from \$input_file= $input_file\n";
		   %sequence=%{&fetch_sequence_from_db($input_file, \@string)};
		   print "\n# $fasta_seq_idx_file file is made by open_fasta_files(fetch_sequence_from_db), you may remove it\n";
	   }
	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	   # (2.2) !!! When seq names NOT given, fetches all (THE DEFAULT)
	   #____________________________________________________________
	   else{
           while(<FILE_1>){                # file1 needs to be xxxx.fasta for the moment, automatic later
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # NCBI's pdbaa file  >gi|6435791|pdb|1QK9|A Chain A, The Solution
               #__________________________________________________________________________
               if(/\>gi\|\d+\|pdb\|(\d\S\S\S)\|((\S*)\s*.*)/){
                    $PDB_seq_name="\L$1";
                    $function_description=$2;
                    $PDB_chain_name=$3;
                    unless($PDB_chain_name=~/\w/){  $PDB_chain_name='_' }
                    $matched_FASTA_seq_name="$PDB_seq_name$PDB_chain_name";

                    if( $sequence{$matched_FASTA_seq_name} ){
                        #------- To avoid identical entry reading repeatedly -----
                        print "\n# I am open_fasta_files: $1 seems to be the same as previous entry, ERROR??\n";
                        $entry_found=0;
                    }else{
                        $matched_FASTA_seq_name=~s/\:/_/; ## changing : to _ in the name.
                        $entry_found=1;
                    }
               }elsif(/^\>\s*gi\|\d+\|\S+\|(\S+)\|(.*)/){  ## for >gi|1669546|dbj|D84107|D84107 Human mRNA for Werner syndrome-1/type 1, complete cds
                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Checks if the previous sequence reading was good
                    #____________________________________________________________
                    if(!$matched_seq){ warn " $matched_FASTA_seq_name didn\'t seem to have matching sequence. Empty sequence ????\n";  }
                    $function_description="$2";
                    if( $sequence{$1} ){
                        $redundant_entry_count++;
                        print "\n# (E) open_fasta_files: $1 The same entry, ERROR, $redundant_entry_count";
                        $entry_found=0;
                    }else{      $matched_FASTA_seq_name=$1;   $entry_found=1;     }
               }elsif(/^\>\s*owl\|\S*\|(\S+)(\s*.*)/ or /^>\s*pir\|\S*\|(\S+)(\s*.*)/){  ## for ">owl|P04439|1A03_HUMAN HLA CLASS I HISTOCOMPATIB
                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Checks if the previous sequence reading was good
                    #____________________________________________________________
                    if(!$matched_seq){ warn " $matched_FASTA_seq_name did seem to have matching sequence. Empty sequence ????\n";  }
                    $function_description="$2";
                    if( $sequence{$1} ){
                           $redundant_entry_count++;
                           print "\n# (E) open_fasta_files: $1 The same entry, ERROR, $redundant_entry_count";
                           $entry_found=0;
                    }else{      $matched_FASTA_seq_name=$1;   $entry_found=1;     }

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Reading DDD.fasta file: >1jlyA:2        fold 37; range 1 159; size 159; MOL_ID: 1;
               #__________________________________________________________
               }elsif(/^>\s*([\w\:]+)\s+fold\s+(\d+)\;\s+range([\d\s]+)\;\s*size\s+(\d+)\;/){
                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Checks if the previous sequence reading was good
                    #____________________________________________________________
                    if(!$matched_seq){ warn " $matched_FASTA_seq_name didnt seem to have matching sequence. Empty sequence ????\n";  }

                    $DC_fold_type=$2;
                    $DDD_seq_range=$3;
                    $DDD_seq_size=$4;
                    $matched_seq=''; # resetting the previous SEQUENCE
                    $function_description="fold:$DC_fold_type range:$DDD_seq_range size:$DDD_seq_size";
                    if( $sequence{$1} ){
                        #------- To avoid identical entry reading repeatedly -----
                        $redundant_entry_count++;
                        print "\n# (E) open_fasta_files: $1 The same entry, ERROR, $redundant_entry_count";
                        $entry_found=0;
                    }else{
                        $matched_FASTA_seq_name=$1;
                        $matched_FASTA_seq_name=~s/\:/_/; ## changing : to _ in the name.
                        $entry_found=1;
                    }
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # (DEfault) The most common FASTA format entry
               #_______________________________________________________
               }elsif(/^>\s{0,5}(\S+)\s*(.*)/){
                    $matched_FASTA_seq_name=$1;
                    $function_description=$2;
                    unless($keep_special_char_in_names){ $matched_FASTA_seq_name=~s/\,//g; }
                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Checks if the previous sequence reading was good
                    #____________________________________________________________
                    if(!$matched_seq){ warn " Reading common FASTA format: $matched_FASTA_seq_name didnt have sequence. Empty or First sequence ????\n";  }

                    if( $sequence{$matched_FASTA_seq_name} ){ # check if the entry already exists
                        $redundant_entry_count++;
                        print "\n# (E) open_fasta_files: $1 The same entry, ERROR, $redundant_entry_count";
                        $entry_found=0;
                    }else{   $entry_found=1;     }
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # (Default) I write at this point <----------<<<
               #_________________________________________________
               }elsif(/^([\w\.\- ]+)\s*$/ and $entry_found == 1){
                    $matched_seq=$1;
                    if($No_gap_char_allowed){          $matched_seq=~s/\W+//g;                    }
                    if($remove_strange_and_masked_residues){ $matched_seq=~s/[\,oOjJxXzZbB\W0-9]+//g; }
                    if($make_Upper_case_seq){    $matched_seq="\U$matched_seq";                  }
                    if($char_opt=~/s/){ # when SIZE(length of seq) return only option is set
                        $Sizes{$matched_FASTA_seq_name}+=length($matched_seq);
                    }else{
                        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        # Filtering by seq size and Actual ASSIGNMENT
                        #____________________________________________________
                        if(length($matched_seq) > $min_seq_leng_accepted){
                             if( %wanted_seq_list and ! $wanted_seq_list{$matched_FASTA_seq_name}){
                                 $entry_found=0; next
                             }else{
                                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                 # $get_description_of_seq is set, the HASH struc is different
                                 #______________________________________________________________
                                 if($get_description_of_seq){
                                     $sequence{$matched_FASTA_seq_name}{'SEQUENCE'}.= $matched_seq if defined($matched_FASTA_seq_name);
                                     $sequence{$matched_FASTA_seq_name}{'DESCRIPTION'}= $function_description;
                                 }else{
                                     $sequence{$matched_FASTA_seq_name}.= $matched_seq if defined($matched_FASTA_seq_name);
                                 }
                             }
                        }
                    }
               }elsif(/^$/){  next;
               }else{  $entry_found=0;  } ## this is when rubbish is matched
           }# end of while
	   }
	   close FILE_1;
	 }


	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~`
	 # (3) When ranges information is given(via \@range), seq in those ranges are returned
	 #______________________________________________________________________________________
	 if(defined(@range)){
         %seq_fragments=%{&get_seq_fragments(\%sequence, \@range)};
	     return(\%seq_fragments);
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 # (4) When only size is asked with -s option
	 #_____________________________________________________________________________
	 elsif($char_opt=~/s/){ # when SIZE(length of seq) return only option is set
	    #@seq_Names=keys %sequence;
	    #for($i=0; $i<@seq_Names; $i++){
	    #	  $Sizes{$seq_Names[$i]}=length($sequence{$seq_Names[$i]});
	    # }
	    return(\%Sizes);
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 # (5) when hash which has range info is given(@range should not be defined)
	 #_____________________________________________________________________________
	 elsif(@hash >=1){
         for($h=0; $h< @hash; $h++){
              my %hash=%{$hash[$h]};
              my @Keys=keys %hash;
              for($k=0; $k<@Keys; $k++){
                  if(defined($hash{$Keys[$k]}) and $hash{$Keys[$k]}=~/(\d+)\-(\d+)/){
                      ($S_start, $S_end)=($1, $2);
                      $sequence{$Keys[$k]}=substr($sequence{$Keys[$k]}, ($S_start-1), ($S_end-$S_start));
                  }
              }
         }
         return(\%sequence);
	 }else{
         return(\%sequence);
	 }
}




#______________________________________________________________________________
# Title     : make_fasta_file_from_NCBI_pdbaa_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
#   $sort_seq_names=s by s
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_fasta_file_from_NCBI_pdbaa_file{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #-----------------------------------------------------------------------------
    if($char_opt=~/s/){ $sort_seq_names='s';  }

    $input_file=$_[0];
    %fasta=%{&open_fasta_files($input_file)};
    $base=${&get_base_names($input_file)};
    &write_fasta(\%fasta, "$base\_clean\.mpfa", 's');
}





#________________________________________________________________________
# Title     : msf_permute_hash_write
# Usage     : &msf_permute_hash_write(\%hash, $group_name); # void
# Function  : gets 2 references (one for %hash the other for group $name)
#             uses &msf_permute_array_write(\%hash, \$group_name)
#             the second arg is for output file name. can be anything.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub msf_permute_hash_write{ my(%hash)=%{$_[0]}; my($group_name)=${$_[1]};
	my(@array)= keys %hash;  &msf_permute_array_write (\@array, $group_name );
}

#________________________________________________________________________
# Title     : msf_permute_array_write
# Usage     : &msf_permu_array_write(\%hash, \$group_name); # void
# Function  :
#             the second arg is for output file name. can be anything.
#             used in &msf_permu_hash_write
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  : gets 2 references
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub msf_permute_array_write{
	my(@array) =@{$_[0]};
	my($group_name)=${$_[1]};
	my($i,$j);
	for ($i=0;$i<@array;$i++) {
	 push(@result,$array[$i]);
	 if (@result>=2){
		  $count+=1;  # this is for the whole number of files(permutation) produced.
			for $key( @result){
			$input{$key}=$hash{$key};
		  }
		  $hash_ref_to_msfs_write=\%input;
					  #print %input;
					  @seq_names= (keys %input);
					  $seqno=($#seq_names) + 1;
					 #print $seqno;&n;
			$out_file_name="$group_name$count\-$seqno\.fasta"; # output file name.
					  ###### eg. result file => perl1-2.fasta, -2 means seq. no.
			&msf_write($hash_ref_to_msfs_write, $out_file_name);
	 }
		  %input=();
		  my(@input_array)=@array[$i+1..$#array];
		  &msf_permute_array_write(\@input_array) if $i<$#array;
			 #&msf_permu_array_write(@array[$i+1..$#array]) if $i<$#array;
		  pop(@result);  # <--this is essential.
	}
}

#________________________________________________________________________
# Title     : pir_permute_hash_write
# Usage     : &pir_permute_hash_write($hash_ref, $group_name); # void
# Function  : gets a reference of hash which has names and sequences as keys and values.
#             uses &pir_permute_array_write
#             the second arg is for output file name. can be anything.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pir_permute_hash_write{
	my(%hash);
	my($hash_ref)=$_[0];  my($group_name)=$_[1];
	%hash=%{$hash_ref};
	my(@array)= keys %hash;
	$array_ref1 = \@array;
	&pir_permute_array_write ($array_ref1, $group_name );
}

#________________________________________________________________________
# Title     : fasta_permute_hash_write
# Usage     : &fasta_permute_hash_write($hash_ref, $group_name); # void
# Function  : gets a reference of a hash which has names and sequences as keys and values.
#             uses &fasta_permute_array_write
#             the second arg is for output file name. can be anything.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fasta_permute_hash_write{ my(%hash)=%{$_[0]}; my($group_name)=${$_[1]};
	my(@array)= keys %hash; $array_ref1 = \@array;
	&fasta_permute_array_write (\@array, \$group_name );
}
#________________________________________________________________________
# Title     : fasta_permute_array_write
# Usage     : &fasta_permu_array_write($hash_ref, $group_name); # void
# Function  : gets a reference of an array which has names and sequences as keys and values.
#             the second arg is for output file name. can be anything.
#             used in &fasta_permu_hash_write
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fasta_permute_array_write{
	my(@array)=@{$_[0]};
	my($group_name)=${$_[1]};
	my($i,$j, @result);
	for ($i=0;$i<@array;$i++) {
	 push(@result,$array[$i]);
	 if (@result>=2){
		$count+=1; # this is for the whole number of files produced.
		for $key( @result){
		  $input{$key}=$hash{$key};
		}
		$hash_ref_to_fastas_write=\%input;
		#print %input;
		@seq_names= (keys %input);
		$seqno=($#seq_names) + 1;
		#print $seqno;&n;
		$out_file_name="$group_name$count\-$seqno\.fasta"; # output file name.
		###### eg. result file => perl1-2.fasta, -2 means seq. no.
		&fastas_write($hash_ref_to_fastas_write, $out_file_name);
	 }
	 %input=();
		my(@input_array)=@array[$i+1..$#array];
		my($array_ref3)=\@input_array;
		&fasta_permute_array_write($array_ref3) if $i<$#array;
		#&fasta_permu_array_write(@array[$i+1..$#array]) if $i<$#array;
		pop(@result);  # <--this is essential.
	 }
}
#________________________________________________________________________
# Title     : ssp_permute_hash_write
# Usage     : &ssp_permute_hash_write($hash_ref, $group_name); # void
# Function  : gets a reference of hash which has names and sequences as keys and values.
#             uses &ssp_permute_array_write
#             the second arg is for output file name. can be anything.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub ssp_permute_hash_write{
	my(%hash);
	my($hash_ref)=$_[0]; my($group_name)=$_[1];
	%hash=%{$hash_ref}; my(@array)= keys %hash;
	$array_ref1 = \@array; &ssp_permute_array_write ($array_ref1, $group_name );
}

#________________________________________________________________________
# Title     : pir_permute_array_write
# Usage     : &pir_permu_array_write($hash_ref, $group_name); # void
# Function  : gets a reference of hash which has names and sequences as keys and values.
#             the second arg is for output file name. can be anything.
#             used in &pir_permu_hash_write
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pir_permute_array_write{
		  my($array_ref1)=$_[0];
		  my($group_name)=$_[1];
		  my($i,$j);
		  my(@array)=@{$array_ref1};
		  for ($i=0;$i<@array;$i++) {
					 push(@result,$array[$i]);
					 if (@result>=2){
								 $count+=1; # this is for the whole number of files produced.
								 for $key( @result){
											$input{$key}=$hash{$key};
								 }
								 $hash_ref_to_pirs_write=\%input;
								 #print %input;
								 @seq_names= (keys %input);
								 $seqno=($#seq_names) + 1;
								 #print $seqno;&n;
								 $out_file_name="$group_name$count\-$seqno\.fasta"; # output file name.
											###### eg. result file => perl1-2.fasta, -2 means seq. no.
								 &pir_write($hash_ref_to_pirs_write, $out_file_name);
					 }
					 %input=();
					 my(@input_array)=@array[$i+1..$#array];
					 my($array_ref3)=\@input_array;
					 &pir_permute_array_write($array_ref3) if $i<$#array;
						#&pir_permu_array_write(@array[$i+1..$#array]) if $i<$#array;
					 pop(@result);  # <--this is essential.
		  }
}
#________________________________________________________________________
# Title     : ssp_permute_array_write
# Usage     : &ssp_permu_array_write($hash_ref, $group_name); # void
# Function  : gets a reference of hash which has names and sequences as keys and values.
#             the second arg is for output file name. can be anything.
#             used in &ssp_permu_hash_write
#             ssp file is for PHD secture prediction service.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub ssp_permute_array_write{
	 my($array_ref1)=$_[0];
	 my($group_name)=$_[1];
	 my($i,$j);
	 my(@array)=@{$array_ref1};
	 for ($i=0;$i<@array;$i++) {
		  push(@result,$array[$i]);
		  if (@result>=2){
				 $count+=1; # this is for the whole number of files produced.
				 for $key( @result){
							$input{$key}=$hash{$key};
				 }
				 $hash_ref_to_ssp_write=\%input;
				 #print %input;
				 @seq_names= (keys %input);
				 $seqno=($#seq_names) + 1;
				 #print $seqno;&n;
				 $out_file_name="$group_name$count\-$seqno\.fasta"; # output file name.
							###### eg. result file => perl1-2.fasta, -2 means seq. no.
				 &ssp_write($hash_ref_to_ssp_write, $out_file_name);
		  }
		  %input=();
		  my(@input_array)=@array[$i+1..$#array];
		  my($array_ref3)=\@input_array;
		  &ssp_permute_array_write($array_ref3) if $i<$#array;
			 #&ssp_permute_array_write(@array[$i+1..$#array]) if $i<$#array;
		  pop(@result);  # <--this is essential.
	 }
}

#________________________________________________________________________
# Title     : permute
# Usage     : &permute(\@array);
# Function  : gets permutated array elements except single char elements.
#             fastest
# Example   :
# Warning   : from : Kenneth Albanowski <kjahds@kjahds.com> CIS: 70705,126)
# Keywords  : permutation, combination
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub permute{
	my(@array)= @{$_[0]};
	my($i,$j);
	for ($i=0;$i<@array;$i++){ push(@result,$array[$i]);
		print join(" ",@result),"\n" if @result>=2;
		&permute(@array[$i+1..$#array]) if $i<$#array;
		pop(@result); }
}

#________________________________________________________________________
# Title     : permute_binary
# Usage     :
# Function  : outs permutated array elements
# Example   : &permute_binary(@array);
# Warning   : from : silly@ugcs.caltech.edu
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub permute_binary{  my(@a)=@_;
	for ($i = 1; $i < (1 << ($#a + 1)); $i++) {
	for ($tmp = $i, $bit = 0; $tmp; ($tmp >>= 1), $bit++) {
	 if ($tmp & 1) { print "@a[$bit]"; push (@result, @a[$bit]);}}
	print "\n"; }
}

#________________________________________________________________________
# Title     : ssp_write
# Usage     : two argments:  $seq_hash_reference  and $output_file_name
#             takes a hash which has got names keys and sequences values.
#             uses Perl5 pointers(references).
# Function  : writes multiple seqs. in fasta format (takes one or more than one seq.!!)
#             ssp is PHD server format.
# Example   : &ssp_write($hash_pointer, $out_file_name);
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub ssp_write{
			my($hash_ref1, $output_file)=@_;	# $name is the name of seq.
			my(%input)=%{$hash_ref1};
			open (SSP_WRITE,">$output_file");		# $string is the seq string.
			for $name(keys %input){
						my($ll)=0;								# $output_file is the name of output.
						$string=$input{$name};
						$string=~s/[ .-]//g;		# replaces all non-chars to null.
						$string=~tr/a-z/A-Z/;    # converts lower to upper cases.
						print SSP_WRITE "# $name.ssp\n";			# this writes only one seq. in one file.
						$ls2=length($string);					# use fasta_append for mul. lines of seq
						for($i=0; $i<$ls2; $i++){
								  $char=substr($string,$i,1);
								  print SSP_WRITE $char;
								  $ll++;
								  if($ll == 60){                # wraps at 60 char position.
											 $ll=0;
											 print SSP_WRITE "\n";
								  }
						}
						print SSP_WRITE "\n";
			}
}
#________________________________________________________________________
# Title     : pir_write
# Usage     : two argments:  $seq_hash_reference  and $output_file_name
#             takes a hash which has got names keys and sequences values.
#             uses Perl5 pointers(references).
# Function  : writes multiple seqs. in fasta format (takes one or more than one seq.!!)
#             pir is PHD server format.
# Example   : &pir_write($hash_pointer, $out_file_name);
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pir_write{
	my($hash_ref1, $output_file)=@_;	# $name is the name of seq.
	my(%input)=%{$hash_ref1};
	my(@names)=keys %input; my($name);
	open (pir_WRITE,">$output_file");		# $string is the seq string.
	print pir_WRITE "# PIR list  @names\n"; # This is !! essential for PHD !!!
	for $name(keys %input){
	 my($ll)=0;								# $output_file is the name of output.
	 $string=$input{$name};
	 $string=~s/[ .-]//g;		# replaces all non-chars to null.
	 $string=~tr/a-z/A-Z/;    # converts lower to upper cases.
	 print pir_WRITE ">P1;\n";
	 print pir_WRITE "$name\n";	# this writes only one seq. in one file.
	 $ls2=length($string);					# use fasta_append for mul. lines of seq
	 for($i=0; $i<$ls2; $i++){
		$char=substr($string,$i,1);
		print pir_WRITE $char;
		$ll++;
		if($ll == 60){                # wraps at 60 char position.
		  $ll=0;
		  print pir_WRITE "\n";
		}
	 }
	 print pir_WRITE "\n";
	}
}

#________________________________________________________________________
# Title     : pir_write
# Usage     : two argments:  $seq_hash_reference  and $output_file_name
#             takes a hash which has got names keys and sequences values.
#             uses Perl5 pointers(references).
# Function  : writes multiple seqs. in fasta format (takes one or more than one seq.!!)
# Example   : &pir_write($hash_pointer, $out_file_name);
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pir_write{
	 my($hash_ref1, $output_file)=@_;    # $name is the name of seq.
	 my(%input)=%{$hash_ref1};
	 open (pir_WRITE,">$output_file");       # $string is the seq string.
	 for $name(keys %input){
	   my($ll)=0;                              # $output_file is the name of output.
	   $string=$input{$name};
	   $string=~s/[ .-]//g;        # replaces all non-chars to null.
	   $string=~tr/a-z/A-Z/;    # converts lower to upper cases.
	   print pir_WRITE ">P1;\n";           # this writes only one seq. in one file.
	   print pir_WRITE "$name\n";
	   $ls2=length($string);                   #
	   for($i=0; $i<$ls2; $i++){
		   $char=substr($string,$i,1);
		   print pir_WRITE $char;
		   $ll++;
		   if($ll == 60){                # wraps at 60 char position.
			  $ll=0;
			  print pir_WRITE "\n";
		   }
	   }
	   print pir_WRITE "\n";
	 }
}
#__________________________________________________________________
# Title     : write_seq_files
# Usage     :
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  :
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sub write_seq_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($string, $na,$out_file_name_provided);
	my($output_file) ='default_out.seq'; ### when no output file name is given, this is used
	if(@file>0){
	$output_file = $file[0];
	$out_file_name_provided=1;
	}else{ $output_file='default_out.seq'; }

	for ($n=0 ; $n < @hash; $n ++){
	 my %hash=%{$hash[$n]};
	 my @keys=keys %hash;
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # When only one seq is given, use the seq name as output file
	 #________________________________________________________________
	 if(@hash==1 and @keys==1 and @file < 1){
	    $output_file="$keys[0]\.seq";
	 }elsif(@file < 1){
	    $output_file="default_fa_$n\.seq";
	 }

	 open (SEQ_WRITE, ">$output_file");      # $string is the seq string.

	 for ($i=0; $i < @keys; $i++){
		$na= $keys[$i];
		$string = "\U$hash{$na}";
		$string=~s/[\n \.-]//g;     # replaces all non-chars to null. '_' is used for stop codon
		$seq_leng=length($string);
		if($debug == 1){
			printf ("%-15s %-5s %s", $na, $seq_leng, $string);
			printf SEQ_WRITE ("%-15s %-5s %s", $na, $seq_leng, $string);
	    }elsif($char_opt=~/v/){
			printf ("%-15s %-5s %s", $na, $seq_leng, $string);
			printf SEQ_WRITE ("%-15s %-5s %s", $na, $seq_leng, $string);
		}else{
			printf SEQ_WRITE ("%-15s %-5s %s", $na, $seq_leng, $string);
		}
		print SEQ_WRITE "\n";
	 }
	}
	close SEQ_WRITE;
	if( $out_file_name_provided != 1){
	  print "\n\n# You didnt give out file name, $output_file  used\n";
	}
	if( -s $output_file){
	 print "\n# Sequences were written in  $output_file ";
	}else{
	 print "\n# The size of written outfile \"$output_file\" is 0, error \n\n" }
}

#__________________________________________________________________________
# Title     : make_singlet_list_from_pdb_entries
# Usage     : &write_pdbs_files(\@files);
# Function  : gets the classificaiton of scop in pdb40d.fasta like file and
#             produces pdb40d.pdbs file.
#
#             1.1.1.1.4  means: Class.Fold.Superfamily.Family.Protein
#
#             Compare with make_groups_from_pdb_entries
# Example   : &make_singlet_list_from_pdb_entries(\@files);
# Input>
#   >d2sn3__ 7.3.6.1.1 scorpion toxin [Centruroides sculpturatus ewing, variant 3]
#   KEGYLVKKSDGCKYGCLKLGENEGCDTECKAKNQGGSYGYCYAFACWCEGLPESTPTYPL
#
# OUTPUT>
#   >d2cmd_1 3.18.1.5.2 (1-145) Malate dehydrogenase [Escherichia coli]
#   >d2naca2 3.18.1.4.1 (148-335) Formate dehydrogenase [Pseudomonas sp. 101]
#
# Keywords  : make_singlet_list_from_pdb40d, make_singlet_list_from_scop, make_superfamilies
#             write_pdbs_files, make_pdbs_files, make_pdb_group_files,
#             write_pdbs, make_singlet_list_from_pdb_entries
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub make_singlet_list_from_pdb_entries{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	for($i=0; $i< @file; $i++){
	   my(%superfamily_singlets, $seq, $classification, $class, $fold, $superfamily,
	      $family, $protein, $description, $group_num_counter, @keys, @values,
		  $all_seq_in_input_classification, $num_of_singlets);

	   $base=${&get_base_names($file[$i])};
	   $out_pdbs_file="$base\.pdbs";
	   open(PDB_SEQ_FILE, "$file[$i]");
	   while(<PDB_SEQ_FILE>){  # matching  1.1.1.1.4  <-- classification,
		  if(/\> {0,3}(\S+) +((\d+)\.(\d+)\.(\d+)\.(\d+)\.(\d+))\s+(.+)/){
			 $seq=$1;
			 $classification=$2;
			 $class = $3;
			 $fold  = $4;
			 $superfamily=$5;
			 $family=$6;
			 $protein=$7;
			 $description=$8;
			 $superfamily_singlets{"$class\.$fold\.$superfamily"}.="\>$seq $classification $description\n";
			 $superfamily_member_count{"$class\.$fold\.$superfamily"}++;
			 $all_seq_in_input_classification++;
		  }
	   }
	   close PDB_SEQ_FILE;
	   open(PDBS, ">$out_pdbs_file");
	   @keys= keys %superfamily_singlets;
	   for($j=0; $j < @keys; $j++){
	      if($superfamily_member_count{$keys[$j]} > 1){
			  $num_of_groups ++;
	          next; ## skipping singlets
	      }else{
		      print PDBS $superfamily_singlets{$keys[$j]}, "\n";
			  $singlet_num_counter++;
		  }
	   }
	   my $num_of_seq_in_group=$all_seq_in_input_classification-$singlet_num_counter;

	   print "\n# No of Groups                : $num_of_seq_in_group";
	   print "\n# No of All seq in the input  : $all_seq_in_input_classification";
	   print "\n# No of singlets              : $singlet_num_counter";
	   print "\n# No of seq in the $num_of_groups groups : $num_of_seq_in_group";
	   print PDBS "\n# No of Groups: $num_of_groups";
	   print PDBS "\n# No of All seq in the input: $all_seq_in_input_classification";
	   print PDBS "\n# No of singlets: $singlet_num_counter";
	   print PDBS "\n# No of seq in the $num_of_groups groups: $num_of_seq_in_group";
	   close PDBS;
	   print "\n# $out_pdbs_file has been written \n\n";
	}
}

#______________________________________________________________________
# Title     : write_pdbg_files
# Usage     : &write_pdbg_files(\@files);
# Function  : gets the classificaiton of scop in pdb40d.fa like file and
#             produces pdb40d.pdbg file.
#
#             1.1.1.1.4  means: Class.Fold.Superfamily.Family.Protein
#
# Example   :
# Input>
#   >d2sn3__ 7.3.6.1.1 scorpion toxin [Centruroides sculpturatus ewing, variant 3]
#   KEGYLVKKSDGCKYGCLKLGENEGCDTECKAKNQGGSYGYCYAFACWCEGLPESTPTYPL
#
# OUTPUT>
#   >d2cmd_1 3.18.1.5.2 (1-145) Malate dehydrogenase [Escherichia coli]
#   >d2naca2 3.18.1.4.1 (148-335) Formate dehydrogenase [Pseudomonas sp. 101]
#
# Keywords  : make_groups_from_pdb40d, make_groups_from_scop, make_superfamilies
#             write_pdbg_files, make_pdbg_files, make_pdb_group_files,
#             write_pdbg, make_groups_from_pdb_entries
# Options   :
#    $write_non_redundant_seq_file_version=n by n
#
# Returns   :
# Argument  :
# Version   : 1.7
#--------------------------------------------------------------------------
sub write_pdbg_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($write_non_redundant_seq_file_version, %PDB_ID, $seq_leng, $num_of_all_superfam);

    if($char_opt=~/n/){ $write_non_redundant_seq_file_version='n' }

    for($i=0; $i< @file; $i++){
       my(%superfamily_groups, $seq, $classification, $class, $fold, $superfamily,
          $family, $protein, $description, $group_num_counter, @keys, @values,
          $all_seq_in_input_classification, $num_of_singlets, $all_possible_pair_combination,
          $alpha_class, $beta_class, $alpha_and_beta_class, $alpha_plus_beta_class,
          %non_redundant_seqs, $seq_length, %superfamily_size);

       $base=${&get_base_names($file[$i])};
       $out_pdbg_file="$base\.pdbg";
       print "\n# (i) \$out_pdbg_file is $out_pdbg_file from $base $file[$i]\n";
       $non_redundant_seq_fasta_outputfile="$base\_non_redun\.mpfa"; # mpfa: multi, protein fasta file
       open(BUGS, ">$base\_PDBD_bugs.list")|| die;
       open(PDB_SEQ_FILE, "$file[$i]");

       while(<PDB_SEQ_FILE>){  # matching  1.1.1.1.4  <-- classification,
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # SCOP PDBD classification
          #_________________________________________________________________________
          if(   /\> {0,3}(\S+)\s+((\d+)\.(\d+)\.(\d+)\.(\d+)\.(\d+))\s*(.*)/){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Putting size information for the last entry
              #______________________________________________________________
              if($superfamily and $seq_length){ $superfamily_size{"$class\.$fold\.$superfamily"} += $seq_length; }
              $seq=$1; $classification=$2; $class = $3; $fold  = $4;
              $superfamily=$5; $family=$6; $protein=$7; $description=$8;
              $seq=~/\w(\d\S\S\S)/; $PDB_ID{$1}++;
              $seq_check{$seq}++;
              if($seq_check{$seq} > 1){ print BUGS "\n# (E) BUGG! $seq occurred $seq_check{$seq} TIMES!!";
                  $seq_name_with_classification='';
                  $write_non_redundant_seq_file_version='n'; # preventing writing non-redundant seq fasta file
                  next;
              }else{
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # Following assigns seq to hash to make non-redundant seqname-> seq hash. To prevent Tim's bug of redundancy in pdb95 etc
                  #_______________________________________________________________________________________
                  $seq_name_with_classification="$seq $classification";
              }
              $fold_groups{"$class\.$fold"}.="\>$seq $classification $description\n";
              $superfamily_groups{"$class\.$fold\.$superfamily"}.="\>$seq $classification $description\n";
              $superfamily_member_count{"$class\.$fold\.$superfamily"}++;
              $all_seq_in_input_classification++;
              $seq_length='';
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Dali classification\  D.C.1.2.3        ,     1a04A_2
          #____________________________________________________________________________
          }elsif(/\>(\S+)\s+(D.C.(\d+)\.(\d+)\.(\d+))\s+range:\s+([\d\- ]+)\s+compound:\s+(.*)/){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Putting size information for the last entry
              #______________________________________________________________
              if($superfamily and $seq_length){ $superfamily_size{"$class\.$fold\.$superfamily"} += $seq_length; }

              $seq=$1;  $classification=$2; $class = $3; $fold  = $4; $ranges=$6;
              $superfamily=$5; $ranges=$6; $description=$7;
              $seq=~/\w(\d\S\S\S)/; $PDB_ID{$1}++;
              $seq_check{$seq}++;
              if($seq=~/(\d\w\w\w\w)_(\d+)/){ $seq="$1$2" }
              if($seq_check{$seq} > 1){ print "\n# (E) BUGG! $seq occurred $seq_check{$seq} TIMES!!";
                  $seq_name_with_classification='';
                  $write_non_redundant_seq_file_version='n'; # preventing writing non-redundant seq fasta file
                  next;
              }else{
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # Following assigns seq to hash to make non-redundant seqname-> seq hash. To prevent Tim's bug of redundancy in pdb95 etc
                  #_______________________________________________________________________________________
                  $seq_name_with_classification="$seq $classification";
              }
              $fold_groups{"$class\.$fold"}.="\>$seq $classification $ranges $description\n";
              $superfamily_groups{"$class\.$fold\.$superfamily"}.="\>$seq $classification $ranges $description\n";
              $superfamily_member_count{"$class\.$fold\.$superfamily"}++;
              $all_seq_in_input_classification++;
              $seq_length='';
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Dali DDID file "101m_1 101m 1 _ 1 2-152   D.C.16.2.4 151", "1a0sP1 1a0s 3 P 1 1-10 47-75 86-122 134-144   D.C.43.1.5 87"
          #________________________________________________________________________________________________________________________
          }elsif(/(\S+)\s+\S+\s+\d+\s+\w+\s+\d+\s+([\d\- ]+)\s+(D.C.(\d+)\.(\d+)\.(\d+))\s+(\d+)/){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Putting size information for the last entry
              #______________________________________________________________
              if($superfamily and $seq_length){ $superfamily_size{"$class\.$fold\.$superfamily"} += $seq_length; }
              $seq=$1;  $classification=$3; $class = $4; $fold  = $5;
              $superfamily=$6; $ranges=$2; $seq_leng=$7;
              $seq=~/\w(\d\S\S\S)/; $PDB_ID{$1}++;
              $seq_check{$seq}++;
              if($seq=~/(\d\w\w\w\w)_(\d+)/){ $seq="$1$2" }
              if($seq_check{$seq} > 1){ print "\n# (E) BUGG! $seq occurred $seq_check{$seq} TIMES!!";
                  $seq_name_with_classification='';
                  $write_non_redundant_seq_file_version='n'; # preventing writing non-redundant seq fasta file
                  next;
              }else{
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # Following assigns seq to hash to make non-redundant seqname-> seq hash. To prevent Tim's bug of redundancy in pdb95 etc
                  #_______________________________________________________________________________________
                  $seq_name_with_classification="$seq $classification";
              }
              $fold_groups{"$class\.$fold"}.="\>$seq $classification $ranges SEQ_LENG=$seq_leng $description\n";
              $superfamily_groups{"$class\.$fold\.$superfamily"}.="\>$seq $classification $ranges $description\n";
              $superfamily_member_count{"$class\.$fold\.$superfamily"}++;
              $all_seq_in_input_classification++;
              $seq_length='';
          }elsif(/^(\S+)\s*$/){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Assigns seq to hash to make non-redundant seqname-> seq hash. To prevent Tim's bug of redundancy in pdb95 etc
              #_______________________________________________________________________________________
              if($seq_name_with_classification){
                  $non_redundant_seqs{$seq_name_with_classification}.=$1;
                  $seq_length += length($1);
              }
          }
        }
        close PDB_SEQ_FILE;

        $no_of_PDB_IDs=keys %PDB_ID;
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Writing PDBG file
        #__________________________________________________________________________
        open(PDBG, ">$out_pdbg_file");
            $num_of_all_superfam=@keys= sort keys %superfamily_groups;
            for($j=0; $j < @keys; $j++){
                $superfamily_member_count = $superfamily_member_count{$keys[$j]};
                $total_SF_size=$superfamily_size{$keys[$j]};
                $average_SF_size=int $total_SF_size/$superfamily_member_count;

                print PDBG "# $keys[$j] \$average_SF_size: $average_SF_size \$total_SF_size: $total_SF_size \$superfamily_member_count $superfamily_member_count\n";

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~`
                # Calculates the possible combination here    (X*(X-1))/2
                #_____________________________________________________________
                $possible_combination=$superfamily_member_count*($superfamily_member_count-1)/2;
                $all_possible_pair_combination +=$possible_combination;
                print "\n# \$possible_combination for $keys[$j] family is $possible_combination";

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # Following is to calculate the number of supfam members in each class
                #________________________________________________________________________
                if($keys[$j]=~/^((\d+)\.(\d+))\.\d+/){
                    $super_fam_num_in_class{$2}++;
                }

                if($keys[$j]=~/^1\./){  ## alfa class
                    $alpha_class+=$possible_combination;
                }elsif($keys[$j]=~/^2\./){  ## beta class
                    $beta_class+=$possible_combination;
                }elsif($keys[$j]=~/^3\./){  ## beta class
                    $alpha_and_beta_class+=$possible_combination;
                }elsif($keys[$j]=~/^4\./){  ## beta class
                    $alpha_plus_beta_class+=$possible_combination;
                }
                if($superfamily_member_count{$keys[$j]} < 2){
                      $num_of_singlets ++;   next; ## skipping singlets
                }else{
                      print PDBG $superfamily_groups{$keys[$j]}, "\n";
                      $group_num_counter++;
                }
          }
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Following for loop is to get numb of folds in each class
          #___________________________________________________________
          @keys= keys %fold_groups;
          for($j=0; $j < @keys; $j++){

          $fold_member_count = $fold_member_count{$keys[$j]};
          $possible_combination=$fold_member_count*($fold_member_count-1)/2;
          $all_possible_pair_combination +=$possible_combination;
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # Following is to calculate the number of supfam members in each class
          #________________________________________________________________________
          if($keys[$j]=~/^(\d+)\.\d+ *$/){
              $fold_num_in_class{$1}++;
          }
       }

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Writing %non_redundant_seqs making NEW fasta file from input fasta
       #____________________________________________________________________
       if($write_non_redundant_seq_file_version){
          &write_fasta(\%non_redundant_seqs, \$non_redundant_seq_fasta_outputfile);
       }

       my $num_of_seq_in_group=$all_seq_in_input_classification-$num_of_singlets;
       $all_possible_Ho_Nomolog_pairs=$all_seq_in_input_classification*($all_seq_in_input_classification-1)/2;
       $all_possible_Nomolog_pairs=$all_possible_Ho_Nomolog_pairs -$all_possible_pair_combination;

       print "\n# No of Groups                : $group_num_counter";
       print "\n# No of Superamilies          : $num_of_all_superfam";
       print "\n# No of All seq in the input  : $all_seq_in_input_classification";
       print "\n# No of All possible pairs    : $all_possible_Ho_Nomolog_pairs";
       print "\n# No of singlets              : $num_of_singlets";
       print "\n# No of seq in the $group_num_counter groups : $num_of_seq_in_group";
       print "\n# No of All pos Homolog combi : $all_possible_pair_combination";
       print "\n# No of All pos Nomolog combi : $all_possible_Nomolog_pairs";
       print "\n# No of poss alpha class combi: $alpha_class";
       print "\n# No of poss beta  class combi: $beta_class";
       print "\n# No of poss a/b   class combi: $alpha_and_beta_class";
       print "\n# No of poss a+b   class combi: $alpha_plus_beta_class";
       print "\n# No of PDB IDs : \$no_of_PDB_IDs => $no_of_PDB_IDs";
       print PDBG "\n# No of Groups                : $group_num_counter";
       print PDBG "\n# No of Superamilies          : $num_of_all_superfam";
       print PDBG "\n# No of All seq in the input  : $all_seq_in_input_classification";
       print PDBG "\n# No of singlets              : $num_of_singlets";
       print PDBG "\n# No of All possible pairs    : $all_possible_Ho_Nomolog_pairs";
       print PDBG "\n# No of seq in the $group_num_counter groups: $num_of_seq_in_group";
       print PDBG "\n# No of all poss. pair combi  : $all_possible_pair_combination\n";
       print PDBG "\n# No of All pos Nomolog combi : $all_possible_Nomolog_pairs";
       print PDBG "\n# No of poss alpha class combi: $alpha_class";
       print PDBG "\n# No of poss beta  class combi: $beta_class";
       print PDBG "\n# No of poss a/b   class combi: $alpha_and_beta_class";
       print PDBG "\n# No of poss a+b   class combi: $alpha_plus_beta_class";
       print PDBG "\n# No of PDB IDs : \$no_of_PDB_IDs => $no_of_PDB_IDs";
       @classes=keys %super_fam_num_in_class;
       for($j=0; $j< @classes; $j++){
          print "\n# No of superfam in  class $classes[$j]  : $super_fam_num_in_class{$classes[$j]}";
          print PDBG "\n# No of superfam in  class $classes[$j]  : $super_fam_num_in_class{$classes[$j]}";
       }
       #@classes=keys %fold_num_in_class;
       for($j=0; $j< @classes; $j++){
          print "\n# No of folds in     class $classes[$j]  : $fold_num_in_class{$classes[$j]}";
          print PDBG "\n# No of folds in     class $classes[$j]  : $fold_num_in_class{$classes[$j]}";
       }

       print  "\n# $out_pdbg_file has been written by $0\n\n";
       if($write_non_redundant_seq_file_version){
          print "\n# (i) $non_redundant_seq_fasta_outputfile is ALSO made\n";
       }else{
          print "\n# (i) write_pdbg_files: additional info: There was no redundancy in fasta file\n";
       }
       close(PDBG);
   }
   print "\n $base\_PDBD_bugs.list is created \n";
}





#__________________________________________________________________________
# Title     : write_mspa3_files
# Usage     : &write_mspa3_files(\@files);
# Function  : opens two files. Gx.mspa_1 and Gx.mspa_2 to create Gx.mspa3 file
#              you can set the mspa3 file extension by e= option,
#              for example, e=interm will make  G1.interm instead of G1.mspa3
#
# Example   : &write_mspa3_files(\@files);  # while @files has G*.pdbg
# Keywords  : make_mspa3_files, create_mspa3_files
# Options   :
#    $upper_expect_limit2= by u2=  # u2 is for mspa_2 files (eg, 0.0006)
#    $upper_expect_limit1= by u1=  # u1 is for mspa_1 files (eg, 0.081 )
#    $lower_expect_limit1= by l1=
#    $lower_expect_limit2= by l2=
#    R for NOT adding ranges in seq names.
#    e= for  extension name
#    n  for  no sort by columns in output
#    e  for  sorting columns by E values (first first and then second)
#    E  for  sorting columns by E values but reverse order
#
# Returns   : returns the names of mspa3 files
# Category  :
# Version   : 1.8
#----------------------------------------------------------------------------
sub write_mspa3_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my $upper_expect_limit1=5  ;
	my $upper_expect_limit2=5;   # default
	my $lower_expect_limit1=0  ;
	my $lower_expect_limit2=0;   # default
	my $mspa3_extension = 'mspa3'; # default
		my $no_sort='n' if $char_opt=~/n/;
		my ($sort_by_Evalue, $sort_by_Evalue_rv);

	if($vars{'u2'}=~/\S+/){ $upper_expect_limit2 = $vars{'u2'}      };
	if($vars{'u1'}=~/\S+/){ $upper_expect_limit1 = $vars{'u1'}      };
	if($vars{'l2'}=~/\S+/){ $lower_expect_limit2 = $vars{'l2'}      };
	if($vars{'l1'}=~/\S+/){ $lower_expect_limit1 = $vars{'l1'}      };
	if($vars{'e'} =~/\S+/){ $mspa3_extension      = $vars{'e'}       };
		if($char_opt=~/R/){     $Dont_add_range      = 'R'              }
		if($char_opt=~/e/){     $sort_by_Evalue      = 'e'              }
		if($char_opt=~/E/){     $sort_by_Evalue_rv   = 'E'              }

	for($i=0; $i< @file; $i++){
	   my ($base, $msp1,  $msp2, %msp2_hash, %final_hash, $j, $k, @mspa_2,
		  $msp2_match, $mspa3, $enq, $value1, @values, $evalue, $score,
		  $size_of_mspa3_file);

	   $base=${&get_base_names($file[$i])};

	   if(-s "$base\.mspa_1"){
		  $msp1="$base\.mspa_1";
	   }elsif( -s "./MSP_1/$base\.mspa_1"){
		  $msp1="./MSP_1/$base\.mspa_1";
	   }elsif( -s "../$base\.mspa_1"){ ## when xxxx.mspa_1 files are in up dir
		  $msp1="../$base\.mspa_1";
	   }
	   if(-s "$base\.mspa_2"){
		  $msp2="$base\.mspa_2";
	   }elsif( -s "./MSP_2/$base\.mspa_2"){
		  $msp2="./MSP_2/$base\.mspa_2";
	   }elsif( -s "../$base\.mspa_2"){   ## when xxxx.mspa_2 files are in up dir
	      $msp2="../$base\.mspa_2";
	   }

	   $mspa3="$base\.$mspa3_extension"; #<--- Exension addition

	   print "\n# $msp1 and $msp2 and $mspa3\n";
			 open(MSP1, "$msp1") || open(MSP1, "./MSP_1/$msp1") || open(MSP1, "../$msp1");
	   open(MSP2, "$msp2") || open(MSP2, "./MSP_2/$msp2") || open(MSP2, "../$msp2");

	   print "\n# I am opening $msp2\n";
	   while(<MSP2>){
					 if( /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
							 $enq="$6";   $evalue=$2;    $score=$1;   $seq_id=$3;
							 $match_seq=$9; $m_start=$7; $m_stop=$8;

					 }elsif(/^\s*(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/ ){ ## OLD format
							 $enq="$5";   $evalue=$2;    $score=$1;
							 $match_seq=$8; $m_start=$6; $m_stop=$7;
					 }else{ next }

					 if($evalue > $upper_expect_limit2 or $evalue < $lower_expect_limit2){ next ; }

					 if($Dont_add_range=~/R/){    $msp2_match="$match_seq";
					 }else{                       $msp2_match="$match_seq\_$m_start\-$m_stop";           }

					 $header1=sprintf ("%-30s %-4s %-10s %-5s %-30s", '#Query', 'Scor','Evalue','ID', 'Matched');
					 $value1 =sprintf("%-30s %-4s %-10s %-5s %-30s\n", $enq, $score, $evalue, $seq_id, $msp2_match);
					 $msp2_hash{$enq} .="$value1";
	   }

	   print scalar keys %msp2_hash,
	         "<- Num of interm. in msp2.  Evalue cut \$upper_expect_limit2: $upper_expect_limit2 \n";

	   print "\n# I am opening $msp1\n";
	   while(<MSP1>){
					if( /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
							$range_start1=$4;              $range_stop1 =$5;
							$range_start2=$7;              $range_stop2 =$8;
							$match=$9;              $enq=$6;
							$evalue=$2;             $seq_id=$3;              $score=$1;
		  }elsif(/^\s*(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)/){
							$range_start1=$3;              $range_stop1 =$4;
							$range_start2=$6;              $range_stop2 =$7;
							$match=$8;              $enq=$5;
							$evalue=$2;             $score=$1;
					}else{ next };

					if($evalue >  $upper_expect_limit1  or  $evalue <  $lower_expect_limit1){ next ; }

					if($enq=~/\S+\_\d+\-\d+/){
					}else{              $enq="$enq\_$range_start1\-$range_stop1";           }

					if($Dont_add_range=~/R/){     $msp2_match="$match";
					}else{
							unless($match =~/\S+\_\d+\-\d+/){   $msp2_match="$match\_$range_start2\-$range_stop2";
							}else{                              $msp2_match=$match;          }
					}

					@mspa_2=split(/\n/, $msp2_hash{$msp2_match});

					for($j=0; $j < @mspa_2; $j++){
							$value1=sprintf("%-30s %-4s %-10s %-5s %-30s", $enq, $score, $evalue, $seq_id, $mspa_2[$j]);
							$final_hash{"$mspa_2[$j]"}="$value1";
					}
	   }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			 # Writing down the resultant mspa3 file
			 #__________________________________________
	   open(MSP3, ">$mspa3");

			 $header2=sprintf ("%-30s %-4s %-10s %-5s %-30s\n", '#Query', 'Scor','Evalue','ID', $header1);
			 print MSP3 $header2;

	   @values= values %final_hash;
	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	   # following sorts by the first column name, 4th colomn name, 2 column E value etc
	   #___________________________________________________________________________
	   unless($no_sort){
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 #  sorting by E value
					 #______________________________________
	       if($sort_by_Evalue){
	           print "\n# $0: sorting by Evalues \n";
							 @values= map {$_->[0]} sort { $a->[1] <=> $b->[1] or $a->[2] <=> $b->[2] }
												 map { ($_=~/^\s*\S+_\d*\-?\d*\s+\d+\s+(\S+)\s+\S*\s*\S+\s+\d+\s+(\S+)\s+\S*\s*\S+_\d*\-?\d*/); [$_,$1,$2] } @values;
					 }elsif($sort_by_Evalue_rv){
	           print "\n# $0: sorting by Evalues BIG first \n";
							 @values= map {$_->[0]} sort { $a->[1] <=> $b->[1] or $a->[2] <=> $b->[2] }
												 map { ($_=~/^\s*\S+_\d*\-?\d*\s+\d+\s+(\S+)\s+\S*\s*\S+\s+\d+\s+(\S+)\s+\S*\s*\S+_\d*\-?\d*/); [$_,$1,$2] } @values;
					 }
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 #  sorting by names
					 #_______________________________________
					 else{
	           @values= map {$_->[0]} sort { $a->[1] cmp $b->[1] or $a->[4] cmp $b->[4] or $a->[2] <=> $b->[2] or $a->[3] <=> $b->[3]}
		             map { ($_=~/^(\S+)_\d+\-\d+\s+\d+\s+(\S+)\s+\S*\s*\S+\s+\d+\s+(\S+)\s+\S*\s*(\S+)_\d+\-\d+/); [$_,$1,$2,$3,$4] } @values;
					 }
	   }

	   for($k=0; $k< @values; $k++){	  print MSP3  "\n$values[$k]"; 	   }
	   print MSP3 "\n";
	   close MSP3;
	   $size_of_mspa3_file=-s $mspa3;
	   if($size_of_mspa3_file > 50){ print "\n# size of $mspa3 is: $size_of_mspa3_file, SUCCESS?\n"; }
	   push(@mspa3_file_names, $mspa3);
	}
	if(@mspa3_file_names > 1){
	   return(\@mspa3_file_names);
	}else{
	   return($mspa3_file_names[0]);
	}
}


#________________________________________________________________________________
# Title     : write_parf_files
# Usage     : @file_out=@{&write_parf_files(@files, "m=$MSP_file", "g=$PDBG_file",
#                "d=$PDBD_file", $pdbd_seq_only, $pdb95d_2092_seq,
#                 $use_eval_but_show_raw_score, $use_raw_score)};
# Function  : takes xxxx.msp files and writes xxxx.parf file PARF file is
#             for performance assessment with ranking.
# Example   :
# Keywords  : write_parf
# Options   :
#  $pdbd_file_seq_only=d  by d -d
#  $sam_571_seq_only=571  by 571 -571
#  $pdb95d_2092_seq =2092 by 2092 -2092
#  $ISS_2nd_Eval_factor=  by E= ## "E=$eval" usually 191 or 150
#  $Eval_thresh=  by e=         ## this is the Evalue cutoff
#  $PDB40D_935_FASTA= 935 by 935
#  $use_raw_score=r
#  $REV_seq_control=R   # this is to abandon the PSI search if Reverse sequence is used in PROFILE building
#  $MSP_file= by m=
#  $NO_Adjustment_in_homology=A by A ## this disables the special family homology adj.
#  $Fold_level_homology=F by F
#  $PDBG_file= by g=            # PDBG file is PDB Grouping file
#  $use_eval_but_show_raw_score=e by e -e  ## eval order but only raw score is shown.
#                                            This is to make a special graph
#                                           requested by David Haussler
# Version   : 3.0
#--------------------------------------------------------------------------------
sub write_parf_files{
        #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
        my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
        my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
        my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
        my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
        my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
        if($debug==1){print "\n\t\@hash=\"@hash\"
        \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
        \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
        #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
        my (%fix_hash, %pdb, $pdbd_seq_only, $sam_571_seq_only, %hash_classification,
            %hash_super,  $pdb95d_2092_seq, @final_parf_files, %hash_super_fam_pairs,
            $PDB40D_935_FASTA, $use_raw_score, %hash_raw_score, @sorted_name,
            $use_eval_but_show_raw_score, $PDBG_file, $MSP_file, $PDBD_file, $ISL_classif,
            $NO_Adjustment_in_homology, $Fold_level_homology, $REV_seq_control,
            $Eval_thresh, %REV_seq_controlled_pairs, @rev_controlled_pairs);
        my $ISS_2nd_Eval_factor=191; ## for ISS only
        $Eval_thresh=0.0005; ## the default;

        print "\n# write_parf_files: \$char_opt is $char_opt\n\n";
        if($char_opt=~/r/){       $use_raw_score='r';
            print "\n# (W) You put r opt, so I will use RAW score than Evalue for PARF file\n\n";
        }
        if($char_opt=~/e/){       $use_eval_but_show_raw_score='e'; $use_raw_score='';
            print "\n# (W) You put e opt, so I will use Eval but show score for PARF file\n\n";
        }
        if($char_opt=~/R/){       $REV_seq_control='R'; }
        if($char_opt=~/A/){       $NO_Adjustment_in_homology='A'; }
        if($char_opt=~/F/){       $Fold_level_homology='F'; }
        if($vars{'m'}=~/(\S+)/){      $MSP_file=$1; @file=($MSP_file);  } ## one big MSP file??
        if($vars{'g'}=~/(\S+)/){      $PDBG_file=$1  }
        if($vars{'d'}=~/(\S+)/){      $PDBD_file=$1  }
        if($vars{'e'}=~/\S+/){        $Eval_thresh=$vars{'e'} }
        if($vars{'E'}=~/\d+/){        $ISS_2nd_Eval_factor=$vars{'E'}
        }elsif($char_opt=~/d/){       $pdbd_seq_only='d';
        }elsif($char_opt=~/571/){     $sam_571_seq_only=571;
        }elsif($char_opt=~/2092/){    $pdb95d_2092_seq=2092;
        }elsif($char_opt=~/935/){     $PDB40D_935_FASTA=935 }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # gettting correcting_pairs from  \&get_scop_correcting_pairs, \%fix_hash made!\n";
        #______________________________________________________________________________________________
        %fix_hash=%{&get_scop_correcting_pairs()};

        if(@file < 1){ print "\n\n\n# \@file is empty, something is wrong, Do your input files in PWD?\n\n\n\n"; exit }

        @file=@{&check_input_file_extension('msp', \@file)};

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # getting to attach classification";
        #___________________________________
        if(-s $PDBG_file){
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # openning PDBG file ";
            #___________________________________
            if(-s $PDBG_file){
                 open(PDBG, "$PDBG_file") || die "\n Can not open $PDBG_file\n";
                 while(<PDBG>){
                      if(/\>(\S+)[\_\d+\-\d+]* +(((\d+)\.\d+)\.\d+)/){
                           if($3 == 8 or $3 == 9){
                                print "\n# $0: Warning write_parf_files sub, superfamily $3 is NOT used\n";
                           }
                           $pdb{$1}=$2;
                           $hash_fold{$1}=$3;
                           $hash_classification{$1}=$2;
                           $hash_super{$1}=$2;
                      }
                 }
                 close(PDBG);
                 print "\n# $pdb{$1}\n";
            }
        }elsif(-s $PDBD_file){
            print "\n# write_parf_files is trying to attach SCOP class to hash var by using $PDBD_file\n\n";
            open(PDBD, $PDBD_file);
            while(<PDBD>){
                if(/\>(\S+)[\_\d+\-\d+]* +(((\d+\.\d+)\.\d+)\.\d+\.\d+)\s*/){
                     $pdb{$1}=$3;
                     $hash_fold{$1}=$4;
                     $hash_classification{$1}=$2;
                     $hash_super{$1}=$3;
                }
            }
            close(PDBD);
        }elsif(-s $ENV{'PDB40D_FASTA'}){
            print "\n# USING ENV $PDB40D_FASTA, trying to attach SCOP class to hash var by using $PDBD_file\n\n";
            print chr(7);
            open(PDBD, $ENV{'PDB40D_FASTA'});
            while(<PDBD>){
                if(/\>(\S+)[\_\d+\-\d+]* +(((\d+\.\d+)\.\d+)\.\d+\.\d+)\s*/){
                     $pdb{$1}=$3;
                     $hash_fold{$1}=$4;
                     $hash_classification{$1}=$2;
                     $hash_super{$1}=$3;
                }
            }
            close(PDBD);
        }else{  print "\n# $0: Can't find \$PDBD_file $PDBD_file, set the ENV var to point it\n";
            exit;
        }
        if($Fold_level_homology){
             %pdb=%hash_fold; ## replacing %pdb with Fold level ( '3.1'  rather than '3.1.5')
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # processing \"@file\" \n"; THSE are MSP files
        #___________________________________________________
        FOR_1: for($i=0; $i< @file; $i++){
                my(%hash, $homol, $pair, $File, $base, $PDBG_file, $pdb40d_old,
                     $sorted_name, $factor, $PDBD_file, $evalue, $evalue2,
                     $evalue1, $answer_char, $outfile, %bad_intermediates);
                $File=$file[$i];
                $base=${&get_base_names($File)};

                open(BAD_ISL_SEQ_MSP, ">BAD\_$File") || die "\n# Can not open BAD\_$File\n";
                open(BAD_ISL_SEQ, ">BAD\_$base\.txt") || die "\n# Can not open BAD\_$base\.txt\n";

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # opening the input  MSP file $File \n";
                #____________________________________________
                if($File=~/\S\.gz$/){ system("gunzip -c $File") } ## Just in case it is compressed
                open(MSP_FILE, "$File") || die "\nCan not open $File, Error!!\n";
                while(<MSP_FILE>){
                     my($intermediate_seq, $homol, $raw_score, @sorted_name, $sorted_name, $query, $match, $evalue, $ISL_classif);
                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # (1) For handling FASTA search output(NORMAL MSP output style, I mean.  LYG_ANSAN_1-182_d153l___4.2.1_1-179    1
                     #__________________________________________________________________________
                     if( /^\s*(\S+)\s+(\S+)\s+\S*\s*\d+\s+\d+\s+(\S+)\s+\d+\s+\d+\s+(\S+_\d+\-\d+_(\S+)_((\d+\.\d+)\.\d+))/){ ## to match ISL search  nr_RIP3_SAPOF_1-220_d1mrj___4.102.1_42-198
                          ($raw_score, $evalue, $query, $intermediate_seq, $match, $ISL_classif, $Fold_classif)=($1,$2, $3, $4, $5, $6, $7);
                          if($Fold_level_homology){  $ISL_classif=$Fold_classif; }
                          $ISL_classif{$match}=$ISL_classif;
                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # $REV_seq_control (R) is to discard the whole PSI search if REV. seq is incorporated in the PROFILE calc
                          #___________________________________________________________________________________________________________
                          if($REV_seq_control and $match=~/\S\_r[e]?v\_/i and $evalue < $Eval_thresh){
                               #print "\n \$REV_seq_control option is set to $REV_seq_control and there was Rev. seq. for Query: $query\n\n";
                               @sorted_name= sort($query, $match);
                               $sorted_name= join(' ', @sorted_name );
                               $REV_seq_controlled_pairs{$query}=$sorted_name;
                          }
                          if($pdbd_seq_only and ($query !~/^[cde][s\d]/ or $match !~/^[cde][s\d]/) ){ next };
                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # (2)
                     #________________________________________________
                     }elsif(/^\s*(\S+)\s+(\S+)\s+\S*\s*\d+\s+\d+\s+(\S+)\s+\d+\s+\d+\s+(\S+)\s*\d*/){ ## This is a direct PDB40D vs PDB40D etc
                          ($raw_score, $evalue, $query, $match)=($1,$2, $3, $4);
                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # $REV_seq_control (R) is to discard the whole PSI search if REV. seq is incorporated in the PROFILE calc
                          #___________________________________________________________________________________________________________
                          if($REV_seq_control and $match=~/\S\_r[e]?v/i and $evalue < $Eval_thresh){
                               #print "\n \$REV_seq_control option is set to $REV_seq_control and there was Rev. seq. for Query: $query\n\n";
                               @sorted_name= sort($query, $match);
                               $sorted_name= join(' ', @sorted_name );
                               $REV_seq_controlled_pairs{$query}=$sorted_name;
                          }
                          if($pdbd_seq_only and ($query !~/^[cde][s\d]/ or $match !~/^[cde][s\d]/) ){ next };
                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # (3) For handling ISS search output";
                     #________________________________________________
                     }elsif(/^\s*(\S+)_\d+\-\d+_(\d+\.\d+\.\d+)\S+\s+\d+\s+(\S+)\s+(\womolog)\s+\S+\s+\d+\s+(\S+)\s+(\S+)_\d+\-\d+_(\d+\.\d+\.\d+)\S+/){
                          $query=$1; $evalue1=$3; $homol=$4; $evalue2=$5; $match=$6;
                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # $REV_seq_control (R) is to discard the whole PSI search if REV. seq is incorporated in the PROFILE calc
                          #___________________________________________________________________________________________________________
                          if($REV_seq_control and $match=~/\S\_r[e]?v/i and $evalue < $Eval_thresh){
                               #print "\n \$REV_seq_control option is set to $REV_seq_control and there was Rev. seq. for Query: $query\n\n";
                               @sorted_name= sort($query, $match);
                               $sorted_name= join(' ', @sorted_name );
                               $REV_seq_controlled_pairs{$query}=$sorted_name;
                          }

                          if($pdbd_seq_only and ($query !~/^[cde][s\d]/ or $match !~/^[cde][s\d]/) ){ next };
                          @sorted_name= sort($query, $match);
                          $sorted_name= join(' ', @sorted_name );
                          if($fix_hash{$sorted_name}){  $homol='Homolog' }; ## correction.
                          $sum_eval=($evalue1+($evalue2*$ISS_2nd_Eval_factor));  ## just the sum
                          $pair=sprintf("%-20s %-7s", $sorted_name, $homol);
                          $hash{$pair}=$sum_eval;
                          if($hash_classification{$sorted_name[0]} and $hash_classification{$sorted_name[1]}){
                               $hash_super_fam_pairs{$pair}=
                               sprintf("%-15s %-15s", $hash_classification{$sorted_name[0]},  $hash_classification{$sorted_name[1]});
                          }else{
                               delete($hash{$pair});
                               print "\n# write_parf_files: classifctn info for \"$pair\" is missing, SKIPPING this line !!";
                          }

                     }else{ next }

                     if($pdbd_seq_only and ($query !~/^[cde][s\d]/ or $match !~/^[cde][s\d]/) ){ ## to match d1dkga1 or ds055_
                          print "\n(E) NO pdbd \$query :$query,  \$match :$match, I need like: d1dkga1 or ds055_\n";
                          print "(E) This could be due to truncated blastp output. \$pdbd_seq_only was $pdbd_seq_only\n"; next };
                     if($query=~/^(\S+)_\d+\.\d+\.\d+/){    $query=$1;      }
                     if($match=~/^(\S+)_\d+\.\d+\.\d+/){    $match=$1;      }
                     if($query=~/^(\S+)_\d+\-\d+/){    $query=$1;      }
                     if($match=~/^(\S+)_\d+\-\d+/){    $match=$1;      }

                     if($query eq $match){ next }
                     @sorted_name= sort($query, $match);
                     $sorted_name= join(' ', @sorted_name );

                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # This is critical part for checking identity.
                     # The first condition $pdb{$query} is necessary, as singlets will not ahve any
                     # classification, so it will be NULL. NULL and NULL are equal, resulting in Homolog, which is incorrect
                     #________________________________________________________________________________

                     if( ($pdb{$query} and  ($pdb{$query} eq $pdb{$match}) ) or $fix_hash{$sorted_name}=~/\S/ ){
                          $homol='Homolog';
                     }else{
                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # Checks if Adjustment is wanted or not. If not, anything notmatched to be equal will be Nomolog
                          #________________________________________________________________________________________________
                          if($NO_Adjustment_in_homology){
                              $homol='Nomolog';
                          }else{
                               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                               # Folling is to fix the prblem in 1.38 SCOP families of 3.1.5, 7, 8, 11, 11/Jan99, 3.4.1, 3.21.1 and 3.22.1
                               #________________________________________________________________________
                               if( ($pdb{$query} =~/^3\.1\.[578]$/ and $pdb{$match} =~/^3\.1\.[578]$/) or
                                    ($pdb{$query} =~/^3\.1\.1[01]$/ and $pdb{$match} =~/^3\.1\.[578]$/)    or
                                    ($pdb{$query} =~/^3\.1\.[578]$/ and $pdb{$match} =~/^3\.1\.1[01]$/)){
                                        $homol='Homolog';
                               }elsif( ($pdb{$query} =~/^3\.2[12]\.1$/ and $pdb{$match} =~/^3\.2[12]\.1$/) or
                                    ($pdb{$query} =~/^3\.4\.1$/ and $pdb{$match} =~/^3\.2[12]\.1$/)  or
                                    ($pdb{$query} =~/3\.2[12]\.1$/ and $pdb{$match} =~/^3\.4\.1$/) ){
                                        $homol='Homolog';
                               }elsif($pdb{$query} =~/^2\.62\./ and $pdb{$match} =~/^2\.62\./){
                                    $homol='Homolog';
                               }elsif($pdb{$query} =~/^1\.81\.[23]$/ and $pdb{$match} =~/^1\.81\.[23]$/){
                                    $homol='Homolog';
                               }elsif($pdb{$query} =~/^2\.5[12]\./ and $pdb{$match} =~/^2\.5[12]\./){
                                    $homol='Nomolog';   $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                               }elsif($pdb{$query} =~/^2\.21\./ and $pdb{$match} =~/^2\.62\./){
                                    $homol='Nomolog';   $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                               }elsif($pdb{$query} =~/^2\.62\./ and $pdb{$match} =~/^2\.21\./){
                                    $homol='Nomolog';   $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                               }elsif($pdb{$query} =~/^2\.62\./ and $pdb{$match} =~/^3\.33\./){
                                    $homol='Nomolog';   $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                               }elsif($pdb{$query} =~/^3\.33\./ and $pdb{$match} =~/^2\.62\./){
                                    $homol='Nomolog';   $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                               # These are removed from ISL due to error
                               #_____________________________________________
                               }elsif($pdb{$query} =~/^3\.22\.1$/ and $pdb{$match} =~/^3\.66\.1$/){
                                    $homol='Nomolog'; $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                                    next;
                               }elsif($pdb{$query} =~/^3\.66\.1$/ and $pdb{$match} =~/^3\.22\.1$/){
                                    $homol='Nomolog'; $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                                    next;
                               }else{
                                    if($hash_fold{$query} =~/^\d+\.\d+$/ and ($hash_fold{$query} eq $hash_fold{$match} )){
                                            $homol='Fomolog'; ## fold level homologues
                                    }else{
                                            $homol='Nomolog'; $bad_intermediates{"$intermediate_seq"}=$intermediate_seq;
                                    }
                               }
                          }
                     }

                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # Noting WRONG ISL sequences
                     #_______________________________________________
                     if( ($pdb{$query} and $pdb{$match} and $ISL_classif) and ($pdb{$match} ne $ISL_classif) ){
                          print "(ERROR) bad_isl_seq_list.msp ->$File: PDB classif of $match, $pdb{$query} isN'T same as interm seq classif $ISL_classif, BadISS assignment?\n$_\n";
                          print "\nBAD ISL seq, writing in MSP file";
                          print BAD_ISL_SEQ_MSP $_;
                     }

                     $pair=sprintf("%-20s %-7s", $sorted_name, $homol);
                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # If we choose RAW score than Evalue, by $use_raw_score (r) opt
                     #___________________________________________________________
                     if($use_raw_score){
                          if(!$hash{$pair} or $hash{$pair} < $raw_score){
                                $hash{$pair}=$raw_score;
                                if($hash_classification{$sorted_name[0]} and $hash_classification{$sorted_name[1]}){
                                        $hash_super_fam_pairs{$pair}=
                                                sprintf("%-15s %-15s", $hash_classification{$sorted_name[0]},  $hash_classification{$sorted_name[1]});
                                }else{
                                        delete($hash{$pair}); ## removing the entry from the hash completely
                                        #print "\n# write_parf_files: classifctn info for \"$pair\" is missing, SKIPPING this line !!";
                                }
                          }
                     }else{
                          if(!$hash{$pair} or $hash{$pair} > $evalue){
                                $hash{$pair}=$evalue;   $hash_raw_score{$pair}=$raw_score; # just storing
                                if($hash_classification{$sorted_name[0]} and $hash_classification{$sorted_name[1]}){
                                        $hash_super_fam_pairs{$pair}=
                                                sprintf("%-15s %-15s", $hash_classification{$sorted_name[0]},  $hash_classification{$sorted_name[1]});
                                }else{
                                        delete($hash{$pair}); ## removing the entry from the hash completely
                                        #print "\n# write_parf_files: classifctn info for \"$pair\" is missing, SKIPPING this line !!";
                                }
                          }
                     }

                }


                @keys=%hash;
                if($use_raw_score){
                        @sorted=  sort { $hash{$b} <=> $hash{$a} }  @keys;
                }else{
                        @sorted=  sort { $hash{$a} <=> $hash{$b} }  @keys;
                }

                if($use_eval_but_show_raw_score){
                        $outfile="e_opt\_$base\_$NO_Adjustment_in_homology\_$Fold_level_homology\.parf";
                }elsif($use_raw_score){
                        $outfile="r_opt\_$base\_$NO_Adjustment_in_homology\_$Fold_level_homology\.parf";
                }else{
                        $outfile="$base\_$NO_Adjustment_in_homology\_$Fold_level_homology\.parf";
                }
                if(@keys > 1 ){
                         open(RANKED, ">$outfile");
                }else{
                         print "\n\n\n# (E) write_parf_files: The seq pair entry number is too small( <2), I think something went wrong\n\n\n";
                         next;
                }

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # sorted by Eval but the result score is raw score
                #__________________________________________________
                if($use_eval_but_show_raw_score){
                   for($j=0; $j< @sorted; $j++){
                        if($sorted[$j]=~/\S+\s+\S+\s+\S+/){
                            printf RANKED ("%-28s %-22s %-30s\n", $sorted[$j], $hash_raw_score{$sorted[$j]},
                                                                  $hash_super_fam_pairs{$sorted[$j]} );
                        }
                   }
                }else{
                   for($j=0; $j< @sorted; $j++){
                       if($sorted[$j]=~/\S+\s+\S+\s+\S+/){
                            printf RANKED ("%-28s %-22s %-30s\n", $sorted[$j], $hash{$sorted[$j]},
                                                                 $hash_super_fam_pairs{$sorted[$j]} );
                       }
                   }
                }
                %hash_raw_score=%hash=();
                close (RANKED);
                close ( MSP_FILE );
                if(-s $outfile){
                    push(@final_parf_files, $outfile);
                    if(-d $ENV{'haussler'} ){
                         $target_direc=$ENV{'haussler'};
                         print "\n# $target_direc is found !!, You must be JONG Park, or Are you Sarah??\n";
                         print "\n# write_rdif_files : As you have haussler dir, I copy $outfile to it\n\n";
                         system("cp $outfile $target_direc");
                    }
                }else{
                    print "\n\n\n\n# write_parf_files: \$outfile is not big, ERROR???\n\n\n\n";
                }

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # writing bad ISL seq alone NOT in MSP file
                #_____________________________________________
                @bad_isl_seqs=keys %bad_intermediates;
                for($b=0; $b< @bad_isl_seqs; $b++){
                    print BAD_ISL_SEQ "$bad_isl_seqs[$b]\n";
                }
                close BAD_ISL_SEQ;
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # Writing REV. seq. controlled pair file output
                #__________________________________________________
                if($REV_seq_control){
                    open(REV_CONTROLLED_PAIRS, ">$base\_REV_seq_filtered\.txt") || die $@;
                    @rev_controlled_pairs=keys %REV_seq_controlled_pairs;
                    for($i=0; $i< @rev_controlled_pairs; $i++){
                        print REV_CONTROLLED_PAIRS "$rev_controlled_pairs[$i] $REV_seq_controlled_pairs{$rev_controlled_pairs[$i]}\n";
                    }
                    close(REV_CONTROLLED_PAIRS);
                }
        }
        close(BAD_ISL_SEQ_MSP);
        return(\@final_parf_files);
}





#________________________________________________________________________________
# Title     : write_mprf_files
# Usage     : &write_mprf_files(@files);
# Function  :
# Example   :
# Keywords  : mean_position_rank_file, mean_rank_position_file
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub write_mprf_files{
		my (@final_out_file_names, $count, $homo, $pair, %first_parf_class,
				%second_parf_class, %homology1, %homology2, %nomolog_count2,
				%homolog_count2, @keys_Ho, $base1, $base2, %all_count, $i, $j,
				$answer, $diff, $av, $sum_found_rank_diff_Nomolog,
				$sum_found_rank_diff_Homolog, $count_found_rank_diff_Nomolog,
				$count_found_rank_diff_Homolog, $do_not_show_missing_diff,
				$mean_position_in_rank);

		for($i=0; $i< @_; $i++){
				if($_[$i] !~/\.parf$/){
						print "\n# write_mprf_files needs PARF file, not NHCO or others \n";
						print "     Shall I continue? Press y to continue\n>>>>";
						$answer=getc;
						if($answer eq 'y'){
								last;
						}else{
								die;
						}
				}elsif($_[$i]=~/^[\-]?n/i){
						$do_not_show_missing_diff='n';
				}
		}
		open(F1, "$_[0]");
		open(F2, "$_[1]");
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the first file
		#_______________________________________
		while(<F1>){
				if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
						$count++;
						$homo=$3;
						$pair=join(' ', sort($1, $2));
						$first_parf_class{$pair}=sprintf("%-13s %-13s", $5, $6);
						if($homo eq 'Nomolog'){
								$nomolog_count1{$pair}=$count;
						}else{
								$homolog_count1{$pair}=$count;
						}
						$all_count{$pair}=$count;
						$homology1{$pair}=$homo;
						if($count > 10000){ last }
				}
		}
		close(F1);
		$count=0;
		$pair='';

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the 2nd file
		#_______________________________________
		while(<F2>){
			 if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
					$homo=$3;
					$count++;
					$pair=join(' ', sort($1, $2));
					$second_parf_class{$pair}=sprintf("%-13s %-13s", $5, $6);
					if($homo eq 'Nomolog'){
							$nomolog_count2{$pair}=$count;
					}else{
							$homolog_count2{$pair}=$count;
					}
					$homology2{$pair}=$homo;
					if($count > 10000){ last }
			 }
		}
		close(F2);
		$count=0;


		#================================================================================================

		@keys_Ho=sort { $all_count{$a}<=> $all_count{$b}} (keys %all_count);

		$base1=${&get_base_names($_[0])};
		$base2=${&get_base_names($_[1])};

		$out_mprf_file="$base1\_vs\_$base2\.mprf";
		$out_mprf_file_sorted="$base1\_vs\_$base2\_sorted\.mprf";
		#$out_mprf_file_Nomol="$base1\_vs\_$base2\_Nomol.mprf";

		push(@final_out_file_names, $out_mprf_file, $out_mprf_file_Nomol);

		open(MPRF_FILE, ">$out_mprf_file") or die "\n#  dying \n";
 #   open(RDIF_FILE_NO, ">$out_mprf_file_Nomol") or die "\n#  dying \n";


		for($i=0; $i< @keys_Ho; $i++){
					$count=$i+1;
					if($homolog_count1{$keys_Ho[$i]}=~/\S/){
							if($homolog_count2{$keys_Ho[$i]}!~/\S/ ){
									$diff=-5000;
									if($do_not_show_missing_diff){
											$av = 0;
									}else{
											#$av = -5000;

											if($count < 300){
													$av = $homolog_count1{$keys_Ho[$i]}*0.8;   # when occurred in one place, get the poisition
											}elsif($count < 600){
													$av = $homolog_count1{$keys_Ho[$i]}*1.0;   # when occurred in one place, get the poisition
											}elsif($count < 1000){
													$av = $homolog_count1{$keys_Ho[$i]}*1.5;
											}elsif($count >= 1000){
													$av = $homolog_count1{$keys_Ho[$i]}*2;
											}
											$mean_position_in_rank=$av;

											print "\n# HOmolog: $keys_Ho[$i] occurred singly at $count with \$av $av";
									}
									if($show_missing){
											print "\n# $count $keys_Ho[$i] is missing in $first_parf_class{$keys_Ho[$i]} $base2. But in $base1";
									}
							}else{
									$diff= abs($homolog_count1{$keys_Ho[$i]} - $homolog_count2{$keys_Ho[$i]}) ;
									$av= ($homolog_count1{$keys_Ho[$i]} + $homolog_count2{$keys_Ho[$i]} )/2 ;
									$mean_position_in_rank=$av;
									$sum_found_rank_diff_Homolog+=$diff;
									$count_found_rank_diff_Homolog++;
							}
							printf MPRF_FILE ("%-20s %-7s %-10s %-16s\n", $keys_Ho[$i], 'Homolog',
												$mean_position_in_rank, $first_parf_class{$keys_Ho[$i]});
							#printf RDIF_FILE_NO ("%-6s %-6s %-6s\n", $count,  0,  $diff);
							next;
					}elsif($nomolog_count1{$keys_Ho[$i]}=~/\S/){
							if($nomolog_count2{$keys_Ho[$i]}!~/\S/){
									$diff=5000;
									if($do_not_show_missing_diff){
											$av = 0;
									}else{
											#$av = 5000;
											if($count < 300){
													 $av = $nomolog_count1{$keys_Ho[$i]}*0.8;
											}elsif($count < 600){
													 $av = $nomolog_count1{$keys_Ho[$i]}*1.0;
											}elsif($count < 1000){
													 $av = $nomolog_count1{$keys_Ho[$i]}*1.5; # when occurred in one place, get the poisition
											}elsif($count >= 1000){
													 $av = $nomolog_count1{$keys_Ho[$i]}*2.0;
											}
											$mean_position_in_rank=$av;
											print "\n# NOmolog: $keys_Ho[$i] occurred singly at $count with \$av $av\n";
									}
							}else{
									$diff= abs($nomolog_count2{$keys_Ho[$i]} - $nomolog_count1{$keys_Ho[$i]}) ;
									$av = ($nomolog_count2{$keys_Ho[$i]} + $nomolog_count1{$keys_Ho[$i]})/2 ;
									$sum_found_rank_diff_Nomolog+= $diff;
									$mean_position_in_rank=$av;
									$count_found_rank_diff_Nomolog++;
							}
							printf MPRF_FILE ("%-20s %-7s %-10s %-16s\n", $keys_Ho[$i],  'Nomolog',
																					$mean_position_in_rank, $first_parf_class{$keys_Ho[$i]});

							#printf RDIF_FILE_NO ("%-6s %-6s %-6s\n", $count,  0,  $diff);
					}
		}
		$av_found_rank_diff_Homolog=int($sum_found_rank_diff_Homolog/$count_found_rank_diff_Homolog);
		$av_found_rank_diff_Nomolog=int($sum_found_rank_diff_Nomolog/$count_found_rank_diff_Nomolog);

		print MPRF_FILE "\n# Abs \$sum_found_rank_diff_Homolog is $sum_found_rank_diff_Homolog with $count_found_rank_diff_Homolog pairs\n";
		print MPRF_FILE "\n# Abs Av is: $av_found_rank_diff_Homolog\n";

		close(MPRF_FILE);
		system("sort_by_column.pl $out_mprf_file 4 > $out_mprf_file_sorted");
		system("write_nhco_files.pl $out_mprf_file_sorted");
		print "\n# $0 has made \"$out_mprf_file\" and $out_mprf_file_sorted \"$out_mprf_file_Nomol\" file in pwd\n\n";
		return(\@final_out_file_names);
}


#________________________________________________________________________________
# Title     : write_evss_files
# Usage     : @files_produced=@{write_evss_files(\@files)};
# Function  : This produces EVSS file(Error VS Score) from PARF file
# Example   :
# Keywords  : get_score_vs_error_from_parf_files.pl
# Options   :
#  d=$query_number    for dividing the errors by all the query number
#   $negate_score=n by n -n  # to make sign change for PSI scores
#   $error_per_query=q by q -q # divide the error by query number
#   $log_of_errors=l by l -l
#   $log_of_evalue_or_score=e by e -e
#   $get_log_base_10=t by t -t
#
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------------------
sub write_evss_files{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my($base, $score, $out_evss_file, @final_out_files, $query_number,
				$negate_score, $error_div_by_query_number, $error_per_query,
				$log_of_errors, $log_of_evalue_or_score, $get_log_base_10,
				@error_count, $log_of_error_count);
		 $query_number=1; ## default NO query number consideration (wrong!!)

		 if($vars{'d'}=~/\S+/){ $query_number=$vars{'d'} }
		 if($char_opt=~/n/){ $negate_score='n' };
		 if($char_opt=~/q/){ $error_per_query='q' };
		 if($char_opt=~/l/){ $log_of_errors='l' };
		 if($char_opt=~/L/){ $log_of_evalue_or_score='L' };
		 if($char_opt=~/t/){ $get_log_base_10='t' };

		 for($i=0; $i< @file; $i++){
					$base=${&get_base_names($file[$i])};
					$char_opt=~s/\,//g;
					$out_evss_file="$base\_opt\_$char_opt\.evss";
					print "\n# Working to produce $out_evss_file\n";
					my (%score_vs_error, $j, @key_errors, $error_count );
					open(PARF_FILE, $file[$i]);
					while(<PARF_FILE>){
							 if(/^\s*\S+\s+\S+\s+(\S+)\s+(\S+)\s+\S+\s+\S+/){
										$score=$2;
										if($1 eq 'Nomolog'){
												$error_count++;

												#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
												# Do we need LOG of score or eval?
												#_________________________________________
												if($log_of_evalue_or_score){
														if($get_log_base_10){    # 10 base log
																 $score=log($score)/log(10); # log10(x) = ln(x) / ln(10)
														}else{ ## this is natural log
																 $score=log($score);
														}
												}
												#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
												# Do we need to negate the score or eval?
												#_________________________________________
												if($negate_score){  $score_vs_error{$error_count}= -$score; # score can be eval according to input parf file
												}else{              $score_vs_error{$error_count}=$score;  }
										}
							 }
					}
					close(PARF_FILE);

					open(EVSS_FILE, ">$out_evss_file");
					print EVSS_FILE "# $out_evss_file was created by write_evss_files in $0 \n";
					print EVSS_FILE "# EVSS stands for Error VS Score. From PARF file\n";
					@error_count=sort {$a <=> $b} keys %score_vs_error;

					if($error_per_query and !$log_of_errors){
							for($j=0; $j< @error_count; $j++){
									 $error_div_by_query_number=$error_count[$j]/$query_number;
									 printf EVSS_FILE ("\n%-14s %-14s", $score_vs_error{$error_count[$j]}, $error_div_by_query_number );
							}
					}elsif($error_per_query and $log_of_errors){
							for($j=0; $j< @error_count; $j++){
									 $error_div_by_query_number=$error_count[$j]/$query_number;
									 printf EVSS_FILE ("\n%-14s %-14s", $score_vs_error{$error_count[$j]}, log($error_div_by_query_number) );
							}
					}elsif($log_of_errors){
							for($j=0; $j< @error_count; $j++){
									 if($get_log_base_10){
											 $log_of_error_count=log($error_count[$j])/log(10);
									 }else{
											 $log_of_error_count=log($error_count[$j]);
									 }
									 printf EVSS_FILE ("\n%-14s %-14s", $score_vs_error{$error_count[$j]}, $log_of_error_count);
							}
					}else{
							for($j=0; $j< @error_count; $j++){
									 printf EVSS_FILE ("\n%-14s %-14s",  $score_vs_error{$error_count[$j]}, $error_count[$j]);
							}
					}
					print EVSS_FILE "\n";
					close (EVSS_FILE);
					if(-s $out_evss_file > 500){
							 print "\n# $out_evss_file is created \n" if -s $out_evss_file > 500;
							 push(@final_out_files, $out_evss_file);
					}else{
							 print "\n# $out_evss_file is less than 500 byte, too small??\n";
					}
		 }
		 return(\@final_out_files);
}


#________________________________________________________________________
# Title     : write_fasta
# Usage     : many argments:  $seq_hash_reference  and $output_file_name
#             takes a hash which has got names keys and sequences values.
# Function  : writes multiple seqs. in fasta format (takes one or more seq.!!)
#             This needs hash which have 'name' 'actual sequence as value'
#
#             To print out each fasta seq into each single file, use write_fasta_seq_by_seq
#             This can rename seq names
#     File Exts:
#             xxxx.fasta   <--- generic FASTA,
#             xxxx.mfa  <--- multiple FASTA seqs format file extension
#             xxxx.pfa  <--- protein seq FASTA
#             xxxx.nfa  <--- Nuclueotide seq FASTA
#             xxxx.sfa  <--- single fasta seq FASTA
#             xxxx.mpfa <--- multiple protein. seq. FASTA
#             xxxx.mnfa <--- multiple Nucl. seq. FASTA
#
# Example   : &write_fasta(\%in1, \$out_file_name, \%in2, \%in3,..., );
#             << The order of the hash and scalar ref. doesn't matter. >>
# Warning   : The default output file name is 'default_out.fasta' if you do not
#             specify output file name.
#             OUTput file should have xxxxx.fasta or xxxx.any_ext NOT just 'xxxxx'
# Keywords  : write_fasta_file, print_fasta_file, write fasta file, fasta_write
#             show_fasta, write_sequence_fasta, write_fasta_files,
# Options   : v for STD out.
#             r for rename the sequences so that Clustalw would not complain with 10 char limit
#               so result wuld be:  0 ->ASDFASDF, 1->ASDFASFASF, 2->ADSFASDFA
#       $write_pure_seq_only=o by o -o  ## writing only the seq (no gap chars or space)
# Returns   :
# Argument  :
#   $sort_seq_names=s by s  ## in writing sorted sequences are written
#   $write_rv_seq_as_well=R by R  # write reverse seq as well as forward seq
#   $gap_char= by g=
#   $write_Protein_seq_only=P by P
# Category  :
# Version   : 4.1
#--------------------------------------------------------------------
sub write_fasta{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    my($sort_seq_names, $string, $string_leng, $na,$out_file_name_provided,
         $write_pure_seq_only, $write_rv_seq_as_well, $output_file_rv,$hash_num,
         @files_made_with_rv, @files_made, %hash, $seq, $sec_str_hash_form_given,
         $write_Protein_seq_only, $default_extension, $output_file, $func_description,
         $hash_with_description_of_seq, %hash_orig);
    $default_extension='fasta';
    $output_file ='default_out.fasta'; ### when no output file name is given, this is used

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Try and determin the output file name
    #________________________________________________________
    if(@file>0){
            if($file[0]=~/\S\.[mpsn]{0,2}fa[sta]?$/){ ## to handle .nfa and .fasta files
                    $output_file = $file[0];   $out_file_name_provided=1;
                    if(-s $output_file){
                            rename($output_file, "$output_file\.bak");
                            print "\n# (INFO) $output_file is present. $output_file\.bak will be created for backup\n";
                    }
            }elsif($file[0]=~/(\S+)\.\S+/){
                    print "\n# (i) Your input filename for \"write_fasta\" did not match xxxxx.[mpsn]fa[sta] format\n";
                    $output_file = "$1\.$default_extension";   $out_file_name_provided=1;
            }
    }else{ $output_file="default_out\.$default_extension"; }

    if($vars{'g'}=~/(\S+)/){ $gap_char=$1;        }
    if($char_opt=~/s/){ $sort_seq_names='s';        }
    if($char_opt=~/o/){ $write_pure_seq_only='o' }
    if($char_opt=~/P/){ $write_Protein_seq_only='P' }
    if($char_opt=~/R/){ $write_rv_seq_as_well='R'; print "\n# (INFO) You wanted REVerse seq as well\n"; }
    $hash_num=@hash;
    print "\n# (i) Number of HASH given to write_fasta is $hash_num\n";
    for ($n=0 ; $n < @hash; $n ++){
         my($seq, @keys_orig);
         %hash_orig=%{$hash[$n]};
         @keys_orig= sort keys %hash_orig;
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (1) If sec. str. hash form is given
         #______________________________________________________
         if($keys_orig[0]=~/^\d+$/ and $hash_orig{$keys_orig[0]}->[0]=~/^\S$/){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # $hash_orig{$keys_orig[0]}->[3] is seq_name, $hash_orig{$keys_orig[0]}->[0] has each residue
              #_____________________________________________________________________________________________
              for($i=0; $i< @keys_orig; $i++){
                  $seq .=$hash_orig{$keys_orig[$i]}->[0];  ## making seq string like 'ASDFADFAFA....'
              }
              %hash=($hash_orig{$keys_orig[0]}->[3], $seq);
              $sec_str_hash_form_given=1;
         }elsif($hash_orig{$keys_orig[0]}{'SEQUENCE'} or $hash_orig{$keys_orig[0]}{'DESCRIPTION'}){ ## !! necessary to have 2 checkings~!!
              $hash_with_description_of_seq=1;
              %hash=%hash_orig;
              %hash_orig=();
         }else{  %hash=%hash_orig;  %hash_orig=();  }

         if($sort_seq_names){  @keys=sort keys %hash;
         }else{        @keys= keys %hash;    }

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (2) When only one seq is given, use the seq name as output file
         #________________________________________________________________
         if( (@hash==1 and @keys==1 and @file < 1) or $sec_str_hash_form_given){
              $output_file="$keys[0]\.$default_extension";
              $output_file_rv="$keys[0]\_rv\.$default_extension";
         }elsif(@file < 1){                        $output_file="default_fa_$n\.$default_extension";
              if($write_rv_seq_as_well){ $output_file_rv="default_fa_$n\_rv\.$default_extension";  }
         }else{
              $output_file; # $output_file is already set when @file > 0
              if($write_rv_seq_as_well and !$base){
                  ($base, $ext)=split(/\./, $output_file);
                  $output_file_rv="$base\_rv\.$ext";
              }
         }

         open (FASTAS_WRITE,">>$output_file");      # $string is the seq string.
         open (FASTAS_WRITE_RV,">>$output_file_rv") if $write_rv_seq_as_well;
         push(@files_made, $output_file);
         push(@files_made_with_rv, $output_file_rv) if ($write_rv_seq_as_well);

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Main loop. @keys have sequence names
         #______________________________________________________________________________________________
         for ($i=0; $i < @keys; $i++){
              $na= $keys[$i];
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # There are two types of HASH structure.
              #_______________________________________________________________
              if($hash_with_description_of_seq){
                  $string           =$hash{$na}{'SEQUENCE'};
                  $func_description =$hash{$na}{'DESCRIPTION'};
              }else{  $string = "\U$hash{$na}";  }

              if($write_rv_seq_as_well){  $string_rv=reverse($string);  $na_rv="$keys[$i]\_rv"; }

              if($write_pure_seq_only){
                  $string=~s/[\n \.-]//g;        # replaces all non-chars to null. '_' is used for stop codon
                  $string_rv=~s/[\n \.-]//g;        # replaces all non-chars to null. '_' is used for stop codon
              }
              if($write_Protein_seq_only and $string=~/[UBR0-9]/){ next; }

              if($char_opt=~/r/){ $na=$i;} # rename the seqeunces with '0, 1, 2, 3," etc for  clustalw

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # $func_description is just NULL if $hash_with_description_of_seq is not true
              #___________________________________________________________________________
              print FASTAS_WRITE ">$na $func_description\n";

              print FASTAS_WRITE_RV ">$na_rv reverse seq of $func_description\n" if $write_rv_seq_as_well;

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # (3) Main algorithm of writing in 60 char leng line
              #_____________________________________________________
              if($gap_char){ $string=~s/\W/$gap_char/g } ## <------------ Change the GAP char
              $string_leng=length($string);
              for($j=0; $j< $string_leng; $j+=60){
                  printf FASTAS_WRITE "%.60s\n", substr($string,$j,60);
              }
              if($write_rv_seq_as_well){
                  for($j=0; $j< $string_leng; $j+=60){
                      printf FASTAS_WRITE_RV "%.60s\n", substr($string_rv,$j,60);
                  }
              }
          }
          close FASTAS_WRITE;
          close(FASTAS_WRITE_RV) if $write_rv_seq_as_well;
    }
    if( $out_file_name_provided != 1){
       print "\n\n# You didnt give out file name, $output_file  used\n";
    }
    if( -s $output_file ){
         if($verbose=~/\S/){ ## if v option is given, mesg is omitted to prevent comments to a redirected output
                 print "\n# Sequences were written in  $output_file ";
         }
    }else{
      print "\n# The size of written outfile \"$output_file\" is 0, error \n\n"
    }
    if($write_rv_seq_as_well){
                        return(\@files_made_with_rv);
    }else{
        return(\@files_made);
    }
}



#________________________________________________________________________
# Title     : write_fasta_seq_by_seq
# Usage     : &write_fasta_seq_by_seq(\%hash, [$extension], [\$output_filename]);
# Function  : accepts one hash of multiple sequences and writes many files
#             of single sequences by using the names as file names.
#             If $extension is provided, it writes an output as in
#             the below example (seq1_sc.fasta). If not, it just attach
#             'fasta' to files.
#             This needs, hash of 'name', 'actual sequence as value'
# Example   : with >xxxx
#                  ASDFASDFASDFASDFASDFASDFASDF
#                  >yyyy
#                  ASDFASDFASDFASDFASDFASDFSDAFSD
#
#             You will get two files (xxxx.fasta, yyyy.fasta)
# Keywords  : write_each_fasta, write_single_fasta, write_fasta_single
#             single_fasta_write, write_fasta_files_seq_by_seq,
#             write_single_fasta_files, write_seq_by_seq
# Options   : can specify extension name.
#             e  for checking fasta file exists or not and skipps if so
#             r for rename the sequences so that Clustalw would not complain with 10 char limit
#               so result wuld be:  0 ->ASDFASDF, 1->ASDFASFASF, 2->ADSFASDFA
#   $write_rv_seq_as_well=R by R  # write reverse seq as well as forward seq
#   $write_pure_seq_only=o by o
#   $extension= by E=
#
# Returns   : nothing. default OUTPUT file name is '$key.fasta' !!
# Category  :
# Version   : 2.4
#--------------------------------------------------------------------
sub write_fasta_seq_by_seq{
	my ($i, $exists_opt, $rename_seq_opt, $out_file_name_given,
  		$write_rv_seq_as_well, $output_file_rv, $extension,
		$output_file, $write_pure_seq_only, $default_extention);
    $default_extention='spfa';  ## spfa ==> Single Protein FAsta

		for($i=0; $i< @_; $i++){
            if($_[$i]=~/e$/){   $exists_opt=1; splice(@_, $i, 1);  $i--;
            }elsif($_[$i]=~/r$/){ $rename_seq_opt='r';  splice(@_, $i, 1);  $i--;
            }elsif($_[$i]=~/o$/){ $write_pure_seq_only='o';  splice(@_, $i, 1);  $i--;
            }elsif($_[$i]=~/R$/){ $write_rv_seq_as_well='R';  splice(@_, $i, 1);   $i--;
            }elsif($_[$i]=~/E=(\S+)/){ $extension=$1;  splice(@_, $i, 1);   $i--;
            }elsif($_[$i]=~/\S\.fasta/ or -e $_[$i] ){  $out_file_name_given=1;  $output_file = $_[$i];
                 splice(@_, $i, 1);     $i--;
            }elsif( ref ($_[$i]) eq 'SCALAR'){
                 if( ${$_[$i]} =~/\.[msp]*fa/ or -e ${$_[$i]} ){
                        $out_file_name_given=1;   $output_file=${$_[$i]};  splice(@_, $i, 1);  $i--;
                 }
            }
		}
		my(%temp_hash, %temp_hash_rv, $key );
		my(%input)     =%{$_[0]};


		for $key (keys %input){
				my(%temp_hash, %temp_hash_rv, $output_file_rv, $output_file);
				%temp_hash=%temp_hash_rv=();
				$temp_hash{$key}=$input{$key};
				if($write_rv_seq_as_well){
						 $key_rv="$key\_rv";
						 $temp_hash_rv{$key_rv}=reverse($input{$key});
				}
				unless($output_file){
						 #print "\n# (i) \$outputfile is NOT given as an argument to write_fasta_seq_by_seq\n";
						 if ($extension){
									if($write_rv_seq_as_well){
											$output_file_rv = "$key\_rv\.$extension";
											$output_file = "$key\.$extension";
									}else{
											$output_file = "$key\.$extension";
									}
						 }else{
                                    #print "\n    (i) You didnt specify \$extension in write_fasta_seq_by_seq, \"$default_extention\" used\n";
									if($write_rv_seq_as_well){
											$output_file_rv = "$key_rv\.$default_extention";
                                            $output_file = "$key\.$default_extention";
									}else{
                                            $output_file = "$key\.$default_extention";
									}
						 }
				}else{
						 #print "\n# (i) \$output_file, $output_file is given as an argument to write_fasta_seq_by_seq\n";
						 $out_file_name; # $out_file_name is already given as an argument
						 ($base, $extension)=split(/\./, $output_file);
						 if($write_rv_seq_as_well){
									$output_file_rv = "$base\_rv\.$extension";
						 }
						 $output_file = "$base\.$extension";
				}

				if( $exists_opt==1 and -e $output_file){
						#print "# write_fasta_seq_by_seq: File $output_file exists, I wouldn\'t overwrite $output_file\n\n\n";
						next;
				}
				if( $out_file_name_given == 1){
						&write_fasta(\%temp_hash, \$output_file, $rename_seq_opt);
						if($write_rv_seq_as_well){
								$output_file_rv=$output_file;  ## because output file name is already given
								&write_fasta(\%temp_hash_rv, \$output_file_rv, $rename_seq_opt, $write_pure_seq_only);
						}
				}else{
						if($write_rv_seq_as_well){
								&write_fasta(\%temp_hash_rv, \$output_file_rv, $rename_seq_opt, $write_pure_seq_only);
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# The very DEFAULT writing
						#__________________________________________________
						&write_fasta(\%temp_hash, $rename_seq_opt, $write_pure_seq_only);
				}
		}
}




#________________________________________________________________________________
# Title     : write_rdif_files
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub write_rdif_files{
		my (@final_out_file_names, $count, $homo, $pair, %first_parf_class,
				%second_parf_class, %homology1, %homology2, %nomolog_count2,
				%homolog_count2, @keys_Ho, $base1, $base2, %all_count, $i, $j,
				$answer, $diff);

		for($i=0; $i< @_; $i++){
				if($_[$i] !~/\.parf$/){
						print "\n# write_rdif2_files needs PARF file, not NHCO or others \n";
						print "     Shall I continue? Press y to continue\n>>>>";
						$answer=getc;
						if($answer eq 'y'){
								last;
						}else{
								die;
						}
				}
		}
		open(F1, "$_[0]");
		open(F2, "$_[1]");
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the first file
		#_______________________________________
		while(<F1>){
			 if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
					$count++;
					$homo=$3;
					$pair=join(' ', sort($1, $2));
					$first_parf_class{$pair}="$5 $4";
					if($homo eq 'Nomolog'){
							$nomolog_count1{$pair}=$count;
					}else{
							$homolog_count1{$pair}=$count;
					}
					$all_count{$pair}=$count;
					$homology1{$pair}=$homo;
					if($count > 10000){ last }
			 }
		}
		close(F1);
		$count=0;
		$pair='';

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the 2nd file
		#_______________________________________
		while(<F2>){
			 if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
					$homo=$3;
					$count++;
					$pair=join(' ', sort($1, $2));
					$second_parf_class{$pair}="$5 $4";
					if($homo eq 'Nomolog'){
							$nomolog_count2{$pair}=$count;
					}else{
							$homolog_count2{$pair}=$count;
					}
					$homology2{$pair}=$homo;
					if($count > 10000){ last }
			 }
		}
		close(F2);
		$count=0;


		#================================================================================================

		@keys_Ho=sort { $all_count{$a}<=> $all_count{$b}} (keys %all_count);

		$base1=${&get_base_names($_[0])};
		$base2=${&get_base_names($_[1])};

		$out_rdif_file_Homol="$base1\_vs\_$base2\_Homol.rdif";
		#$out_rdif_file_Nomol="$base1\_vs\_$base2\_Nomol.rdif";

		push(@final_out_file_names, $out_rdif_file_Homol);

		open(RDIF_FILE_HO, ">$out_rdif_file_Homol") or die "\n#  dying \n";
		#open(RDIF_FILE_NO, ">$out_rdif_file_Nomol") or die "\n#  dying \n";


		for($i=0; $i< @keys_Ho; $i++){
					$count=$i+1;
					if($homolog_count1{$keys_Ho[$i]}=~/\S/){
							if($homolog_count2{$keys_Ho[$i]}!~/\S/ ){

									#$diff=-5000; ## for rdif2 file
									$diff=0;
									print "\n# $count $keys_Ho[$i] is missing in $first_parf_class{$keys_Ho[$i]} $base2. But in $base1";
							}else{
									$diff= $homolog_count1{$keys_Ho[$i]} - $homolog_count2{$keys_Ho[$i]} ;
							}

							printf RDIF_FILE_HO "$count  $diff\n";
							#printf RDIF_FILE_NO "$count  0\n";
							next;
					}
		}

		close(RDIF_FILE_HO);
		print "\n# $0 has made \"$out_rdif_file_Homol\" \"$out_rdif_file_Nomol\" file in pwd\n\n";
		return(\@final_out_file_names);
}




#________________________________________________________________________________
# Title     : write_rdif2_files
# Usage     : &write_rdif2_files(@files);
# Function  :
# Example   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub write_rdif2_files{
		my (@final_out_file_names, $count, $homo, $pair, %first_parf_class,
				%second_parf_class, %homology1, %homology2, %nomolog_count2,
				%homolog_count2, @keys_Ho, $base1, $base2, %all_count, $i, $j,
				$answer, $diff);

		for($i=0; $i< @_; $i++){
				if($_[$i] !~/\.parf$/){
						print "\n# write_rdif2_files needs PARF file, not NHCO or others \n";
						print "     Shall I continue? Press y to continue\n>>>>";
						$answer=getc;
						if($answer eq 'y'){
								last;
						}else{
								die;
						}
				}
		}
		open(F1, "$_[0]");
		open(F2, "$_[1]");
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the first file
		#_______________________________________
		while(<F1>){
			 if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
					$count++;
					$homo=$3;
					$pair=join(' ', sort($1, $2));
					$first_parf_class{$pair}="$5 $4";
					if($homo eq 'Nomolog'){
							$nomolog_count1{$pair}=$count;
					}else{
							$homolog_count1{$pair}=$count;
					}
					$all_count{$pair}=$count;
					$homology1{$pair}=$homo;
					if($count > 10000){ last }
			 }
		}
		close(F1);
		$count=0;
		$pair='';

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the 2nd file
		#_______________________________________
		while(<F2>){
			 if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
					$homo=$3;
					$count++;
					$pair=join(' ', sort($1, $2));
					$second_parf_class{$pair}="$5 $4";
					if($homo eq 'Nomolog'){
							$nomolog_count2{$pair}=$count;
					}else{
							$homolog_count2{$pair}=$count;
					}
					$homology2{$pair}=$homo;
					if($count > 10000){ last }
			 }
		}
		close(F2);
		$count=0;


		#================================================================================================

		@keys_Ho=sort { $all_count{$a}<=> $all_count{$b}} (keys %all_count);

		$base1=${&get_base_names($_[0])};
		$base2=${&get_base_names($_[1])};

		$out_rdif_file_Homol="$base1\_vs\_$base2\_Homol.rdif2";
		$out_rdif_file_Nomol="$base1\_vs\_$base2\_Nomol.rdif2";

		push(@final_out_file_names, $out_rdif_file_Homol, $out_rdif_file_Nomol);

		open(RDIF_FILE_HO, ">$out_rdif_file_Homol") or die "\n#  dying \n";
		open(RDIF_FILE_NO, ">$out_rdif_file_Nomol") or die "\n#  dying \n";
		print RDIF_FILE_HO "\n# written by $0\n";
		print RDIF_FILE_NO "\n# written by $0\n";

		for($i=0; $i< @keys_Ho; $i++){
					$count=$i+1;
					if($homolog_count1{$keys_Ho[$i]}=~/\S/){
							if($homolog_count2{$keys_Ho[$i]}!~/\S/ ){
									$diff=-5000;
									print "\n# $count $keys_Ho[$i] is missing in $first_parf_class{$keys_Ho[$i]} $base2. But in $base1";
							}else{
									$diff= $homolog_count1{$keys_Ho[$i]} - $homolog_count2{$keys_Ho[$i]} ;
							}

							printf RDIF_FILE_HO "$count  $diff\n";
							printf RDIF_FILE_NO "$count  0\n";
							next;
					}elsif($nomolog_count1{$keys_Ho[$i]}=~/\S/){
							if($nomolog_count2{$keys_Ho[$i]}!~/\S/ ){
									$diff=5000;
							}else{
									$diff= $nomolog_count2{$keys_Ho[$i]} - $nomolog_count1{$keys_Ho[$i]} ;
							}
							printf RDIF_FILE_NO "$count  $diff\n";
							printf RDIF_FILE_HO "$count  0\n"; next
					}
		}

		close(RDIF_FILE_HO);
		close(RDIF_FILE_NO);
		print "\n# $0 has made \"$out_rdif_file_Homol\" \"$out_rdif_file_Nomol\" file in pwd\n\n";
		return(\@final_out_file_names);
}

#________________________________________________________________________________
# Title     : write_ardf_files
# Usage     : &write_ardf_files(@files);
# Function  :
# Example   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub write_ardf_files{
		my (@final_out_file_names, $count, $homo, $pair, %first_parf_class,
				%second_parf_class, %homology1, %homology2, %nomolog_count2,
				%homolog_count2, @keys_Ho, $base1, $base2, %all_count, $i, $j,
				$answer, $diff, $av, $sum_found_rank_diff_Nomolog,
				$sum_found_rank_diff_Homolog, $count_found_rank_diff_Nomolog,
				$count_found_rank_diff_Homolog, $do_not_show_missing_diff);

		for($i=0; $i< @_; $i++){
				if($_[$i] !~/\.parf$/){
						print "\n# write_ardf_files needs PARF file, not NHCO or others \n";
						print "     Shall I continue? Press y to continue\n>>>>";
						$answer=getc;
						if($answer eq 'y'){
								last;
						}else{
								die;
						}
				}elsif($_[$i]=~/^[\-]?n/i){
						$do_not_show_missing_diff='n';
				}
		}
		open(F1, "$_[0]");
		open(F2, "$_[1]");
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the first file
		#_______________________________________
		while(<F1>){
				if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
						$count++;
						$homo=$3;
						$pair=join(' ', sort($1, $2));
						$first_parf_class{$pair}="$5 $4";
						if($homo eq 'Nomolog'){
								$nomolog_count1{$pair}=$count;
						}else{
								$homolog_count1{$pair}=$count;
						}
						$all_count{$pair}=$count;
						$homology1{$pair}=$homo;
						if($count > 10000){ last }
				}
		}
		close(F1);
		$count=0;
		$pair='';

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reading in the 2nd file
		#_______________________________________
		while(<F2>){
			 if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/){
					$homo=$3;
					$count++;
					$pair=join(' ', sort($1, $2));
					$second_parf_class{$pair}="$5 $4";
					if($homo eq 'Nomolog'){
							$nomolog_count2{$pair}=$count;
					}else{
							$homolog_count2{$pair}=$count;
					}
					$homology2{$pair}=$homo;
					if($count > 10000){ last }
			 }
		}
		close(F2);
		$count=0;


		#================================================================================================

		@keys_Ho=sort { $all_count{$a}<=> $all_count{$b}} (keys %all_count);

		$base1=${&get_base_names($_[0])};
		$base2=${&get_base_names($_[1])};

		$out_ardf_file_Homol="$base1\_vs\_$base2\_Homol.ardf";
		$out_ardf_file_Nomol="$base1\_vs\_$base2\_Nomol.ardf";

		push(@final_out_file_names, $out_ardf_file_Homol, $out_ardf_file_Nomol);

		open(RDIF_FILE_HO, ">$out_ardf_file_Homol") or die "\n#  dying \n";
		open(RDIF_FILE_NO, ">$out_ardf_file_Nomol") or die "\n#  dying \n";


		for($i=0; $i< @keys_Ho; $i++){
					$count=$i+1;
					if($homolog_count1{$keys_Ho[$i]}=~/\S/){
							if($homolog_count2{$keys_Ho[$i]}!~/\S/ ){
									#$diff=-5000;
									if($do_not_show_missing_diff){
											$av = 0;
									}else{
											$av = -5000;
									}
									print "\n# $count $keys_Ho[$i] is missing in $first_parf_class{$keys_Ho[$i]} $base2. But in $base1";
							}else{
									$diff= abs($homolog_count1{$keys_Ho[$i]} - $homolog_count2{$keys_Ho[$i]}) ;
									$av= ($homolog_count1{$keys_Ho[$i]} + $homolog_count2{$keys_Ho[$i]} )/2 ;
									$sum_found_rank_diff_Homolog+=$diff;
									$count_found_rank_diff_Homolog++;
							}

							printf RDIF_FILE_HO "$count  $av\n";
							printf RDIF_FILE_NO "$count  0\n";
							next;
					}elsif($nomolog_count1{$keys_Ho[$i]}=~/\S/){
							if($nomolog_count2{$keys_Ho[$i]}!~/\S/){
									#$diff=5000;
									if($do_not_show_missing_diff){
											 $av = 0;
									}else{
											 $av = 5000;
									}
							}else{
									$diff= abs($nomolog_count2{$keys_Ho[$i]} - $nomolog_count1{$keys_Ho[$i]}) ;
									$av = ($nomolog_count2{$keys_Ho[$i]} + $nomolog_count1{$keys_Ho[$i]})/2 ;
									$sum_found_rank_diff_Nomolog+= $diff;
									$count_found_rank_diff_Nomolog++;
							}
							printf RDIF_FILE_NO "$count  $av\n";
							printf RDIF_FILE_HO "$count  0\n"; next
					}
		}
		$av_found_rank_diff_Homolog=int($sum_found_rank_diff_Homolog/$count_found_rank_diff_Homolog);
		$av_found_rank_diff_Nomolog=int($sum_found_rank_diff_Nomolog/$count_found_rank_diff_Nomolog);

		print RDIF_FILE_HO "\n# Abs \$sum_found_rank_diff_Homolog is $sum_found_rank_diff_Homolog with $count_found_rank_diff_Homolog pairs\n";
		print RDIF_FILE_HO "\n# Abs Av is: $av_found_rank_diff_Homolog\n";
		print RDIF_FILE_NO "\n# Abs \$sum_found_rank_diff_Nomolog is $sum_found_rank_diff_Nomolog with $count_found_rank_diff_Nomolog pairs\n";
		print RDIF_FILE_NO "\n# Abs Av is: $av_found_rank_diff_Nomolog\n";

		close(RDIF_FILE_HO);
		close(RDIF_FILE_NO);
		print "\n# $0 has made \"$out_ardf_file_Homol\" \"$out_ardf_file_Nomol\" file in pwd\n\n";
		return(\@final_out_file_names);
}


#________________________________________________________________________________
# Title     : write_nhco_files
# Usage     :
# Function  : writes nhco files with each class(4 of them) file nhco as well.
#              NHCO stands for Nomolog, Homolog Column Output file
# Example   :
#            Output example (from: ~/Proj/Bio/Search_meth_comp/Final x>more ISS_935.nhco)
#              1        130
#              2        418
#              3        451
#              4        461
#              5        506
#
# Keywords  : write homology column file, write_nomol_homol_column_files,
#             write_homol_col_files
# Options   :
#  $exclude_these_pairs= by x=
#  $ISS_2nd_Eval_factor= by E=
#  $show_fractional_success= by f=   # for example f=6964  to show the fraction out of 6964
#
# Author    : jong@salt2.med.harvard.edu, NHCO stands for Nomolog, Homolog Column Output file
# Category  :
# Version   : 2.4
#--------------------------------------------------------------------------------
sub write_nhco_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #---------------------------------------------------------------------------
    my($out_nhco_file_name, @final_nhco_files, $answer_char, $target_direc, $query_class, $match_class, $homolog_a, $homolog_b, $homolog_a_b,
       $out_linked_pairs_file, %linkage_hash, %all_linked_pair_hash, $homolog_a_p_b, %all_pair_hash, $exclude_these_pairs,  $exclude_these_pairs, %pairs_excluded); ## $exclude_these_pairs contains filename

    if($vars{'E'}=~/\d+/){    $ISS_2nd_Eval_factor=$vars{'E'};
    }elsif(-s $vars{'x'}){    $exclude_these_pairs=$vars{'x'};
    }elsif($vars{'f'} > 2){   $show_fractional_success=$vars{'f'}; ## fraction denominator is a big number usually (6964 for pdb40d_1.38)
    }elsif($char_opt=~/d/){   $pdbd_seq_only='d';
    }elsif($char_opt=~/571/){ $sam_571_seq_only=571;    }

    $pair_info_file=$exclude_these_pairs;
    open(PAIR_INFO, $pair_info_file);
    while(<PAIR_INFO>){   if(/^(\S+\s+\S+)/){ $pairs_excluded{$1}=$1;   }   }
    close(PAIR_INFO);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    print "\n# (1) gettting correcting_pairs from  \&get_scop_correcting_pairs, \%fix_hash made!\n";
    #___________________________________
    %correcting_pairs=%{&get_scop_correcting_pairs()};

    if(@file < 1){ print "\n\n\n# \@file is empty, something is wrong, Do your input files in PWD?\n\n\n\n"; die }

    @file=@{&check_input_file_extension('parf,mprf', \@file)};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    print "\n# (4) processing \"@file\" \n";
    #_______________________________________
    for($i=0; $i< @file; $i++){
        my($File, $seq1, $seq2, $sorted, $base, $homolog_counter, $nomolog); $File=$file[$i];
        $base=${&get_base_names($File)};
        if($base=~/(\S+[^_]+)_+$/){ $base=$1; }
        $out_nhco_file_name      ="$base\.nhco";
        $out_nhco_file_name_a    ="$base\_a\.nhco";
        $out_nhco_file_name_b    ="$base\_b\.nhco";
        $out_nhco_file_name_a_b  ="$base\_a_b\.nhco";
        $out_nhco_file_name_a_p_b="$base\_a_p_b\.nhco";
        $out_nhco_linked_file_name      ="$base\_linked\.nhco";  ### These are for Single linkage counting result
        $out_nhco_linked_file_name_a    ="$base\_linked\_a\.nhco";
        $out_nhco_linked_file_name_b    ="$base\_linked\_b\.nhco";
        $out_nhco_linked_file_name_a_b  ="$base\_linked\_a_b\.nhco";
        $out_nhco_linked_file_name_a_p_b="$base\_linked\_a_p_b\.nhco";
        $out_linked_pairs_file=">$base\_linked\.pair";
        $out_linked_pairs_file_a=">$base\_linked_a\.pair";
        $out_linked_pairs_file_b=">$base\_linked_b\.pair";
        $out_linked_pairs_file_a_b=">$base\_linked_a_b\.pair";
        $out_linked_pairs_file_a_p_b=">$base\_linked_a_p_b\.pair";

        open(F, $File) || die "Can not open $File \n";
        open(NHCO, ">$out_nhco_file_name");               open(NHCO_LINKED, ">$out_nhco_linked_file_name");
        open(NHCO_a, ">$out_nhco_file_name_a");   open(NHCO_LINKED_a, ">$out_nhco_linked_file_name_a");
        open(NHCO_b, ">$out_nhco_file_name_b");     open(NHCO_LINKED_b, ">$out_nhco_linked_file_name_b");
        open(NHCO_a_b, ">$out_nhco_file_name_a_b");   open(NHCO_LINKED_a_b, ">$out_nhco_linked_file_name_a_b");
        open(NHCO_a_p_b, ">$out_nhco_file_name_a_p_b");   open(NHCO_LINKED_a_p_b, ">$out_nhco_linked_file_name_a_p_b");
        open(NHCO_LINKED_PAIRS, ">$out_linked_pairs_file") || die "$0 can not open $out_linked_pairs_file\n\n";
        open(NHCO_LINKED_PAIRS_a, ">$out_linked_pairs_file_a") || die "$0 can not open $out_linked_pairs_file_a\n\n";
        open(NHCO_LINKED_PAIRS_b, ">$out_linked_pairs_file_b") || die "$0 can not open $out_linked_pairs_file_b\n\n";
        open(NHCO_LINKED_PAIRS_a_b, ">$out_linked_pairs_file_a_b") || die "$0 can not open $out_linked_pairs_file_a_b\n\n";
        open(NHCO_LINKED_PAIRS_a_p_b, ">$out_linked_pairs_file_a_p_b") || die "$0 can not open $out_linked_pairs_file_a_p_b\n\n";

        while(<F>){
           if(/^\s*#/ or /\s+Un/ or /^\s*#/ or /\s+[FV]omolog/i){ next; # ignoring Unmologk=Vomolog, Fomolog

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
           # (5) This is when there is NO HOMOLogy information is written in the line as in RAW data file from Kevin Karplus
           #____________________________________________________________________________________________________________
           }elsif(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+((\d+)\.\d+\.\d+)\.*\d*\.*\d*\s*((\d+)\.\d+\.\d+)\.*\d*\.*\d*/){
               $seq1=$1; $seq2=$2;  $single_linkage_made_with_linkage_hash=0; ## this should be reset
               if($seq1=~/(\S+)_\d+\.\d+\.\d+/){ $seq1=$1; }
               if($seq2=~/(\S+)_\d+\.\d+\.\d+/){ $seq2=$1;                 }
               $sorted = join(' ', sort($seq1, $seq2));

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # This is to prevent repetitive counting.
               #_______________________________________________________________
               if( $all_pair_hash{$sorted} ){  print "\n# Already $sorted\n"; next
               }else{                       $all_pair_hash{$sorted}=$sorted;                     }

               if($5 == 8 or $7 == 8 or $5 == 9 or $7 == 9){  next; ## ignore class 8 and 9
               }else{     $query_class=$5;  $match_class=$7;  $match_superfam=$4; $query_superfam=$6;               }

               if($match_class eq $query_class){      $homolog_counter++;  goto HOMOLOGY_CASE;
               }elsif($match_class ne $query_class){  $nomolog++;  goto NOMOLOGY_CASE;
               }else{  print "\n# write_nhco_files: Something is wrong, dying, \n"; die;    }
           }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
           # (6) Dealing with proper PARF file (Paired Ranking File), HOMOLOGY case
           #___________________________________________________________
           elsif(/^\s*(\S+)\s+(\S+)\s+Homolog\s+(\S+)\s+(\d+)\.\d+\.\d+[\.\d+\.\d+]*\s*(\d+)\.\d+\.\d+[\.\d+\.\d+]*/){
               $seq1=$1; $seq2=$2; $query_class=$4; $match_class=$5;
               $sorted=join(' ', sort($seq1, $seq2)); $single_linkage_made_with_linkage_hash=0; ## this should be reset
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # This is to prevent repetitive counting.
               #_______________________________________________________________
               if( $all_pair_hash{$sorted} ){ print "\n# Already $sorted\n"; next  }else{  $all_pair_hash{$sorted}=$sorted; }

               HOMOLOGY_CASE: $homolog_counter++; #==================================================<<<<<<<<<
               if($exclude_these_pairs and $pairs_excluded{$sorted} ){    $homolog_exclude++;
                   if(    $query_class == 1){   $homolog_a_exclude++;
                   }elsif($query_class == 2){   $homolog_b_exclude++;
                   }elsif($query_class == 3){   $homolog_a_b_exclude++;
                   }elsif($query_class == 4){   $homolog_a_p_b_exclude++;  }
               }
               if(    $query_class == 1){   $homolog_a++;
               }elsif($query_class == 2){   $homolog_b++;
               }elsif($query_class == 3){   $homolog_a_b++;
               }elsif($query_class == 4){   $homolog_a_p_b++;
               }
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Single LINKage clustering counting. Checks if there were previous entries
               #___________________________________________________________________________________
               for $j (@hash_index_array){
                   if( $linkage_hash{$j}{$seq1}=~/\S/ or $linkage_hash{$j}{$seq2}=~/\S/ ){
                        #print "\n $j : $linkage_hash{$j}{$seq1} ";
                        $linkage_hash{$j}{$seq1}=$seq1;
                        $linkage_hash{$j}{$seq2}=$seq2;
                        $linkage_hash_a{$j}{$seq1}=$seq1 if $query_class==1;
                        $linkage_hash_a{$j}{$seq2}=$seq2 if $query_class==1;;
                        $linkage_hash_b{$j}{$seq1}=$seq1 if $query_class==2;;
                        $linkage_hash_b{$j}{$seq2}=$seq2 if $query_class==2;;
                        $linkage_hash_a_b{$j}{$seq1}=$seq1 if $query_class==3;;
                        $linkage_hash_a_b{$j}{$seq2}=$seq2 if $query_class==3;;
                        $linkage_hash_a_p_b{$j}{$seq1}=$seq1 if $query_class==4;;
                        $linkage_hash_a_p_b{$j}{$seq2}=$seq2 if $query_class==4;;
                        $single_linkage_made_with_linkage_hash=1;    last;
                   }
               }
               unless($single_linkage_made_with_linkage_hash){
                   $linkage_hash{$homolog_counter}{$seq1}=$seq1;
                   $linkage_hash{$homolog_counter}{$seq2}=$seq2;
                   $linkage_hash_a{$homolog_counter}{$seq1}=$seq1 if $query_class==1;
                   $linkage_hash_a{$homolog_counter}{$seq2}=$seq2 if $query_class==1;
                   $linkage_hash_b{$homolog_counter}{$seq1}=$seq1 if $query_class==2;
                   $linkage_hash_b{$homolog_counter}{$seq2}=$seq2 if $query_class==2;
                   $linkage_hash_a_b{$homolog_counter}{$seq1}=$seq1 if $query_class==3;
                   $linkage_hash_a_b{$homolog_counter}{$seq2}=$seq2 if $query_class==3;
                   $linkage_hash_a_p_b{$homolog_counter}{$seq1}=$seq1 if $query_class==4;
                   $linkage_hash_a_p_b{$homolog_counter}{$seq2}=$seq2 if $query_class==4;
                   push(@hash_index_array, $homolog_counter);
               }
           }
           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # (7) Dealing with proper PARF file (Paired Ranking File), NOMOLOG and Fomolog (fold level homology only)
           #___________________________________________________________________________________________________________
           elsif(/^\s*(\S+)\s+(\S+)\s+Nomolog\s+(\S+)\s+(\d+)\.\d+\.\d+[\.\d+\.\d+]*\s+(\d+)\.\d+\.\d+[\.\d+\.\d+]*/){
               $seq1=$1; $seq2=$2;
               if($seq1=~/(\S+)_\d+\.\d+\.\d+/){ $seq1=$1; } # remving attached classification info
               if($seq2=~/(\S+)_\d+\.\d+\.\d+/){ $seq2=$1; }
               $sorted=join(' ', sort($seq1, $seq2));
               if($seq1 =~/^ds030__/ or $seq2 =~/^ds030__/){ next } ## ds030 is a bug in PDB40D , May 20th 1999,
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # This is to prevent repetitive counting.
               #_______________________________________________________________
               if( $all_pair_hash{$sorted} ){ print "\n# Already $sorted\n"; next
               }else{          $all_pair_hash{$sorted}=$sorted;            }

               NOMOLOGY_CASE:  #==================================================<<<<<<<<<
               if($4 >= 8 or $5 >= 8){ next; }else{  $query_class=$4; $match_class=$5;   }
               $possible_combination=0; ## To have correct all possible pairs count
               $possible_combination_a=$possible_combination_b=$possible_combination_a_b=$possible_combination_a_p_b=0;

               if($correcting_pairs{$sorted}){  $homolog_counter++;
                   if($exclude_these_pairs and $pairs_excluded{$sorted} ){
                       $homolog_exclude++;
                       if(    $query_class == 1){   $homolog_a_exclude++;
                       }elsif($query_class == 2){   $homolog_b_exclude++;
                       }elsif($query_class == 3){   $homolog_a_b_exclude++;
                       }elsif($query_class == 4){   $homolog_a_p_b_exclude++;
                       }
                   }
                   if(    $query_class == 1){    $homolog_a++;
                   }elsif($query_class == 2){    $homolog_b++;
                   }elsif($query_class == 3){    $homolog_a_b++;
                   }elsif($query_class == 4){    $homolog_a_p_b++;
                   }
               }else{  $nomolog++;
                   if($exclude_these_pairs and $pairs_excluded{$sorted} ){     $nomolog_exclude++;
                       if(    $query_class == 1){   $nomolog_a_exclude++;
                       }elsif($query_class == 2){   $nomolog_b_exclude++;
                       }elsif($query_class == 3){   $nomolog_a_b_exclude++;
                       }elsif($query_class == 4){   $nomolog_a_p_b_exclude++;
                       }
                   }
                   $homolog_after_exclude     = $homolog_counter - $homolog_exclude;
                   $homolog_after_exclude_a   = $homolog_a-$homolog_a_exclude;
                   $homolog_after_exclude_b   = $homolog_b-$homolog_b_exclude;
                   $homolog_after_exclude_a_b = $homolog_a_b - $homolog_a_b_exclude;
                   $homolog_after_exclude_a_p_b= $homolog_a_p_b - $homolog_a_p_b_exclude;

                   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   # Writing all the outputs!
                   #_____________________________________________________
                   for($v=1; $v <=5; $v++){
                       $possible_combination=0;
                       if($v==1){    %temp=%linkage_hash;       $NHCO='NHCO';       $NHCO_LINKED='NHCO_LINKED';     $NHCO_LINKED_PAIRS= 'NHCO_LINKED_PAIRS'; }
                       elsif($v==2){ %temp=%linkage_hash_a;     $NHCO='NHCO_a';     $NHCO_LINKED='NHCO_LINKED_a';   $NHCO_LINKED_PAIRS= 'NHCO_LINKED_PAIRS_a';}
                       elsif($v==3){ %temp=%linkage_hash_b;     $NHCO='NHCO_b';     $NHCO_LINKED='NHCO_LINKED_b';   $NHCO_LINKED_PAIRS= 'NHCO_LINKED_PAIRS_b';}
                       elsif($v==4){ %temp=%linkage_hash_a_b;   $NHCO='NHCO_a_b';   $NHCO_LINKED='NHCO_LINKED_a_b'; $NHCO_LINKED_PAIRS= 'NHCO_LINKED_PAIRS_a_b';}
                       elsif($v==5){ %temp=%linkage_hash_a_p_b; $NHCO='NHCO_a_p_b'; $NHCO_LINKED='NHCO_LINKED_a_p_b'; $NHCO_LINKED_PAIRS= 'NHCO_LINKED_PAIRS_a_p_b';}
                       @linkage_keys= sort {$a <=> $b } keys %temp;
                       for($k=0; $k< @linkage_keys; $k++){
                           $superfamily_member_count       =@members      =keys %{$temp{$linkage_keys[$k]}};
                           $superfamily_member_pairs       =$superfamily_member_count *($superfamily_member_count   -1)/2;
                           $possible_combination       += $superfamily_member_pairs;
                           %all_linked_pair_hash =%{&get_all_possible_pairs_from_array(\@members)};
                           @all_linked_pairs=keys %all_linked_pair_hash;
                           print $NHCO_LINKED_PAIRS   "\n>$linkage_keys[$k] $superfamily_member_pairs : @members : $homolog_counter << $possible_combination";
                           for($j=0 ; $j< @all_linked_pairs; $j++){
                              if($all_pair_hash{$all_linked_pairs[$j]}){  print $NHCO_LINKED_PAIRS "\n       *$all_linked_pairs[$j]";
                              }else{                                      print $NHCO_LINKED_PAIRS "\n        $all_linked_pairs[$j]";     }
                           }
                           print $NHCO_LINKED_PAIRS "\n";
                       }
                       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                       # WRITING !!, at each NOMOLOGY detection
                       #_____________________________________________________________________
                       if($show_fractional_success){ $fractional_homolog=$homolog_counter/$show_fractional_success }else{ $fractional_homolog='' }
                       printf $NHCO_LINKED ("%-8s %-6s\n", $nomolog, $possible_combination);

                       if($nomolog ==5 or $nomolog==10 or $nomolog==44 or $nomolog==88 or $nomolog==433 ){
                            if($show_fractional_success){ $fractional_homolog=$homolog_counter/$show_fractional_success }else{ $fractional_homolog='' }
                            #printf ("%-8s %-6s %-6s %-6s %-6s\n", $nomolog,$homolog_counter, $homolog_after_exclude, $homolog_exclude);
                            #printf ("%-8s %-6s %-6s %-6s\n", $nomolog, $homolog_counter, $superfamily_member_pairs, $possible_combination);
                       }
                    }
                    # writing class only counts
                    printf NHCO ("%-8s %-6s %-6s %-6s %-6s\n", $nomolog, $fractional_homolog, $homolog_counter, $homolog_after_exclude, $homolog_exclude);
                    if(    $query_class == 1){   $nomolog_a++;
                        printf NHCO_a ("%-6s %-6s %-6s %-6s\n", $nomolog_a, $homolog_a, $homolog_after_exclude_a, $homolog_a_exclude);
                        printf NHCO_LINKED_a ("%-6s %-6s\n",    $nomolog_a, $possible_combination);
                    }elsif($query_class == 2){   $nomolog_b++;
                        printf NHCO_b ("%-8s %-6s %-6s %-6s\n", $nomolog_b,  $homolog_b, $homolog_after_exclude_b, $homolog_b_exclude);
                        printf NHCO_LINKED_b ("%-6s %-6s\n",    $nomolog_b, $possible_combination);
                    }elsif($query_class == 3){   $nomolog_a_b++;
                        printf NHCO_a_b ("%-8s %-6s %-6s %-6s\n", $nomolog_a_b, $homolog_a_b, $homolog_after_exclude_a_b, $homolog_a_b_exclude);
                        printf NHCO_LINKED_a_b ("%-6s %-6s\n",    $nomolog_a_b, $possible_combination);
                    }elsif($query_class == 4){    $nomolog_a_p_b++;
                        printf NHCO_a_p_b ("%-8s %-6s %-6s %-6s\n", $nomolog_a_p_b, $homolog_a_p_b, $homolog_after_exclude_a_p_b, $homolog_a_p_b_exclude);
                        printf NHCO_LINKED_a_p_b ("%-6s %-6s\n",    $nomolog_a_p_b,    $possible_combination);
                    }

               }
           }
       }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Closing all the NHCO files here
       #______________________________________________________________
       close (NHCO); close (NHCO_a); close (NHCO_b);  close(NHCO_a_b);  close(NHCO_a_p_b);
       close (NHCO_LINKED); close(NHCO_LINKED_a); close(NHCO_LINKED_b); close(NHCO_LINKED_a_b); close(NHCO_LINKED_a_p_b);

       if(-s $out_nhco_file_name){
           push(@final_nhco_files, $out_nhco_file_name, $out_nhco_file_name_a, $out_nhco_file_name_b, $out_nhco_file_name_a_b,
                $out_nhco_file_name_a_p_b );
           if(-d $ENV{'haussler'} ){  $target_direc=$ENV{'haussler'};
                print "\n# $target_direc is found !!, You must be JONG Park, or Are you Sarah??\n";
                print "\n# write_nhco_files : As you have haussler dir, I copy $out_nhco_file_name and others to it\n\n";
                for(@final_nhco_files){   system("cp $_ $target_direc");    }
           }
       }else{   print "\n\n\n\n# write_nhco_files: \$out_nhco_file_name is not big, ERROR???\n\n\n\n";    }
    }
    return(\@final_nhco_files);
}






#______________________________________________________________________________
# Title     : write_c3al_files
# Usage     :
# Function  : &write_c3al_files(\%seq, \$base, \$pdb_seq_start);
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub write_c3al_files{
		my($i, %multiple_seq_aln, $out_c3al_file, $base,$target_name,
			 $sec_str, @names, $pdb_seq_name, $reliability, $pdb_seq_res_count,
			 $author_code,$pdb_seq_start,
			 $pdb_seq_name );
		$pdb_seq_res_count=1;
		$author_code='1143-9512-5546';
		%multiple_seq_aln=%{$_[0]};
		$base=${$_[1]};
		if (${$_[2]}=~/^\d+$/){
				$pdb_seq_res_count = $pdb_seq_start = ${$_[2]};
		}else{
				print "\n# (i) write_c3al_files: You didn\'t put \$pdb_seq_start, 1 is used\n";
				$pdb_seq_start=1;
		}
		$out_c3al_file="$base\.c3al";
		@names=keys %multiple_seq_aln;
		for($i=0; $i< @names; $i++){
			 if($names[$i]=~/^\S*(\d\w\w\w\w*)\_*/){
					 $pdb_seq_name=$1;
					 splice(@names, $i, 1); $i--;
			 }elsif($names[$i]=~/(T\d\d*)/){
					 $target_name=$1;
					 splice(@names, $i, 1); $i--;
			 }
		}
		if(!$pdb_seq_name or !$target_name){
			 print "\n# (E) It is difficult to tell which is PDB and which is Target\n";
			 print "\n# (E) PDB seq name is like  1abc. Target looks like T74\n";
			 die;
		}else{
			 #print "\n# (i) PDB is $pdb_seq_name and Target is $target_name\n";
		}

		@target_seq=split(//, $multiple_seq_aln{$target_name });
		@pdb_seq   =split(//, $multiple_seq_aln{$pdb_seq_name});


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Making the correct target name like = 'T0042' from $target_name
		#__________________________________________________________________
		if($target_name=~/T(\d+)/){
				$digit_part=$1;
				if($digit_part=~/\d\d\d\d/){
				}elsif($digit_part=~/^(\d\d)$/){
						$target_name="T00$1";
				}elsif($digit_part=~/^(\d\d\d)$/){
						$target_name="T0$1";
				}
		}

		open (C3AL_FILE, ">$out_c3al_file");
		print C3AL_FILE "PFRMAT AL\n";
		print C3AL_FILE "TARGET $target_name\n";
		print C3AL_FILE "AUTHOR $author_code\n";
		print C3AL_FILE "REMARK similar to $pdb_seq_name . For casp3 fold recog.\n";
		print C3AL_FILE "METHOD sequence search\n";
		print C3AL_FILE "MODEL  1\n";
		print C3AL_FILE "PARENT $pdb_seq_name\n";

		for($i=0; $i< @target_seq; $i++){
			 $target_residue=$target_seq[$i];
			 $pdb_residue=$pdb_seq[$i];
			 #print "\n#  \$target_residue $target_seq_res_count $target_residue,  \$pdb_residue $pdb_residue $pdb_seq_res_count";
			 if($target_residue =~/\W/){
					 splice(@target_seq, $i, 1);
					 splice(@pdb_seq, $i, 1);
					 $i--;
					 $pdb_seq_res_count ++;
					 #print "\n# (i) Target seq residue $target_residue  is not AminoAcid, \$pdb_seq_res_count : $pdb_seq_res_count\n";
					 next # skipping non residue(gap)
			 }else{
					 if($pdb_residue !~/\W/){
							 $target_seq_res_count++;
							 print C3AL_FILE "$target_residue $target_seq_res_count $pdb_residue $pdb_seq_res_count\n";
							 $pdb_seq_res_count ++;
					 }else{
							 $target_seq_res_count++;
							 #$pdb_seq_res_count --;
							 #print C3AL_FILE "$target_residue $target_seq_res_count $pdb_residue $pdb_seq_res_count\n";
							 #$pdb_seq_res_count ++;
					 }
			 }
		}
		print C3AL_FILE "TER\n";
		print C3AL_FILE "END\n";
		close(C3AL_FILE);
		push(@file_out,$out_c3al_file);
		if(@file_out > 1){
				return(\@file_out);
		}elsif(@file_out==1){
				return(\$file_out[0]);
		}
}



#______________________________________________________________________________
# Title     : write_c3ss_files
# Usage     :
# Function  : This is CASP3 Secondary Str prediction format
#             http://predictioncenter.llnl.gov/casp3/Casp3.html
# Example   : &write_c3ss_files(\%prdl, \$base);
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.4
#------------------------------------------------------------------------------
sub write_c3ss_files{
		my($i, $ext, $sec_str, %prdl, $reliability);
		%prdl=%{$_[0]};
		$base=${$_[1]} || $_[1];
		$ext=${$_[2]} || $_[2];
		if($ext){
				$out_c3ss_file="$base\_$ext\.c3ss";
		}else{   $out_c3ss_file="$base\.c3ss"; }
		open(C3SS_FILE, ">$out_c3ss_file");
		print C3SS_FILE "PFRMAT SS\n";
		print C3SS_FILE "TARGET $base\n";
		print C3SS_FILE "AUTHOR 1143-9512-5546\n";
		print C3SS_FILE "REMARK secondary struc prediction, _ means NO prediction\n";
		print C3SS_FILE "METHOD FBRV postprocessing method\n";
		print C3SS_FILE "MODEL  1\n";
		@position=sort{$a<=>$b} keys %prdl;
		for($i=0; $i<@position; $i++){
			 $residue=$prdl{$position[$i]}->[0];
			 if($residue =~/\W/){ next } # skipping non residue(gap)
			 $reliability=substr($prdl{$position[$i]}->[2], 0, 5);
			 $sec_str="\U$prdl{$position[$i]}->[1]";
			 if($sec_str eq '_'){
					 $sec_str="\U$prdl{$position[$i-1]}->[1]";
					 $prdl{$position[$i]}->[1]=$sec_str;
					 $reliability=0;
			 } ## this is to convert _ to H, E, or C
			 if($reliability > 0.9){
					 $reliability=1.0; ## To be 100% sure
			 }
			 print C3SS_FILE "$residue $sec_str $reliability\n"
		}
		print C3SS_FILE "END\n";
		return(\$out_c3ss_file);
}


#________________________________________________________________________
# Title     : write_pred_files
# Usage     :
# Function  :
# Example   : &write_pred_files(\%gapped_av_for_back_pred, $final_output_pred_name,
#                 $graphical_rep_of_str, "$put_reliability_line_in_PRED");
#
# Warning   :
# Keywords  : write_predator_short_out_file, write_pred_file, write_prd_file
# Options   :
#   $put_reliability_line_in_PRED=r by r
#   $omit_coil_region=c by c
#   $protein_name= by n=
#   $graphical_rep_of_str=g by g
#   $show_on_screen_only=s by s
# Returns   :
# Argument  :
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------
sub write_pred_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#$| = 1;
		my($sort_seq_names, $string, $string_leng, $na,$out_file_name_provided,
			 $write_pure_seq_only, $show_coil_region, %one_to_three, $each_reliability,
			 $each_seq_fragment, $each_str_fragment, $end_seq_point, $each_reliability_frag,
			 $protein_name, $omit_coil_region, $ext, $graphical_rep_of_str,
			 $show_on_screen_only);
		my($output_file) ='default_out.pred'; ### when no output file name is given, this is used
		$protein_name='pred_temp_name';

		if($char_opt=~/r/){ $put_reliability_line_in_PRED='l' } ## putting additional reliability line
		if($char_opt=~/c/){ $omit_coil_region='c' } ## putting additional reliability line
		if($char_opt=~/g/){ $graphical_rep_of_str='g' } ## putting additional reliability line
		if($char_opt=~/s/){ $show_on_screen_only='s' } ## putting additional reliability line
		if($vars{'n'}=~/(\S+)/){ $protein_name=$1; }

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  If any input file has the prdl extension, I assume it is the output name
		#__________________________________________________________________________
		$ext='pred';
		for($i=0; $i< @file; $i++){
				if($file[$i]=~/$ext/){
						$output_file=$file[$i];
				}
		}

				%one_to_three = (
					 "A", "ALA",  "C", "CYS",  "D", "ASP",  "E", "GLU",  "F", "PHE",
					 "G", "GLY",  "H", "HIS",  "I", "ILE",  "K", "LYS",  "L", "LEU",
					 "M", "MET",  "N", "ASN",  "P", "PRO",  "Q", "GLN",  "R", "ARG",
					 "S", "SER",  "T", "THR",  "V", "VAL",  "W", "TRP",  "Y", "TYR"
					 );

	if(@file>0){
	    $output_file = $file[0];
	    $out_file_name_provided=1;
				}elsif($protein_name){ $output_file="$protein_name\.pred"
				}else{ $output_file='default_out.pred'; }

	for ($n=0 ; $n < @hash; $n ++){
						 my($reliability, $position, $residue, $sec_str);
						 my %hash=%{$hash[$n]};
						 my @keys= sort {$a <=> $b} keys %hash;
						 unless($show_on_screen_only){
								 open (PRED_WRITE,">$output_file");      # $string is the seq string.
								 print PRED_WRITE "# written by $0 .  predator sec. str prediction based\n";
								 print PRED_WRITE "\n\> $protein_name\n";
						 }else{
								 print "# written by $0 .  predator sec. str prediction based\n";
								 print "\n\> $protein_name\n";
						 }
						 for ($i=0; $i < @keys; $i++){
								 $position= $keys[$i];
								 if($put_reliability_line_in_PRED){
										 $each_reliability=int($hash{$position}->[2]*10);
										 if($each_reliability >= 9){
												 $each_reliability= '*';
												 $sec_str .= "\U$hash{$position}->[1]";
										 }elsif($each_reliability < 4 and $each_reliability > 0){
												 $sec_str .= $hash{$position}->[1];
										 }elsif($each_reliability >= 4){
												 $sec_str .= "\U$hash{$position}->[1]";
										 }elsif($each_reliability <= 0){ ## If the reliability is 0, Don't show the sec. str
												 $sec_str .='_';
										 }
										 $residue .= $hash{$position}->[0];
										 $reliability .= $each_reliability;
								 }else{
										 $residue .= $hash{$position}->[0];
										 $sec_str .= "\U$hash{$position}->[1]"; ## usually one of 'c h e'
								 }
						 }

						 if( $omit_coil_region){
								 $sec_str=~s/[Cc]/_/g;
						 }
						 if($graphical_rep_of_str){
								 $sec_str=~s/[Hh]/>/g;
								 $sec_str=~s/[Ee]/=/g;
								 $sec_str=~s/[Cc]/~/g;
								 $sec_str=~s/_/ /g;
						 }

						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
						 # writing down the 80 residue seq fragment
						 #______________________________________________________
						 $seq_ruler_line='         .         .         .         .         .         .         .         .';
						 for($i=0; $i< @keys; $i+= 80){
								 $each_seq_ruler_line=substr($seq_ruler_line, 0, @keys-$i-1);
								 $each_seq_fragment=substr($residue, $i, 80);
								 $each_str_fragment=substr($sec_str, $i, 80);
								 $end_seq_point=$i+length($each_seq_fragment);
								 unless($show_on_screen_only){
										 printf PRED_WRITE ("%5s %-80s %-5s\n", ' ', $each_seq_ruler_line, ' ');
										 printf PRED_WRITE ("%5s %-80s %-5s\n", $i+1, $each_seq_fragment, $end_seq_point);
								 }else{
										 printf  ("%5s %-80s %-5s\n", ' ', $each_seq_ruler_line, ' ');
										 printf ("%5s %-80s %-5s\n", $i+1, $each_seq_fragment, $end_seq_point);
								 }
								 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								 # if you want to put reliability index line
								 #____________________________________________
								 if($put_reliability_line_in_PRED){
										 $each_reliability_frag=substr($reliability, $i, 80);
										 if(! $show_on_screen_only){
												 printf PRED_WRITE ("%5s %-80s %-5s\n", ' ', $each_str_fragment, ' ');
												 printf PRED_WRITE ("%5s %-80s %-5s\n\n", ' ', $each_reliability_frag, ' ');
										 }else{
												 printf ("%5s %-80s %-5s\n", ' ', $each_str_fragment, ' ');
												 printf ("%5s %-80s %-5s\n\n", ' ', $each_reliability_frag, ' ');
										 }
								 }else{
										 if(! $show_on_screen_only){
												 printf PRED_WRITE ("%5s %-80s %-5s\n\n", ' ', $each_str_fragment, ' ');
										 }else{
												 printf ("%5s %-80s %-5s\n\n", ' ', $each_str_fragment, ' ');
										 }
								 }
						 }
						 close PRED_WRITE unless $show_on_screen_only;
	}
	if( $out_file_name_provided != 1){
	    print "\n\n# You didnt give out file name, $output_file  used\n" unless $show_on_screen_only;
	}
	if( -s $output_file ){
						if($verbose=~/\S/){ ## if v option is given, mesg is omitted to prevent comments to a redirected output
							 print "\n# Sequences were written in  $output_file " unless $show_on_screen_only;
						}
	}else{
						print "\n# The size of written outfile \"$output_file\" is 0, error \n\n"
	}
}


#________________________________________________________________________
# Title     : write_prdl_files
# Usage     :
#
# Function  :
# Example   :
#
# Warning   :
# Keywords  : write_predator_long_out_file
# Options   :
#   $protein_name= by n=
# Returns   :
# Argument  :
# Version   : 1.5
#--------------------------------------------------------------------
sub write_prdl_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#$| = 1;

		my($sort_seq_names, $string, $string_leng, $na,$out_file_name_provided,
			 $write_pure_seq_only, %one_to_three, $protein_name, $ext,
			 $num_of_residues, @DATE, $protein_name);
		my($output_file) ='default_out.prdl'; ### when no output file name is given, this is used
		$protein_name='temp_prdl';
		@DATE=@{&get_date};

		if($vars{'n'}=~/(\S+)/){ $protein_name=$1; }

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  If any input file has the prdl extension, I assume it is the output name
		#__________________________________________________________________________
		$ext='prdl';
		for($i=0; $i< @file; $i++){
				if($file[$i]=~/(\S+?)[\_fb]+$ext/ or $file[$i]=~/(\S+)$ext/){
						$output_file=$file[$i];
						$protein_name=$1;
				}
		}

		%one_to_three = (
			 "A", "ALA",  "C", "CYS",  "D", "ASP",  "E", "GLU",  "F", "PHE",
			 "G", "GLY",  "H", "HIS",  "I", "ILE",  "K", "LYS",  "L", "LEU",
			 "M", "MET",  "N", "ASN",  "P", "PRO",  "Q", "GLN",  "R", "ARG",
			 "S", "SER",  "T", "THR",  "V", "VAL",  "W", "TRP",  "Y", "TYR"
			 );

		if(@file>0){
				$output_file = $file[0];
				$out_file_name_provided=1;
		}elsif($protein_name){ $output_file="$protein_name\.prdl"
		}else{ $output_file='default_out.prdl'; }

		for ($n=0 ; $n < @hash; $n ++){
				 my(%hash, @keys, $mismatched_prediction_count, $matched_prediction_count,
						%mismatch_stats, @mismatch_stat_keys);

				 %hash=%{$hash[$n]};
				 $mismatched_prediction_count= $hash{'mismatched_prediction_count'};
				 $matched_prediction_count   = $hash{'matched_prediction_count'};
				 $num_of_residues=$hash{'num_of_residues'};
				 %mismatch_stats = %{$hash{'mismatch_stats'}};

				 delete($hash{'mismatch_stats'});
				 delete($hash{'mismatched_prediction_count'});
				 delete($hash{'matched_prediction_count'});
				 delete($hash{'number_of_residues'});

				 @keys= sort {$a <=> $b} keys %hash;
				 @mismatch_stat_keys = keys %mismatch_stats;

				 open (PRDL_WRITE,">$output_file");      # $string is the seq string.

				 print PRDL_WRITE "\n# Options used: $char_opt,  @DATE";
				 print PRDL_WRITE "\n# No of Forw Backward Mismatch pred. res/total: $mismatched_prediction_count /$num_of_residues\n";

				 if(@mismatch_stat_keys > 0){
						 for($i=0; $i< @mismatch_stat_keys; $i++){
								 $mismatch_predict_value=$mismatch_stats{$mismatch_stat_keys[$i]};
								 print PRDL_WRITE "# Mismatch stat: $mismatch_stat_keys[$i] $mismatch_predict_value\n";
						 }
				 }

				 print PRDL_WRITE "\nNAME $protein_name\n";
				 print PRDL_WRITE "HEADER  |- Residue -| Pred Rel   NAli Asn\n";

				 for ($i=1; $i < @keys; $i++){
						 $position= $keys[$i];
						 $residue = $hash{$position}->[0];
						 if($residue =~/[\.\_\- ]$/){ next } ## skipping gaps
						 $sec_str = $hash{$position}->[1]; ## usually one of 'c h e'
						 $reliability = $hash{$position}->[2];
						 if($reliability == 0){
								 $reliability='0.000';
						 }else{
								 $reliability=substr($reliability, 0, 5);
						 }
						 printf PRDL_WRITE ("PRED  %6s  %-3s  %-1s  %-1s    %-5s %-s    %-s\n",
																 $position, $one_to_three{$residue}, $residue,
																 $sec_str, $reliability, '0', '?');

				 }
				 close PRDL_WRITE;
		}
		if( $out_file_name_provided != 1){ print "\n\n# You didnt give out file name, $output_file  used\n";  }
		if( -s $output_file ){
				if($verbose=~/\S/){ ## if v option is given, mesg is omitted to prevent comments to a redirected output
					 print "\n# Sequences were written in  $output_file ";
				}
		}else{
				print "\n# The size of written outfile \"$output_file\" is 0, error \n\n"
		}
}



#________________________________________________________________________
# Title     : show_in_fasta
# Usage     : &show_hash_in_fasta(\%in1, \%in2, \%in3, .... );
#             takes a hash which has got names keys and sequences values.
#             uses Perl5 pointers(references).
# Function  : shows multiple seqs. in fasta format (takes one or more seq.!!)
# Example   : &show_in_fasta(\%hash);
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub show_in_fasta{ my($k, $name, $string);
		 for ($k=0; $k<=$#_; $k++){
					my(%input) = %{$_[$k]};
					for $name(keys %input){
								 my($ll)=0;                                                              # $output_file is the name of output.
								 $string=$input{$name};
								 $string=~s/\n//g;
								 $string=~tr/a-z/A-Z/;   # converts lower to upper cases.
								 print ">$name\n";             # this writes only one seq. in one file.
								 for($i=0; $i<length($string); $i+=60){
									 printf "%.60s\n", substr($string,$i,60);
								 }
								 print "\n";
					}
		 }
}


#______________________________________________________________________________
# Title     : show_FSSP_PAIR_TABLE_hash
# Usage     :
# Function  :
# Example   :
#    %FSSP_PAIR_TABLE_hash is assigned this way>>
#    $FSSP_PAIR_TABLE_hash{$REP_STR}{$PDB_str1}="$mutual_percent_sequence_identity";
# Keywords  : display_FSSP_PAIR_TABLE_hash, show_TABLE2_file
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub show_FSSP_PAIR_TABLE_hash{
    my (@representatives, %FSSP_PAIR_TABLE_hash, $i, $j);
    %FSSP_PAIR_TABLE_hash=%{$_[0]};
    @representatives=keys %FSSP_PAIR_TABLE_hash;
    for($i=0; $i< @representatives; $i++){
       print "\n$representatives[$i] ==================";
       @MEMBERS=keys %{$FSSP_PAIR_TABLE_hash{$representatives[$i]}};
       #@MEMBERS=$FSS_PAIR_TABLE_hash{$representatives[$i]};

       for($j=0; $j< @MEMBERS; $j++){
          print "\nREP: $representatives[$i] MEMBER: $MEMBERS[$j]";
       }
    }

}





#________________________________________________________________________
# Title     : One_To_Three_Letter  ( amino acid code change)
# Usage     : %one_letter  = %{&One_To_Three_Letter};   # takes no arguments (void).
# Function  : a hash of one letter to 3 letter amino acid code , returns a hash
# Example   :
# Warning   :
# Keywords  : 1_to_3
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub One_To_Three_Letter{  my(%one_letter) =
	( "A", "Ala",  "C", "Cys",  "D", "Asp",  "E", "Glu",  "F", "Phe",
	 "G", "Gly",  "H", "His",  "I", "Ile",  "K", "Lys",  "L", "Leu",
	 "M", "Met",  "N", "Asn",  "P", "Pro",  "Q", "Gln",  "R", "Arg",
	 "S", "Ser",  "T", "Thr",  "V", "Val",  "W", "Trp",  "Y", "Tyr"   );
	return(\%one_letter);
}
#________________________________________________________________________
# Title     : ONE_TO_THREE_LETTER  ( amino acid code change)
# Usage     : %one_letter  = %{&ONE_TO_THREE_LETTER };   # takes no arguments (void).
# Function  : a hash of one letter to 3 letter amino acid code , returns a hash
# Example   :
# Warning   :
# Keywords  : 1_to_3, convert_1_to_3_letter
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub ONE_TO_THREE_LETTER{  my(%one_letter) = (
	 "A", "ALA",  "C", "CYS",  "D", "ASP",  "E", "GLU",  "F", "PHE",
	 "G", "GLY",  "H", "HIS",  "I", "ILE",  "K", "LYS",  "L", "LEU",
	 "M", "MET",  "N", "ASN",  "P", "PRO",  "Q", "GLN",  "R", "ARG",
	 "S", "SER",  "T", "THR",  "V", "VAL",  "W", "TRP",  "Y", "TYR"   );
	return(\%one_letter);
}

#________________________________________________________________________
# Title     : one_to_three_letter  ( amino acid code change)
# Usage     : %one_letter  = %{&one_to_three_letter};   # takes no arguments (void).
# Function  : a hash of one letter to 3 letter amino acid code , returns a hash
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub one_to_three_letter{  my(%one_letter) = (
		"a", "ala",  "c", "cys",  "d", "asp",  "e", "glu",  "f", "phe",
		"g", "gly",  "h", "his",  "i", "ile",  "k", "lys",  "l", "leu",
		"m", "met",  "n", "asn",  "p", "pro",  "q", "gln",  "r", "arg",
		"s", "ser",  "t", "thr",  "v", "val",  "w", "trp",  "y", "tyr"   );
	 return(\%one_letter);
}


#________________________________________________________________________
# Title     : three_to_one_letter  ( amino acid code change)
# Usage     : %three_letter  = &three_to_one_letter ;   # takes no arguments (void).
# Function  : a hash of one letter to 3 letter amino acid code , returns a hash
# Example   :
# Warning   :
# Keywords  : 321, 3to1 3_to_1 THREE_TO_ONE_LETTER Three_To_One_Letter
#             convert_3_to_1, convert_3_to_1_aa_name
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub three_to_one_letter{  my(%aa);
		$aa{"ala"} = "a";  $aa{"met"} = "m";  $aa{"asp"} = "d";  $aa{"pro"} = "p";
		$aa{"cys"} = "c";  $aa{"asn"} = "n";  $aa{"glu"} = "e";  $aa{"gln"} = "q";
		$aa{"phe"} = "f";  $aa{"arg"} = "r";  $aa{"gly"} = "g";  $aa{"ser"} = "s";
		$aa{"his"} = "h";  $aa{"thr"} = "t";  $aa{"ile"} = "i";  $aa{"val"} = "v";
		$aa{"lys"} = "k";  $aa{"trp"} = "w";  $aa{"leu"} = "l";  $aa{"tyr"} = "y";

		$aa{"ALA"} = "A";  $aa{"MET"} = "M";  $aa{"ASP"} = "D";  $aa{"PRO"} = "P";
		$aa{"CYS"} = "C";  $aa{"ASN"} = "N";  $aa{"GLU"} = "E";  $aa{"GLN"} = "Q";
		$aa{"PHE"} = "F";  $aa{"ARG"} = "R";  $aa{"GLY"} = "G";  $aa{"SER"} = "S";
		$aa{"HIS"} = "H";  $aa{"THR"} = "T";  $aa{"ILE"} = "I";  $aa{"VAL"} = "V";
		$aa{"LYS"} = "K";  $aa{"TRP"} = "W";  $aa{"LEU"} = "L";  $aa{"TYR"} = "Y";
	 return(\%aa);
}


#________________________________________________________________________
# Title     : convert_3_to_1_letter
# Usage     : %three_letter  = &three_to_one_letter ;   # takes no arguments (void).
# Function  : a hash of one letter to 3 letter amino acid code , returns a hash
# Example   :
# Warning   :
# Keywords  : 321, 3to1 3_to_1 THREE_TO_ONE_LETTER Three_To_One_Letter
#             convert_3_to_1, convert_3_to_1_aa_name, convert_three_to_one_letter
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub convert_3_to_1_letter{
    my(%aa, $seq, $file, @AAs, $i);
    $file=$_[0];
    $aa{"ala"} = "a";  $aa{"met"} = "m";  $aa{"asp"} = "d";  $aa{"pro"} = "p";
    $aa{"cys"} = "c";  $aa{"asn"} = "n";  $aa{"glu"} = "e";  $aa{"gln"} = "q";
    $aa{"phe"} = "f";  $aa{"arg"} = "r";  $aa{"gly"} = "g";  $aa{"ser"} = "s";
    $aa{"his"} = "h";  $aa{"thr"} = "t";  $aa{"ile"} = "i";  $aa{"val"} = "v";
    $aa{"lys"} = "k";  $aa{"trp"} = "w";  $aa{"leu"} = "l";  $aa{"tyr"} = "y";
    $aa{"ALA"} = "A";  $aa{"MET"} = "M";  $aa{"ASP"} = "D";  $aa{"PRO"} = "P";
    $aa{"CYS"} = "C";  $aa{"ASN"} = "N";  $aa{"GLU"} = "E";  $aa{"GLN"} = "Q";
    $aa{"PHE"} = "F";  $aa{"ARG"} = "R";  $aa{"GLY"} = "G";  $aa{"SER"} = "S";
    $aa{"HIS"} = "H";  $aa{"THR"} = "T";  $aa{"ILE"} = "I";  $aa{"VAL"} = "V";
    $aa{"LYS"} = "K";  $aa{"TRP"} = "W";  $aa{"LEU"} = "L";  $aa{"TYR"} = "Y";
    open(SEQ_FILE, "<$file") || die;
    while(<SEQ_FILE>){
      if(@AAs=/(\S\S\S)/g){
         for($i=0; $i< @AAs; $i++){
            $seq.=$aa{$AAs[$i]};
         }
      }
    }
    #print "\n$seq\n";
    close(SEQ_FILE);
    return(\$seq);
}

#________________________________________________________________________
# Title     : convert_1_to_3_letter
# Usage     : %three_letter  = &three_to_one_letter ;   # takes no arguments (void).
# Function  : a hash of one letter to 3 letter amino acid code , returns a hash
# Example   :
# Warning   :
# Keywords  : 123, 1to3 1_to_3 one_TO_three_LETTER One_To_Three_Letter
#             convert_1_to_3, convert_1_to_3_aa_name
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub convert_1_to_3_letter{  my(%aa);
		$aa{"a"} = "ala";  $aa{"m"} = "met";  $aa{"d"} = "asp";  $aa{"p"} = "pro";
		$aa{"c"} = "cys";  $aa{"n"} = "asn";  $aa{"e"} = "glu";  $aa{"q"} = "gln";
		$aa{"f"} = "phe";  $aa{"r"} = "arg";  $aa{"g"} = "gly";  $aa{"s"} = "ser";
		$aa{"h"} = "his";  $aa{"t"} = "thr";  $aa{"i"} = "ile";  $aa{"v"} = "val";
		$aa{"k"} = "lys";  $aa{"w"} = "trp";  $aa{"l"} = "leu";  $aa{"y"} = "tyr";
		return(\%aa);
}



#________________________________________________________________________
# Title     : amino_acid_compos_id_percent
# Usage     : $percent = &amino_acid_compos_id_percent (%any_hash_with_sequences);
#             The way identity(composition) is derived is;
#
# Function  : gets amino acid composition identity of any given
#             number of sequences(at least 2).
# Example   :
# Warning   :
# Keywords  : get_amino_acid_composition, get_protein_composition, composition
# Options   :
# Argument  : hash of at least 2 sequences.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub amino_acid_compos_id_percent{
	my(%input)= %{$_[0]};
	my(@names)=keys (%input);
	my(@temp, $i, $j, $iden, @all_pairs_id, $iden_sum);
	my(%compos_table1, %compos_table2, $final_iden, $larger);
	for ($i=0; $i < @names; $i ++){  # putting seqs in arrays.
	 $input{$names[$i]}=~ tr/a-z/A-Z/;
	 $input{$names[$i]}=~ s/\W//g;
	 @{"string$i"}= split('', $input{$names[$i]});
	 $larger = @{"string$i"} if @{"string$i"} > $larger;
	}
	for ($i=0; $i < @names; $i++){   # to make permutated pairs.
	 for ($j=$i; $j < @names; $j ++){
		if ($j == $i){ next; }
		for ($k=0; $k < $larger; $k ++){  # getting composition tables for two seqs.
		  $compos_table1{${"string$i"}[$k]}++ if (${"string$i"}[$k] =~ /\w/);
		  $compos_table2{${"string$j"}[$k]}++ if (${"string$j"}[$k] =~ /\w/);
		}
		$iden = ${&common_compos_id_hash(\%compos_table1, \%compos_table2)};
		%compos_table1=();  %compos_table2=();
		push (@all_pairs_id,  $iden );
	 }
	}
	for $iden (@all_pairs_id){  $iden_sum+= $iden;  }
	if(@all_pairs_id == 0){ @all_pairs_id =1; }
	$final_iden=$iden_sum/@all_pairs_id;
	\$final_iden;
}

#________________________________________________________________________
# Title     : seq_id_percent_array  (more than 2 elements array)
# Usage     : $percent = &seq_id_percent_array(@any_array_sequences);
#             The way identity(pairwise) is derived is;
#
# Function  : produces amino acid composition identity of any given number of sequences.
# Example   :
# Warning   : This can handle 'common gaps' in the sequences
# Keywords  : get_percent_composition_identity, seq_composition_identity,
#             percent_sequence_composition_id
#
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub seq_id_percent_array{
	my(@input, $denominator,@all_pairs_id, $percent_id);
	my($largest,$p,$i,$j,$k,$iden_residue_num,$iden,@temp,$iden_sum,$gap_num,$final_iden);
	for($d=0; $d<@_; $d++){
		if(ref($_[$d]) eq 'ARRAY'){ @input=@{$_[$d]}; }
		elsif( (ref($_[$d]) eq 'SCALAR') &&( ${$_[$d]}=~/^[aA]/) ){ $average_len_opt =1 }
		elsif( !(ref($_[$d])) && ( $_[$d] =~/^[aA]/) ){ $average_len_opt =1 } }
	if ((@input== 1)||( @input== 0)){
		print "\n\n \" $0 \"  requires at least 2 sequences\n\n";
		print "\n Abnormally dying at seq_id_percent_array in $0 \n\n";
		print chr(7); die;}
	$shortest=length($input[0]);
	my($sans_gap_seq, $length_sum, $average_seq_len);
	for($p=0; $p < @input; $p++){
		$input[$p]=~ tr/a-z/A-Z/;
		$sans_gap_seq=$input[$p];
		$sans_gap_seq=~s/\W//g;
		$input[$p]=~ s/\W/./g;
		(@{"string$p"})=split(//, $input[$p]);
		$largest = length($input[$p]) if length($input[$p]) > $largest;
		$shortest = length($sans_gap_seq) if length($sans_gap_seq) < $shortest;
		$length_sum += length($sans_gap_seq);
	}
	$average_seq_len = $length_sum/@input;
	for($i=0; $i< @input; $i++){
		for($j=$i+1; $j< @input; $j++){
			for ($k=0; $k <  $largest; $k ++){  # getting composition tables for two seqs.
				if ((${"string$i"}[$k] !~ /\W/)&&(${"string$i"}[$k] eq ${"string$j"}[$k])){
					$iden_residue_num++; }
				elsif((${"string$i"}[$k] =~ /\W/)&&(${"string$i"}[$k]=~ /\W/)){ $gap_num++; }}
			if( $average_len_opt == 1){ $denominator = $average_seq_len; }
			else{ $denominator = $shortest; }
			if($denominator == 0){ $denominator=1; }  # in the above it is 50% rather than 0.07%
			$percent_id=($iden_residue_num/($denominator))*100;
			push(@all_pairs_id, $percent_id);
			$iden_residue_num=$gap_num='';
		}
	}
	for (@all_pairs_id){  $iden_sum+=$_;    }
	$final_iden=$iden_sum/($#all_pairs_id+1);
	return( \$final_iden );
}

#________________________________________________________________________
# Title     : compos_id_percent_array  (more than 2 elements array)
# Usage     : $percent = &compos_id_percent_array(@any_array_sequences);
#             The way identity(composition) is derived is;
# Function  : produces amino acid composition identity of any given number of sequences.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub compos_id_percent_array{
	 my(@input)=@{$_[0]};
	 my($largest,$iden,@temp,$iden_sum,$final_iden, @all_pairs_id);
	for($i=0; $i<=$#input; $i++){  $input[$i]=~ tr/a-z/A-Z/;  $input[$i]=~ s/[\.\-\s]//g;
		@temp = split('', $input[$i]);  (@{"string$i"})= @temp;
		$largest = @{"string$i"} if @{"string$i"} > $largest;    }
	for($i=0; $i< @input; $i++){ #_________ permutating ___________
		for($j=$i+1; $j<=$#input; $j++){
			for ($k=0; $k <= $largest; $k ++){  # getting composition tables for two seqs.
				$compos_table1{${"string$i"}[$k]}++ if (${"string$i"}[$k] =~ /\w/);
				$compos_table2{${"string$j"}[$k]}++ if (${"string$j"}[$k] =~ /\w/);   }
			$iden =${&calc_compos_id_hash(\%compos_table1, \%compos_table2)};
			push(@all_pairs_id, $iden);  %compos_table1=();  %compos_table2=();   }   }
	for $iden (@all_pairs_id){  $iden_sum+=$iden;  }
	$final_iden=$iden_sum/(@all_pairs_id);
	#-----------------------------------------------------
	#  Input here is like :  %hash1= (A,3,B,3,C,4,D,4), %hash2= (A,4,B,1,C,4)
	sub  calc_compos_id_hash{  # input is like this;
	  my(%hash1)=%{$_[0]};
	  my(%hash2)=%{$_[1]};
	  my(%common_of_the_2)=();
	  my($common, $compos_id, $sum_residues, $sum_of_the_common_residue_no);
	  my(@values1) = values (%hash1);
	  my(@values2) = values (%hash2);
	  my(@combined_values)=(@values1,@values2);
	  for $elem (@combined_values){  $sum_residues += $elem;   }
	  if($sum_residues == 0){ $compos_id =0; } # to prevent Illegal division error.
	  else{ for $key1(keys %hash1){
				 $common=&smaller_one($hash1{$key1}, $hash2{$key1});
					 sub smaller_one{if ($_[0] > $_[1]){ $_[1];}else{$_[0];}}
				 $sum_of_the_common_residue_no += $common;     }
			 $compos_id = $sum_of_the_common_residue_no/($sum_residues/2)*100;   }
	  \$compos_id;
	}
	#-----------------------------------------------------
	return ( \$final_iden ); # final identity for any given set of strings(seq).
}

#________________________________________________________________________________
# Title     : compos_id_percent_hash  (synonym of amino_acid_compos_id_percent)
# Usage     : $percent = &compos_id_percent_hash(%any_hash_with_sequences);
#             The way identity(composition) is derived is;
#
# Function  : gets amino acid composition identity of any given number of sequences.
# Example   :
# Warning   :
# Keywords  : get_amino_acid_composiiton
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub compos_id_percent_hash{ my(%input, @names);
	if(ref($_[0]) eq 'HASH'){  %input= %{$_[0]}; @names= keys  %input;  }
	else{ print "\n hash ref was not passed to compos_id_percent_hash\n"; die; }
	my(@temp, $iden, @all_pairs_id, $i, $j, $k,$iden_sum);
	my(%compos_table1, %compos_table2, $final_iden, $larger);
	for ($i=0; $i < @names; $i ++){  $input{$names[$i]}=~ tr/a-z/A-Z/;
	 $input{$names[$i]}=~ s/\W//g;    @temp = split('', $input{$names[$i]});
	 (@{"string$i"})=@temp; $larger = @{"string$i"} if @{"string$i"}>$larger;}
	for ($i=0; $i < @names; $i++){
	 for ($j=$i; $j < @names; $j ++){
		if ($j == $i){ next; }
		for ($k=0; $k < $larger; $k ++){
		  $compos_table1{${"string$i"}[$k]}++ if (${"string$i"}[$k] =~ /\w/);
		  $compos_table2{${"string$j"}[$k]}++ if (${"string$j"}[$k] =~ /\w/); }
		$iden = ${&common_compos_id_hash(\%compos_table1, \%compos_table2)};
		%compos_table1=(); %compos_table2=(); push (@all_pairs_id, $iden); }}
	for $iden (@all_pairs_id){ $iden_sum+=$iden; }
	$final_iden=$iden_sum/(@all_pairs_id);
	return(\$final_iden);
}
#________________________________________________________________________
# Title     : common_compos_id_hash (BUG free)
# Usage     : %hash = &common_compos_hash(\%any_hash1, \%any_hash1);
# Function  : actual calculation of identity
# Example   : ('A', 200, 'C', 191, D, 99)
#                  ('A', 290, 'C', 199, D, 100)
#             uses only two sequences.
# Warning   :
# Keywords  :
# Options   :
# Returns   : ref. of a scaler (in percent)  eg)  95
# Argument  : two references of hash of seqeunces.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub  common_compos_id_hash{
	my(%hash1)=%{$_[0]};
	my(%hash2)=%{$_[1]};
	my(%common_of_the_2)=();  my($common, $compos_id, $sum_of_the_common_residue_no);
	my(@values1) = values (%hash1);  my(@values2) = values (%hash2);
	my(@combined_values)=(@values1, @values2);
	my($sum_residues) = ${&sum_array(\@combined_values)};
	for $key1(keys %hash1){
	 $common=&smaller_one($hash1{$key1}, $hash2{$key1});
	 sub smaller_one{if ($_[0] > $_[1]){ $_[1];}else{$_[0];}}
	 $sum_of_the_common_residue_no += $common;
	}
	if( $sum_residues == 0){ $sum_residues =1 }
	$compos_id = $sum_of_the_common_residue_no/($sum_residues/2)*100;
	\$compos_id;
}


#________________________________________________________________________
# Title     : calc_compos_id_hash (the same as 'common_compos_hash')
# Usage     : %hash = &calc_compos_hash(\%any_hash1, \%any_hash1);
# Function  : actual calculation of identity
# Example   : ('A', 200, 'C', 191, D, 99)
#                  ('A', 290, 'C', 199, D, 100)
#             uses only two sequences.
# Warning   :
# Keywords  :
# Options   :
# Returns   : ref. of a scaler (in percent)  eg)  95
# Argument  : two references of hash of seqeunces.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub  calc_compos_id_hash{ my(%hash1)=%{$_[0]}; my(%hash2)=%{$_[1]}; my(%common_of_the_2)=();
	  my($common, $compos_id, $sum_residues, $sum_of_the_common_residue_no);
	  my(@values1) = values (%hash1);   my(@values2) = values (%hash2);
	  my(@combined_values)=(@values1,@values2);
	  for $elem (@combined_values){
			$sum_residues += $elem;   }
	  if($sum_residues == 0){ $compos_id =0; } # to prevent Illegal division error.
	  else{
		  for $key1(keys %hash1){
			  $common=&smaller_one($hash1{$key1}, $hash2{$key1});
				  sub smaller_one{if ($_[0] > $_[1]){ $_[1];}else{$_[0];}}
			  $sum_of_the_common_residue_no += $common;     }
		  $compos_id = $sum_of_the_common_residue_no/($sum_residues/2)*100;   }
	  \$compos_id;
}
#________________________________________________________________________
# Title     : get_percentage
# Usage     : %out= %{&get_percentage(\%result, '1')};
# Function  : calculates the percentage content of any single char over the whole
#             length of strings in it.
# Example   : if the string is  'seq  ABCDEEEEEFFEFE' given in a hash
#             if you put 'A' as one argument, it counts the occurances of 'A'
#             and gets the percentage of it.
# Warning   : This converts array and string input as ref. into arbitrary hash and
#             returns hash
#             programmed by A Biomatic
# Keywords  : get_percentage_of_char
# Options   : None yet.
# Returns   : Numerical Percentage
# Argument  : ref. for Scalar string or Array of chars or Hash  AND 'the target char'
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_percentage{
	my(@in, $k, $sort, $numerator, $residue, @out_hash_ref, %hash_out );
	for($k=0; $k< @_ ;$k++){
	  if( !ref($_[$k])&& (length($_[$k]) == 1 )){
		 $numerator = $_[$k];
	  }
	  elsif( (ref($_[$k]) eq 'SCALAR') && (length(${$_[$k]}) == 1 )){
		 $numerator = ${$_[$k]};
	  }
	  elsif(ref($_[$k]) eq "HASH")  { push(@in, $_[$k]); }
	  elsif(ref($_[$k]) eq "ARRAY") { push(@in, &convert_arr_and_str_2_hash($_[$k], $k));} #<-- conv array to hash.
	  elsif(ref($_[$k]) eq "SCALAR"){ push(@in, &convert_arr_and_str_2_hash($_[$k], $k));} #<-- conv array to hash.
	}
	####### final output is => @in of hash ref elements #######
	for (@in){   my(%H) = %{$_}; my(@keys)= sort keys %H;
	 for $name(@keys){
		 my($numerator_count);
		 my($seq_len) = length($H{$name}); print  "\n $name Sequence length: ", $seq_len, "\n";
		 my(@string) = split(//, $H{$name});
		 for $residue (@string){  if($residue =~/^$numerator$/){ $numerator_count ++; }}
		 my($percent) = $numerator_count/$seq_len *100;
		 $hash_out{$name}=$percent;    }
	 push(@out_hash_ref, \%hash_out);  }
	if(@out_hash_ref ==1){ return($out_hash_ref[0]); }
	elsif( @out_hash_ref > 1){ return(@out_hash_ref); }
}


#________________________________________________________________________
# Title     : pairwise_percent_id  (pairwise sequence identity in percentage)
# Usage     : $identity = ${&pairwise_percent_id(%arrayinput)};
#
# Function  : takes a ref. of a hash of names and sequences, returns
#             percent identity.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pairwise_percent_id{
	my($i,$j,$k, @iden_array_ref);
	for($i=0; $i< @_; $i++){  my %input= %{$_[$i]};  my @names= sort keys %input;
	  my(@temp, $iden, @all_pairs_id, $whole_seq_len, $residue_sum1,$residue_sum2);
	  my($final_av_iden, $larger, $percent_for_pair,@percent_for_pair, $iden_sum);
	  for ($i=0; $i < @names; $i ++){ $input{$names[$i]}=~ tr/a-z/A-Z/;
		 @temp = split('', $input{$names[$i]});  (@{"string$i"})=@temp;
		 $larger = @{"string$i"} if @{"string$i"} > $larger; }
			 for ($i=0; $i < @names; $i++){       # to make permutated pairs.
				for ($j=$i+1; $j < @names; $j ++){
					for ($k=0; $k < $larger; $k ++){  # getting composition tables for two seqs.
					  $iden+=2 if ((${"string$i"}[$k] eq ${"string$j"}[$k])&&(${"string$i"}[$k] =~ /\w/));
					  $residue_sum1++ if (${"string$i"}[$k] =~ /\w/);
					  $residue_sum2++ if (${"string$j"}[$k] =~ /\w/);  }
					$whole_seq_len =($residue_sum1+$residue_sum2);
					$percent_for_pair = $iden/$whole_seq_len*100;
					push(@percent_for_pair,$percent_for_pair);
					$residue_sum1=0; $residue_sum2=0; $iden=0; } }
			 for $iden (@percent_for_pair){ $iden_sum+=$iden;}
	  $final_av_iden=$iden_sum/( @percent_for_pair );
	  push(@iden_array_ref, \$final_av_iden);  }
	if(@iden_array_ref ==1){ return($iden_array_ref[0]);}else{ return(@iden_array_ref);}
}


#________________________________________________________________________
# Title     : get_seq_identity
# Usage     : $identity = ${&get_seq_identity(%arrayinput)};
#
# Function  : takes a ref. of a hash of names and sequences, returns
#             percent identity. NOT composition identity.
#
#             This is different from get_alignment_seq_identity which checks
#             for only aligned region seq ID.
# Example   :
# Warning   :
# Keywords  : get_sequence_identity calculate_sequence_identity, calc_sequence_id
#             get_seq_id, get_seq_ID
# Options   :
# Returns   :
# Argument  : hash(es) of sequences.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_seq_identity{
	my($i,$j,$k, $c, @iden_array_ref);
	for($c=0; $c< @_; $c++){
	  my %input= %{$_[$c]};
	  my @seq_names= sort keys %input;
	  my(@temp, $iden, @all_pairs_id, $whole_seq_len, $residue_sum1, $residue_sum2,
	     $final_av_iden, $larger, $percent_for_pair,@percent_for_pair, $iden_sum);
      for ($i=0; $i < @seq_names; $i ++){
		 $input{$seq_names[$i]}=~ tr/a-z/A-Z/;
		 @temp = split(//, $input{$seq_names[$i]});
		 @{"string$i"}=@temp;
		 $larger = @{"string$i"} if @{"string$i"} > $larger; }
		 for ($i=0; $i < @seq_names; $i++){       # to make permutated pairs.
			for ($j=$i+1; $j < @seq_names; $j ++){
				for ($k=0; $k < $larger; $k ++){
				  if ( ${"string$i"}[$k] eq ${"string$j"}[$k] and ${"string$i"}[$k] =~ /\w/){
					 $iden+=2 ;
				  }
				  $residue_sum1++ if (${"string$i"}[$k] =~ /\w/);
				  $residue_sum2++ if (${"string$j"}[$k] =~ /\w/);
				}
				$whole_seq_len =($residue_sum1 + $residue_sum2);
				$percent_for_pair = $iden/$whole_seq_len*100;
				push(@percent_for_pair,$percent_for_pair);
				$residue_sum1=0;
				$residue_sum2=0;
				$iden=0;
			}
		 }
	  for $iden (@percent_for_pair){
		  $iden_sum+=$iden;
	  }
	  if(@percent_for_pair <1){ @percent_for_pair=(1); }
	  $final_av_iden=$iden_sum/( @percent_for_pair );
	  push(@iden_array_ref, \$final_av_iden);
      @{"string$i"}=();
	}
	if(@iden_array_ref ==1){
	   return($iden_array_ref[0]);
	}else{
	   return(@iden_array_ref);
	}
}


#________________________________________________________________________
# Title     : get_alignment_seq_identity
# Usage     : $identity = ${&get_seq_identity(%arrayinput)};
#
# Function  : takes a ref. of a hash of names and sequences, returns
#             percent identity. NOT composition identity.

# Example   :
# Warning   :
# Keywords  : get_sequence_identity calculate_sequence_identity, calc_sequence_id
#             get_seq_id, get_seq_ID, block_sequence_identity
# Options   :
# Returns   :
# Argument  : hash(es) of sequences.
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_alignment_seq_identity{
	my($i,$j,$k, $c, @iden_array_ref);
	for($c=0; $c< @_; $c++){
	  my %input= %{$_[$c]};
	  my @seq_names= sort keys %input;
	  my(@temp, $iden, @all_pairs_id, $residue_sum,
	     $final_av_iden, $larger, $percent_for_pair,@percent_for_pair, $iden_sum);
      for ($i=0; $i < @seq_names; $i ++){
		 $input{$seq_names[$i]}=~ tr/a-z/A-Z/;
		 @temp = split(//, $input{$seq_names[$i]});
         @{"string$i"}=@temp;
		 $larger = @{"string$i"} if @{"string$i"} > $larger; }
		 for ($i=0; $i < @seq_names; $i++){       # to make permutated pairs.
			for ($j=$i+1; $j < @seq_names; $j ++){
                for ($k=0; $k < $larger; $k ++){
                    if(${"string$i"}[$k] =~ /\w/ and ${"string$j"}[$k] =~ /\w/){
                        if ( ${"string$i"}[$k] eq ${"string$j"}[$k] and ${"string$i"}[$k] =~ /\w/){
                           $iden++ ;
                        }
                        $residue_sum++;
                    }
				}
				if($residue_sum){
                    $percent_for_pair = $iden/$residue_sum*100;
                    push(@percent_for_pair, $percent_for_pair);
                    $residue_sum=$iden=0;
				}else{
				    push(@percent_for_pair, 0); $iden=0;
				}
			}
		 }
	     for $iden (@percent_for_pair){
		     $iden_sum+=$iden;
	     }
	     if(@percent_for_pair <1){ @percent_for_pair=(1); }
	     $final_av_iden=$iden_sum/( @percent_for_pair );
	     push(@iden_array_ref, \$final_av_iden);
         @{"string$i"}=();
	}
	if(@iden_array_ref ==1){
	   return($iden_array_ref[0]);
	}else{
	   return(@iden_array_ref);
	}
}







#________________________________________________________________________
# Title     : get_correct_percent_alignment_rate  (made for Bissan)
# Usage     : &get_correct_percent_alignment_rate(\$file1, \$file2);
# Function  : accepts two files and prints out the sequence identities of the alignment.
# Example   :
# Warning   : Alpha version,  A Biomatic , made for Bissan
# Keywords  :
# Options   : h  # for help
#             v  # for verbose printouts(prints actual sequences)
# Returns   : reference of Scalar for percentage correct alignment(for already
#             aligned sequences)
# Argument  : two sequence files which have identical sequence names.
# Category  :
# Version   :
#--------------------------------------------------------------------
sub get_correct_percent_alignment_rate{
	 my($i, $j, $k, $verbose, @string1, @string2, $larger, $seq_pair_id, @seq_pair_ids );
	 my(%inputhash1) = %{&read_any_seq_files($_[0])};
	 my(%inputhash2) = %{&read_any_seq_files($_[1])};
	 my(@names)= sort keys %inputhash1;
	 ######################################
	 ####### Sub argument handling ########
	 ######################################
	 for($k=0; $k< @_ ;$k++){
		if( !ref($_[$k])&& (length(${$_[$k]}) < 5)){  # when inputs are not ref.
		  if($_[$k]=~ /^[\-vV]$/){ $verbose = 1; next;}
		}
		elsif((ref($_[$k]) eq "SCALAR")&&(length(${$_[$k]})<5)){  #  when inputs are  ref.
		  if(${$_[$k]}=~ /^[\-vV]$/){$verbose = 1;next;}          # should shorter than 5
		}
	 }
	 for($i =0; $i < @names; $i++){
		print "\n\n==== Processing structural $names[$i] against artificial $names[$i]\n";
		$inputhash1{$names[$i]} =~ tr/a-z/A-Z/;
		$inputhash2{$names[$i]} =~ tr/a-z/A-Z/;
		@string1=split(//, $inputhash1{$names[$i]});
		@string2=split(//, $inputhash2{$names[$i]});
		print "\n The string1 is  ",@string1,"\n" if $verbose ==1;
		print "\n The string2 is  ",@string2,"\n" if $verbose ==1;
		(@string2 > @string1) ? ($larger=@string2, $smaller=@string1) : ($larger=@string1, $smaller=@string2);
		$true_seq=$inputhash1{$names[$i]};
		$true_seq=~s/\W//g;
		$true_len=length($true_seq);
		print "\n True seq length:   $true_len  , Whole length inc gap: $larger\n";
		for($j = 0; $j < $larger; $j++){
		  $iden_sum++ if ($string1[$j] eq $string2[$j])&& !($string1[$j]=~/\W/); }
		$seq_pair_id =($iden_sum/$true_len) * 100;
		print "\nID between structural and artifical alignment is  $seq_pair_id \%" , "\n";
		push(@seq_pair_ids, $seq_pair_id);
		$iden_sum=$seq_pair_id='';
	 }
	 print "\n", "_"x88, "\n";
	 my($whole_average_of_the_id)=${&array_average(\@seq_pair_ids)};
	 print "The whole average is; $whole_average_of_the_id\n";
	 if(@seq_pair_ids == 1){ return( \$seq_pair_ids[0] ); }
	 elsif(@seq_pair_ids > 1){ return( \@seq_pair_ids ); }
}


#________________________________________________________________________
# Title     : amino_acid_compos_id_percent_trend
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub amino_acid_compos_id_percent_trend{
	my(%input) = %{$_[0]};
	my(@common, @string,@accumu_percent_iden)=(); my(%common_so_far, %compos_table);
	my($percent_id_so_far, $length_of_one_seq,$length_of_all_seq, $seq_no)=0;
	for $key(keys %input){
			$input{$key}=~s/[. \d-]//g;
			@string= split(//, $input{$key});
			print @string; print "\n";
			$length_of_one_seq = $#string+1;
			$length_of_all_seq +=$length_of_one_seq;
			$seq_no += 1;
			%compos_table  = &composition_table(@string);
			@check = keys (%common_so_far);
			if  ($#check < 0){ %common_so_far = %compos_table; }
			else{ %common_so_far= %{&common_compos_2_hash(\%common_so_far,\%compos_table)};}
			for $value(values %common_so_far){ $common_residue_sum +=$value; }
			$final_percent_id = $common_residue_sum/($length_of_all_seq/$seq_no)*100;
			$common_residue_sum =0;  }
	for $value(values %common_so_far){ $common_residue_sum +=$value; }
	$final_percent_id = $common_residue_sum/($length_of_all_seq/$seq_no)*100;
	return(\$final_percent_id);
}

#________________________________________________________________________
# Title     : composition_table   (can handle both nucleic and protein seq)
# Usage     : %output = %{&compos_table(@input_array1, @input_array2,,,,)};
#             example input
#
# Function  : returns a table of alphabet with occurances.
#             can handle any char, this converts char to upper case.
# Example   :
# Warning   : converts all SMALL letters to Capital letters before counting!!
# Keywords  :
# Options   :
# Returns   : %hash1 = ('A',3, 'C',2, 'D',1, 'Q',2, 'S',1), %hash2,,,
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub composition_table{
	my($i, @input,%input,$input,$j,@ref_out);
	for($i=0;$i<@_; $i++){
	 my(%alphabet)=();
	 if( ref($_[$i]) eq 'ARRAY'){ @input=@{$_[$i]}; undef(%alphabet);
		 for ($j=0; $j<=$#input; $j++){ $input[$j] =~ tr/a-y/A-Y/;
			 $alphabet{$input[$j]}+=1 if ($input[$j] =~/[A-Y]/) }
		 push(@ref_out, \%alphabet); }
	 elsif( ref($_[$i]) eq 'HASH'){ %input=%{$_[$i]};@input=keys %input;undef(%alphabet);
		 for ($j=0; $j< @input; $j++){ $input[$j] =~ tr/a-y/A-Y/;
			 $alphabet{$input[$j]}+=1 if ($input[$j] =~/[A-Y]/) }
		 push(@ref_out, \%alphabet); }
	 elsif( ref($_[$i]) eq 'SCALAR'){ $input=${$_[$i]}; $input=s/\,//g if $input=~/\,/;
		 @input=split('', $input); undef(%alphabet);
		 for ($j=0; $j<@input; $j++){ $input[$j] =~ tr/a-y/A-Y/;
			 $alphabet{$input[$j]}+=1; }
		 push(@ref_out, \%alphabet); }    }
	if(@ref_out ==1){
	 return($ref_out[0]);
	}else{ return(@ref_out); }
}

#________________________________________________________________________
# Title     : common_compos_2_hash
# Usage     : %hash = &common_compos_hash(\%any_hash1, \%any_hash1);
# Function  :
# Example   : common gaps means only '.' (dots, not alphabets!!)
#             AAA....BBCB
#             AAAB..B.BCC  --> A.A.....BC. (as in an array)
#             A.AAA...BCA
# Warning   :
# Keywords  :
# Options   :
# Returns   : a hash (string1, number1, string2, number2, string3, number3, ...)
# Argument  : two references of hash of seqeunces.
# Category  :
# Version   :
#--------------------------------------------------------------------
sub  common_compos_2_hash{ my(%hash1)=%{$_[0]}; my(%hash2)=%{$_[1]};
	my(%common_of_the_2)=(); my($common)=0;
	for $key1(keys %hash1){
	 $common=&smaller_one($hash1{$key1}, $hash2{$key1});
	 if ($common =~ /\d+/){
		$common_of_the_2{$key1}=$common; } }
	\%common_of_the_2;
}

#________________________________________________________________________
# Title     : get_pairwise_percent_id
# Usage     : $identity = ${&get_pairwise_percent_id(\%arrayinput)};
#
# Function  : takes a ref. of a hash of names and sequences, returns
#             percent identity.
# Example   :
#             %hash=('seq1', 'ASDFASFDASDFDSA',
#             			 'seq2', 'DFDFADFAFAFDAFA');
#              print ${&get_pairwise_percent_id(\%hash)}, "\n";
#
# Warning   :
# Class     :
# Keywords  : calc_pairwise_percent_id, calc_pairwise_percent_id_hash
# Options   :
# Argument  :
# Author    : A Biomatic
# Version   : 1.0
#--------------------------------------------------------------------
sub get_pairwise_percent_id{
		my($i,$j,$k, @iden_array_ref);
		for($i=0; $i< @_; $i++){
			 my %input= %{$_[$i]};
			 my @names= sort keys %input;
			 my(@temp, $iden, @all_pairs_id, $whole_seq_len, $residue_sum1,$residue_sum2,
					$final_av_iden, $larger, $percent_for_pair,@percent_for_pair, $iden_sum);
			 for ($i=0; $i < @names; $i ++){
					$input{$names[$i]}=~ tr/a-z/A-Z/;
					@temp = split('', $input{$names[$i]});  (@{"string$i"})=@temp;
					$larger = @{"string$i"} if @{"string$i"} > $larger;
			 }
			 for ($i=0; $i < @names; $i++){       # to make permutated pairs.
				 for ($j=$i+1; $j < @names; $j ++){
					 for ($k=0; $k < $larger; $k ++){  # getting composition tables for two seqs.
						 $iden+=2 if ((${"string$i"}[$k] eq ${"string$j"}[$k])&&(${"string$i"}[$k] =~ /\w/));
						 $residue_sum1++ if (${"string$i"}[$k] =~ /\w/);
						 $residue_sum2++ if (${"string$j"}[$k] =~ /\w/);
					 }
					 $whole_seq_len =($residue_sum1+$residue_sum2);
					 $percent_for_pair = $iden/$whole_seq_len*100;
					 push(@percent_for_pair,$percent_for_pair);
					 $residue_sum1=0; $residue_sum2=0; $iden=0;
				 }
			 }
			 for $iden (@percent_for_pair){ $iden_sum+=$iden; }
			 $final_av_iden=$iden_sum/( @percent_for_pair );
			 push(@iden_array_ref, \$final_av_iden);
		}
		if(@iden_array_ref ==1){
		    return($iden_array_ref[0]);
		}else{
		    return(@iden_array_ref);
		}
}


#________________________________________________________________________
# Title     : pair_percent_id_trend
# Usage     : @array = &pair_percent_id_trend (%arrayinput);
# Function  :
# Example   : common gaps means only '.' (dots, not alphabets!!)
#             AAA....BBCB
#             AAAB..B.BCC  --> A.A.....BC. (as in an array)
#             A.AAA...BCA
#             The resulting array XXXXX..XXXX is literally like so.
#             This is to detect absurd gaps in the above.
#
#
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub pair_percent_id_trend{
	my(%input) = %{$_[0]};
	my(@common, @string,@accumu_percent_iden)=();
	my($percent_id_so_far)=0;
	for $key(keys %input){
	  my($len) = &smaller_one($#common, $#string) unless $#common < 0;
	  $input{$key}=~s/ //g;
	  @string= split(//, $input{$key});
	  $length_of_one_seq = $#string+1;
	  $length_of_all_seq +=$length_of_one_seq;
	  $seq_no += 1;
	  for ($k=0; $k <= $len;$k++){
		  if($#common == -1){
			 @common = @string;
			 last;
		  }
		  elsif (($string[$k] =~ /^(\W)/)&&($1 ne $previous_non_char)){
			 $non_char_count +=1;
			 $previous_non_char=$1;
		  }
		  elsif ( $string[$k] eq $common[$k] ){
			 $common[$k] = $string[$k];
			 $identical_count +=1;
		  }elsif( $string[$k] ne $common[$k]){
			 $common[$k]='.';
		  }
	  }
	  $num_of_iden_char = &count_num_of_char(\@common);
	  $av_seq_no = $length_of_all_seq/$seq_no;
	  $percent_id_so_far = $num_of_iden_char/$av_seq_no*100;

	  print "\n percent_id so far = $percent_id_so_far \n";
	  push(@accumu_percent_iden,$percent_id_so_far);

	} # end of for (after all sequences have been run).
	$num_of_iden_char = &count_num_of_char(@common);
	$av_seq_no = $length_of_all_seq/$seq_no;
	$percent_id_so_far = $num_of_iden_char/$av_seq_no*100;
	print "\n percent_id so far = $percent_id_so_far \n";
	\@accumu_percent_iden; # final ids array.
}
#________________________________________________________________________
# Title     : smaller_one
# Usage     : $smaller = & smaller_one($var, $var2);
#
# Function  : gets smaller value of the two inputs
# Example   : will return   5   with  &smaller_one(5, 50);
# Warning   : gets only digits!!
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub smaller_one{
	if (($_[0], $_[1]=~/\d+/)||($_[0] > $_[1])){
	 return $_[1];
	}elsif(($_[0], $_[1]=~/\d+/)||($_[0] <= $_[1])){
	 return $_[0];
	}else{
	 print "\n I am sub 'smaller_one', the input were not digits \n";
	}
}

#________________________________________________________________________
# Title     : count_num_of_char
# Usage     : $num_char = &count_num_of_char(@input_array_of_single_char);
# Function  : takes only ARRAY and counts the number of char. Each elem should be
#             a single char.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub count_num_of_char{
	 my(@input)={$_[0]};
	 my($num_of_char)=0;
	 for $elem(@input){  # this is for the percentage of TWO seqs.
		 if ($elem =~ /\w/){
					 $num_of_char +=1;
		 }
	 }
	 $num_of_char;
}
#________________________________________________________________________
# Title     : remov_com_column2  (this is the older and slower version)
# Usage     : %new_string = %{&remov_com_column2(\%input_hash)};
# Function  :
# Example   : seq1  ABCDE------DDD         seq1  ABCDE--DDD
#             seq2  ABCDEE-----DD-  ==>    seq2  ABCDEE-DD-
#             seq3  ---DEE----DDE-         seq3  ---DEEDDE-
#                         ^^^^
#             from above the 4 columns of gap will be removed
#             To remove absurd gaps in multiple sequence alignment
# Warning   :
# Keywords  :
# Options   :
# Returns   : a ref. of a hash.
#
#               <input hash>                   <out hash>
#
# Argument  : accepts reference for a hash.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub remov_com_column2{
	my(%input) = %{$_[0]};
	my(@common)=();
	my($len)=0;
	my(@string)=();
	my(@new_string)=();
	my(@string2)=();
	my(%new_string);

	########## Finds common gaps ###########
	for $key(keys %input){
	  $len  = &smaller_one($#common, $#string) unless $#common < 0;
		  sub smaller_one{if ($_[0] > $_[1]){ $_[1];}else{$_[0];}}
	  @string = split(/|| /, $input{$key});
	  for ($k=0; $k <= $len;$k++){
		  if($#common == -1){
			  @common = (@string);
			  last;
		  }
		  if (($string[$k] eq '.')&&($common[$k] eq '.')){
			  $common[$k]='.';
		  }else{
			  $common[$k]='X';
		  }
	  }
	}

	########## removes gaps ###########
	for $key2 (keys %input){
		@string2 = split(//, $input{$key2});
		for ($i=0; $i <= $#string2; $i++){
		  if ($common[$i] eq $string2[$i]){
			  print;
		  }else{
			  push(@new_string, $string2[$i]);
		  }
		}
		$new_string{$key2}= join("", @new_string);
		@new_string = ();
	}
	\%new_string;
}

#________________________________________________________________________
# Title     : get_common_column   (similar to overlay_seq_for_identical_chars )
# Usage     : %out =%{&get_common_column(\%hash1, \%hash2, '-')};
# Function  : (name1         --EHH--HHEE-- )
#             (name2         --HHH--EEEE-- ) ==> result is;
#
#             (name1_name2   -- HH--  EE-- )
#             to get the identical chars in hash strings of sequences.
#
# Example   : %out =%{&get_common_column(\%hash1, \%hash2, '-')};
#             output> with 'E' option >>> "name1     --HHH--1232-"
#   Following input will give;
#  %hash1 = ('s1', '--EHH-CHHEE----EHH--HHEE----EHH--HHEE----EHH-CHHEE--');
#  %hash2 = ('s2', '--EEH-CHHEE----EEH-CHHEE----EEH-CHHEE----EEH-CHHEE--');
#  %hash3 = ('s3', '-KEEH-CHHEE-XX-EEH-CHHEE----EEH-CHHEE----EEH-CHHEE--');
#  %hash4 = ('s4', '-TESH-CHEEE-XX-EEH-CHHEE----EEH-CHHEE----EEH-CHHEE--');
#
#    s1_s2_s3_s4    --E-H-CH-EE----E-H--HHEE----E-H--HHEE----E-H-CHHEE--
#
# Warning   : This gets more than 2 hashes. Not more than that!
#
# Class     : get_common_column, get_common_column_in_seq, get common column in sequence
#             for secture only representation.
# Keywords  : Overlap, superpose hash, overlay identical chars, superpose_seq_hash
#             get_common_column, get_com_column, get_common_sequence,
#             get_common_seq_region, multiply_seq_hash, get_common_column_in_sequence
# Options   :
# Reference :
# Returns   : one hash ref. of the combined key name (i.e., name1_name2). Combined by '_'
# Tips      :
# Argument  : 2 or more ref for hash of identical keys and value length.
#             One optional arg for replacing space char to the given one.
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------
sub get_common_column{
	my($i, $k,$j, $name1, $name2, $sorted_name, @in, %out, @out_chars,
		 $gap_chr, @str1, @str2);
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#  Sub argument handling     $gap_chr here can be 'HE' etc.
	#_______________________________________________________
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^(.)$/) ){
		  $gap_chr  .= $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(.)$/) ){
		  $gap_chr  .= $1;    }
					elsif(ref($_[$k]) eq "HASH") { push(@in,  $_[$k]); }    }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#  Checking if the input hashes were right
	#_______________________________________________________
	if( (@in < 2) && ( ref($in[0]) eq 'HASH') ){
	  print "\n", __LINE__, " # get_common_column usually needs 2 hashes. Error \n";
	  print "\n", __LINE__, " # get_common_column : Anyway, I will just return the single input hash:  @in. \n";
	  %out=%{$in[0]}; # <--- This is essential to return the single input hash!!
	  goto FINAL;
	}
	if(@in ==2){  print "\n# (INFO) \@in has 2 elements for ref. of hash, good!\n\n"; }

	%out = %{$in[0]};  ## Initializing %out
	print "\n",__LINE__, " # get_common_column hashes given are: @in \n" if $debug eq 1;

	for( $k=1; $k < @in; $k++){
			my(@out_chars);   ## <-- Necessary to prevent concatenation.
			my(%hash1)=%out;
			my(%hash2)=%{$in[$k]};
			my(@names1)= sort keys %hash1;
			my(@names2)= sort keys %hash2;
			$name1 = $names1[0];
			$name2 = $names2[0];
			@str1=split(/\||\,/, $hash1{$names1[0]});
			@str2=split(/\||\,/, $hash2{$names2[0]});

			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# Trying to guess the correct gap char
			#_____________________________________________________
			if($hash2{$names2[0]}=~/_/){
					$gap_chr='_';
			}elsif($hash2{$names2[0]}=~/(\W)\W/){
					$gap_chr=$1;
			}

			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			#  If I fail to split string by ',', then split by ''
			#_____________________________________________________
			if(@str1 == 1){  @str1=split(//, $hash1{$names1[0]}); }
			if(@str2 == 1){  @str2=split(//, $hash2{$names2[0]}); }
			for($i=0; $i < @str1; $i++){
					if($str1[$i] eq $str2[$i] ){
							push(@out_chars, $str1[$i]);
					}else{
							if( defined($gap_chr) ){
									 push(@out_chars, $gap_chr);
							}else{
									 push(@out_chars, ' ');
							}
					}
			}
			$sorted_name=join('', ($name1, $name2));
			%out='';
			$out{"$sorted_name"}= join("", @out_chars);

	}
	FINAL:
	if ($debug eq 1){
	  print "\n",__LINE__, " # get_common_column Final res. \%out :\n",
	  &show_hash(%out);
	}
	return(\%out);
}

#________________________________________________________________________
# Title     : overlay_seq_for_identical_chars
# Usage     : %out =%{&overlay_seq_for_identical_chars(\%hash1, \%hash2, '-')};
# Function  : (name1         --EHH--HHEE-- )
#             (name2         --HHH--EEEE-- ) ==> result is;
#
#             (name1_name2   -- HH--  EE-- )
#             to get the identical chars in hash strings of sequences.
#
# Example   : %out =%{&overlay_seq_for_identical_chars(\%hash1, \%hash2, '-')};
#             output> with 'E' option >>> "name1     --HHH--1232-"
# Warning   : Works only for 2 sequence hashes.
# Keywords  : Overlap, superpose hash, overlay identical chars, superpose_seq_hash
# Options   :
# Returns   : one hash ref. of the combined key name (i.e., name1_name2). Combined by '_'
# Argument  : 2 ref for hash of identical keys and value length. One optional arg for
#             replacing space char to the given one.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub overlay_seq_for_identical_chars{
	my($i, $k,$j, $name1, $name2, @in, %out, @out_chars, $gap_chr, @str1, @str2);
	######################################
	####### Sub argument handling ########  $gap_chr here can be 'HE' etc.
	######################################
	for($k=0; $k< @_ ;$k++){
	  if( ( !ref($_[$k]) )&&($_[$k]=~ /^(.)$/) ){
		  $gap_chr  .= $1;    }
	  elsif((ref($_[$k]) eq "SCALAR")&&(${$_[$k]}=~ /^(.)$/) ){
		  $gap_chr  .= $1;    }
	  elsif(ref($_[$k]) eq "HASH") { push(@in,  $_[$k]); }    }

	if(@in < 2){ print "\n overlay_seq_for_identical_chars needs 2 hashes. Error \n"; die; }
	my(%hash1)=%{$in[0]}; my(%hash2)=%{$in[1]};
	my(@names1)=sort keys %hash1; my(@names2)= sort keys %hash2;
	$name1 = $names1[0]; $name2 = $names2[0];
	@str1=split(/|\,/, $hash1{$names1[0]}); @str2=split(/|\,/, $hash2{$names2[0]});
	for($i=0; $i < @str1; $i++){
	  if($str1[$i] eq $str2[$i] ){
		  push(@out_chars, $str1[$i]); }
	  elsif( defined($gap_chr) ){ push(@out_chars, $gap_chr); }
	  else{ push(@out_chars, ' '); }
	}
	if( $name2 gt $name1){
	  $out{"$name1\_$name2"}= join(",", @out_chars); }
	else{  $out{"$name2\_$name1"}= join(",", @out_chars); }
	\%out;
}

#________________________________________________________________________
# Title     : remov_com_column
# Usage     : %new_string = %{&remov_com_column(\%hashinput)};
#             @out=@{&remov_com_column(\@array3)};
# Function  : removes common gap column in seq.
# Example   :
# Warning   :
# Keywords  : remove_com_column, remove_common_column,
#             remove_common_gap_column, remov_common_gap_column,
#             remove com column
# Options   :
# Returns   : a ref. of  hash(es) and array(s).
#
#             name1   ABCDE....DDD       name1  ABCDE..DDD
#             name2   ABCDEE..DD..  -->  name2  ABCDEEDD..
#             name3   ...DEE..DDE.       name3  ...DEEDDE.
#
#             (ABC....CD, ABCD...EE) --> (ABC.CD, ABCDEE)
#             from above the two column of dot will be removed
#             To remove absurd gaps in multiple sequence alignment. for nt6-hmm.pl
# Argument  : accepts reference for hash(es) and array(s).
# Category  :
# Version   :
#--------------------------------------------------------------------
sub remov_com_column{
	my(@hash_ref_out, $d, $gap_char);
	for($d=0; $d < @_; $d++){
	  if(ref($_[$d]) eq 'HASH'){
	      my($len,@string,@new_string,@string2);
		  my(%input)=%{$_[$d]};
		  my(@common);
		  for (keys %input){
			  @string = split('', $input{$_});
			  if(!(defined(@common))){ @common = (@string);  }
			  else{ for ($k=0; $k < @string; $k++){
				 if (($string[$k] =~ /\W/ )&&($common[$k] =~ /(\W)/)){ $common[$k]= $1;}
				 elsif(($string[$k] =~ /(\W)/)&&(!(defined($common[$k])))){ $common[$k]=$1;}
				 else{ $common[$k]='X';} } } }
		  for (keys %input){ @string2 = split(//, $input{$_});
			  for ($i=0; $i < @string2; $i++){
				 if ($common[$i] ne $string2[$i]){ push(@new_string, $string2[$i]); } }
			  $new_string{$_}= join('', @new_string); @new_string = ();      }
		  push(@hash_ref_out, \%new_string);
	  }
	  elsif(ref($_[$d]) eq 'ARRAY'){
	      my( $k, $y, $x,@string_array, @string);
		  my(@input)=@{$_[$d]};  @common=();
		  for($y=0; $y< @input; $y++){
			  @string = split('', $input[$y]);
			  if(!(defined(@common))){  @common = @string;  }
			  else{
				 for ($k=0; $k < @string; $k++){
					 if (($string[$k]  =~ /(\W)/)&&($common[$k]  =~ /(\W)/)){ $common[$k]=$1;}
					 elsif(($string[$k] =~ /(\W)/)&&(!(defined($common[$k])))){ $common[$k]=$1;}
					 else{ $common[$k]='X';}
				 }
			  }
		  }
		  for($x=0; $x < @input; $x++){
		      my($new_string, @string2);
			  @string2 = split(//, $input[$x]);
			  for ($i=0; $i < @string2; $i++){
				  if ($common[$i] ne $string2[$i]){ $new_string.= "$string2[$i]"; }
			  }
			  push(@string_array, $new_string);
		  }
		  push(@hash_ref_out, \@string_array);
	  }
	}
	if(@hash_ref_out ==1) { return( $hash_ref_out[0] ); }
	elsif(@hash_ref_out>1){ return( @hash_ref_out ) }
}

#________________________________________________________________________
# Title     : remov_common_gap
# Usage     : %result = &remov_common_gap (*common_pos_arr, *target_hash_of_sequence);
# Function  : XXX...XXX, and an hash input. removes all the common gap(dots) in targets.
# Example   : XXX...XXX with AAA.....BBBB, The common positions of 3,4,5 deleted
#             XXX...XXX will be removed in AAA.....BBBB --> AAA..BBBB
#             XXX...XXX is an @array, while AAA.....BBBB is a value of the input hash
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub remov_common_gap{
	my(@common)=@{$_[0]}; my(%input)=%{$_[1]};
	for $key2 (keys %input){
		my(@string2)  = split(//, $input{$key2});
		for ($i=0; $i <= $#string2; $i++){
		  if ($common[$i] eq $string2[$i]){shift;}else{ push(@new_string, $string2[$i]);}}
		$new_string{$key2}= join("", @new_string);
		@new_string = (); }
	\%new_string;
}


#________________________________________________________________________
# Title     : com_gap_pos_hash
# Usage     : @array = @{&com_elem_pos_hash(%arrayinput)};
# Function  : returns X...XXXX, as an array. '.' means common elements.
# Example   : common gaps means only '.' (dots, not alphabets!!)
#             AAA....BBBB
#             AABB....BBC  --> XXXXX..XXXX (as in an array)
#             ..AAA...BCA
#             This is to detect absurd gaps in the above.
# Warning   :
# Keywords  : common_gap_pos_hash
# Options   :
# Returns   :
# Argument  : gets a ref. of a hash of sequences
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub com_gap_pos_hash{
	my(%input) = %{$_[0]};
	for $key(keys %input){
	my($len) = &smaller_one($#common, $#string) unless $#common < 0;
	  sub smaller_one{if ($_[0] > $_[1]){ $_[1];}else{$_[0];}}
	@string= split(//, $input{$key});
	for ($k=0; $k <= $len;$k++){
	  if($#common == -1){
	     my(@common) = @string;
		 last;
	  }
	  if (($string[$k] ne '.')||($common[$k] ne '.')){
	     $common[$k]='X';
	  }
	}
	}
	\@common;
}
#________________________________________________________________________
# Title     : pairwise_iden_pos
# Usage     : @array = &pairwise_iden_pos(%arrayinput);
# Function  :
# Example   : common gaps means only '.' (dots, not alphabets!!)
#             AAA....BBCB
#             AAAB..B.BCC  --> A.A.....BC. (as in an array)
#             A.AAA...BCA
#             The resulting array XXXXX..XXXX is literally like so.
#             This is to detect absurd gaps in the above.
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pairwise_iden_pos{
	my(%input) = %{$_[0]};
	my(@common, @string)=();
	for $key(keys %input){
	  my($len) = &smaller_one($#common, $#string) unless $#common < 0;
	  sub smaller_one{if ($_[0] > $_[1]){ $_[1];}else{$_[0];}}
	  @string= split(//, $input{$key});
	  for ($k=0; $k <= $len;$k++){
					  if($#common == -1){
								 @common = @string;
								 last;
					  }
					  elsif (($string[$k] =~ /^(\W)/)&&($1 ne $previous_non_char)){
								 $non_char_count +=1;
								 $previous_non_char=$1;
					  }
					  elsif ( $string[$k] eq $common[$k] ){
						$common[$k] = $string[$k];
					  }elsif( $string[$k] ne $common[$k]){
								 $common[$k]='.';
					  }
	  }
	}
	\@common;	# returns an array.
}


#________________________________________________________________________
# Title     : open_pdb_files
# Usage     : %out = %{&open_pdb_files(\$VAR)};
# Function  : Convert a PDB structure file to FASTA format sequences.
# Example   :
# Warning   : (read the sequences only)
# Keywords  : read_pdb_files{, read pdb files, open pdb files, open_brk_files,
#             open_ent_files, open_protein_database_files
# Options   :
# Returns   : One ref. for a hash of sequences(DNA, RNA, PROTEIN (IN diff chains)
#             If the two chains are identical, it rids of one of them and returns
#             a name with out chain note-->  2tma, not 2tmaA and 2tmaB
# Argument  : one ref. for an inputfile (absolute
#             >>> PDB example >>>
#             SEQRES   1 A  284  MET ASP ALA ILE LYS LYS LYS MET GLN MET LEU LYS LEU  2TMA  51
#             SEQRES   2 A  284  ASP LYS GLU ASN ALA LEU ASP ARG ALA GLU GLN ALA GLU  2TMA  52
#
# Category  :
# Version   : 1.9
#--------------------------------------------------------------------
sub open_pdb_files{
    my ($input, $pdb_name);
    if(ref($_[0]) eq 'SCALAR'){
                     $input=${$_[0]};
    }else{
                     $input=$_[0];
    }
    if($input=~/\.[mpsn]+fa[sta]?$/){ print "\n You have put fasta file to PDB prog\n" }
    $input=${&find_seq_files(\$input)};
    my($i, $j, $keys, $temp,$outseq, $SEQRES, $res_numb, $structure, %outhash, @fields,
        %AA, @residues);

     $AA{"ALA"} = "A";  $AA{"MET"} = "M";  $AA{"ASP"} = "D";  $AA{"PRO"} = "P";
     $AA{"CYS"} = "C";  $AA{"ASN"} = "N";  $AA{"GLU"} = "E";  $AA{"GLN"} = "Q";
     $AA{"PHE"} = "F";  $AA{"ARG"} = "R";  $AA{"GLY"} = "G";  $AA{"SER"} = "S";
     $AA{"HIS"} = "H";  $AA{"THR"} = "T";  $AA{"ILE"} = "I";  $AA{"VAL"} = "V";
     $AA{"LYS"} = "K";  $AA{"TRP"} = "W";  $AA{"LEU"} = "L";  $AA{"TYR"} = "Y";

    print "\n# $0: opening $input file to find SEQRES entry line\n";
    open(INPUT_PDB_FILE, "$input");
    while (<INPUT_PDB_FILE>){
		 my($chain, $seq_size, $residues);
		 if(/DBREF\s+(\S+)\s+/){
														$pdb_name=$1;
						 }elsif(!$pdb_name and /SEQADV\s+(\S+)/){
				$pdb_name=$1;
		 }elsif(/^SEQRES\s+\d+\s+(\S*)\s+(\d+)\s+(.{51,53})\s*([\w\w\w\w]*)[\w]*\s*\d*/){
						$SEQRES = 1;
						$chain =$1;
						$seq_size = $2;
						$residues = $3;
														$pdb_name=$4 if $4;
						@residues=split(' ', $residues);
						if($residues[0]=~/^[A-U]$/){
										for(@residues){$outhash{"\L$pdb_name\U$chain\E"}.=$_;}
						}else{
										for(@residues){$outhash{"\L$pdb_name\U$chain\E"}.=$AA{$_};}  ## use %AA matrix
						}
		 }elsif( ($SEQRES != 1)&&(/^ATOM\s+\d+\s+\w+\s+(\w\w\w) (.)\s+(\d+).+\s+(\w\w\w\w)\s*\d+/) ){
						if($res_numb == $3){ next;
						}else{
							$chain = $2;
							$res_numb = $3;
							$pdb_name=$4;
							$outhash{"\L$pdb_name\U$chain\E"}.= $AA{"$1"};
						}
		 }
		}
		@keys=keys %outhash;
		if ($chain=~/[A-Z]/){
		 for ($i=0; $i < @keys; $i++){
              for ($j=$i+1; $j < @keys; $j++){
                  if ($outhash{$keys[$i]} eq $outhash{$keys[$j]}){
                               delete($outhash{$keys[$j]});
                               $temp=$keys[$i];
                               chop($temp);
                               $outhash{$temp}=$outhash{$keys[$i]};
                               delete($outhash{$keys[$i]});
                  }
              }
		 }
    }
	return( \%outhash );
}

#________________________________________________________________________
# Title     : open_brk_files (read the sequences only)(the same as open_pdb_files
# Usage     : %out = %{&open_brk_files(\$VAR)};
# Function  : Convert a PDB structure file to FASTA format sequences.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : One ref. for a hash of sequences(DNA, RNA, PROTEIN (IN diff chains)
#             If the two chains are identical, it rids of one of them and returns
#             a name with out chain note-->  2tma, not 2tmaA and 2tmaB
# Argument  : one ref. for an inputfile (absolute
#             >>> PDB example >>>
#
#             SEQRES   1 A  284  MET ASP ALA ILE LYS LYS LYS MET GLN MET LEU LYS LEU  2TMA  51
#             SEQRES   2 A  284  ASP LYS GLU ASN ALA LEU ASP ARG ALA GLU GLN ALA GLU  2TMA  52
#             SEQRES   3 A  284  ALA ASP LYS LYS ALA ALA GLU ASP ARG SER LYS GLN LEU  2TMA  53
#
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_brk_files{    my($input)=${$_[0]};  $input=${&find_seq_files(\$input)};
	my($outseq, $structure, %outhash, @fields, %AA, $chain, $residues);
	 $AA{"ALA"} = "A";  $AA{"MET"} = "M";  $AA{"ASP"} = "D";  $AA{"PRO"} = "P";
	 $AA{"CYS"} = "C";  $AA{"ASN"} = "N";  $AA{"GLU"} = "E";  $AA{"GLN"} = "Q";
	 $AA{"PHE"} = "F";  $AA{"ARG"} = "R";  $AA{"GLY"} = "G";  $AA{"SER"} = "S";
	 $AA{"HIS"} = "H";  $AA{"THR"} = "T";  $AA{"ILE"} = "I";  $AA{"VAL"} = "V";
	 $AA{"LYS"} = "K";  $AA{"TRP"} = "W";  $AA{"LEU"} = "L";  $AA{"TYR"} = "Y";
	open(INPUT_PDB_FILE, "$input");
	while (<INPUT_PDB_FILE>){
	 if(/^HELIX/ || /^ATOM/ || /^FTNOTE/ || /^HET/){ last; };
	 if(/^SEQRES\s+\d+\s+(.)\s+(\d+)\s+(.+)\s+(\w+)\s+\d+.+$/){
		$chain =$1; $seq_size = $2; $residues = $3; $pdb_name=$4;
		@residues=split(' ', $residues);
		if($residues[0]=~/[A-U]/){ # <-- Check if it is DNA/RNA seq.
		  for(@residues){  $outhash{"\L$pdb_name\U$chain\E"}.=$_;  }
		}else{
		  for (@residues){  $outhash{"\L$pdb_name\U$chain\E"}.=$AA{$_}; } } }
	}
	@keys=keys %outhash;
	if ($chain=~/[A-Z]/){
	 for ($i=0; $i < @keys; $i++){
		for ($j=$i+1; $j < @keys; $j++){
		  if ($outhash{$keys[$i]} eq $outhash{$keys[$j]}){
			 delete($outhash{$keys[$j]});  $temp=$keys[$i];
			 chop($temp);  $outhash{$temp}=$outhash{$keys[$i]};
			 delete($outhash{$keys[$i]});}}}}  return( \%outhash  );
}

#________________________________________________________________________
# Title     : open_pdb_seqres_files
# Usage     : %fasta_seq=%{&open_pdb_seqres_files($fasta_file, ['MJ0084'])};
#             if you put additional seq name as MJ0084 it will
#             fetch that sequence only in the database file.
#
#             %out=%{&open_pdb_seqres_files(@ARGV, \%index)};
#               while  %index has (seq indexpos seq2 indexpos2,,,)
#               In this case, the fasta file should have xxxx.fasta format
#
# Function  : open pdb_seqres file and put sequences in a hash
#              If hash(es) is put which has sequence names and seek position
#              of the index file, it searches the input FASTA file to
#              fetch at that seek position. This is useful for Big fasta DBs
#             If the seq name has ranges like  XXXXXX_1-30, it will only
#              return 1-30 of XXXXXX sequence.
#
#             FASTA sequence file format is like this;
#
#     >12ca_  mol:protein length:260     Carbonic Anhydrase II (Carbonate Dehydratase
#     MSHHWGYGKHNGPEHWHKDFPIAKGERQSPVDIDTHTAKYDPSLKPLSVSYDQATSLRILNNGHAFNVEFDDSQD
#     >12e8_L mol:protein length:214     2E8 (Igg1=Kappa=) Antibody
#     DIVMTQSQKFMSTSVGDRVSITCKASQNVGTAVAWYQQKPGQSPKLMIYSASNRYTGVPDRFTGSGSGTDFTLTI
#
# Example   : %out = %{&open_pdb_seqres_files(@ARGV)};
#             %out2=%{&open_pdb_seqres_files('seq.fasta', \%index)};
#             %out3=%{&open_pdb_seqres_files('seq.fasta', \%range)};
#             %seq=%{&open_pdb_seqres_files($PDB40_FASTA, \@seq_to_fetch)};
#
#             while @ARGV at prompt was: 'GMJ.pep MJ0084'
#
# Keywords  : open_pdb_seqres, open_fa_files, open_FASTA_files,
# Options   : Seq name to fetch the specified seq only.
#             as open_pdb_seqres_files.pl MY_SEQ_NAME Swissprot.fasta
#            -d  for giving back desc as well as the name. so it
#                gives  'HI0002 This is the description part'
#                as the key
#             If you put hash which is like('seq_name', ['20-30', '30-44',..])
#              it will produce hash which has got:
#              ( seq_name_20-30 'asdfasdfasdfasdfasd',
#                seq_name_30-44 'kljkljkjkjljkjljkll',
#                ....           .... )
#            -s for returning sequence size only
#   $min_seq_leng_accepted= by m=
#   $No_gap_char_allowed=N by N  # removes all \W
#   $remove_strange_and_masked_residues=R by R  # removes X, B, Z etc
#   $make_Upper_case_seq=U by U
# Version   : 1.0
#--------------------------------------------------------------------
sub open_pdb_seqres_files{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    my (%sequence, %HASH, @Keys, $seq_found1, $S_start, $S_end, $seq_found,
        $present_seq, @seq_Names, %Sizes, $bare_seq_name, $fasta_seq_idx_file,
        %seq_fragments, $min_seq_leng_accepted, $No_gap_char_allowed,
        $remove_strange_and_masked_residues, $make_Upper_case_seq,
        $DC_fold_type, $DDD_seq_range, $DDD_seq_size);
    $min_seq_leng_accepted=0;

    if(@file<1){
        print "\n \@file has less than 1 elem. There is no fileinput for open_pdb_seqres_files\n";
        exit
    }
    if($vars{'m'}=~/(\d+)/){ $min_seq_leng_accepted=$1; }
    if($char_opt=~/N/){  $No_gap_char_allowed='N'; }
    if($char_opt=~/R/){  $remove_strange_and_masked_residues='R'; }
    if($char_opt=~/U/){  $make_Upper_case_seq='U'; }

    print "\n# \@file are @file\n" if $verbose;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  (1) When perl file INDEX pos info is given in hash, this speeds up
    #_________________________________________________________________________________
    for($d=0; $d < @hash; $d++){
	   my ($sequence, $NAME, $range_start, $range_leng);
	   %HASH=%{$hash[$d]};
	   my @Keys=keys %HASH;  ## <<< NOTE it is @Keys, not @keys
	   for($f=0; $f< @file; $f++){
		  #====== It must be xxxx.fa format =======
									unless($file[$f]=~/\S\.[mpsn]{0,2}fa[sta]?$/){
			  print "\n# open_pdb_seqres_files: \$file\[\$f\] does not have fasta extension, skipping"; next; }
		  open(FASTA, $file[$f]);
		  F0: for($e=0; $e< @Keys; $e++){
			 my $sequence;
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # When seq name has range attachment, it handles
			 #________________________________________________
			 if($Keys[$e]=~/^(\S+)_(\d+)\-(\d+)/){
			      $NAME=$1;
			      $range_start=$2-1;    ## to fit in substr function
			      $range_leng =$3-$2+1; ## to fit in substr
			 }else{
			      $NAME=$Keys[$e];
			 }
			 if($HASH{$Keys[$e]}=~/^(\d+)$/){
                  splice(@hash, $d, 1);
                  $d--;
                  splice(@file, $f, 1);
                  $f--;
                  seek(FASTA, $1-220, 0);  # -220 is necessary
                  while(<FASTA>){
                     if( /^\> *$NAME/  or
                             /^\> *\S+$NAME/){  # to handle ">owl|P04439|1A03_HUMAN HLA CLASS I HISTOCOMPATIBILITY
                            $seq_found1=1;
                     }elsif(/^(\w+)$/ and $seq_found1==1){   $sequence .=$1;
                     }elsif(/^\> *\S+/ and $seq_found1==1 and length($sequence) > $min_seq_leng_accepted){
     # Filtering by seq size
                         if($No_gap_char_allowed){
                                  $sequence=~s/\W+[0-9]//g;
                         }
                         if($remove_strange_and_masked_residues){
                                  $sequence=~s/[oOjJxXzZbB\W0-9]+//g;
                         }
                         if($make_Upper_case_seq){
                                  $sequence="\U$sequence";
                         }
                         if($range_start =~/\d+/){
                                         $sequence{$Keys[$e]}=substr($sequence, $range_start, $range_leng);
                         }else{         $sequence{$Keys[$e]}=$sequence; }
                         $range_start='';
                         $sequence='';
                         $seq_found1=0; next F0;
                     }
                  }
			  }
		  }
	  }
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	# !(2)! -- opening FASTA files (NORmal, when no perl index pos number is given)
	#_______________________________________________________________________
	for($i=0; $i< @file; $i++){
	   unless(-s $file[$i]){ next; } ## this is essential as handle_arguments has a problem
	   my($entry_found, $input_file, $matched_FASTA_seq_name, $matched_seq);
	   if(ref( $file[$i] ) eq 'SCALAR' ){
			 $input_file = ${$file[$i]};
	   }else{
			 $input_file=$file[$i];
			 #print "\n# (i) I am opening $file[$i]\n";
       }

	   if($debug eq 1){ print "\n open_pdb_seqres_files: Inputfile is $input_file\n" };
	   unless (-e $input_file){
           print chr(7);
           print "\n\n\t This is sub open_pdb_seqres_files in $0  \n\n";
           print "\t Fatal: The input file $input_file is not in the directory \n";
	   }
	   open(FILE_1,"$input_file");
	   if(@hash >=1){  ## if seq names are given in hash
           for($h=0; $h< @hash; $h++){
                        @string=(@string, keys %{$hash[$h]});
           }
	   }
	   @string=sort @string;
	   $num_of_seq_to_fetch=@string;
	   if(@string > 0){
		   print "\n# open_pdb_seqres_files(normal fasta fetch): \$num_of_seq_to_fetch is $num_of_seq_to_fetch\n";
	   }

	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	   # (2) !!! When seq names NOT given, fetches all (THE DEFAULT)
	   #____________________________________________________________
       while(<FILE_1>){                # file1 needs to be xxxx.fasta for the moment, automatic later
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # The most common pdb_seqres FASTA format entry
              #_______________________________________________________
              if(/^> {0,5}(\S+)\s+mol:(\S+)\s+length:(\d+)\s*(.*)/){
                    $matched_FASTA_seq_name=$1;
                    $mole_type=$2;
                    $seq_length=$3;
                    unless($mole_type eq 'protein'){ next } # protein-het , nucleic, protein
                    if($matched_FASTA_seq_name=~/(\d\S\S\S)_(\S)/){
                        $PDB_ID=$1;
                        $chain_ID=$2;
                        $matched_FASTA_seq_name="$PDB_ID$chain_ID";
                    }elsif($matched_FASTA_seq_name=~/\d\S\S\S_$/){
                    }

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Checks if the previous sequence reading was good
                    #____________________________________________________________
                    if(!$matched_seq){ warn " Reading common FASTA format: $matched_FASTA_seq_name didnt seem to have matching sequence. Empty sequence ????\n";  }

                    if($char_opt=~/[\-]?d/i){   $matched_FASTA_seq_name=$_;  # To add the description
                    }else{
                         if( $sequence{$matched_FASTA_seq_name} ){ # check if the entry already exists
                                 print "\n# (i) open_pdb_seqres_files: $1 seems to be the same as previous entry, ERROR??\n";
                                 $entry_found=0;
                         }else{     $matched_FASTA_seq_name=$matched_FASTA_seq_name;   $entry_found=1;      }
                    }
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # I write at this point <----------<<<
               #_________________________________________________
               }elsif(/^([\w\.\- ]+)$/ and $entry_found == 1){
                    $matched_seq=$1;
                    if($No_gap_char_allowed){
                               $matched_seq=~s/\W+//g;
                    }
                    if($remove_strange_and_masked_residues){
                               $matched_seq=~s/[oOjJxXzZbB\W0-9]+//g;
                    }
                    if($make_Upper_case_seq){
                               $matched_seq="\U$matched_seq";
                    }
                    if($char_opt=~/s/){ # when SIZE(length of seq) return only option is set
                               $Sizes{$matched_FASTA_seq_name}+=length($matched_seq);
                               #print $Sizes{$matched_FASTA_seq_name}, "\n";
                    }else{
                               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                               # Filtering by seq size
                               #__________________________________________
                               if(length($matched_seq) > $min_seq_leng_accepted){
                                        $sequence{$matched_FASTA_seq_name}.= $matched_seq if defined($matched_FASTA_seq_name);
                               }
                    }
               }elsif(/^$/){  next;
               }else{  $entry_found=0;  } ## this is when rubbish is matched
           }# end of while
	 }
	 close FILE_1;



	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~`
	 # (3) When ranges information is given(via \@range), seq in those ranges are returned
	 #______________________________________________________________________________________
	 if(defined(@range)){
	   %seq_fragments=%{&get_seq_fragments(\%sequence, \@range)};
	   return(\%seq_fragments);
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 # (4) When only size is asked with -s option
	 #_____________________________________________________________________________
	 elsif($char_opt=~/s/){ # when SIZE(length of seq) return only option is set
	   #@seq_Names=keys %sequence;
	   #for($i=0; $i<@seq_Names; $i++){
	   #	  $Sizes{$seq_Names[$i]}=length($sequence{$seq_Names[$i]});
	   # }
	   return(\%Sizes);
	 }
	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	 # (5) when hash which has range info is given(@range should not be defined)
	 #_____________________________________________________________________________
	 elsif(@hash >=1){
         for($h=0; $h< @hash; $h++){
              my %hash=%{$hash[$h]};
              my @Keys=keys %hash;
              for($k=0; $k<@Keys; $k++){
                  if(defined($hash{$Keys[$k]})){
                      ($S_start, $S_end)=$hash{$Keys[$k]}=~/(\d+)\-(\d+)/;
                      $sequence{$Keys[$k]}=substr($sequence{$Keys[$k]}, ($S_start-1), ($S_end-$S_start));
                  }
              }
         }
         return(\%sequence);
	 }else{
         return(\%sequence);
	 }
}





#________________________________________________________________________
# Title     : open_msf_jp_files
# Usage     : &open_msf_jp_files($file1, $file2);
# Function  : makes two hashes from  ...msf and ..jp files. %array1 is for msf
# Example   :
# Warning   : !!! not very general bettter not use.
#             msf file is meant to be seq
#             jp file is meant to be structural alignment (correct seq
#
#             msf format is
#
#             cofi_human  ATFVKM
#             ici2_horvu  RVRLFVDKLD NIA
#             ici3_horvu  RVRLFVDRLD NIA
#
#             jp format is;
#
#             ycah_ecoli  RNVEIV----VID-GVRRFGNIA
#             icis_vicfa  RVRLYVDESNKVV-RAAPIGNIA
#             ier1_lyces  RVRLFVNLLDIVV-QTPKVGNIA
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_msf_jp_files{
	my($file1, $file2) = @{$_[0]};  my(@return);
	open(F1,"$file1");
	while(<F1>){
	  if(/^([\w_]+)[\t]*\s+(.+)$/){	# matching patterns
		 if(!$array1{$1}){      		# if hash %array1 is not defined,
			$names1[++$nf1]=$1;
		 }
		 $array1{$1}.=$2;   }   }
	open(F2,"$file2");  			# reading in (JP) file
	while(<F2>){
		if(/^([\w]+)[\t]*\s+([\w-]+[ ]+)$/){
			substr($_,11)=~ s/ /-/g;      }
		if(/^([\w]+) \s+([\w-]+)$/){
			if(!$array2{$1}){
				$names2[++$nf2]=$1;
			}
			$array2{$1}.=$2; }  }
	@return =(\%array1, \%array2);
	return(\@return);
}



#________________________________________________________________________
# Title     : scoring
# Usage     :
# Function  :
# Example   :
# Warning   : not general, !!!
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub scoring{
	$hash_subt{$subt}++; 	# this is for individual seq.
																		  # if $subt is 1, $hash_subt{1} will increase
																		  # its value(not key) by one, etc.
	$hash_subt_all{$subt}++;  # for the wholesome of seqs.
}

#______________________________________________________________
# Title     : sort_files_by_time
# Usage     : @files = @{&sort_files_by_time(\@files)};
# Function  : sorts files by creation time. Oldest the first
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : sort_by_time, sort_files_chronically
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub sort_files_by_time{  # by "Shawn Wagner" <shawnw@wpi.edu>
		my @files;
		if(ref($_[0]) eq 'ARRAY'){
		 @files=@{$_[0]};
		}else{
		 @files=@_;
		}
		@files= reverse sort { -M $a <=> -M $b} @files;
		return(\@files);
}


#______________________________________________________________________
# Title     : sort_hash_by_value_and_make_array
# Usage     : @values_sorted =@{&sort_hash_by_value_and_make_array(\%assoc)};
# Function  : sorts any hash by its values and returns ref. of sorted hash values
#             with keys attached. So, if the input key value were
#             key1 value1, the result will be an element 'value1 key1' as
#             a string
# Example   :
# Warning   : The same values will be overwritten.
# Keywords  : sort_hash_by_value, sort_hash, sort_by_values,
# Options   : -n  for numerical sort(not working yet)
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#------------------------------------------------------------------
sub sort_hash_by_value_and_make_array{
		my ($i, $j, %hash2, @array, $num_sort, @array_sorted);
		my %hash = %{$_[0]};
		my @keys = keys %hash;
		sub numerically{  $a <=> $b;  }
		for($i=0; $i<@ARGV; $i++){ # if numerically option is set.
			if($ARGV[$i]=~/^\-n$/){
							$num_sort =1;
							splice(@ARGV, 0, 1);
			}
		}
		for($i=0; $i < @keys; $i ++){
			${"long_string$i"} = "$hash{$keys[$i]} $keys[$i]";
			#push(@array, ${"long_string$i"});
		}
		for($i=0; $i < @keys; $i++){
			for($j=1; $j < @_; $j ++){
							%hash2 = %{$_[$j]};
							${"long_string$i"} .= "  $hash2{$keys[$i]}";
			}
			push(@array, ${"long_string$i"});
		}
		if($num_sort==1){
			@array_sorted = sort numerically @array;
		}else{ @array_sorted = sort  @array; }
		return(\@array_sorted);
}

#________________________________________________________________________
# Title     : sort_by_hash_values
# Usage     : @values_sorted =@{sort_by_by_values(\%assoc)};
# Function  : sorts any hash by its values and returns ref. of sorted hash values
# Example   :
# Warning   : The same values will be overwritten.
# Keywords  : sort_hash_by_value, sort_hash, sort_by_values, sort_by_value
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub sort_by_hash_values{
		my(%hash) = %{$_[0]};
		@values = sort values %hash;
		return(\@values);
}

#________________________________________________________________________
# Title     : sort_by_keys
# Usage     : @values_sorted =@{sort_by_by_values(\%assoc)};
# Function  : sorts any hash by its values and returns ref. of sorted hash values
# Example   :
# Warning   :
# Keywords  : sort_hash_by_keys, sort_hash, key_sort
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sort_by_keys{
	my(%hash) = %{$_[0]};
	@values = sort keys %hash;
	return(\@values);
}

#________________________________________________________________________
# Title     :  sort_hash_by_keys
# Usage     : @values_sorted =@{sort_by_values(\%assoc)};
# Function  : sorts any hash by its values and returns ref. of sorted hash values
# Example   :
# Warning   :
# Keywords  : sort_hash_by_keys, sort_hash, key_sort
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sort_hash_by_keys{
	my(%hash) = %{$_[0]};
	@values = sort keys %hash;
	\@values
}


#__________________________________________________________________________
# Title     : sort_hash_by_value
# Usage     : @out=@{&sort_hash_by_value(\%input_line_hash, <column num>)};
# Function  : it sorts values of hash by the given column , small comes top. Unless number is
#             is given, it sorts by the first column.
#             It returnns ARRAY of the keys of the input HASH!!!
#
#             It can handle gzipped file. It called gunzip to open and sort.
#
# Example   : Above will sort the file xxxx.msp by its 3rd column(numerically)
#               small numbers will come to the top.
# Keywords  : sort_by_2nd_column, sort_by_second_column, sort_by_e_values,
#             sort_by_evalues, sort_hash_by_column, sort_value_by_column,
# Options   :
#      s  for sorting stringwise
#      d  for sorting by digit
#      n  for sorting by digit(numerically)
#   $sort_numerically_RV=r by r
#
#   numerically  an alias of n
#
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub sort_hash_by_value{
		my (%in, $i, $col, $sort_numerically, $sort_numerically_RV,
				$sort_non_numerically, @keys);
		$sort_numerically=1;
		if(@_ < 1  ){ print "\n# FATAL: sort_by_column needs 2 arguments\n"; die }
		for (@_){
				if(ref $_ eq 'HASH'){ %in =%{$_}; }
				elsif( ref $_ eq 'SCALAR'){ $col=${$_}; }
				elsif(/^\d+$/){ $col=$_ }
				elsif(/^\s*r\s*$/i){ $sort_numerically=1; $sort_numerically_RV='r'; $sort_non_numerically=0; }
				elsif(/^\s*[nd]\s*$/i){ $sort_numerically=1; $sort_non_numerically=0; }
				elsif(/^\s*n[umerically]*\s*$/i){ $sort_numerically=1; $sort_non_numerically=0; }
				elsif(/^\s*s\s*$/i){ $sort_non_numerically=1; $sort_numerically=0; }
		}
		$col--;

		@keys= keys %in;
		if($sort_numerically ){
				 if($sort_numerically_RV){
						 @keys=  sort { $in{$b} <=> $in{$a} } @keys;
				 }else{
						 @keys=  sort { $in{$a} <=> $in{$b} } @keys;
				 }
		}else{ # here let's do the sring sort
						 @keys=  sort { $in{$a} cmp $in{$b} } @keys;
		}
		return(\@keys);
}




#________________________________________________________________________
# Title     : by_values
# Usage     : for $key(sort by_values(values %assoc)){print $assoc{$key},"\n";}
# Function  :
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub by_values{
	$hash{$a} cmp  $hash{$b}
}

#______________________________________________________________________
# Title     : sort_string_by_length (synonym of sort_str_by_length  )
# Usage     : @output = @{&sort_string_by_length(@any_input_strings, [-r], @more)};
# Function  : sorts strings in array according to their sizes
#             bigger comes first.
# Example   :
# Warning   :
# Keywords  : sort_array_by_length, sort_str_by_length, sort_array_string_by
#             sort_string_by_leng, sort_by_length, sort_by_leng,
#             sort_array_by_string_length, sort_array_elements_by_string_length
# Options   : -r  reverse the order
# Category  :
# Version   : 1.2
#-------------------------------------------------------------------
sub sort_string_by_length{
		my(@input, $i, $small_first, @output);
		for($i=0; $i<@_; $i++){
				if( $_[$i]=~/^\-?r$/i){
								$small_first =1;
								splice(@_, $i, 1);
				}elsif(ref($_[$i]) eq 'ARRAY'){
						push(@input, @{$_[$i]});
				}elsif(ref($_[$i]) eq 'SCALAR'){
								if(${$_[$i]}=~/^\-?r$/i){
									 $small_first=1;
									 splice(@_, $i, 1);
								}else{
									 push(@input, ${$_[$i]});
								}
				}elsif( !ref($_[$i]) ){
						push(@input, $_[$i]);
				}
		}
		if($small_first ==1){
				@output = sort {length($a) <=> length($a) || ($b cmp $a)} @input;
		}else{
				@output = sort {length($b) <=> length($a) || ($a cmp $b)} @input;
		}
		return (\@output);
}


#________________________________________________________________________
# Title     : get_host_by_addr
# Usage     : ($name,$aliases,$addrtype,$length,@addrs)=&get_host_by_addr('131.111.137.11'); or
# Function  :
# Example   : ($name,$aliases,$addrtype,$length,@addrs)=&get_host_by_addr($var); while $var = "13.13.12.12";
# Warning   :
# Keywords  : get_host_by_address, get_hostname_by_address
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_host_by_addr{
	 my $addr, @output;
	 if(ref($_[0]) eq 'SCALAR'){
	   $addr= ${$_[0]};
	 }elsif(!ref($_[0])){
	  $addr=$_[0];
	 }
	my(@addr) = split(/\./, $addr);
	my($address) = pack("C4",@addr);
	 my($name,$alias,$addrtype,$leng,@addrs)= gethostbyaddr($address,2);
	 push(@output, $name,$alias,$addrtype,$leng,@addrs);
	 return(\@output);
}


#________________________________________________________________________________
# Title     : get_hostname    asherman@fmrco.com (Aaron Sherman)
# Usage     :
# Function  :
# Example   :
# Keywords  : get_hostname, hostname
# Options   :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub get_hostname{
		local (*P,@tmp,$hostname,$_);
		if (open(P,"hostname 2>&1 |") && (@tmp = <P>) && close(P)){
						chop($hostname = $tmp[$#tmp]);
		}elsif (open(P,"uname -n 2>&1 |") && (@tmp = <P>) && close(P)){
						chop($hostname = $tmp[$#tmp]);
		}else{
						die "$0: Cannot get hostname from 'hostname' or 'uname -n'\n";
		}
		@tmp = ();
		close P; # Just in case we failed in an odd spot....
		return(\$hostname);
}


#________________________________________________________________________
# Title     : get_host_by_name
# Usage     : ($name,$aliases,$addrtype,$length,@addrs)=&get_host_by_name('ind4'); or
# Function  :
# Example   : ($name,$aliases,$addrtype,$length,@addrs)=&get_host_by_name($var);
#             while $var = "ind4";
# Warning   : ! not working yet.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_host_by_name{
	my($name)=$_[0];
	my($name,$alias,$addrtype,$leng,@addrs)= gethostbyname($name);
}

#________________________________________________________________________
# Title     : word_wrap
# Usage     : &word_wrap($line_to_format)
# Function  :
# Example   :
# Warning   :
#             The following subroutine does word wrapping on a text string
# Keywords  :
# Options   :
# Returns   :
#             The string with newlines replacing spaces in appropriate places.
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub word_wrap {
	 local ($_) = @_;            # Access the argument.
	 s/(.{60}\S+)\s+/$1\n/g;     # Wrap on first space after 60th char.
										  # (This isn't the best algorithm, but it's
										  # simple.)
	 $_ && "$_\n";               # Append a newline if there's any text.
}

#________________________________________________________________________
# Title     : show_array
# Usage     : &show_array(\@input_array);
# Function  : for debugging purpose. Shows any array elem line by line.
# Example   : Output:      item1
#             Output:      item2
#             Output:      item3
# Warning   : can handle scalar ref, too.
# Keywords  :
# Options   : -h  for horizontal display of elements
#             c   for compact (do not put new line between array chunk)
#             s   for putting new line between arrays
# Returns   :
# Argument  :
# Category  :
# Version   : 2.4
#--------------------------------------------------------------------
sub show_array{
	my($k, $i, $t,  @in2, $in, $space, $show_horizontally, $compact);
	my(@in)=@_;

	## This is to get the option of 'horizontal' to make horizontal output.
	for($t=0; $t < @in ; $t++){
	 if($in[$t] =~/\-?[hH][orizontal]*$/){   ### No ref.
		 $show_horizontally = "h";
		 splice(@in, $t, 1);  $t--;
	 }elsif(${in[$t]} =~/-?[hH][orizontal]*$/){  ### ref.
		 $show_horizontally = "h";
		 splice(@in, $t, 1);  $t--;
	 }elsif(${in[$t]} =~/^s$/i){  ### ref.
		 $space = "s";
		 $compact='';
		 splice(@in, $t, 1);  $t--;
	 }elsif(${in[$t]} =~/^c$/i){  ### ref.
		 $compact = "c";
		 $space='';
		 splice(@in, $t, 1);  $t--;
	 }
	}

	for($k=0; $k < @in; $k++){
	 if(ref($in[$k]) eq 'ARRAY'){
		 &show_array(@{$in[$k]}, "$show_horizontally", "$compact", "$space" );
	 }elsif(ref($in[$k]) eq 'SCALAR'){
		 if($show_horizontally eq "h"){
			 print ${$in[$k]}, ",  ";
		 }elsif(  $show_horizontally ne "h"){
			 print ${$in[$k]}, "\n";
		 }
	 }elsif( !ref($in[$k]) ){
		 if($show_horizontally eq 'h'){
			 print  $in[$k] , ",  ";
		 }elsif(  $show_horizontally ne "h"){
			 print  $in[$k] , "\n";
		 }
	 }
	}
	if($compact !~/^c$/i){
	print "\n"; #### This is necessary to distinguish different arrays.
	}
}

#________________________________________________________________________
# Title     : array_most_occur
# Usage     : $median = ${&array_most_occur(\@array)};
# Function  :
# Example   :
# Warning   :
# Keywords  :  median_array, get_median_array, get_array_median, array_median
# Options   :
# Returns   : \$median
# Argument  : \@array
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub array_most_occur{
	my(%hash, @keys, $i, $most, $most_key);
	my(@array)=@{$_[0]};
	for($i=0; $i<@array; $i++){
		$hash{$array[$i]}++;
	}
	@keys = keys %hash;
	#&show_array(@keys);
	$most = $hash{$keys[0]};
	for($i=1; $i<@keys; $i++){
		if($hash{$keys[$i]} > $most){
	  $most_key=$keys[$i];
			 $most    =$hash{$keys[$i]};
		}
	}
	\$most_key;
}

#________________________________________________________________________
# Title     : array_least_occur
# Usage     : $median = ${&array_least_occur(\@array)};
# Function  :
# Example   :
# Warning   :
# Keywords  :  median_array, get_median_array, get_array_median, array_median
# Options   :
# Returns   : \$median
# Argument  : \@array
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub array_least_occur{
	my(%hash, @keys, $i, $least, $least_key);
	my(@array)=@{$_[0]};
	for($i=0; $i<@array; $i++){
		$hash{$array[$i]}++;
	}
	@keys = keys %hash;
	#&show_array(@keys);
	$least = $hash{$keys[0]};
	for($i=1; $i<@keys; $i++){
		if($hash{$keys[$i]} < $least){
	  $least_key=$keys[$i];
			 $least    =$hash{$keys[$i]};
		}
	}
	\$least_key;
}

#________________________________________________________________________
# Title     : show_hash_matrix
# Usage     : &show_hash_matrix(\%input_hash);
# Function  :
#
# Example   : &show_hash_matrix(\%DP_matrix);
#    0       0       -0      -0      -0      -0      -0      -0      -0      -0      -0
#    1       -0      -1      4       0       4       -3      0       -2      -1      -1
#    2       -0      -3      -4      2       -3      15      4       -2      -5      -4
#    3       -0      0       -5      -6      0       4       13      12      1       -5
#    4       -0      5       -1      -7      -7      -3      2       13      17      6
#    5       -0      -1      9       -1      -3      -10     -3      2       12      16
#    6       -0      5       -2      7       -2      -6      -12     -3      7       17
#
# Warning   : There is a global variable:  $show_matrix_option
# Keywords  : show_matrix, show_matrix_hash
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub show_hash_matrix{
		my($i, $j, %hash, @keys1, @keys2 ); ## You should not put $show_matrix_option

		%hash=%{$_[0]};

		@keys1=keys %hash;
		print "\n";
		for($i=0; $i< @keys1; $i++){
			 print "$keys1[$i] |\t";
			 @keys2=keys %{$hash{$keys1[$i]}};
			 for($j=0; $j< @keys2; $j++){
					if(ref($hash{$keys[$i]}{$keys2[$j]}) eq 'ARRAY'){
						 print "@{$hash{$keys[$i]}{$keys2[$j]}}\t";
					}elsif(ref($hash{$keys[$i]}{$keys2[$j]}) eq 'SCALAR'){
						 print "${$hash{$keys[$i]}{$keys2[$j]}}\t";
					}else{
					   print "$hash{$keys[$i]}{$keys2[$j]}\t";
					}
			 }
			 print "\n";
		}
}

#_________________________________________________________________________
# Title    : show_hash_for_dir_subroutine
# Function : for debugging purpose. Shows any hash elems line by line in 2 columns.
# Usage    : &show_hash(\%input_hash1, \%input_hash2,.....);
# Version  : 1.1
#-------------------------------------------------------------------
sub show_hash_for_dir_subroutine{
    my($i, %in);
    for($i=0; $i<= $#_; $i++){ %in=%{$_[$i]};
	   for(keys %{$_[$i]}){ print $_,  "\t",  $in{$_},  "\n"; }
	}
}



#________________________________________________________________________
# Title     : show_array_matrix
# Usage     : &show_array_matrix(\@input_array);
# Function  :
#
# Example   : &show_array_matrix(\@DP_matrix);
#    0 |       0       -0      -0      -0      -0      -0      -0      -0      -0      -0
#    1 |      -0      -1      4       0       4       -3      0       -2      -1      -1
#    2 |      -0      -3      -4      2       -3      15      4       -2      -5      -4
#    3 |      -0      0       -5      -6      0       4       13      12      1       -5
#    4 |      -0      5       -1      -7      -7      -3      2       13      17      6
#    5 |      -0      -1      9       -1      -3      -10     -3      2       12      16
#
# Warning   : There is a global variable:  $show_matrix_option
# Keywords  : show_matrix, show_matrix_array
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub show_array_matrix{
		my($i, $j, @array, @keys1, @keys2 ); ## You should not put $show_matrix_option

		@array=@{$_[0]};

		print "\n";
		for($i=0; $i< @array; $i++){
			 print "$i |\t";
			 $dim_size=@{$array[0]};
			 for($j=0; $j< $dim_size; $j++){
					if(ref($array[$i][$j]) eq 'ARRAY'){
						 print "@{$array[$i][$j]}\t";
					}elsif(ref($array[$i][$j]) eq 'SCALAR'){
						 print "$array[$i][$j]\t";
					}else{
					   print "$array[$i][$j]\t";
					}
			 }
			 print "\n";
		}
}

#________________________________________________________________________
# Title     : show_array_path_matrix
# Usage     : &show_array_path_matrix(\@input_array);
# Function  :
#
# Example   : &show_array_path_matrix(\@DP_matrix);
#    0 |       0       -0      -0      -0      -0      -0      -0      -0      -0      -0
#    1 |      -0      -1      4       0       4       -3      0       -2      -1      -1
#    2 |      -0      -3      -4      2       -3      15      4       -2      -5      -4
#    3 |      -0      0       -5      -6      0       4       13      12      1       -5
#    4 |      -0      5       -1      -7      -7      -3      2       13      17      6
#    5 |      -0      -1      9       -1      -3      -10     -3      2       12      16
#
# Warning   : There is a global variable:  $show_matrix_option
# Keywords  : show_matrix, show_matrix_array
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub show_array_path_matrix{
		my($i, $j, @array, @keys1, @keys2 ); ## You should not put $show_matrix_option

		@array=@{$_[0]};

		print "\n";
		for($i=0; $i< @array; $i++){
			 print "$i |\t";
			 $dim_size=@{$array[0]};
			 for($j=0; $j< $dim_size; $j++){
					print "@{$array[$i][$j]}\t";
			 }
			 print "\n";
		}
}





#________________________________________________________________________
# Title     : show_hash
# Usage     : &show_hash(\@input_array);
# Function  : for debugging purpose. Shows any array elem line by line.
#             the line is 60 elements long (uses recursion)
# Example   : Output:      item1
#             Output:      item2
#             Output:      item3
# Warning   : There is a global variable:  $show_hash_option
#             It tries to detect any given sting which is joined by ','
# Keywords  :
# Options   : -s or -S or s or S for spaced output. Eg)
#             seq1       1 1 1 1 1 1 1 1 1 1 1 1
#
#             instead of
#             seq1       111111111111
#
#             -h or -H or h or H for horizontal line of '---------...'
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.9
#--------------------------------------------------------------------
sub show_hash{
		my($k, $i, $t, @in2, $in, $LEN, %TEM, $out_in_html_form ); ## You should not put $show_hash_option
		my(@in)=@_;                     ## and $horizontal_line  in my !!!
		my($KL)=18; # default keys string length;
		my($VL)=80; # default values string length;
		my($GAP)=2;  # default space between keys and values
		my($horizontal_line, $show_hash_optionXX, $Hash_counter, @line);

		## This is to get the option of 'space' to make spaced output.
		for($t=0; $t < @in; $t++){
				if($in[$t] =~/^[-]+[sS][pace]*$/){
						$show_hash_optionXX = 1;  splice(@in, $t, 1);
				}elsif(${in[$t]} =~/^[-]+[sS][pace]*$/){
						$show_hash_optionXX = 1;  splice(@in, $t, 1);
				}elsif($in[$t] =~/^[-]+[hH][rR]*$/){
						$horizontal_line = 1;     splice(@in, $t, 1);
				}elsif($in[$t] =~/html/i){
						$out_in_html_form="HTML"; splice(@in, $t, 1);
				}elsif(${in[$t]} =~/html/i){
						$out_in_html_form='HTML'; splice(@in, $t, 1);
				}

		}

		######## Main loop #################
		if($horizontal_line ==1){  ## This puts the delimiter '--------------(  )'
				$Hash_counter ++;
				print "\n","-"x78,"(${Hash_counter}th hash)", "\n";
		}

		for($k=0; $k < @in; $k++){
			 if(ref($in[$k]) eq 'ARRAY'){  ### When the hashes were given in array ref.
						&show_hash(@{$in[$k]}, $show_hash_optionXX, $horizontal_line, $out_in_html_form);
						print "\n";
			 }elsif(ref($in[$k]) eq 'HASH'){  ### recursion
						&show_hash(%{$in[$k]}, $out_in_html_form, $show_hash_optionXX, $horizontal_line);
						print "\n";
			 }elsif(ref($in[$k+1]) eq 'HASH'){  ### recursion
						&show_hash(%{$in[$k+1]}, $horizontal_line, $out_in_html_form, $show_hash_optionXX); print "\n";
			 }elsif(ref($in[$k]) eq 'SCALAR'){
						if($out_in_html_form){  print ${$_[$k]}, "<br>\n";
						}else{   print ${$_[$k]}, "\n"; }
			 }elsif( !ref($in[$k]) ){
						if( !ref($in[$k+1]) && defined($in[$k+1])  ){
								 if($show_hash_optionXX){  #### space option checking.
										 %TEM = @in;
										 $LEN = ${&max_elem_string_array_show_hash(keys %TEM)};
											if($LEN > $KL){ $KL = $LEN + $GAP +2};
											if($out_in_html_form){
												 printf ("<br>%-${KL}s ", $in[$k]);  $k++;
												 printf ("%-${VL}s<br>\n","@line");
											}else{
												 printf ("%-${KL}s ", $in[$k]);  $k++;
												 printf ("%-${VL}s\n","@line");
											}
								 }else{                        ### If not option is set, just write
											%TEM = @in;
											$LEN = ${&max_elem_string_array_show_hash( keys %TEM)};
											if($LEN > $KL){ $KL = $LEN + $GAP +2};
											if($out_in_html_form){
												 printf ("<br>%-${KL}s ", $in[$k]);  $k++; # print $in[$k], "\t";  $k++;
												 printf ("%-${VL}s<br>\n",$in[$k]);        # print $in[$k], "\n";
											}else{
												 printf ("%-${KL}s ", $in[$k]);  $k++; # print $in[$k], "\t";  $k++;
												 printf ("%-${VL}s\n",$in[$k]);        # print $in[$k], "\n";
											}
								 }
						}
						#________________________________________________________
						# Title    : max_elem_string_array_show_hash
						# Keywords : largest string length of array
						# Function : gets the largest string length of element of any array of numbers.
						# Usage    : ($out1, $out2)=@{&max_elem_array(\@array1, \@array2)};
						#            ($out1)       =${&max_elem_array(\@array1)          };
						# Argument : numerical arrays
						# Version  : 1.1
						#-------------------------------------------------------
						sub max_elem_string_array_show_hash{
								my(@input, $i, $max_elem); @input = @{$_[0]} || @_;
								for($i=0; $i< @input ; $i++){
										 $max_elem = length($input[0]);
										 if (length($input[$i]) > $max_elem){
														 $max_elem = length($input[$i]);
										 }
								}
								return(\$max_elem);
						}
						#####################################insert_gaps_in_seq_hash
			 }
	 }
}

#_______________________________________________________________
# Title     : open_stride_files
# Usage     :
# Function  :
# Example   :
# Warning   :
# Class     : Utility
# Keywords  :
# Options   :
# Package   :
# Reference : http://sonja.acad.cai.cam.ac.uk/bioperl.html
# Returns   :
# Tips      :
# Argument  :
# Todo      :
# Author    : A Biomatic
# Version   : 1.0
#-----------------------------------------------------------
sub open_stride_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my (%sequence, %HASH, @Keys, $seq_found1, $S_start, $S_end, $seq_found,
			$present_seq, @seq_Names, %Sizes, $bare_seq_name, $fasta_seq_idx_file,
			%seq_fragments, $min_seq_leng_accepted, $No_gap_char_allowed,
			$remove_strange_and_masked_residues, $make_Upper_case_seq,
			%sec_str);
		$min_seq_leng_accepted=0;
		my %AA=%{&convert_3_to_1_letter};
		$name='name';
		$prediction_reliability=1;

		if(@file<1){
			print "\n \@file has less than 1 elem. There is no fileinput for open_fasta_files\n";
			die
		}
		if($vars{'m'}=~/(\d+)/){ $min_seq_leng_accepted=$1; }
		if($char_opt=~/N/){  $No_gap_char_allowed='N'; }
		if($char_opt=~/R/){  $remove_strange_and_masked_residues='R'; }
		if($char_opt=~/U/){  $make_Upper_case_seq='U'; }
		$stride_file=$file[0]; ## for the time being
		open(STRIDE_FILE, $stride_file) || die "\n# (E) Cant open $stride_file\n";
		while(<STRIDE_FILE>){
			 if(/ASG\s+(\w+)\s+\w?\s+(\d+)\s+(\d+)\s+(\w)\s+/){
					 $s=$3;
					 $pdb_position=$2;
					 $residue=$AA{$1};
					 $position=$s+1;
					 $residues ={$position, $residue};
					 $sequence .=$residue;
					 $sec_str .=$4;
					 $secondary_structure= {$position, $4};
			 }
		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# Definition of Seq information detail, Ver 1.0
		#______________________________________________________________________________
		%sec_str=('name'                  =>$name,
							'ID'                    =>$name,
							'protein_name'          =>$name,
							'seq_name'              =>$name,
							'residue_array'         =>$residues,
							'residue_string'        =>$sequence,
							'sec_str_array'         =>$secondary_structure,
							'sec_str_string'        =>$sec_str,
							'sec_str'               =>$sec_str,
							'mol_type'              =>'protein',
							'type'                  =>'protein',
							'prediction_reliability'=>$prediction_reliability,
							'prediction'            =>'prediction',
							'sequence'              =>"$sequence",
							'seq_string'            =>$sequence,
							'structure_assignment'  =>0); # this is not a struc. assignment as in DSSP
		#__________________________________________________________________________________
		return(\%sec_str);
}

#____________________________________________________________________
# Title     :  open_predator_files
# Usage     :
# Function  : gets sec. str. prediction of predator(sec. str pred program)
#             and puts in hash If 's' option is given, it also gives
#             sequence hash ref as the second output ref.
#             This can handle the 2 types of output format of
#             predator. So, the output can will be different according
#             to inputs.
# Example   :
#  There are 2 types of output.  The short output:>
#
#  > MOZ_HUMAN_part
#                .         .         .         .         .
#  1    LDHKTLYYDVEPFLFYVLTQNDVKGCHLVGYFSKEKHCQQKYNVSCIMIL   50
#       ___EEEEEE__HHHHHHH_______EEE____________EEEEEEEEE_
#
# ((-l option for long output )
#  NAME MOZ_HUMAN_part
#  HEADER  |- Residue -|  Pred  Rel      NAli   Asn
#  PRED    1    MET    M  c     0.000    0      ?
#  PRED    2    ALA    A  c     0.000    0      ?
#
# Warning   :
# Keywords  : open_prd_files, open_pred_files, predator, open_prdl_files{
#             open_pre_files, secture prediction file
# Options   : 's' for sequence output as well (\%sec_str, \%seq)
#             'p' for percentage of the sec. str.
#             'a' for accumulated percentage. This will
#                  set 'p' automatically
#             'n' for NO name when outputing Percentage of chars with
#                 HASH input to get_occurances_of_char sub.
#    $reverse_residue_order=r by r
#    $use_universal_seq_hash_format=u by u -u
#    $consider_top_X_percent_only= by T=
# Returns   :
# Argument  :
# Category  :
# Version   : 3.0
#-----------------------------------------------------------
sub open_predator_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my( @out_ref, $seq_out, %sec_str, %seq, $percent_out, $NO_name_out,
				$short_form_out_detected, $long_form_out_detected, $accumulate, $sequence,
				$reverse_residue_order, %rev_sec_str, $use_universal_seq_hash_format,
				@seq, @sec_str, $sec_str, $secondary_structure, @reliability_sorted,
				$num_of_diff_pred_for_both_methods, %mismatch_stats, $num_of_residues,
				$name_found, $consider_top_X_percent_only, @posi_under_threshold_arr,
				@residues_array, $top_X_perc_sec_str);
		$consider_top_X_percent_only=100; # the default
		if($vars{'T'}=~/(\d+)/i){ $consider_top_X_percent_only=$1; }
		if($char_opt=~/s/i){ $seq_out=1 }
		if($char_opt=~/a/i){ $accumulate=1  }
		if($char_opt=~/p/i){ $percent_out=1 }
		if($char_opt=~/n/i){ $NO_name_out='n' }
		if($char_opt=~/r/){  $reverse_residue_order='r' }
		if($char_opt=~/u/){  $use_universal_seq_hash_format='u'; print "\n# (i) \$use_universal_seq_hash_format is set";}

		for($i=0; $i< @file; $i++){
	 my (%sec_str, $sec_str, %seq) if($accumulate !=1);
     my ($secondary_structure, $cut_off_position, @reliability, $top_X_perc_sec_str,
             @posi_under_threshold_arr, $cut_off_relia_value, $sequence, $residue_num_count);

     open(PREDATOR_FILE, "$file[$i]");
     print "\n# (INFO) open_predator_files: opening $file[$i]";
	 while(<PREDATOR_FILE>){
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # Simple sec str input form
               #________________________________________________
               if(/# No of Forw Backward Mismatch pred. res\/total:\s+(\d+)\s*\/\s*(\d*)/i){
                    $num_of_diff_pred_for_both_methods=$1;
                    $num_of_residues=$2; ## If the info is given, will be assigned
               }elsif(/# Mismatch stat:\s+(\w+)\s+(\d+)/){ ## for # Mismatch stat: H_E_mismatch 13
                    $mismatch_stats{$1}=$2;
               }elsif(/^\s*\>\s*(\S+)/){
                    $name=$1; $name_found=1;
               }elsif($name_found and /^\s+\./){
                    $short_form_out_detected=1; $name_found=0;
                    print "\n# (INFO) \"$name\" was found in $file[$i]";
               }elsif($short_form_out_detected and /^\s+([CHE_]+)\s*$/i){
                    $sec_str .=$1;
                    $sec_str{$name}.=$1;
               }elsif($short_form_out_detected and /\s*\d+\s*(\w+)\s*\d+/){
                    $seq{$name}.=$1;
               }elsif($short_form_out_detected and /^\s+\d+\s+\S/){
                    next;
               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
               # Sec str form HASH input. Complex form, The long one
               #________________________________________________
               }elsif(/^\s*NAME\s+(\S*)/){
                    $name=$1;   $long_form_out_detected=1;
               }elsif($long_form_out_detected and /^\s*\S+\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S)\s+(\S+)\s+\S+\s+\S+/){
                    $residue_num_count++;
                    $position=$1;
                    $residue_3_letter=$2;
                    $residue_1_letter=$3;
                    $sec_str_predicted=$4;
                    $sec_str .=$4;
                    $reliability=$5;
                    push(@residues_array,  $residue_1_letter);
                    push(@reliability, $reliability);
                    $sequence .=$residue_1_letter;
                    if($position < 2){ $reliability=2.0; $sec_str_predicted='C'; } # <-- This is to make the prediction of Coil to 1.0

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Making a simple HASH style output(OLD form)
                    #_______________________________________________________
                    $sec_str{$position}=[$residue_1_letter, $sec_str_predicted,
                                                               $reliability, $name, $residue_num_count];
                    if( $use_universal_seq_hash_format ){

                            $residues ={$position, $residue_1_letter};
                    }
            }
	 }
				 close (PREDATOR_FILE);

				 $num_of_residues=@sec_str=split(//, $sec_str);

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # Considering only certain high ranking predictions (this is to make the same sample size as commonly predicted region
				 #______________________________________________________________________________________________________________________
				 if($consider_top_X_percent_only < 100){  # as default $consider_top_X_percent_only has 100
						 my ($exclusion_count, @top_X_perc_sec_str);
						 my @reliability_sorted  = sort {$a<=>$b} @reliability;
						 my $cut_off_position    = int( $num_of_residues *(1-$consider_top_X_percent_only/100) );
						 my $cut_off_relia_value = $reliability_sorted[$cut_off_position];
						 print  "\n\$cut_off_relia_value $cut_off_relia_value \$cut_off_position $cut_off_position \/$residue_num_count\n";
						 for($j=0; $j< @sec_str; $j++){
								if($reliability[$j] <= $cut_off_relia_value or $reliability[$j] == 0){
										$exclusion_count++;
										if($exclusion_count >= $cut_off_position){
												$top_X_perc_sec_str[$j]=$sec_str[$j];
										}else{
												$top_X_perc_sec_str[$j]='-'; ## strike out
												push(@posi_under_threshold_arr, $j);
										}
								}elsif($reliability[$j] > $cut_off_relia_value){
										$top_X_perc_sec_str[$j]=$sec_str[$j];
								}else{    print "\n# Error ,,, "; die;      }
						 }
						 $top_X_perc_sec_str=join('', @top_X_perc_sec_str);
				 }
				 if($reverse_residue_order){
						 $secondary_structure   =[reverse @sec_str];
						 $prediction_reliability=[reverse @reliability];
						 $sequence=reverse($sequence);
						 $sec_str =reverse($sec_str);
				 }else{
						 $secondary_structure=[@sec_str];
						 $prediction_reliability=[@reliability];
				 }
				 $matched_prediction_count=$residue_num_count-$num_of_diff_pred_for_both_methods;

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # This is the general Seq object format
				 #_______________________________________________
				 if( $use_universal_seq_hash_format ){
						if($short_form_out_detected){  ## OLD style
								$sequence=$seq{$name};
								$sec_str=$sec_str{$name};
								@seq=split(//, $sequence);
								for($s=0; $s< @sec_str; $s++){
										$position=$s+1;
										$residues ={$position, $seq[$s]};
								}
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						# Definition of Seq information detail, Ver 1.5
						#______________________________________________________________________________
						%sec_str=('name'                    =>$name,
											'ID'                      =>$name,
											'PDB_chain_number'        =>$chain,
											'chain_number'            =>$chain,
											'protein_name'            =>$name,
											'seq_name'                =>$name,
											'top_X_perc_sec_str'      =>$top_X_perc_sec_str,
											'residue_hash'            =>$residues,
											'residue_array'           =>[@residues_array],
											'residue_string'          =>$sequence,
											'sec_str_array'           =>$secondary_structure,
											'sec_str_string'          =>$sec_str,
											'sec_str'                 =>$sec_str,
											'mol_type'                =>'protein',
											'type'                    =>'protein',
											'prediction_reliability'  =>$prediction_reliability,
											'cut_off_reliability_val' =>$cut_off_relia_value,
											'prediction'              =>'prediction',
											'sequence'                =>"$sequence",
											'seq_string'              =>$sequence,
											'structure_assignment'    =>0,
											'matched_prediction_count'   =>$matched_prediction_count,
											'mismatched_prediction_count'=>$num_of_diff_pred_for_both_methods,
											'num_of_diff_pred_for_both_methods'=>$num_of_diff_pred_for_both_methods,
											'num_of_residues'         =>$num_of_residues,
											'size_of_sequence'        =>$num_of_residues,
											'mismatch_stats'          =>{%mismatch_stats},
											'reverse_residue_order'   =>$reverse_residue_order,
											'posi_under_threshold_arr'=>[@posi_under_threshold_arr]
											); # this is not a struc. assignment as in DSSP
						#__________________________________________________________________________________
				 }
	 print "\n \%sec_str for $file[$i] is: ", %sec_str, "\n" if ($debug == 1);
	 if($seq_out==1){ push(@out_ref, \%sec_str, \%seq);
	 }elsif($percent_out==1 ){
	      push(@out_ref, [%{&get_occurances_of_char(\%sec_str, $NO_name_out, 'p')}] );
	 }elsif($percent_out !=1){ push(@out_ref, \%sec_str) }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # If -r option is set (for long form, this does not affect
				 #____________________________________________________________
				 if($short_form_out_detected and $reverse_residue_order){
							@keys=keys %sec_str;
							for($r=0; $r<@keys; $r++){
									$rev_sec_str{$keys[$r]}=reverse($sec_str{$keys[$r]});
							}
							%sec_str=%rev_sec_str;
				 }
		}
		print "\n# (INFO) \$long_form_out_detected is returned from open_predator_files\n" if $long_form_out_detected;
		print "\n# (INFO) \$short_form_out_detected is returned from open_predator_files\n" if $short_form_out_detected;
		if(@out_ref==1){
			 return($out_ref[0]);
		}elsif(@out_ref>1){
			 return(@out_ref);
		}
}









#_______________________________________________________________________________
# Title     : open_phd_files
# Usage     : &open_phd_files(\$file_name, $options,,,,,);
# Function  : open phd files and put sequences in a hash(s) (run open_phd_files.pl to
#             get some ideas on how this works. type  'open_phd_files.pl xxx.phdo s',
#             it will produce 5 different hashes of secture pred.
# Example   :
# Warning   : All the spaces are converted to '_'
# Keywords  :
# Options   : $secondary, $access, $PHD_sec, $Rel_sec, $prH_sec, $prE_sec, $prL_sec,
#                  $prL_sec, $SUB_sec, $P_3_acc, $PHD_acc, $Rel_acc, $SUB_acc);
#   $attach_class_info_in_seq_name=c by c ## this makes seq_name   seq_name_PHD_s
#   $simple_seq_with_name_hash=s by s
#   $use_universal_seq_hash_format=u by u
#
# Returns   : one or more hashes(ref.) secture prediction of PHD server
#     --- The PHD secondary server output which are read by open_phd_files -----
#     1 =>       PHD sec |         HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH     HHHHHHH|
#     2 =>       Rel sec |987544342178899999999987678999998478999999999995679771688999|
#     3 =>       prH sec |001222323478899999999987778999998678999999999986110115788999
#     4 =>       prE sec |000010000101000000000000010000000000000000000000000000010000
#     5 =>       prL sec |987666565410000000000001110000001211000000000002789774100000
#     6 =>       SUB sec |LLLL
#     7 =>       P_3 acc |eeeeeeeeee bbeeebbbebbbbebeeee b bbebbebb eebeebe eee eebbeb|
#     8 =>       PHD acc |988787787630066600060000606667515007007005760671847885760160
#     9 =>       Rel acc |979685546222352421667053233245604127749164753790316552446141
#     0 =>       SUB acc |eeeeeeeee
#     types of PHD output, like 1 for 'PHD sec', 2 for 'Rel sec' etc.
# Argument  : one or more file names and options. Files should be PHD server's result.
# Version   : 1.8
#-------------------------------------------------------------------------------
sub open_phd_files{
	my(@names, $i, $j,$n, $s, @in, @out_hash_ref_list, $base, @option);
	my($secondary, $access, %PHD_sec, %Rel_sec, %prH_sec, %prE_sec, %prL_sec, %prL_sec,
		 %SUB_sec, %P_3_acc, %PHD_acc, %Rel_acc, %SUB_acc, $simple_seq_with_name_hash,
		 $PHD_sec_on, $Rel_sec_on, $prH_sec_on, $prE_sec_on, $prL_sec_on, $SUB_sec_on,
		 $P_3_acc_on, $PHD_acc_on, $Rel_acc_on, $SUB_acc_on, $residues, $residue_string,
		 $PHD_sec, $Rel_sec, $prH_sec, $prE_sec, $prL_sec, $SUB_sec, $P_3_acc,
		 $PHD_acc, $Rel_acc, $SUB_acc, $attach_class_info_in_seq_name, %sec_str,
		 $use_universal_seq_hash_format, $position);

	for($i=0; $i < @_; $i ++){
			if  ( (ref($_[$i]) eq 'SCALAR' )&&(-f ${$_[$i]}) ){ push(@in, ${$_[$i]}) }
			elsif( ref($_[$i]) eq 'ARRAY' ){
							for($j=0; $j< @{$_[$i]}; $j ++){
											if( -f ${$_[$i]}[$j]){ push (@in, ${$_[$i]}[$j]) }
							}
			}
			elsif((ref($_[$i]) eq 'SCALAR' ) && ($_[$i]=~/^[\-]*\w+/) ){ push(@option, ${$_[$i]}); }
			elsif(!ref($_[$i]) && (-e $_[$i]) ){  push(@in, $_[$i]) }
			elsif(!ref($_[$i]) && ($_[$i]=~/^[\-]*\w+/) ){ push(@option, $_[$i]); }
			if($_[$i]=~/^s$/i){  $simple_seq_with_name_hash='s'; };
			if($_[$i]=~/^c$/i){  $attach_class_info_in_seq_name='c'; };
			if($_[$i]=~/^\-?u$/){$use_universal_seq_hash_format='u'; print "\n# (i) PHD \$use_universal_seq_hash_format is set\n"; };
	}
	## option handling ##
	if(@option == 0){ $PHD_sec_on = 1; } # if no option is given. default is single PHD_sec output.

	elsif(@option >= 1){ $PHD_sec_on = 0;
		 for($i=0; $i < @option; $i ++){
			 if( $option[$i] =~ /^[sS]$/){
					$PHD_sec_on = 1;  $Rel_sec_on = 1; $prH_sec_on = 1;
					$prE_sec_on = 1;  $prL_sec_on = 1; $SUB_sec_on = 1;   }
			 elsif( $option[$i] =~ /^[aA]$/){
							$P_3_acc_on = 1; $PHD_acc_on = 1; $Rel_acc_on = 1;  $SUB_acc_on = 1;  }
			 elsif( $option[$i] =~ /^PHD_sec$/){ $PHD_sec_on = 1}
			 elsif( $option[$i] =~ /^Rel_sec$/){ $Rel_sec_on = 1}
			 elsif( $option[$i] =~ /^prH_sec$/){ $prH_sec_on = 1}
			 elsif( $option[$i] =~ /^prE_sec$/){ $prE_sec_on = 1}
			 elsif( $option[$i] =~ /^prL_sec$/){ $prL_sec_on = 1}
			 elsif( $option[$i] =~ /^SUB_sec$/){ $SUB_sec_on = 1}
			 elsif( $option[$i] =~ /^P_3_acc$/){ $P_3_acc_on = 1}
			 elsif( $option[$i] =~ /^PHD_acc$/){ $PHD_acc_on = 1}
			 elsif( $option[$i] =~ /^Rel_acc$/){ $Rel_acc_on = 1}
			 elsif( $option[$i] =~ /^SUB_acc$/){ $SUB_acc_on = 1}
		 }
	}## option handling END ##

	for($i=0; $i < @in; $i++){
		 $base=${&get_base_names($in[$i])};
		 $seq_name=$base; ## default name when 'protein: xxxx' line is not in there.
		 open(FILE_1, "$in[$i]");    ########  This pattern matching is most buggy !! ####
				 while(<FILE_1>){
						if( /^# +(\w+)\s*$/ or /protein ?\: +(\S+)\s+length\s+\d+/i  ){
								if($1 eq 'predict'){ $seq_name     =$base }else{ $seq_name=$1 }; ## when no name is given to phd, it puts 'predict' in xxx.phd, so to change it to a proper name.
						}elsif( /^\s+PHD\s+sec\s\|([\t\w\. ]+)[\|]+\s*$/ ){ $PHD_sec .=$1 }
						elsif(  /^\s+AA\s+\|([\w]+)[\|]*\s*$/i){ $residue_string .=$1 }
						elsif(  /^\s+Rel\s+sec\s+\|([\w\. ]+)[\|]*\s*$/){ $Rel_sec .=$1 }
						elsif( (/^\s+prH\s+sec\s+\|([\w]+)[\|]*\s*$/) &&($prH_sec_on==1) ){ $prH_sec .=$1 }
						elsif( (/^\s+prE\s+sec\s+\|([\w]+)[\|]*\s*$/) &&($prE_sec_on==1) ){ $prE_sec .=$1 }
						elsif( (/^\s+prL\s+sec\s+\|([\w]+)[\|]*\s*$/) &&($prL_sec_on==1) ){ $prL_sec .=$1 }
						elsif( (/\s+SUB\s+sec\s+\|([\w\. ]+)[\|]+\s*$/)&&($SUB_sec_on==1) ){ $SUB_sec .=$1 }
						elsif( (/\sP_3\s+acc\s+\|([\w\. ]+)[\|]*\s*$/)&&($P_3_acc_on==1) ){ $P_3_acc .=$1 }
						elsif( (/\sPHD\s+acc\s+\|([\w\. ]+)[\|]*\s*$/)&&($PHD_acc_on==1) ){ $PHD_acc .=$1 }
						elsif( (/\s+Rel\s+acc\s+\|([\w\. ]+)[\|]*\s*$/)&&($Rel_acc_on==1) ){ $Rel_acc .=$1 }
						elsif( (/\s+SUB\s+acc\s+\|([\w\. ]+)[\|]*\s*$/)&&($SUB_acc_on==1) ){ $SUB_acc .=$1 }
				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
				# Writing the sec. str hash format
				#____________________________________________________
				unless($simple_seq_with_name_hash){
						if($use_universal_seq_hash_format){
								$PHD_sec=~s/ /C/g;
								@sec_str=split(//, $PHD_sec);
								if(@sec_str < 1){ print "\n# (E) open_phd_files: \@sec_str is empty\n"; die }
								@residues=split(//, $residue_string);
								@reliability=split(//, $Rel_sec);
								for($j=0; $j< @residues; $j++){
									 $position=$j+1;
									 $predic_relia_array={$position, $reliability[$j]/10};
									 $residue_1_letter=$residues[$j];
									 $residue_array={$position, $residue_1_letter};
									 $sec_str_array={$position, $sec_str[$j]};
								}
								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
								# Definition of Seq information detail, Ver 1.0
								#______________________________________________________________________________
								%sec_str=('name'                  =>$seq_name,
													'ID'                    =>$seq_name,
													'seq_name'              =>$seq_name,
													'residue_array'         =>$residue_array,
													'residue_string'        =>$residue_string,
													'sec_str_array'         =>$sec_str_array,
													'sec_str_string'        =>$PHD_sec,
													'sec_str'               =>$PHD_sec,
													'mol_type'              =>'protein',
													'type'                  =>'protein',
													'predic_relia_array'    =>$predic_relia_array,
													'predic_relia_string'   =>$Rel_sec,
													'prediction'            =>'prediction',
													'sequence'              =>$residue_string,
													'seq_string'            =>$residue_string,
													'structure_assignment'  =>0); # this is not a struc. assignment as in DSSP
								#__________________________________________________________________________________
						}else{
								$PHD_sec=~s/ /C/g;
								@sec_str=split(//, $PHD_sec);
								@residues=split(//, $residues);
								@reliability=split(//,$Rel_sec);
								for($j=0; $j< @residues; $j++){
									 $reliability=$reliability[$j]/10;
									 $sec_str{$j}=[$residues[$j], $sec_str[$j], $reliability, $seq_name];
								}
						}
				}elsif($PHD_sec_on==1 and $attach_class_info_in_seq_name){
						 $PHD_sec =~s/ /_/g; $PHD_sec{"$seq_name"._PHD_s} = $PHD_sec
				}elsif($PHD_sec_on==1){
						 $PHD_sec =~s/ /_/g; $PHD_sec{"$seq_name"} = $PHD_sec
				}
				if ($Rel_sec_on==1){ $Rel_sec =~s/ /_/g; $Rel_sec{"$seq_name"._Rel_s} = $Rel_sec }
				if ($prH_sec_on==1){ $prH_sec =~s/ /_/g; $prH_sec{"$seq_name"._prH_s} = $prH_sec }
				if ($prE_sec_on==1){ $prE_sec =~s/ /_/g; $prE_sec{"$seq_name"._prE_s} = $prE_sec }
				if ($prL_sec_on==1){ $prL_sec =~s/ /_/g; $prL_sec{"$seq_name"._prL_s} = $prL_sec }
				if ($SUB_sec_on==1){ $SUB_sec =~s/ /_/g; $SUB_sec{"$seq_name"._SUB_s} = $SUB_sec }
				if ($P_3_acc_on==1){ $P_3_acc =~s/ /_/g; $P_3_acc{"$seq_name"._P_3_a} = $P_3_acc }
				if ($PHD_acc_on==1){ $PHD_acc =~s/ /_/g; $PHD_acc{"$seq_name"._PHD_a} = $PHD_acc }
				if ($Rel_acc_on==1){ $Rel_acc =~s/ /_/g; $Rel_acc{"$seq_name"._Rel_a} = $Rel_acc }
				if ($SUB_acc_on==1){ $SUB_acc =~s/ /_/g; $SUB_acc{"$seq_name"._SUB_a} = $SUB_acc }
				push(@out_hash_ref_list, \%PHD_sec) if $PHD_sec_on;
				push(@out_hash_ref_list, \%Rel_sec) if $Rel_sec_on;
				push(@out_hash_ref_list, \%prH_sec) if $prH_sec_on;
				push(@out_hash_ref_list, \%prE_sec) if $prE_sec_on;
				push(@out_hash_ref_list, \%prL_sec) if $prL_sec_on;
				push(@out_hash_ref_list, \%SUB_sec) if $SUB_sec_on;
				push(@out_hash_ref_list, \%P_3_acc) if $P_3_acc_on;
				push(@out_hash_ref_list, \%PHD_acc) if $PHD_acc_on;
				push(@out_hash_ref_list, \%Rel_acc) if $Rel_acc_on;
				push(@out_hash_ref_list, \%SUB_acc) if $SUB_acc_on;
		}
		if($simple_seq_with_name_hash){
				if(@out_hash_ref_list == 1){ $out_hash_ref_list[0] }
				else{ return(@out_hash_ref_list) }
		}else{
				return(\%sec_str);
		}
}




#________________________________________________________________________
# Title     : open_swissprot_seq_files
# Usage     :
# Function  : open swiss files and puts ONLY the sequences in a hash(s)
# Example   :
# Warning   : ONLY the seq.
# Keywords  : open_swiss_seq_files, open_swiss_seq, read_swissprot_seq_files,
#            read_swiss_seq, get_swissprot_seq, take_swissprot_seq,
# Options   : 'v' for STDOUT printout as well.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub open_swissprot_seq_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	my(@names, $i, $name, $n, $seq, $s, %hash, @out_hash_ref_list);
	for($i=0; $i< @file; $i++){
	 open(FILE_1, "$file[$i]");
	 undef(%hash);
	 while(<FILE_1>){      # file1 needs to be xxxx.msf
		 if(/^ID\s+(\w+)\s*/){
			 $name=$1;
			 if($char_opt =~ /v/i){ print "\>$name\n"; }
		 }elsif(/^\s+([\w ]+)$/){
			 $seq.=$1;
		 }elsif(/^\/\//){
			 $seq=~s/ //g;
			 if($char_opt =~ /v/i){ print "$seq\n"; }
			 $hash{$name}=$seq;
			 push(@out_hash_ref_list, \%hash);
			 $seq='';
		 }
	 }
	}
	if(@out_hash_ref_list  == 1 ){ return(\%hash); }
	elsif(@out_hash_ref_list > 1){ return(@out_hash_ref_list); }
}



#______________________________________________________________
# Title     : open_clu_files
# Usage     : %clus=%{&open_clu_files(\$input)};
# Function  :
# Example   : Clu file eg)
#
#  Cluster 7360103
#    1  1 SLL1058         7-255       2   Origin: 3   736   Sub:3
#    1  1 MJ0422          17-283      2   Origin: 3   736   Sub:3
#    1  1 HI1308          3-245       2   Origin: 3   736   Sub:3
#
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
#              This automatically converts lower to upper letters
# Keywords  : open_cluster_files,
# Options   : _  for debugging.
#             #  for debugging.
#             b  for to get just names ($simple_clu_reading)
#             r  for adding ranges in the names
#             U  for makeing sequence names upppercase
#
# Returns   : a ref of hash of $clus{"$clus_size\-$id"}.=$m."\n";
#             Actual content:
#             3-133 => 'HI00111 HI00222 MG1233 '
# Argument  :
# Category  :
# Version   : 1.9
#--------------------------------------------------------------
sub open_clu_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my($simple_clu_reading, $possible_range, $add_ranges,
	  $id, $name_range, %clus, $found, $upper_case_seq_name);
	 my $file=$file[0];
	 if($char_opt=~/b/){ $simple_clu_reading= 'b' };
	 if($char_opt=~/U/){ $upper_case_seq_name='U'; };

	 my $clus_size=1;
	 open(CLU, "$file");
	 while(<CLU>){
	  if($simple_clu_reading=~/\S/){ ## to get just names
		  if(/^\s*\d+\s+\d+\s+\d+\s+\d+\s+\d+/ or /^\s*#/){  ## To skip the very first summary columns
			 next;
		  }elsif(/^\s*\d+\s+\d+\s+(\S+)\s+(\S+)/){
			 $seq_name=$1;
			 $possible_range=$2;
			 if($2=~/\d+\-\d+/ and $char_opt=~/r/){
				$name_range="$seq_name\_$possible_range";
				$clus{$name_range} = $name_range;
			 }else{
			    $clus{$seq_name}=$seq_name;
			 }
		  }
	  }else{
		  if(/^\s*\d+\s+\d+\s+\d+\s+\d+\s+\d+/ or /^\s*#/ ){  ## To skip the very first summary columns
			 next;
		  }elsif(/^\s*Cluster\s+size\s+(\d+)/i ){
			 $clus_size=$1;
			 $found=1;
		  }elsif(/^\s*Cluster\s+([_\d]+)\s*size:? *(\d+)/i){  # to match 'Cluster 14313'  or  'Cluster 234_1234_1'
			 $id  =$1;
			 $found=1;
			 $clus_size=$2; # if defined($2);
		  }elsif(/^ *Cluster\s+[number]* *([\w]+)/i){  # to match 'Cluster 14313'  or  'Cluster 234_1234_1'
			 $id  = $1;
			 $found=1;
		  }elsif(($found==1)&&(/^ *\S* *\S* *(\S+)\.prot\,? *.*/)){ ## this is to correct MP genome names
			 $m=$1;
						 if($upper_case_seq_name){
								 $clus{"$clus_size\-$id"}.="\U$m ";
						 }else{
								 $clus{"$clus_size\-$id"}.="\U$m ";
						 }
		  }elsif(($found==1)&&(/^ *(\d+) *\d* *(\S{2,32}) *(\S*)/)){          # general clu match
			 $clus_size=$1 unless ($clus_size);
			 $m=$2;
			 $possible_range=$3;
			 if($2=~/\d+\-\d+/ and $char_opt=~/r/){
				$name_range="$m\_$possible_range";
								if($upper_case_seq_name){
										$clus{"$clus_size\-$id"}.="\U$name_range ";
								}else{  $clus{"$clus_size\-$id"}.="$name_range "; }
			 }else{
								if($upper_case_seq_name){
										$clus{"$clus_size\-$id"}.="\U$m ";
								}else{  $clus{"$clus_size\-$id"}.="$m ";  }
			 }
		  }
	  }
	 }
	 close(CLU);
	 return(\%clus);
}




#________________________________________________________________________
# Title     : open_msf_files
# Usage     : (*out, *out2) = @{&open_msf_files(\$inputfile1, \$inputfile2)};
#             : %hash_seq = %{&open_msf_files(\$inputfile1)};
#             : (@out)        = @{&open_msf_files(\$inputfile1, \$inputfile2)};
#             ---------- Example of MSF ---
#             PileUp
#
#             MSF:   85  Type: P    Check:  5063   ..
#
# Function  : open msf files and put sequences in a hash(s)
# Example   :
# Warning   :
# Keywords  :
# Options   :
#   $no_gap_char_included=n by n  ## to remove gaps noted by '.'
#   $reverse_seq=r by r
#   $produce_seq_oder_info=O by O
# Returns   : (*out, *out2)  or (@out_array_of_refs)
# Argument  : (\$inputfile1, \$inputfile2, .... )};
# Category  :
# Version   : 1.9
#--------------------------------------------------------------------
sub open_msf_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		my(@names,  @out_hash_ref_list, $no_gap_char_included,
			 @seq_order, $produce_seq_oder_info, $reverse_seq, $seq_order);
		if($char_opt=~/n/){ $no_gap_char_included='n' }
		if($char_opt=~/r/){ $reverse_seq='r' }
		if($char_opt=~/O/){ $produce_seq_oder_info='O'; print "\n# (INFO) open_msf_files: \$produce_seq_oder_info is set\n"; }

		for($i=0; $i< @file; $i++){
			 local ( %hash, %redundency_check, %hash_rv);
			 print "\n# (INFO) open_msf_files($produce_seq_oder_info, $reverse_seq): Opening $file[$i] in \@file: @file";
			 open(FILE_1, "$file[$i]") or die "\n# (E) open_msf_files: Can\'t open $file[$i]\n";
			 while(<FILE_1>){      # file1 needs to be xxxx.msf
					if(/^\S+\s*$/ or /^\#/||/^\-+/ ){  next;  }
					if(/^(\w\S*)\s+([\.\-A-Z ]+) *$/){
						 $n=$1;  $s=$2;  $s=~s/ //g;
						 if($no_gap_char_included){ $s=~s/\.//g; }
						 $hash{$n}.= $s;
						 if($produce_seq_oder_info){
								 unless ($redundency_check{$n}){
										 push(@seq_order, $n);
										 $seq_order.="$n "; # redundant
								 }
								 $redundency_check{$n}=$n;
						 }
					}
			 }
			 if($reverse_seq){  print "\n# (INFO) open_msf_files: I am reversing seq";
					 %hash_rv=%{&reverse_sequences(\%hash)};
					 push(@out_hash_ref_list, \%hash_rv);
			 }else{
					 push(@out_hash_ref_list, \%hash);
			 }
			 close(FILE_1);
		}
		if(@out_hash_ref_list  == 1 ){
			 print "\n# (i) open_msf_files: \@out_hash_ref_list has ONE element";
			 if($produce_seq_oder_info and $seq_order){
					return($out_hash_ref_list[0], \@seq_order);
			 }else{ return($out_hash_ref_list[0]) }
		}elsif(@out_hash_ref_list > 1){
			 print "\n# (i) open_msf_files: \@out_hash_ref_list has over 1 hash refs";
			 if($produce_seq_oder_info or @seq_order > 1){
					return(\@out_hash_ref_list, \@seq_order);
			 }else{
					return(@out_hash_ref_list);
			 }
		}
}




#__________________________________________________________________________
# Title     : open_hmmls_files
# Usage     : %out=%{&open_hmmls_files(\@file)};
# Function  : hmmls matches the full length model to target seq. while, hmmfs
#             does for fragments as well.
# Example   :
# Keywords  :
# Options   :
#   t=$thresh  for bits score threshold
#   e=$evalue_thresh  for bits score threshold
#    r for adding ranges
#    m for making MSP file format output
#    E=Enguiry_name    for specifying enquiry seq name rather than 'HMM', the default
# Returns   :
# Argument  :
# Version   : 1.5
#----------------------------------------------------------------------------
sub open_hmmls_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
				my($query, $thresh, $evalue_thresh, $read_point_found); # $read_point_found is not used in this sub
				$thresh = 10; # default threshold
				$evalue_thresh=5;

				if($vars{'t'}=~/\S/){  $thresh = $vars{'t'} }
				if($vars{'e'}=~/\S/){  $thresh = $vars{'e'} }
				if($vars{'E'}=~/\S/){  $enquiry_name = $vars{'E'} }

	if(@file<1){
	   print "\n# open_hmmls_files needs one or more files !!\n";
	}else{
 	   print "\n# open_hmmls_files: threshold used = $thresh \n";
	}

				print "\n# (INFO) open_hmmls_files: score \$thresh is  $thresh\n";
	for($i=0; $i< @file; $i++){
	   $input_file=$file[$i];
	   open(HMMLS, "$input_file");
	   while(<HMMLS>){
	      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	      # HMMER version 1
	      #_____________________________________________________
							if(/^ {0,2}(\S+)\s+\S+\s+\S+\s+(\d+)\s+\S+\s+(\d+)\s+\S+\s+(\S+) *$/){
									if($1 > $thresh){
										 $score=$1;
										 $matched=$4;
										 $from=$2;
										 $to=$3;
										 if($char_opt=~/r/){
												if($char_opt=~/m/){ ## convert to msp file format
																$hash{"$matched"}="$score $score $from $to HMM $from $to $matched\n";
												}else{
																$hash{"$matched\_$from\-$to"}=$score;
												}
										 }else{
												if($char_opt=~/m/){ ## convert to msp file format
																$hash{"$matched"}="$score $score $from $to HMM $from $to $matched\n";
												}else{
														$hash{"$matched"}=$score;
												}
										 }
									}
	      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	      # HMMER version 2  (it has evalue)
	      #_____________________________________________________
							}elsif(/^ {0,2}(\S+)\s+\S+\s+(\d+)\s+(\d+)\s+\S+\s+(\d+)\s+(\d+)\s+\S+\s+(\S+)\s+(\S+)$/){
									if($6 > $thresh and $7 <= $evalue_thresh){
										 $score=$6;  $matched=$1;
										 $query_range_start=$4; $query_range_stop=$5;
										 $match_string_start=$2; $match_string_stop=$3;
										 $evalue=$7;
										 if($char_opt=~/r/){
												if($char_opt=~/m/){ ## convert to msp file format
														 $hash{"$matched"}=sprintf("%-6s %-9s %-5s %-5s %-5s %-32s %-5s %-5s %-38s %-3s\n",
																		 $score, $evalue, "n/a", $query_range_start, $query_range_stop,
																		 $query, $match_string_start, $match_string_stop,
																		 $matched, $read_point_found);
												}else{
																$hash{"$matched\_$from\-$to"}=$evalue;
												}
										 }else{
												if($char_opt=~/m/){ ## convert to msp file format
														 $hash{"$matched"}=sprintf("%-6s %-9s %-5s %-5s %-5s %-32s %-5s %-5s %-38s %-3s\n",
																		 $score, $evalue, "n/a", $query_range_start, $query_range_stop,
																		 $query, $match_string_start, $match_string_stop,
																		 $matched, $read_point_found);
												}else{
														$hash{"$matched"}=$evalue;
												}
										 }
									}
							}elsif(/^ *Query HMM: *(\S+)/){
									$query=$1;
							}
	   }
	}
	return(\%hash);
}





#__________________________________________________________________________
# Title     : open_hmmfs_files
# Usage     : %out=%{&open_hmmfs_files(\@file, "t=$thresh", $attch_ranges)};
# Function  :
# Example   :
# Keywords  :
# Options   :
#   "t=$thresh"  for bits score threshold
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub open_hmmfs_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		$thresh = 15; # default threshold
		if($vars{'t'}=~/\S/){  $thresh = $vars{'t'} }
		print "\n# open_hmmfs_files: threshold used = $thresh \n";

		for($i=0; $i< @file; $i++){
			 $input_file=$file[$i];
			 open(HMMLS, "$input_file");
			 while(<HMMLS>){
					 if(/^ {0,2}(\S+)\s+(\d+)\s+(\d+)\s+\d+\s+\d+\s+(\S+)/){
							 if($1 > $thresh){
										$score=$1;
										$target=$4;
										$from=$2;
										$to=$3;
										if($char_opt=~/r/){
												$hash{"$target\_$from\-$to"}=$score;
										}else{
												$hash{"$target"}=$score;
										}
							 }
					 }
			 }
		}
		return(\%hash);
}


#________________________________________________________________________
# Title     : open_seq_files
# Usage     : %seq=%{&open_seq_files($tim_seq_file, ['MJ0084'], [15] )};
#             if you put additional seq name as MJ0084 it will
#             fetch that sequence only in the database file.
#             Any digit will be used as minimum seq size to be fetched.
# Function  : open seq files and put sequences in a hash
#             seq sequence file format is like this;
#
# 1l94   162 MNIFEMLRIDEGLRLKIYKDTEGYYTIGIGHLLTKSPSLNAAKSELDKAIGRTFRTGTWDAYK
# 1lye   162 MNIFEMLRIDEGLRLKIYKDTEGYYTIGIGHLLTKSPSLNAAKSELDKAIGRTFRTGTWDAYK
# 1lyj   162 MNIFEMLRIDEGLRLKIYKDTEGYYTIGIGHLLTKSPSLNAAKSELDKAIGRTFRTGTWDAYK
# 1mngA  203 PYPFKLPDLGYPYEALEPHIDAKTMEIHHQKHHGAYVTNLNAALEKYPYLHGVLNWDVAEEFFKKA
#
#  or
# 1l94   MNIFEMLRIDEGLRLKIYKDTEGYYTIGIGHLLTKSPSLNAAKSELDKAIGRTFRT
# 1l93   RIDEGLRLKIYKDTEGYYTIGIGHLLTKSPSLNAAKSELDKAIGRTFRT
#
#             This can also return the sizes of sequences rather than seqs.
# Example   : %out = %{&open_seq_files(@ARGV)};
#                    while @ARGV at prompt was: 'pdb_40.seq'
#             %seq=%{&open_seq_files(@ARGV, '1cgpa_140-197')};
#                    to fetch 1cgbA but in range of 140-197 only
# Warning   :
# Keywords  : open_pdbs_files
# Options   : any digit for the minimum seq length
# Returns   :
# Argument  :
# Category  :
# Version   : 1.7
#--------------------------------------------------------------------
sub open_seq_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

		my (%sequence, @lines, $S_start, $S_end, @seq_Names, %Sizes, $name_stem,
			$seq_start, $seq_leng, $min_size);
		$min_size=$num_opt[0];
		if(@file<1){ print "\n There is no fileinput for open_seq_files\n"; die}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  If the file is not found, it goes to @string
		#_________________________________________________
		for($i=0; $i< @file; $i++){
			 my($input_file) = ${$file[$i]} || $file[$i];
			 unless (-e $input_file){
						push(@string, $input_file);
						splice(@file, $i, 1); $i--;
						next;
			 }
		}


		for($i=0; $i< @file; $i++){
	  my($input_file) = ${$file[$i]} || $file[$i];
	  if($debug eq 1){ print "\n open_seq_files: Inputfile is $input_file\n" };

	  open(FILE_1,"$input_file");
	  @lines=<FILE_1>;
	  close FILE_1;

	  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  #  when hash is directly given for selected sequence names
	  #_____________________________________________________________
	  if(@hash >=1){
							for($h=0; $h< @hash; $h++){
										 @string=(@string, keys %{$hash[$h]});
							}
	  }
	  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  #  When there are asked seqs to fetch
	  #_______________________________________________________
	  if( (@_ > 1)&&(@string > 0) ){
							 for $lines (@lines){
									 for($j=0; $j< @string; $j++){
											 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
											 #  If the seq name has ranges -> 1xxx_10-20
											 #___________________________________________
											 if($string[$j]=~/^(\S+)_(\d+)\-(\d+)$/){
														$name_stem=$1;
														$seq_start=$2-1;
														$seq_leng=$3-$2+1;
														if($lines=~/^\>?($name_stem)\s+(\d+)\s+(\w+)$/i){
																 $seq_in_range=substr($3, $seq_start, $seq_leng);
																 $sequence{$string[$j]}=$seq_in_range;
																 splice(@string, $j, 1); ## for optimization
																 $j--;
														}
											 }else{
														if($lines=~/^\>?($string[$j])\s+(\d+)\s+(\w+)/i){
																 if($min_size < $2){
																		 splice(@string, $j, 1);
																		 $j--; ## for optimization
																		 $sequence{$1} = $3;
																 }
														}
											 }
									 }
							 }
							 return(\%sequence);
	  }else{ # getting all seq in the given file(s)
							 for(@lines){                # file1 needs to be xxxx.fasta for the moment, automatic later
									 if(/^\>?(\S+)\s+(\d+)\s+(\w+)$/){
											 if($min_size < $2){
														 $sequence{$1} = $3;
											 }
									 }elsif(/^\>?(\S+)\s+(\D\D+) *$/){ ## plain 'seqname  ASDASDFAASSEQUECN'
											 $sequence{$1} = $2;
									 }else{  next }
							 }
	  }
	  close FILE_1;
		 }
		 if(defined(@range)){
				 %seq_fragments=%{&get_seq_fragments(\%sequence, \@range)};
				 return(\%seq_fragments);
		 }elsif($char_opt=~/s/i){ # when SIZE return only option is set
				 @seq_Names=keys %sequence;
				 for($i=0; $i < @seq_Names; $i++){
								$Sizes{$seq_Names[$i]}=length($sequence{$seq_Names[$i]});
				 }
				 return(\%Sizes);
		 }elsif(@hash >=1){
				 for($h=0; $h< @hash; $h++){
						my %hash=%{$hash[$h]};
								my @Keys=keys %hash;
								for($k=0; $k<@Keys; $k++){
											 if(defined($hash{$Keys[$k]})){
													($S_start, $S_end)=$hash{$Keys[$k]}=~/(\d+)\-(\d+)/;
													$sequence{$Keys[$k]}=substr($sequence{$Keys[$k]}, ($S_start-1), ($S_end-$S_start));
											 }
								}
				 }
				 return(\%sequence);
		 }else{
				 return(\%sequence);
		 }
}


#_________________________________________________________________________________
# Title     : open_sso_files
# Usage     :  @sso=@{&open_sso_files(@file, $add_range, $add_range2, "u=$upper_expect_limit",
#			                            "l=$lower_expect_limit", "m=$margin", $new_format)};
# Function  : This reads the parseable( -m 10 option)
#             and non-parseable form of ssearch program output
#             If you give 5 files, it produces 5 hashes as a ref of array.
#             This understands xxxx.gz files.
#             This reads FASTA -m 10 output, too.
#             SSO means sequence search output (SSSO = ssearch seq search output)
#             FSSO=fasta seq. search output, MSSO=machine readable seq search output
# Example   :
#  717    0         0.343  16    373    EC1260_16-373              74    434    YBL6_YEAST_74-434
#  348    9e-16     0.500  113   233    EC1260_113-233             27    146    YDBG_ECOLI_27-146
#  472    2.9e-08   0.271  13    407    EC1260_13-407              148   567    YHJ9_YEAST_148-567
#  459    1.9e-22   0.260  1     407    EC1260_1-407               65    477    YLQ6_CAEEL_65-477
#  452    4.5e-14   0.275  1     407    EC1260_1-407               103   537    YSCPUT2_103-537
#  1131   0         0.433  1     407    EC1260_1-407               112   519    ZMU43082_112-519
#
#  Input SSO file example)-> below
#
#   >>MG032 ATP-dependent nuclease (addA) {Bacillus subtilis  (666 aa)
#    Z-score: 88.3 expect()  1.9
#   Smith-Waterman score: 77;  27.143% identity in 70 aa overlap
#
#           30        40        50        60        70        80
#   MJ0497 RSAGSKGVDLIAGRKGEVLIFECKTSSKTKFYINKEDIEKLISFSEIFGGKPYLAIKFNG
#                                        : .. ...  . .:.:::. :: : ..:
#   MG032  HDKVRYAFEVKFNIALVLSINKSNVDFDFDFILKTDNFSDIENFNEIFNRKPALQFRFYT
#        200       210       220       230       240       250
#
#           90       100             110       120       130
#   MJ0497 EMLFINPFLLSTNGK------NYVIDERIKAIAIDFYEVIGRGKQLKIDDLI
#          .   ::   :: ::.      : ....... . ::. . :
#   MG032  K---INVHKLSFNGSDSTYIANILLQDQFNLLEIDLNKSIYALDLENAKERFDKEFVQPL
#        260          270       280       290       300       310
#
# Parseable form -m 10 option =========================================
#   >>>MJ0497.fasta, 133 aa vs GMG.fasta library
#   ; pg_name: Smith-Waterman (PGopt)
#   ; pg_ver: 3.0 June, 1996
#   ; pg_matrix: BL50
#   ; pg_gap-pen: -12 -2
#   >>MG032 ATP-dependent nuclease (addA) {Bacillus subtilis
#   ; sw_score:  77
#   ; sw_z-score: 88.3
#   ; sw_expect    1.9
#   ; sw_ident: 0.271
#   ; sw_overlap: 70
#   >MJ0497 ..
#   ; sq_len: 133
#   ; sq_type: p
#   ; al_start: 58
#   ; al_stop: 121
#   ; al_display_start: 28
#
# Warning   : By default, the SW score comes to the first
#             If expect value is not found, it becomes '0'
#             By default, the offset of seq match with a seq name like seq_30-40
#               will be 30 not 1.
#             It ignores special chars like , : .prot in the name (eg, AADF_FASDF: will be AADF_FASDF)
# Keywords  : open_ssearch_output_files, ssearch_output, ssearch, FASTA,
# Options   : _  for debugging.
#             #  for debugging.
#             u= for upper E value limit
#             l= for lower E value limit
#             r  for attaching ranges to out seq names (eg> HI0001_1-20 as a key)
#             U  for making the matched seqname to upppercase
#             L  for making the matched seqname to lowercase
#             R  for attaching ranges to out seq names for both TARGET and MATCH
#             n  for new format (msp2)
#             a  for getting alignments of the pair
#
# Category  :
# Version   : 4.6
#----------------------------------------------------------------------------
sub open_sso_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my (@out_refs, @SSO, $create_sso, $parseable, @OUT, @temp_sso_lines,
						%match, $attach_range_in_names, $margin, $uppercase_seq_name,
						$lowercase_seq_name, $target_seq, $new_format, $get_alignment,
						$pvm_version_fasta_out, $original_target_seq, $big_mspa_out_file);

		my ($upper_expect_limit, $lower_expect_limit)=(50,0);

		if($char_opt=~/R/){  $attach_range_in_names2=1; };
		if($char_opt=~/r2/){ $attach_range_in_names =1; $attach_range_in_names2=1 };
		if($char_opt=~/r/){  $attach_range_in_names =1; };
		if($char_opt=~/c/){  $create_sso   ='c' };
		if($char_opt=~/n/){  $new_format   ='n' };
		if($char_opt=~/a/){  $get_alignment='a' };
		if($char_opt=~/U[pperPPER]*/){ $uppercase_seq_name='U' };
		if($char_opt=~/L[owerOWER]*/){ $lowercase_seq_name='L' };
		if($vars{'u'}=~/(\.?\d+)/){ $upper_expect_limit = $vars{'u'} };
		if($vars{'l'}=~/(\.?\d+)/){ $lower_expect_limit = $vars{'l'} };
		if($vars{'m'}=~/\d+/){ $margin = $vars{'m'} };
		$attach_range_in_names2=$attach_range_in_names=1;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# opening file input (can handle .gz  files)
		#_______________________________________________
		if(@file < 1 and @array > 0){
				 for($i=0; $i< @array; $i++){
							@sso=@{$array[$i]};
				 }
				 print "\n# (I) \@sso has ", scalar(@sso), " lines. \n"  if $verbose;
				 if(@sso > 3000){ # if @sso is very big, I remove the useless contents
						 print "\n# (INFO) open_sso_files: size of \@sso for $file[$i] exceeds 3000 lines, ", scalar(@sso), " !!! \n";
				 }
				 push(@OUT, &read_sso_lines(\@sso, $create_sso,  ## read_sso_lines has read_machine_readable_sso_lines and machine unreadl...
										"u=$upper_expect_limit",
										"l=$lower_expect_limit",
										$attach_range_in_names,
										$attach_range_in_names2,
										$new_format, $get_alignment) );
		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Opening input FILE!
		#_______________________________________________
		else{
				 #print "\n# open_sso_files : processing @file \n\n";
				 for($i=0; $i< @file; $i++){
							if($file[$i]=~/\S+\.msp *$/){ $big_mspa_out_file=$file[$i]; splice (@file, $i, 1); $i--;
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# Opening zipped file
							#_______________________________________________
							}elsif($file[$i]=~/\S+\.\gz$/ or -B $file[$i]){  ## if file has xxxx.gz extension
									my (@sso);
									@sso=`gunzip -c $file[$i]`;
									if(@sso < 30){  @sso=`zcat $file[$i]`; }      # if zcat fails to produce output use gunzip -c
									if(@sso > 3000){ # if @sso is very big, I remove the useless contents
											print "\n# open_sso_files: size of \@sso for $file[$i] exceeds 3000 lines, ", scalar(@sso), " !!! \n";
									}
									push(@OUT, &read_sso_lines(\@sso, $create_sso,
											"u=$upper_expect_limit",
											"l=$lower_expect_limit",
											$attach_range_in_names,
											$attach_range_in_names2,
											$new_format, $get_alignment) );
							}
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# Opening plain file(not zipped)
							#_______________________________________________
							elsif($file[$i]=~/\S+\.[fsm]?sso/ or $file[$i]=~/\S+\.out/ or $file[$i]=~/\S+\.fso/){
									open(SSO, "$file[$i]") or die "\n# (ERROR) open_sso_files: Failed to open $file[$i]\n";
									my @sso=<SSO>;
									if(@sso < 30){  @sso=`zcat $file[$i]`; }      # if zcat fails to produce output use gunzip -c
									if(@sso > 3000){ # if @sso is very big, I remove the useless contents
											print "\n# (INFO) open_sso_files: size of \@sso is for $file[$i] exceeds 3000 lines, ",
											scalar(@sso), " !!! \n";
									}
									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# !!! DEFAULT !!! Calling read_sso_lines sub
									#_____________________________________________
									push(@OUT, &read_sso_lines([@sso], $create_sso,
											 "u=$upper_expect_limit",
											 "l=$lower_expect_limit",
											 $attach_range_in_names,
											 $attach_range_in_names2,
											 $new_format, $get_alignment) );
									close SSO;
							}
				 }
		}
		#print "\n# \@OUT, in open_sso_files, has ", scalar(@OUT), " elements \n";
		return(\@OUT); # @OUT has refs of hashes  (\%xxx, \%YYY, \%XXX,,,,)
}



#_____________________________________________________________________________
# Title     : open_mspa_files
# Usage     : %seq=%{&open_mspa_files(@file, $names_only)};
# Function  : opens Erik Sonhammer's MSPcrunch file output(default).
#             This looks up xxxxx.fasta files in the pwd (with S opt) and see
#             if it can get the sequences as well.
#             With 'n' option you can just get the matched sequence
#              names with ranges.
# Example   :
#
# Keywords  : exchange_mspa_file_columns,
# Options   :
#          s -s  for size return only
#          S -S  for the sequences are fetched if equivalent xxxx.fasta files are in pwd
#          n -n  for matched seq NAMEs with ranges only (eg: HI0001_1-12,,), hash ref is out
#          R     for NO range attachment in Name only return option (n)
#          e=    for evalue threshhold, if e=1, ignores all which are over 1
#          t=    for score threshhold if t=100, ignores all which are less 100
#          l=    for match length threshold.
#          x     for exchange query with matched seqs. eg)      12 0.09 1 30 QUERY  1 29 MATCH
#                                                       becomes 12 0.09 1 30 MATCH  1 29 QUERY
#                This returns the same lines as input only with exchanged query and match seqs
#
# Returns   :
# Argument  :
# Category  :
# Version   : 2.9
#------------------------------------------------------------------------------
sub open_mspa_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my (%matched_seq, @MSP, %Sizes, $input_file, %new_exchanged_hash,
			 %matched_seq_names, $new_line, %simple_default_output, $simple_default_out_flag );
		 my  $Evalue_thresh = 50; ### default very high evalue
		 my  $Score_thresh  = 30; # 30 is very very tiny
		 my  $query_length_thresh  = 5; ## absurdly low 5.

		 if($vars{'t'}=~/^\d+$/){ $Score_thresh= $vars{'t'} }
		 if($vars{'e'}=~/^\S+$/){ $Evalue_thresh= $vars{'e'} }
		 if($vars{'l'}=~/^\S+$/){ $query_length_thresh= $vars{'l'} }
		 for($i=0; $i< @file; $i++){     $input_file = ${$file[$i]} || $file[$i];
		     if($input_file !~/\.msp$/){
		         print "\n# (W) The file does not have MSP file extension, O.K??\n";
		     }
				 unless ( (-s $input_file) < 20){
						 print chr(7);
						 print "\n\n\t This is sub open_mspa_files in $0  \n\n";
						 print "\t Fatal: The input file $input_file is not in the directory \n";
				 }
				 if($input_file=~/\S\.gz *$/){ # if input file is gzzipped
						 @MSP=`gunzip -c $input_file`;
						 print "\n# open_mspa_files: Input file \"$input_file\" is gzipped !\n";
				 }elsif($input_file=~/\S\.bz2 *$/){ # if input file is bzzipped
						 @MSP=`bzip2 -c -d $input_file`;
						 print "\n# open_mspa_files: Input file \"$input_file\" is bzipped !\n";
				 }else{
						 open(FILE,"$input_file") or die "\n# Error opening $input_file\n";
						 @MSP=<FILE>;     close(FILE);
				 }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 #  When x option for exchanging query and match is set
				 #___________________________________________________________
				 if($char_opt=~/x/){
						 my($name1);
						 for($j=0; $j< @MSP; $j++){
								 if($MSP[$j]=~/^ *(\S+)\s+(\S+) *\S*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+) *(.*)/){
											$query_length=$4-$3;
											if($1 < $Score_thresh or $2 > $Evalue_thresh
											  or $query_length < $query_length_thresh){ next }
											unless($char_opt=~/R/){
													$name1="$5\_$3\-$4";
											}else{  $name1="$5";    }
											$new_line=sprintf("%-4s %-10s %-5s %-5s %-32s %-5s %-5s %-32s",
															 $1, $2, $6,  $7,  $8,   $3,  $4,  $name1);
											$new_exchanged_hash{"$5\_$8"}=$new_line;
								 }
						 }
						 return(\%new_exchanged_hash);
				 }
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  When matched sequence NAMEs only are wanted
				#________________________________________________
				elsif($char_opt=~/n/){
						F2: for($j=0; $j<@MSP; $j++){
								if($MSP[$j]=~/^ *(\S+)\s+(\S+) *\S*\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+) *(.*)/){
									$query_length=$4-$3;
									if($2 > $Evalue_thresh or $1 < $Score_thresh
										 or $query_length < $query_length_thresh){  next F2; }
									$name1=$8;        $r_start=$6;
									$r_end  =$7;      $target =$5;
									if($name1=~/^(\S+)_\d+\-\d+/){
										 $bare=$1;
										 if($char_opt=~/R/){  ## When NO range option is set
											 $matched_seq_names{$target} .="$bare "  # returns string
										 }else{
												 $matched_seq_names{$target} .="$name1 ";   # returns string
										 }
									}else{
										 if($char_opt=~/R/){  ## When NO range option is set
											 $matched_seq_names{$target} .="$name1 ";
										 }else{
											 $matched_seq_names{$target} .="$name1\_$r_start\-$r_end ";
										 }
									}
								}
						}
						#$matched_seq_names{$4}=\@matched_seq_names;
				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  When matched ACTUAL sequences are wanted (without n opt)
				#____________________________________________________________
				elsif($char_opt=~/S/){
				 F3: for($j=0; $j<@MSP; $j++){
					#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
					#                   $1          $2     $3    $4      $5     $6    $7     $8
					#                   171     41.18      6      73  HI1690    9      76  HI0736 sodium...
					#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
					if($MSP[$j]=~/^ *(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+) *(.*)/i){
							$query_length=$4-$3;
							if($2 > $Evalue_thresh or $1 < $Score_thresh
							 or $query_length < $query_length_thresh ){ next F3; } ##<-- filtering

							if($5 eq $8){
							$query_name=$8;
							$query_leng=($4 - $3 + 1);
							my $matched_seq;
							for($k=0; $k<$query_leng; $k++){
								$query[$k]=0;
							}
							$query_fasta="$query_name\.fasta";
							open(QUERY_FASTA, "$query_fasta") || die "\n# open_mspa_files, die: No $matched_fasta. Didn't you want \'n\' opt?\n";
							my @QUERY_FASTA=<QUERY_FASTA>;
							for(@QUERY_FASTA){
								 if(/\>$query_name/){
									$query_found=1; next;
								 }elsif(($query_found==1)&&(/^(\w{10,})$/)){
									$matched_seq .=$1;
								 }
							}
							$matched_seq{$query_name}=$matched_seq;
							close(QUERY_FASTA);
						 }elsif($5 ne $8){
							if($match_name ne $8){
								 $match_name=$8;
								 my $matched_seq;
								 push(@matched_members, $8);
								 $matched_fasta="$match_name\.fasta";
								 open(MATCHED_FASTA, "$matched_fasta") || die "\n# open_mspa_files, die: No $matched_fasta. Didn't you want \'n\' opt?\n";
								 my @MATCHED_FASTA=<MATCHED_FASTA>;
								 for(@MATCHED_FASTA){
								 if(/\>$match_name/){
									 $found=1; next;
								 }elsif(($found==1)&&(/^(\w{10,})$/)){
									 $matched_seq .=$1;
								 }
								 }
								 $matched_seq{$match_name}=$matched_seq;
							}
							}
					 }
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~~`
					 #  New MSP format
					 #_____________________________________________________________
					 elsif($MSP[$j]=~/^ *(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+) *(.*)/i){ # new MSP format
						 if($6 eq $9){
								$query_name=$9;
								$query_leng=($5 - $4 + 1);
								if($query_leng < $query_length_thresh){ next }
								my $matched_seq;
								for($k=0; $k<$query_leng; $k++){
									 $query[$k]=0;
								}
								$query_fasta="$query_name\.fasta";
								open(QUERY_FASTA, "$query_fasta") || die "\n# open_mspa_files, die: No $matched_fasta. Didn't you want \'n\' opt?\n";
								my @QUERY_FASTA=<QUERY_FASTA>;
								for(@QUERY_FASTA){
									 if(/\>$query_name/){
										$query_found=1; next;
									 }elsif(($query_found==1)&&(/^(\w{10,})$/)){
										$matched_seq .=$1;
									 }
								}
								$matched_seq{$query_name}=$matched_seq;
								close(QUERY_FASTA);
						}elsif($6 ne $9){
								if($match_name ne $9){
									 $match_name=$9;
									 $query_leng=($5 - $4 + 1);
									 if($query_leng < $query_length_thresh){ next }
									 my $matched_seq;
									 push(@matched_members, $9);
									 $matched_fasta="$match_name\.fasta";
									 open(MATCHED_FASTA, "$matched_fasta") || die "\n# open_mspa_files, die: No $matched_fasta. Didn't you want \'n\' opt?\n";
									 my @MATCHED_FASTA=<MATCHED_FASTA>;
									 for(@MATCHED_FASTA){
									 if(/\>$match_name/){
										 $found=1; next;
									 }elsif(($found==1)&&(/^(\w{10,})$/)){
										 $matched_seq .=$1;
									 }
									 }
									 $matched_seq{$match_name}=$matched_seq;
								}
						 }
					}
				 }
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# THE DEFAULT
				#__________________________________________________________________________
				}else{ # default output. This filters with given E and Score thresholds
						$simple_default_out_flag++;
						F4: for($j=0; $j<@MSP; $j++){
								#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
								#                   $1          $2     $3    $4      $5     $6    $7     $8
								#                   171     41.18      6      73  HI1690    9      76  HI0736 sodium...
								#,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
								if($MSP[$j]=~/^ *(\S+) +(\S+) +\S* *(\d+) +(\d+) +(\S+) +(\d+) +(\d+) +(\S+) *(.*)/i){
										 my $query_length = $4-$3;
										 if($2 > $Evalue_thresh or $1 < $Score_thresh
												 or $query_length < $query_length_thresh ){ next F4;
										 }else{
												 $simple_default_output{$input_file} .= $MSP[$j];
										 }
								}
						}
				}
		 } #<<<<<-- for($i=0; $i< @file; $i++){

		 if($simple_default_out_flag >=1){ %matched_seq=%simple_default_output; }
		 if($simple_default_out_flag > 1){ print "\n# You have asked me to open more than one file. I merge output into one hash\n"; }

		 if(defined(@range) && ($char_opt !~ /n/)){ ## m opt is for matched seq names only
				 %seq_fragments=%{&get_seq_fragments(\%matched_seq, \@range)};
				 return(\%seq_fragments);
		 }elsif($char_opt=~/s/){ # when SIZE return only option is set
				 @seq_Names=keys %matched_seq;
				 for($i=0; $i<@seq_Names; $i++){
						$Sizes{$seq_Names[$i]}=length($matched_seq{$seq_Names[$i]});
				 }
				 return(\%Sizes);
		 }else{
				 if($char_opt=~/n/){
						 return(\%matched_seq_names);
				 }else{
						 return(\%matched_seq);
				 }
		 }
}





#________________________________________________________________________
# Title     : open_dssp_files
# Usage     : (*out, *out2) = @{&open_dssp_files(\$inputfile1, \$inputfile2, \$H, \$S,,,,)};
#             (@out)        = @{&open_dssp_files(\$inputfile1, \$inputfile2, \$H, \$S,,,,)};
# Function  : open dssp files and put sequences in a hash(s)
#              It can take options for specific secture types. For example,
#              if you put an option $H in the args of the sub with the value of 'H'
#              open_dssp_files will only read secture whenever it sees 'H'
#              in xxx.dssp file ignoring any other sec. str. types.
#              If you combine the options of 'H' and 'E', you can get only Helix and long
#              beta strand sections defined as segments. This is handy to get sec. str. segments
#              from any dssp files to compare with pdb files etc.
#             With 'simplify' option, you can convert only all the 'T', 'G' and 'I' sec. to
#              'H' and 'E'.
# Example   :
# Warning   : 6taa.dssp  and 6taa are regarded as the same.
# Keywords  :
# Options   : H, S, E, T, I, G, B, P, C, -help
# $H        =        'H' by   -H or -h or H or h  # to retrieve 4-helix (alpha helical)
# $S        becomes  'S' by   -S or -s or S or s  # to retrieve Extended strand, participates in B-ladder
# $E        becomes  'E' by   -E or -e or E or e  # to retrieve residue in isolated Beta-bridge
# $T        becomes  'T' by   -T or -t or T or t  # to retrieve H-bonded turn
# $I        becomes  'I' by   -I or -i or I or i  # to retrieve 5-helix (Pi helical) segment output
# $G        becomes  'G' by   -G or -g or G or g  # to retrieve 3-helix (3-10 helical)
# $B        becomes  'B' by   -B or -b or B or b  # to retrieve only B segment
# $simplify becomes   1  by   -p or P or -P, p
# $comm_col becomes  'c' by   -c or c or C or -C or common
# $HELP     becomes   1  by   -help   # for showing help
#
# Returns   : (*out, *out2)  or (@out_array_of_refs)
# Argument  : files names like (6taa, 6taa.dssp) If you put just '6taa' without extension, it
#             searches if there is a '6taa.dssp' in both PWD and $DSSP env. set directory.
#             ---------- Example of dssp ---
#             **** SECONDARY STRUCTURE DEFINITION BY THE PROGRAM DSSP, VERSION JUL
#             REFERENCE W
#             HEADER    RIBOSOME-INACTIVATING PROTEIN           01-JUL-94   1MRG
#             COMPND    ALPHA-MOMORCHARIN COMPLEXED WITH ADENINE
#             SOURCE    BITTER GOURD (CUCURBITACEAE MOMORDICA CHARANTIA) SEEDS
#             AUTHOR    Q
#             246  1  0  0  0 TOTAL NUMBER OF RESIDUES, NUMBER OF CHAINS, NUMBER OF SS-BRIDGES(TOTAL,INTRACHAIN,INTERCHAIN)                .
#             112 95.0   ACCESSIBLE SURFACE OF PROTEIN (ANGSTROM**2)                                                                         .
#             171 69.5   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(J)  , SAME NUMBER PER 100 RESIDUES                              .
#             12   4.9   TOTAL NUMBER OF HYDROGEN BONDS IN     PARALLEL BRIDGES, SAME NUMBER PER 100 RESIDUES                              .
#             36  14.6   TOTAL NUMBER OF HYDROGEN BONDS IN ANTIPARALLEL BRIDGES, SAME NUMBER PER 100 RESIDUES                              .
#             1    0.4   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I-5), SAME NUMBER PER 100 RESIDUES                              .
#             1    0.4   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I-4), SAME NUMBER PER 100 RESIDUES                              .
#             74  30.1   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I+4), SAME NUMBER PER 100 RESIDUES                              .
#             5    2.0   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I+5), SAME NUMBER PER 100 RESIDUES                              .
#             1    2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30     *** HISTOGRAMS OF ***           .
#             0    0  0  0  1  1  0  2  0  0  1  0  0  1  0  0  0  0  0  2  0  0  0  0  0  0  0  0  0  0    RESIDUES PER ALPHA HELIX         .
#             1    0  0  2  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0    PARALLEL BRIDGES PER LADDER      .
#             2    0  1  2  0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0    ANTIPARALLEL BRIDGES PER LADDER  .
#             2    0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0    LADDERS PER SHEET                .
#             #   RESIDUE AA STRUCTURE BP1 BP2  ACC   N-H-->O  O-->H-N  N-H-->O  O-->H-N    TCO  KAPPA ALPHA  PHI   PSI    X-CA   Y-CA   Z-CA
#             1    1   D              0   0  132    0, 0.0   2,-0.3   0, 0.0  49,-0.2   0.000 360.0 360.0 360.0 153.4   44.0   96.9  -23.8
#             2    2   V  E     -a   50   0A  10   47,-1.5  49,-2.8   2, 0.0   2,-0.3  -0.889 360.0-163.3-115.9 151.4   43.1  100.4  -22.5
#             3    3   S  E     -a   51   0A  63   -2,-0.3   2,-0.3  47,-0.2  49,-0.2  -0.961  10.3-172.8-131.0 152.3   44.8  103.7  -23.4
#             4    4   F  E     -a   52   0A   8   47,-2.2  49,-2.3  -2,-0.3   2,-0.4  -0.985   6.9-161.2-143.2 139.5   45.0  107.2  -22.0
#             5    5   R  E     -a   53   0A 144   -2,-0.3   4,-0.2  47,-0.2  49,-0.2  -0.993   9.7-156.0-121.0 125.9   46.6  110.2  -23.6
#             6    6   L  S    S+     0   0    1   47,-2.3   2,-0.5  -2,-0.4   3,-0.4   0.644  73.2  90.9 -73.3 -22.4   47.5  113.2  -21.4
#             7    7   S  S    S+     0   0   81   47,-0.3   3,-0.1   1,-0.2  -2,-0.1  -0.695 106.0   5.2 -75.5 121.0   47.4  115.6  -24.4
#             8    8   G  S    S+     0   0   72   -2,-0.5  -1,-0.2   1,-0.3   5,-0.1   0.269  97.6 147.8  90.2 -10.7   43.9  117.0  -24.7
#             9    9   A        +     0   0   10   -3,-0.4  -1,-0.3  -4,-0.2  -3,-0.1  -0.256  16.8 166.8 -58.8 142.4   42.9  115.2  -21.5
#             (\$inputfile1, \$inputfile2, .... )};
# Category  :
# Version   : 2.9
#--------------------------------------------------------------------
sub open_dssp_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my $gap_char = '_';

	if($char_opt !~ /[HEBGIST]/i){  ## This is default sec. str type setting. (full representation)
		$char_opt = 'HEBGIST';
	}
	if ($debug eq 1){
	  print __LINE__, " # open_dssp_files : \$simplify     is  $simplify\n" ;
	  print __LINE__, " # open_dssp_files : \@file given   is  @file \n" ;
	  print __LINE__, " # open_dssp_files : \@string given is  @string\n" ;
	}
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	### Big main loop for input argument handling   ####
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#  This is to check if the given file is not in pwd but in ENV var $DSSP
	#  Or if the file name was given only by the base name of seq(eg. 1cdg rather
	#  than 1cdg.dssp
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	for ($i=0; $i < @string; $i ++){
		 print __LINE__, " ${i}th string input is  $string[$i] \n" if $debug eq 1;
		 $string[$i] = "$string[$i]\.dssp"; ## adding  .dssp extension
		 print __LINE__, " ${i}th string inputwith \.dssp is now, $string[$i] \n" if $debug eq 1;

		 if(-f $string[$i]){
			 print chr(7) if $debug eq 1;
			 print __LINE__, " Your input filename exist in this File: $string[$i]\n" if $debug eq 1;
			 unshift(@file, "$string[$i]");
		 }
		 elsif(-l $string[$i]){
			 print chr(7) if $debug eq 1;
			 print "\n Your input filename exist as a Link to : $string[$i]\n" if $debug eq 1;
			 unshift(@file, "$string[$i]");
		 }
		 elsif( -d $ENV{'DSSP'} ){
			 $string[$i] =~ s/(\w+)\.dssp$/$1/; ## stripping .dssp extension
			 if( -e "$ENV{'DSSP'}\/$string[$i]\.dssp" ){
				unshift(@file, "$ENV{'DSSP'}\/$string[$i]\.dssp");
				$BASE = $string[$i];
			 }else{
				 print chr(7);
				 print __LINE__, " !! Error your DSSP env setting seems wrong. \n";
				 print __LINE__, " !! Your DSSP env path is also a link. \n" if (-l $ENV{'DSSP'});
				 print __LINE__, " I can't find  $ENV{'DSSP'}\/$string[$i] \n\n";
			 }
		 }
		 elsif( -l $ENV{'DSSP'} ){ #"""""""  IF $DSSP was a link
			 print __LINE__, " !! Your DSSP env path is also a link. \n" if $debug eq 1;
			 if( -e "$ENV{'DSSP'}\/$string[$i]\.dssp" ){
				unshift(@file, "$ENV{'DSSP'}\/$string[$i]\.dssp");
				$BASE = $string[$i];
			 }
			 elsif( -e "$ENV{'DSSP'}\/$string[$i]" ){
				unshift(@file, "$ENV{'DSSP'}\/$string[$i]\.dssp");
			 }
		 }
	}

	@file=@{remove_dup_in_array(\@file)};

	if ($debug eq 1){
	  print __LINE__, " # open_dssp_files : ENV set for dssp is $ENV{'DSSP'} \n" ;
	  print __LINE__, " # open_dssp_files : Final \@file given are \" @file \"\n" ;
	}
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#  END of File and string input checking in searching for the right dssp file.
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#"""""""""""""""""""""""" MAIN """"""""""""""""""""""""""""""""""""""
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	for($i=0; $i< @file; $i++){  ## <<-- loops over the input files.
		 my($flag, %hash, $name, $s, $matched, $ori_name, $chain);
		 my($real_file) = $file[$i];
		 $file[$i] =~ s/(.*\/)(\w+)\.(\w+)$/$2/; ## stripping .dssp extension
		 $file[$i] =~ s/(\w+)\.(\w+)$/$1/;       ## stripping .dssp extension
		 $ori_name = $name = $file[$i];
		 print "\n",__LINE__, " VAR \$ori_name is  $ori_name , \$file\[\$i\] is $file[$i]\n" if $debug eq 1;
		 unless(-e $real_file){
			print "\n",__LINE__,"  !!! ERROR $real_file does not exists as the final filename\n" if $debug eq 1;
			splice(@file, $i, 1); $i--;
			print "\n",__LINE__,"  Skipping to the next file to open" if $debug eq 1;
			next;
		 }

		 open(FILE_1,"$real_file");
		 print "\n",__LINE__, " ${i}th file $real_file is being opened from \@file \n" if $debug eq 1;
		 print "_"x86,"\n", if $debug eq 1;

		 while(<FILE_1>){
			 if(/^[\s]*\#\s+RESIDUE/){
				 $flag =1;
				 print __LINE__," \"#  RESIDUE\"   string found at line $. in $real_file\n" if $debug eq 1;
				 next
			 }  ##   '#  RESIDUE' is the starting key

			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 #    Matching the column
			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

			 if(  ($flag==1) && (/^[\s]*-*\d+\s+-*\d*\s+[\w]\s\s([\w ]) /)  ){
				 $matched = $1;
				 print __LINE__," \"$matched\" is matched\n" if $debug2 eq 1;

				 if( $char_opt =~ /$matched/){ ## Here OPTIONS affect the operation.
					 $s .= $matched;    ## $match_option is like 'HE'. If the
					 next;              ## single char $matched is H or E, it will be
				 }else{                ## annexed to $s as an output.
					 $s .= $gap_char;
					 next;
				 }  # <-- this is necessary to get the right length (not to ignore
			 }     #     not matched char by converting them to ' '.

			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 #    When there are chains like A, B, ,,,
			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 elsif( ($flag==1) && (/^[\s]*-*\d+\s+-*(\d+)[\s\w]+(\w)\s+[\w]\s\s([\w ]) /) ){
				 $chain = $2;   ## $flag  is for the starting key
				 # ${"chain_start$name$2"} = $1 unless defined(${"chain_start$name$2"});
				 my($matched_chain) = $3;
				 if( $char_opt =~ /$matched_chain/){
					$s .= $matched_chain;   next; }
				 else{
					$s .= $gap_char; next; }
			 }elsif( (/^\s+\d+\s+\!/)&&($chain =~/\w/) ){
				 $name="$name$chain";
				 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
				 ##   IF simplify  option is set
				 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
				 if($simplify eq 1){
					 $s =~ tr/TGI/EHH/;   ### change the characters.
					 print __LINE__," Simplifying TGI to EHH by \"tr\"\n" if $debug eq 1;
				 }
				 if($debug eq 1){ print __LINE__, " Name of seq:  $name \n"; }
				 $hash{$name}=$s; $s='';
				 $name=$ori_name; next;
			 }
		 }
		 close(FILE_1);  ##<<---- Reading finished.

		 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 ##  Naming procedure
		 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 if($chain =~/^\w$/){     # when there are chains, put A,B, etc to seq. names.
			 $name="$name$chain";  ## <<-- This is for the last chain entry.
			 if($debug eq 1){ print __LINE__, " Name of seq:  $name, There were Chains !\n"; }
			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 ##   IF simplify  option is set
			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 if($simplify eq 1){
				 $s =~ tr/TGI/EHH/;   ### change the characters.
				 print __LINE__," Simplifying TGI to EHH by \"tr\"\n" if $debug eq 1;
			 }
			 $hash{$name}=$s;
			 $s='';   ##<<--- This is essential, a former bug!
			 $name=$ori_name;
		 }else{      # <<-- Without chains option.
			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 ##   IF simplify  option is set
			 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
			 if($simplify eq 1){
				 $s =~ tr/TGI/EHH/;   ### change the characters.
				 print __LINE__," Simplifying TGI to EHH by \"tr\"\n" if $debug eq 1;
			 }
			 $hash{$name}=$s;
			 if($debug eq 1){ print __LINE__, " Name of seq:  $name \n"; }
			 $s='';   #<<--- This is essential, a former bug!
		 }

		 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 ### OUTput format determination according to options #####
		 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 if($debug eq 1){ print "\n", __LINE__, " The Hash out of \"$real_file\" is \n ";
			 &show_hash(%hash);
		 }
		 push(@out_hash_ref_list, \%hash) if ref(\%hash) eq 'HASH';
	}
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	#"""""""""""" END of Main """""""""""""""""""""""""""
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	if($comm_col =~ /c/i){ # $comm_col  is a global
	  if($debug eq 1){
		  print "\n", __LINE__;
		  print " # open_dssp_files : you have put 'c' option for common column only\n";
		  $temp = @out_hash_ref_list;
		  print __LINE__, " # open_dssp_files : No. of hashes passed to get_common_column is: $temp\n";
		  print __LINE__, " # open_dssp_files : The hash are(is) : @out_hash_ref_list\n";
	  }
	  $ref_hash_out = &get_common_column(@out_hash_ref_list);
	  return($ref_hash_out);
	}else{
	  if(@out_hash_ref_list == 1){ return($out_hash_ref_list[0]); }
	  elsif(@out_hash_ref_list > 1){ return(@out_hash_ref_list);  }
	}
}

#________________________________________________________________________
# Title     : open_dna_files  (genbank file opener)
# Usage     : ($out, $out2) = @{&open_dna_files(\$inputfile1, \$inputfile2)};
#             : (@out)        = @{&open_dna_files(\$inputfile1, \$inputfile2)};
#             ---------- Example of dna file --- dna files are genbank file format
#
#
#             1 ggatcttgct gaatacatgg tggcacaatt gaaattagat ccgcgaattt
#               tcatcaaaac
#             61 agcgggatta tggtcaacaa atccgtaaaa atgaaaagcc tgtcttgcga
#               caggcttttt
#             121 tatttgaatg taatcctcac tggtaaacgt ttaacgccaa agacaaaggg
#               actagggatc
#             181 gcttcaagct tttcatcatg agcagctttt tcgatacaag ctgacattga
#
# Function  : open dna files and put sequences in a hash(s)
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : (@out_array_of_refs)
# Argument  : (\$inputfile1, \$inputfile2, .... )};
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_dna_files{  my(@in)=@_; my(@names, $i,$n, $s, %hash,@out_hash_ref_list);
	for($i=0; $i<=$#in; $i++){
	 if(ref($in[$i])){ unless (-e ${$_[$i]}){ next; }
		 open(FILE_1,"${$_[$i]}");  undef(%hash);
		 while(<FILE_1>){      # file1 needs to be xxxx.msf for the moment, automatic later
			 if(/Name\:\s+(\S+)\s+/){ $n=$1; $n=~s/\,//g; }
			 if((/\s+\d+\s([acgt ]+)$/)||(/\s\s\s\s+([acgt ]+)$/)){
				$s=$1; $s=~s/ //g; $s=~tr/a-z/A-Z/; $hash{$n}.=$s; }     }
		 push(@out_hash_ref_list, \%hash); } }
	if(@out_hash_ref_list  == 1 ){ return(\%hash); }
	elsif(@out_hash_ref_list > 1){ return(@out_hash_ref_list); } # <-- contains (\%out_seq0, \%out_seq1, \%out_seq2, .... )
}
#________________________________________________________________________
# Title     : open_tem_files
# Usage     : ($r1, $r2, $r3, $r4, $r5)=&open_tem_files(\$infile1, \$inputfile2..)};
#             ---------- Example of xxxx
#             >P1;1cdg
#             sequence
#             APDTSVSNKQNFSTDVIYQIFTDRFSDGNPANNPTGAAFDGTCTN-LRLYCGGDWQGIINKINDGYLTGMGVTAI
#             >P1;1cdg
#             secture and phi angle
#             CCCCCCCCCCCCCCCCEEECCHHHHCCCCHHHCCCPHHCCCCPCC-CCCCCPCCHHHHHHHHHCPHHHHHPCCEE
#             >P1;1cdg
#             solvent accessibility
#             TTTTTTTTTTTFFFFFFFFFFFFFFTTTTTTTTTTTTTTTTTFTT-TTTTFFFFFTFFTTTFTTTFFTTFTFTFF
#             >P1;1cdg
#             DSSP
#             CCCCCCCCCCCCCCCCEEECCHHHHCCCCGGGCCCGGGCCCCCCC-CCCCCCCCHHHHHHHHHCCHHHHHCCCEE
#             >P1;1cdg
#             percentage accessibility
#             67523272360000000000000002213792129b722248085-14110000030015105660028040200
#             2ltn           ----TETTSFLITKFSPDQQNLIFQGDGYTT-KEKLTLTK------AVKNTVGRALYSSP
#             1loe           ----TETTSFSITKFGPDQQNLIFQGDGYTT-KERLTLTK------AVRNTVGRALYSSP
#
#             2ltn           ----CEEEEEEECCCCCCCCCEEEEPCCEEP-PPCEEEEC------CCCPCEEEEEECCC
#             1loe           ----CEEEEEEECCCCCCCCCEEEEPCCEEE-PPEEEEEC------CCCPCEEEEEECCC
#
#             2ltn           ----TTTTTTTTTTFTTTTTTFTTTTTFTFT-TTTFTFFT------TTTTTTFFFFTTTT
#             1loe           ----TTTTTTTTTTFTTTTTTFTTTTTFTFT-TTTFFFFT------TTTTTTFFFFTTTT
#
#             2ltn           ----CEEEEEEECCCCCCCCCEEEEECCEEC-CCCEEEEC------CCCCCEEEEEECCC
#             1loe           ----CEEEEEEECCCCCCCCCEEEEECCEEE-CCEEEEEC------CCCCCEEEEEECCC
#
#             2ltn           ----543251b16504681c50422650502-75201006------35681200001453
#             1loe           ----6532e1508a07981b50422750404-8a200006------36672200001453
# Function  : opens JPO's xxxx.tem file, stores in 5 hashes. (usually one tem file)
# Example   :
# Warning   :
# Keywords  :
# Options   : -n, n, or N for removing any gaps in the sequences.
#             -s, s, or S for getting only the sequences.
# Returns   : ($r1, $r2, $r3, $r4, $r5) <= these are references for hashes.
# Argument  : (\$inputfile1, \$inputfile2, .... )};
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_tem_files{
	my($a, $b, $c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r,
	  $s, $t, $u, $v, $w, $x, $y, $z, $pwd, $file, $dir, $output, $in_dir,
	  %hash, @keys, @array, @hash, $option_string, $string, @in, $line,
	  $name, %out, $gap_chr, @str1, @str2, $num_opt, @file, @dir,
	  $char_opt, $char_opt_given, $num_opt_given,
	  @char_options, @file, $original_dir, @read_files, %array_msf, %array_jp,
	  $jp_file, $error_rate, $id_compos, @dir, @names, $name, $name_found,
	  @outref, %sequence, %secondary,%solvent_access, %DSSP, %percent_accessibility,
	  $name_found,$type_seq, $type_secon, $type_sol, $type_DSSP, $type_acc
	);
	##################################################
	##### Start of  general argument handling   ######
	##################################################
	for($k=0; $k< @_ ;$k++){
	  if( !ref($_[$k]) ){
			  if($_[$k]=~ /^[\-]*(\w)$/){
				  $char_opt  .= "\,$1";
				  $char_opt_given =1;
			  }elsif($_[$k]=~ /^\-(\w\w+)$/){       ## When multiple option is given,
				  my(@char_options) = split(/|\,/, $1); ## '-' should be used. eg. '-HEGI'
				  $char_opt .= join("\,", @char_options);  ## as an option string.
				  $char_opt_given = 1;
			  }elsif($_[$k]=~ /^([\-]*\d)$/){
				  $num_opt   .= "\,$1";  ## delimiter is ','
				  $num_opt_given = 1;
			  }elsif(-f $_[$k]){     ## When file is given,
				  push(@file, \$_[$k] );
			  }elsif(-d $_[$k]){     ## When dir is given,
				  push(@dir, \$_[$k] );    }
	  }elsif( ref($_[$k]) ){
			if(ref($_[$k]) eq "SCALAR")
				{if(${$_[$k]} =~ /^[\-]*(\w)$/){  ## check if it has '-' before option char
					$char_opt  .= "\,$1";  ## delimiter for option char is ','
					$char_opt_given = 1;
				}elsif(${$_[$k]}=~ /^\-(\w\w+)$/){       ## When multiple option is given,
					my(@char_options) = split(/|\,/, $1); ## '-' should be used. for eg. '-HEGI'
					$char_opt  .= join("\,", @char_options);  ## as an option string.
					$char_opt_given =1;
				}elsif(${$_[$k]}=~ /^([\-]*\d)$/){
					$num_opt   .= "\,$1";  ## delimiter is ','
					$num_opt_given = 1;
				}elsif(-f ${$_[$k]}){     ## When file is given,
					push(@file, $_[$k] );
				}elsif(-d ${$_[$k]}){     ## When dir is given,
					push(@dir, $_[$k] );  }
			}elsif(ref($_[$k]) eq "ARRAY"){  ## When ARRAY is given,
					push(@array, $_[$k]);
			}elsif(ref($_[$k]) eq "HASH"){   ## When HASH is given,
					push(@hash, $_[$k]);
			}
	  }
	  ###################################################
	  ## The output of this option handling section is
	  ## one or combination of these:
	  ## $char_opt_given   ##<<-- Simple boolean '1' or none
	  ## $num_opt_given    ##<<-- Simple boolean '1' or none
	  ## $char_opt, as ('A,B,C')
	  ## $num_opt,  as ('1,-2,3')
	  ## @file          as (\file1, \file2,...)
	  ## @dir           as (\dir1, \dir2,...)
	  ## @array         as (\array1, \array2,,,)
	  ## @hash          as (\hash1, \hash2,,,,)
	  ###################################################
	}
	################################################
	##### END of  general argument handling   ######
	################################################

	for($i=0; $i < @file; $i++){
	 if(ref($file[$i])){ unless(-T ${$file[$i]}){ next; }
		 open(FILE_1, "${$file[$i]}");
		 while(<FILE_1>){
			 if(/^\>P1\;([\w\-]+)/){ $name=$1; #=================== SEQUENCE
				($type_seq, $type_secon, $type_sol, $type_DSSP, $type_acc)=();
			 }elsif(/^sequence/){  $type_seq = 1;
			 }elsif(($type_seq ==1)&&(/^([\w\-]+)[\*]*$/)){
				my($line) = $1;
				if( $char_opt =~ /n/i){  ## to remove the gaps etc.
					$line=~s/\W//g;
					$sequence{$name}.=$line;
				}else{
					$sequence{$name}.=$line;
				} #from below ============== SECONDARY
			 }elsif(/^secondary structure and phi angle/){  $type_secon = 1;
			 }elsif(($type_secon ==1)&&(/^([\w\-]+)[\*]*$/)){
				$secondary{$name}.=$1;     #from below============= SOLVENT ACCESSIBILITY
			 }elsif(/^solvent accessibility/){  $type_sol = 1;
			 }elsif(($type_sol ==1)&&(/^([\w\-]+)[\*]*$/)){
				$solvent_access{$name}.=$1;     #from below========= DSSP
			 }elsif(/^DSSP/){  $type_DSSP = 1;
			 }elsif(($type_DSSP ==1)&&(/^([\w\-]+)[\*]*$/)){
				$DSSP{$name}.=$1;     #from below=================== PERCENTAGE ACCESSIBILITY
			 }elsif(/^percentage accessibility/){  $type_acc = 1;
			 }elsif(($type_acc ==1)&&(/^([\w\-]+)[\*]*$/)){
				$percent_accessibility{$name}.=$1;  } }
		  push(@outref,\%sequence,\%secondary,\%solvent_access,\%DSSP,\%percent_accessibility);
	  }  }
	if( ($char_opt =~ /s/i) || ( @outref  == 1 ) ){
	  return(\%sequence); }
	elsif( @outref > 1){ return(@outref); } # <-- contains (\%sequence,\%secondary,....)
}

#________________________________________________________________________
# Title     : open_hlx_files
# Usage     :
# Function  :
#             Example of hlx file (For Bo Nielson)
#             Residue Frame Score Probability
#             1 M   a  1.00563E+00 2.05479E-03
#             2 T   b  1.01814E+00 2.52053E-03
#             3 R   c  1.01814E+00 2.52053E-03
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : list of ref. for hash(es)
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_hlx_files{  my(@in)=@_; my(@names, $i,$n, $s, %hash,@out_hash_ref_list);
	for($i=0; $i< @in; $i++){
	 if(ref($in[$i])){ unless(-e ${$in[$i]}){ next; }}
	 open(FILE_1, "${$in[$i]}");
	 while(<FILE_1>){
		if(/^[\s]+([\d]+)\s+(\w+)\s+(\w+)\s+\S+\s+(\S+)$/){
		  $hash_residue{$1}=($2); # residue num is key, residue is value.
		  $hash_frame{$1}=($3);   # residue num is key, frame is  value.
		  $hash_prob{$1}=($4);    # residue num is key, probability is  value.
		}
	 }
	 push(@out_hash_ref_list, \%hash_residue, \%hash_frame, \%hash_prob);
	}
	if($#out_hash_ref_list  == 0 ){ return(\%hash_residue); }
	elsif($#out_hash_ref_list > 0){ return(@out_hash_ref_list); }
}


#________________________________________________________________________
# Title     : open_jp_files  (bug free!!)
# Usage     : %out_hash=%{&open_jp_files(\$file_name)};
# Function  : reads jp files and stores results in a hash.
# Example   :
# Warning   : All the spaces  '-' !!!
# Keywords  :
# Options   :
# Returns   : a reference of a hash for names and  their sequences.
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub open_jp_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%hash_out, $s1);
	open(FILE_JP, "$file[0]");
	while(<FILE_JP>){    if(/^CLUSTAL/){ next; }
		if((/^([\S]+)[\t]* +$/)||(/^\#/)){ next; }
		if(/^([\w\.\-\=\+]+) +\t*(\S+)[\n]$/){ $n=$1; $s=$2; $hash_out{$n}.= $s; }
	}
	#&show_hash(%hash_out);
	\%hash_out;
}

#________________________________________________________________________
# Title     : open_ali_files
# Usage     : %anyhash = %{&open_ali_files(\$filename)};
# Function  : open fasta files and put sequences in a hash
#             FASTA sequence file format is like this;
#
#             >P1;1abp
#             structureX:1abp:   1 : : 306 : :L-arabinose-binding protein:Escherichia coli: 2.40:-1.00
#             ENLKLGFLVKQPEEPWFQTEWKFADKAGKDLG-FEVIKIAV-PDGEKTLNAIDSLAASGAKGFVICTPDPKLGSA
#             TEGQGFKAADIIGIGINGVDAVSELSKAQATGFYGSLLPSPDVHGYKSSEMLYNWVAK--------DVEPPKFTE
#             VTDVVLITRDNFKEELEKKGLGGK*
#             >P1;2gbp
#             structureX:2gbp:   1 : : 309 : :D-galactose/D-glucose-bind:Escherichia coli: 1.90:14.60
#             ADTRIGVTIYKYDDNFMSVVRKAIEQDAKAAPDVQLLMNDSQNDQSKQNDQIDVLLAKGVKALAINLVDPAAAGT
#             LKAHNKS-SIP-VFGVDA--LPEALALVKSGALAGTVLNDANNQAKATFDLAKNLADGKGAADGTNWKIDNKVVR
#             VP-YVGVDKDNLAEFSKK------*
#
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_ali_files{    my($input_file)=${$_[0]}; my(@names, %sequence, $flag,$name,$temp2);
	unless (-e $input_file){     print chr(7);
	  print "\n\n\t This is sub open_ali_files in th_lib.pl \n\n";
	  print "\n\n\t Fatal: The input file $input_file is not in the directory \n"; die; }
	open(FILE_1,"$input_file");
	while(<FILE_1>){         		# file1 needs to be xxxx.fasta for the moment, automatic later
	  if(/^\>\S\S\;([\w\-\.]+)$/){ $name=$1; next; }
	  elsif(/\:/){ next; }
	  elsif(/^([\w\-]+)[\*]*$/){ $sequence{$name}.= $1; }
	  else{  next; }    }
	return(\%sequence);
}



#________________________________________________________________________
# Title     : open_pir_files
# Usage     : %anyhash = &open_pir_files($any_sequence_file_fasta_form);
# Function  : open fasta files and put sequences in a hash
#             FASTA sequence file format is like this;
#
#             >P1;1abp
#             structureX:1abp:   1 : : 306 : :L-arabinose-binding protein:Escherichia coli: 2.40:-1.00
#             ENLKLGFLVKQPEEPWFQTEWKFADKAGKDLG-FEVIKIAV-PDGEKTLNAIDSLAASGAKGFVICTPDPKLGSA
#             VTDVVLITRDNFKEELEKKGLGGK*
#             >P1;2gbp
#             structureX:2gbp:   1 : : 309 : :D-galactose/D-glucose-bind:Escherichia coli: 1.90:14.60
#             LKAHNKS-SIP-VFGVDA--LPEALALVKSGALAGTVLNDANNQAKATFDLAKNLADGKGAADGTNWKIDNKVVR
#             VP-YVGVDKDNLAEFSKK------*
#
# Example   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub open_pir_files{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#_____________________________________________________________________________
		my($input_file, @names, %sequence, $flag,$seq, $name,$temp2,
			 @final_out_hash_ref, $description);
		for($i=0; $i< @file; $i++){
				my( %sequence);
				$input_file=$file[$i];
				unless (-e $input_file){
					 print chr(7);
					 print "\n# (ERROR) open_pir_files This is sub open_pir_files \n\n";
					 print "\n\t Fatal: The input file $input_file is not in the directory \n"; die;
				}
				open(FILE_1,"$input_file") or die "\n# (ERROR) Failed to open $input_file\n";
				while(<FILE_1>){                        # file1 needs to be xxxx.fasta for the moment, automatic later
						if($name_entry_found and /^(\S.+)/){
								 $description=$1;
								 $name_entry_found=0; # skipping Description line
								 next;
						}
						if(/^\>\S\S\;([\w\-\.]+) */){ # eg)   >P1;TY1A_A
							 $name=$1;
							 $name_entry_found=1;
							 next;
						}elsif(/\:/ or /^\*/){
							 next;
						}elsif(/^(\w[\w\- ]*)[\*]?$/){
							 $seq=$1; $seq=~s/\s+//g; ## to remove the space
							 $sequence{$name}.= $seq;
						}else{
							 next;
						}
				}
				push(@final_out_hash_ref, \%sequence);
		}
		if(@final_out_hash_ref > 1){
				return(\@final_out_hash_ref);
		}else{
				return($final_out_hash_ref[0]);
		}
}

#________________________________________________________________________
# Title     : open_aln_files
# Usage     : %out_hash=%{&open_aln_files(\$file_name)};
# Function  : reads CLUSTALW aln files and stores results in a hash.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : a reference of a hash for names and  their sequences.
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub open_aln_files{
		 my(%hash_out, $s, $n, $s1, $input_aln_file);
		 if(ref($_[0]) eq SCALAR){
				 $input_aln_file=${$_[0]};
		 }else{
				 $input_aln_file=$_[0];
		 }
		 open(FILE_ALN, "$input_aln_file");  # reading in (JP) file
		 while(<FILE_ALN>){
				 if(/^CLUSTAL/){ next; }
				 if((/^([\S]+)[\t]* +$/)||(/^ *\#/)){ next; }
				 if(/^ {0,5}(\S+)\s+([\-ACDEFGHIKLMNPQRSTVWXY]+) *$/i){
						$n=$1; $s=$2; $hash_out{$n}.= $s;
				 }
		}
		return( \%hash_out );
}

#________________________________________________________________________
# Title     : open_seq_alignment_files
# Usage     : (*out, *out2) = @{&open_seq_alignment_files(\$inputfile1, \$inputfile2)};
#           : %hash_seq = %{&open_seq_alignment_files(\$inputfile1)};
#           : (@out)        = @{&open_seq_alignment_files(\$inputfile1, \$inputfile2)};
# Function  : open various sequence alignment files and put sequences in a hash(s)
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : (*out, *out2)  or (@out_array_of_refs)
# Argument  : (\$inputfile1, \$inputfile2, .... )};
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_seq_alignment_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	my(@names,  %hash, @out_hash_ref_list,  %seq);

	for($i=0; $i< @file; $i++){
						 print "\n# Trying to open $file[$i]\n";
						 if($file[$i]=~/\.msf$/){ ## MSF file format
								 %seq=%{&open_msf_files($file[$i])};
						 }elsif($file[$i]=~/\.aln$/){
								 %seq=%{&open_aln_files($file[$i])};
						 }elsif($file[$i]=~/\S+/){
								 $file_type=${&detect_file_format_type($file[$i])};
								 $subroutine_to_be_called="open\_${file_type}\_files";
								 %seq=%{&$subroutine_to_be_called};
						 }
						 push(@out_hash_ref_list, \%seq);
	}
	if(@out_hash_ref_list  == 1 ){ return(\%seq); }
				elsif(@out_hash_ref_list > 1){ return(@out_hash_ref_list); }
}





#________________________________________________________________________
# Title     : open_sst_files (also look at "open_sst_files_with_gap")
# Usage     : %out_sst_hash =%{&open_sst_files(\$jp_file_dir_and_name)};
# Function  : gets the name of a file(jp file) with its absolute dir path
#             reads the sequence names in the jp file and looks up all
#             the sst files in the same directory. Puts sst sequences
#             in a hash with keys of sequence names.
#
# Example   : jp file  ==  seq1 ABDSF--DSFSDFS   <- true sequence
#                              seq2 lkdf-jlsjlsjf
#
#                 sst files == seq1.sst, seq2.sst
#
#                 output hash == seq1 hHHHHHHHttEEEEEEEE
#                                seq2 hHHHHHHHHHEEEEEEhh
#
# Warning   : $jp_file_dir_and_name should be absolute dir and file name
# Keywords  :
# Options   :
# Returns   : a ref. for a hash
# Argument  : a ref. for scaler of "jp file name"
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_sst_files{
	my($dir)=${$_[0]};
	my(%jp_file)=%{&open_jp_files($_[0])};
	my(%out_sst_seq_hash, $directory);
	if (${$_[0]} =~/^(.+\/)\w+\.jp$/){
	  $directory = $1;   }
	my(@keys)= (keys %jp_file);
	for $seq_name (@keys){
	  my($sst_file_name)="$directory$seq_name\.sst";
	  my($sst_seqs);
	  open(SST, "$sst_file_name");
	  while(<SST>){
		  if(/^  summary  (.*)  summary  $/){
			 $sst_seqs.=$1;  }   }
	  $out_sst_seq_hash{$seq_name}=$sst_seqs;   }
	\%out_sst_seq_hash;
}
#________________________________________________________________________
# Title     : read_sst_files  (synonym of open_sst_files )
# Usage     : %out_sst_hash =%{&read_sst_files(\$jp_file_dir_and_name)};
# Function  : gets the name of a file(jp file) with its absolute dir path
#             reads the sequence names in the jp file and looks up all
#             the sst files in the same directory. Puts sst sequences
#             in a hash with keys of sequence names.
#
# Example   : jp file  ==  seq1 ABDSF--DSFSDFS   <- true sequence
#                              seq2 lkdf-jlsjlsjf
#
#                 sst files == seq1.sst, seq2.sst
#
#                 output hash == seq1 hHHHHHHHttEEEEEEEE
#                                seq2 hHHHHHHHHHEEEEEEhh
#
# Warning   : $jp_file_dir_and_name should be absolute dir and file name
# Keywords  :
# Options   :
# Returns   : a ref. for a hash
# Argument  : a ref. for scaler of "jp file name"
# Category  :
# Version   :
#--------------------------------------------------------------------
sub read_sst_files{  my($dir)=${$_[0]};  my(%jp_file)=%{&open_jp_files($_[0])};
	my(%out_sst_seq_hash, $directory);
	if (${$_[0]} =~/^(.+\/)\w+\.jp$/){
	  $directory = $1;   }
	my(@keys)= (keys %jp_file);
	for $seq_name (@keys){
	  my($sst_file_name)="$directory$seq_name\.sst";
	  my($sst_seqs);
	  open(SST, "$sst_file_name");
	  while(<SST>){
		  if(/^  summary  (.*)  summary  $/){
			 $sst_seqs.=$1;  }   }
	  $out_sst_seq_hash{$seq_name}=$sst_seqs;   }
	\%out_sst_seq_hash;
}


#________________________________________________________________________
# Title     : open_slx_files
# Usage     : %anyarray = &open_slx_files(\$any_sequence_file_slx_form);
# Function  : open slx files and put sequences in a hash
# Example   : selex file (foo.slx) looks like this:
#
#         #=SQ GLB_TUBTU  5.9393 - - 0..0::0 -
#         #=SQ GGZLB      20.9706 - - 0..0::0 -
#         #=RF        x.....x.xxxx.xxx.xxxxxx....xxxxxxxxxxxxxxx.xxxx
#         HAHU        ......VLSPADKTNVKAAWGKVGA......HAGEYGAEALERMFLS
#         HBA3_PANTR  ......VLSPADKTNVKAAWGKVGA......HAGZYGAEALERMFLS
#
# Warning   : The slx FORMAT SHOULD BE AT LEAST 30 residue long
# Keywords  :
# Options   :
# Returns   : a ref. of a hash
# Argument  : takes one ref. for a file.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub open_slx_files{
	my(@names, $n, $s, %hash);
	if ((-z ${$_[0]})|| (-B _) || (-x _)){   print chr(7);
		print "\n\t I am $0: Input file $file1 isn't in the dir \n"; die;
	}
	open(FILE_1,"${$_[0]}");  	# reading in (slx)
	while(<FILE_1>){         	# file1 needs to be xxxx.slx for the moment, automatic later
	  if((/^([\S]+)[\t]* +$/)||(/^\#\=/)){ next; }
	  if(/^(\w+)\s+([\w\.\-]+)$/){
		  $n=$1; $s=$2; $hash{$n}.= $s;  }}
	return( \%hash );
}

#________________________________________________________________________
# Title     : open_out_files
# Usage     : %anyarray = &open_out_files(\$any_out_file);
# Function  : open out files and put their sequences in a hash
# Example   :
# Warning   : well tested. It skips lines starting with blank, lines with '-' in them.
# Keywords  :
# Options   :
# Returns   : a ref. of a hash
#             Output example in a hash(fills the space)
#
#             3aat       --mfe---aapadp----adlfraderpGk---gigvY--etgktpvltS
#             1ama       ---eamiaakkmdkeylpiaGladFtraSA----eAfksgryVTV
#
# Argument  : takes one ref. for a file.
#             >>Out file looks like this===>
#
#             3aat         mfe   aapadp----adlfraderpGk   gigvY--etgktpvltS
#             1ama       sswwshvemgppdp  krdtns--kkMnLG---YrddngkpyvLnC-
#
# Category  :
# Version   :
#--------------------------------------------------------------------
sub open_out_files{    			# opening msf files. input is a file name.
	my($flag, %hash, @names, $n, $s);
	unless (-e ${$_[0]}){
	  print chr(7);	# beep warning for error
	  print "\n\n\t This is sub open_out_files in th_lib.pl \n\n";
	  print "\n\n\t I am $0: The input file $file1 is not in the directory \n";
	  die; # these subs are in th_lib.pl
	}
	open(FILE_1,"${$_[0]}");  	# reading in (MSF)
	while(<FILE_1>){         	# file1 needs to be xxxx.msf for the moment, automatic later
	  if (/^pairwise sequence distances/){  # <<---!! recognising que !!
		 $flag =1;}
	  if((/^(...........)([\s\w\-]+)[\n]$/) && ($flag == 1)){ 	# matching patterns (includin tab space)
		 $n=$1; $s=$2; $n=~ s/ //g; $s=~ s/ /-/g;
		 $hash{$n}.= $s;   		# may and concatenate second set to first set(name)
	  }
	}
	%hash=%{&fill_ending_space(\%hash)};  ### << filling the ending gaps !!
	return ( \%hash );
}


#________________________________________________________________________
# Title     : package Roman;
# Usage     :
# Function  : Roman.pm : Roman <-> Arabic conversion package
# Example   :
# Warning   : From: ozawa@prince.pe.u-tokyo.ac.jp (OZAWA Sakuro)
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
package Roman;
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(isroman arabic Roman roman);
sub isroman{
	 my($arg) = @_;
	 $arg ne '' and $arg =~ /^(?: M{0,3})           (?: D?C{0,3} | C[DM])
									  (?: L?X{0,3} | X[LC]) (?: V?I{0,3} | I[VX])$/ix;
}
%roman2arabic = qw(I 1 V 5 X 10 L 50 C 100 D 500 M 1000);
sub arabic{
	 my($last_digit, $arg) = (1000, @_);
	 isroman $arg or return undef;
	 my($arabic);
	 foreach (split(//, uc $arg)) {
		  my($digit) = $roman2arabic{$_};
		  $arabic -= 2 * $last_digit if $last_digit < $digit;
		  $arabic += ($last_digit = $digit);
	 }
	 $arabic;
}
%roman_digit = qw(1 IV 10 XL 100 CD 1000 MMMMMM);
@figure = reverse sort keys %roman_digit;
grep($roman_digit{$_} = [split(//, $roman_digit{$_}, 2)], @figure);
sub Roman{
	 my($arg) = @_;
	 0 < $arg and $arg < 4000 or return undef;
	 my($x, $roman);
	 foreach (@figure){
		  my($digit, $i, $v) = (int($arg / $_), @{$roman_digit{$_}});
		  if (1 <= $digit and $digit <= 3) {
				$roman .= $i x $digit;
		  } elsif ($digit == 4) {
				$roman .= "$i$v";
		  } elsif ($digit == 5) {
				$roman .= $v;
		  } elsif (6 <= $digit and $digit <= 8) {
				$roman .= $v . $i x ($digit - 5);
		  } elsif ($digit == 9) {
				$roman .= "$i$x";
		  }
		  $arg -= $digit * $_;
		  $x = $i;
	 }
	 $roman;
}
sub roman{
	 lc Roman @_;
}
1;
package main;


#________________________________________________________________________
# Title     : time_date
# Usage     :
# Function  : returns current time & date as 05/15/95 23:22:41
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub time_date{
	 my($sec, $min, $hour, $day, $mon, $year) = localtime(time);
	 sprintf("%.2d/%.2d/%.2d %.2d:%.2d:%.2d", $mon+ 1, $day, $year, $hour, $min, $sec);
}

#________________________________________________________________________
# Title     : sep
# Usage     : &sep;
# Function  : separater. \n#________________________________\n
# Example   :
# Warning   :
# Keywords  : separating_line
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sep{
		print "\n#___________________________________________#\n";
}


#________________________________________________________________________
# Title     : diff_dates
# Usage     : $output = &diff_dates("05/15/1994", "05/15/1995")
# Function  : gets number of days between two dates ( "05/15/94" )
# Example   :
# Warning   : modified (originally from reb@serf.nsc.com (Edward Brown))
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub diff_dates{
		  print "\nNote: diff_dates subroutine accepts 00/00/0000 format \n";
		  print " If you put 11/15/94, diff_dates understands it as 11/15/0094 \n\n";
		  my($date1, $date2)  = @_;
		  my($absolute_days1) = &toJulian($date1);
		  my($absolute_days2) = &toJulian($date2);
		  my($diff_of_days)   = abs($absolute_days1 - $absolute_days2);
		  $diff_of_days;
}

#________________________________________________________________________
# Title     : fromJulian
# Usage     :
# Function  : taking the days between two dates.
# Example   : print &fromJulian(34469), "\n";
# Warning   : got from reb@serf.nsc.com (Edward Brown)
#             require "julian
#             $Value1 = &toJulian("05/15/1994");        # Assign $Value1 a Julian Day
#             print "$Value1\n";
#             $Value2 = &toJulian("05/20/1994");        # Assign Value2 a Julian Day
#             print "$Value2\n";
#             $Days = $Value2 - $Value1;              #Difference in Days
#             print "$Days\n";
#             print &fromJulian(34469), "\n";         # Give a Julian Day, give the date
#             print &fromJulian(34474), "\n";
#             What is the Date 25 Days from Today?  (You can get format from `date`)
#
#             $Value = &toJulian("05/16/1995");
#             $Value +=  25;
#             print &fromJulian($Value), "\n";
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fromJulian{
		  print "\n Note: fromJulian subroutine accepts any numbers for days \n";
		  print " It counts from 0000 year. \n\n";
		  my ($value) = @_;
		  my ($yr, $mo, $dy, $julian, $leapflag, $holdjulian)=0;
		  $yr = 0; 	$mo = 1;	$dy = 1;	 $julian = 0;
		  while ($yr>=0){
			   $holdjulian = $julian;
			   $leapflag = "FALSE";
			   if ($yr % 400 == 0){
									$julian += 365;
			   } elsif ($yr % 4 == 0){
									$leapflag = "TRUE";
									$julian += 366;
			   } else {
									$julian += 365;
			   }
			   if ($value < $julian){
									$julian = $holdjulian;
									last;
			   };
			   ++$yr;
		  }
		  $julian = $value - $julian;
		  while ($mo){
			  $holdjulian = $julian;
			  if ($mo == 1 || $mo == 3 || $mo == 5 ||
								   $mo == 7 || $mo == 8 || $mo == 10 ||
								   $mo == 12) {
								   $julian -= 31;
			  } elsif ( $mo == 4 || $mo == 6 ||
								   $mo == 9 || $mo == 11) {
								   $julian -= 30;
			  } elsif ($leapflag eq "TRUE") {
								   $julian -= 29;
			  } else {
								   $julian -= 28;
			  }

			  if ($julian < 0 ){
								   $julian = $holdjulian;
								   last;
			  };
		  ++$mo;
		  }
		  $dy = $julian;
		  $julRetDate = sprintf("%02d/%02d/%04d", $mo, $dy, $yr);
}
#________________________________________________________________________
# Title     : toJulian
# Usage     :
# Function  : taking the days between two dates.
# Example   : $Value1 = &toJulian("05/15/94"); print "$Value1\n";
# Warning   : got from reb@serf.nsc.com (Edward Brown)
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub toJulian {
		  print "\n Note: toJulian subroutine accepts 00/00/0000 format \n";
		  print " If you put 11/15/94, 'toJulian' understands it as 11/15/0094 \n\n";
		  my ($value) = @_;
		  my ($yr, $mo, $dy, $julian, $leapflag, $holdjulian)=0;
		  ($mo, $dy, $yr) = split(/\//, $value);
		  # checking if $mo, $dy, $yr are numbers.
		  if (!($mo =~ /^[\d]+$/)||!($dy =~ /^[\d]+$/)||!($yr =~ /^[\d]+$/)){
					 print "\nInputs to sub toJulian and sub diff_dates must be numbers.\n";
					 print "\nExiting sub toJulian \n";
					 &caller_info;
					 die;
		  }
		  if ($yr % 400 == 0){
								$leapflag = "FALSE";
		  } elsif ($yr % 4 == 0){
								$leapflag = "TRUE";
		  } else {
								$leapflag = "FALSE";
		  }
		  $julian = 0;
		  for ($i = 0; $i < $yr; ++$i){
								if ($i % 400 == 0){
													 $julian += 365;
								} elsif ($i % 4 == 0){
													 $julian += 366;
								} else {
													 $julian += 365;
								}
		  }
		  for ($i = 1; $i < $mo; ++$i){
								if ($i == 1 || $i == 3 || $i == 5 ||
													 $i == 7 || $i == 8 || $i == 10 ||
													 $i == 12) {
													 $julian += 31;
								} elsif ( $i == 4 || $i == 6 ||
													 $i == 9 || $i == 11) {
													 $julian += 30;
								} elsif ($leapflag eq "TRUE"){
													 $julian += 29;
								} else {
													 $julian += 28;
								}
		  }
		  $julian += $dy;
}

#________________________________________________________________________
# Title     : opendir_and_go
# Usage     : &opendir_and_go($input_dir); #$inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files if you wish, and then go in any sub
#             dir of it. Using recursion. created by A Biomatic
#             if any file is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub opendir_and_go{
		my($original_dir)=$_[0];
		my(@read_files)=&read_any_dir($original_dir);
		foreach $file(@read_files){
				my($dir)=$split_path[$#split_path];
				if (-l $realfile1){
															 next;
				}elsif (-d $realfile1){
								 &opendir_and_go($realfile1);
				}elsif (-f $realfile1){ #<<------ This is where things match
						chdir($original_dir);
						if($realfile1 =~/(\d+\-$no\.msf)$/){
								@dir=split(/\//, $realfile1);
								$dir=$dir[($#dir-1)];  # where am I ?
								# $jp_file = $original_dir.'/'.$dir.'.jp';
								# %array_msf =&open_msf_files($realfile1);
								# %array_jp  =&open_jp_files ($jp_file);
								# $array_ref_msf = \%array_msf;
								# $array_ref_jp  = \%array_jp;
								# $error_rate =&get_posi_shift_hash($array_ref_msf, $array_ref_jp);
								# $id_compos  =&amino_acid_compos_id_percent($array_ref_jp);
								# push(@rates_accumu,$error_rate);
								# push(@compos_id,$id_compos);
						}
				}
				else
				{
															 next;
				}
		}
}
#________________________________________________________________________
# Title     : occurances
# Usage     : sort occurances (@any_array_with_repeating_element);
# Function  : this is for sort, to sort things according to the higher num. of occu.
# Example   :
# Warning   : This is from 21 DAYS book, page 373.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub occurances{
	 $occurance_hash{$a} <=> $occurance_hash{$b};
}

#________________________________________________________________________
# Title     : extract_ori_seq
#             nt5
# Usage     : &extract_ori_seq($input_file, $output_file, $out_seq_no, *array2);
# Function  : extract seqs. which are from struc. alignment only. to be analysed.
#             after mul. alignment with added seq. you can extract original str.
#             sequ. by using this. The output always has ...msff  ext.
#             *array_ali is the JPO's or true alignment hash.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub extract_ori_seq{
	 local($input_file, $output_file, $out_seq_no, *array1, *array2) = @_; # something like $dir.$mul_factor.msf
		  local(%array_ext) = &open_msf_files("$input_file");
		  %array_ext = &hash_substract(*array_ext, *array2); # getting rid of added seq.
		  %array_ext = &hash_common(*array_ext, *array1);
		  open(OUTPUT, ">$output_file"); # this is different from $dir.msff
	 printf OUTPUT "PileUp\n\n\n";
	 printf OUTPUT "  MSF:%5d  Type: P                     Check:    0  ..\n",$ls;
	 print  OUTPUT "\n\n";
		  my(@keys3) = ( keys %array_ext );
		  $max = &max_str_value_hash(%array_ext);
	 $ls = $max;
	 $seq3 = ($#keys3+1);
	 for($j=0; $j < $seq3 ;$j++){
					 $name3=$keys3[$j];
					 printf OUTPUT " Name: %10s     Len: %5d  Check:    0  Weight:  1.00\n",$name3,$ls;
	 }
	 print OUTPUT "\n//\n\n";
	 for($seq_len = 0;$seq_len < $ls;$seq_len = $seq_len + 50){
				print OUTPUT "\n";
				foreach $name(keys %array_ext){
						  $string=$array_ext{$name};
						  if (length($name)<= 7){
									 $out=$name."\t    ";
						  }elsif(length($name)==8){
									 $out=$name."    ";
						  }elsif(length($name)== 9){
									 $out=$name."   ";
						  }elsif(length($name)== 10){
									 $out=$name."  ";
						  }elsif(length($name)== 11){
									 $out=$name." ";
						  }else{
									 $out=$name."\t";
						  }
						  # loop over blocks of 10
						  $is=$seq_len;
						  $ie=$seq_len+50;
						  $ie=$ls if $ie > $ls;
						  while($is < $ie){
										  $iee=$is+10;
										  $iee=$ls if $iee > $ls;
										  $out.=' ';
										  while($is < $iee){
													 $char=substr($string,$is,1);
													 if($char ne ' '){
													 $char =~ tr/a-z/A-Z/;
													 $out.=$char;
													 $char='.' if $char eq '-';
													 }
													 $is++;
										  }
						  }
				print OUTPUT "$out\n";
				}
				print OUTPUT "\n";	# open(OUTPUT, ">$dir.msff");
	 }
}	#  end of extract_ori_seq
#________________________________________________________________________
# Title     : get_pair_homol_array
# Usage     : $hom_out_count = ${&get_pair_homol_array(\@any_array_of_2_elem)};= @ar=(ABCDE..., CDEGA..)
# Function  : get pair wise seq. !! Number of pair identical residues.
# Example   :
# Warning   : reliable, but input seq. strings shouldn't contain spaces.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_pair_homol_array{
	 my(@input)=@{$_[0]};
	 $input[0] =~ tr/a-z/A-Z/; # capitalizing.
	 $input[1] =~ tr/a-z/A-Z/; # capitalizing.
	 my(@string1)= split(//,$input[0]);
	 my(@string2)= split(//,$input[1]);
	 if (($#string1 == -1) || ($#string2 == -1)){
		  print "\n One of the string is empty O.K. ? \n";
	 }
	 my($larger)= &max($#string1, $#string2);
	 my($id_counter, $gap_counter, $non_equal_counter, $sum)=0;
	 for ($i = 0; $i<=$larger; $i++){
		  if (($string1[$i] eq '.')|| ($string2[$i] eq '.')){
				$gap_counter+=1;
		  }elsif ($string1[$i] eq $string2[$i]){
				$id_counter +=1;
		  }else{
				$non_equal_counter += 1;
		  }
	 }
	 $sum = ($id_counter + $gap_counter + $non_equal_counter);
	 if ($sum != ($larger+1)){
		  print "\n There is something wrong in getting homology in get_pair_homol \n";
		  &caller_info;
	 }
	 \$id_counter; # $id_counter is the homology counter;
}
#________________________________________________________________________
# Title     : get_percent_homol_arr
# Usage     : $homology_out = ${&get_pair_homol(\@any_array_of_2_elem)};= @ar=(ABCDE..., CDEGA..)
# Function  : get pair wise seq. identity of any two strings, outputs a scalar (%)
# Example   :
# Warning   : reliable, but input seq. strings shouldn't contain spaces.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_percent_homol_arr{
	 my(@input)=@{$_[0]};
	 $input[0] =~ tr/a-z/A-Z/; # capitalizing.
	 $input[1] =~ tr/a-z/A-Z/; # capitalizing.
	 my(@string1)= split(//,$input[0]);
	 my(@string2)= split(//,$input[1]);
	 if (($#string1 == -1) || ($#string2 == -1)){
		  print "\n One of the string is empty O.K. ? \n";
	 }
	 my($larger)= &max($#string1, $#string2);
	 my($id_counter, $gap_counter, $non_equal_counter, $sum,$percent_homol)=0;
	 for ($i = 0; $i<=$larger; $i++){
		  if (($string1[$i] eq '.')|| ($string2[$i] eq '.')){
				$gap_counter+=1;
		  }elsif ($string1[$i] eq $string2[$i]){
				$id_counter +=1;
		  }else{
				$non_equal_counter += 1;
		  }
	 }
	 $sum = ($id_counter + $gap_counter + $non_equal_counter);
	 if ($sum != ($larger+1)){
		  print "\n There is something wrong in getting homology in get_pair_homol \n";
		  &caller_info;
	 }else{
		  $percent_homol=($id_counter/$sum)*100;
	 }
	 return(\$percent_homol); # $id_counter is the homology counter;
}

#________________________________________________________________________
# Title     : get_pair_homol_hash
# Usage     : $homology_out = & get_pair_homol (%any_hash); , eg) %hash = (name1, ABCDE..., name2, CDEGA..)
# Function  : get pair wise seq. identity as a scalar count
# Example   :
# Warning   : reliable, but input seq. strings shouldn't contain spaces.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_pair_homol_hash{
	 my(%input)=@_;
	 &hash_chk(\%input);
	 my(@keys_input)= keys (%input);
	 my(@values_input) = values (%input);
	 $values_input[0] =~ tr/a-z/A-Z/; # capitalizing.
	 $values_input[1] =~ tr/a-z/A-Z/; # capitalizing.
	 my(@string1)= split(//,$values_input[0]);
	 my(@string2)= split(//,$values_input[1]);
	 if (($#string1 == -1) || ($#string2 == -1)){
					 print "\n One of the string is empty O.K. ? \n";
	 }
	 my($larger)= &max($#string1, $#string2);
	 my($id_counter, $gap_counter, $non_equal_counter)=0;
	 for ($i = 0; $i<=$larger; $i++){
		  if (($string1[$i] eq '.')|| ($string2[$i] eq '.')){
				$gap_counter+=1;
		  }elsif ($string1[$i] eq $string2[$i]){
				$id_counter +=1;
		  }else{
				$non_equal_counter += 1;
		  }
	 }
	 my($sum) = ($id_counter + $gap_counter + $non_equal_counter);
	 if ($sum != ($larger+1)){
		 print "\n There is something wrong in getting homology in get_pair_homol \n";
		 &caller_info;
			}
	 return ($id_counter); # $id_counter is the homology counter;
}
#________________________________________________________________________
# Title     : get_percent_homo_hash
# Usage     : $homology_out = &get_pair_homol_hash(%any_hash); , eg) %hash = (name1, ABCDE..., name2, CDEGA..)
# Function  : get pair wise seq. identity(%) of any two strings put in as a hash
# Example   :
# Warning   : reliable, but input seq. strings shouldn't contain spaces.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_percent_homo_hash{
	 my(%input)=@_;
	 &hash_chk(\%input);
	 my(@keys_input)= keys (%input);
	 my(@values_input) = values (%input);
	 $values_input[0] =~ tr/a-z/A-Z/; # capitalizing.
	 $values_input[1] =~ tr/a-z/A-Z/; # capitalizing.
	 my(@string1)= split(//,$values_input[0]);
	 my(@string2)= split(//,$values_input[1]);
	 if (($#string1 == -1) || ($#string2 == -1)){
					 print "\n One of the string is empty O.K. ? \n";
	 }
	 my($larger)= &max($#string1, $#string2);
	 my($id_counter, $gap_counter, $non_equal_counter,$percent_homol,)=0;
	 for ($i = 0; $i<=$larger; $i++){
		  if (($string1[$i] eq '.')|| ($string2[$i] eq '.')){
				$gap_counter+=1;
		  }elsif ($string1[$i] eq $string2[$i]){
				$id_counter +=1;
		  }else{
				$non_equal_counter += 1;
		  }
	 }
	 my($sum) = ($id_counter + $gap_counter + $non_equal_counter);
	 if ($sum != ($larger+1)){
		  print "\n There is something wrong in getting homology in get_pair_homol \n";
		  &caller_info;
	 }else{
		  $percent_homol=($id_counter/$sum)*100;
	 }
	 return ($percent_homol);
}


#________________________________________________________________________
# Title     : file_size
# Usage     : $outputfilesize = &file_size($input_file_name);
# Function  : returns the size of any single testing file
# Example   :
# Warning   : Q is for quality of this sub. This can't be wrong.
# Keywords  : get_file_size, tell_file_size
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub file_size { my($infile)=$_[0];
	if ( $size=(-s "$infile")){ return $size; }
}

#________________________________________________________________________
# Title     : seq_comp_percent2
# Usage     : @outarray = &seq_comp_percent2(@any_input_string_array);
# Function  : get string seq COMPOSITION identities(a to z). gets array
#             of strings and outs array of % numbers
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub seq_comp_percent2{   	# simple and basic seq. id. eg. ABC on ABCABC is 50 % identical.
	my(@input)=@_;
	my(@array_of_ids2, $id2, @char1, @char2);
	&array_chk(sort @input);
	my($longest_str_size)  = &get_long_str_size (@input), "\n";
	my($shortest_str_size) = &get_short_str_size(@input), "\n";
	print "longest_str_size",$longest_str_size;
	print "shortest_str_size",$shortest_str_size;
	if (($longest_str_size/$shortest_str_size) > 4){
		  print "\n  The shortest string is less than 1/4 of the longest\n";
		  print "  This is quite meaningless, but will go on\n";
	}
	for ($i = 0; $i <= $#input ; $i++){
		  if ($input[$i]=~/(\W)/){
			  &remove_non_char($input[$i]);
		  }
		  @char1 = split(/|\s+|\.+|\-+/, $input[$i]);   # splitting into char.
		  foreach $char (@char1){
			  if ($char eq ' '){
					 next;
			  }
			  $charcount1{$char} +=1; # making array of ['A' => 6, 'B'=>2...]
		  }
		  for($j = $i+1 ; $j <= $#input; $j++){
			  if ($input[$j]=~/(\W)/){
				  &remove_non_char($input[$j]);
			  }
			  @char2 = split(/|\s+|\.+|\-+/, $input[$j]); # splitting into char.
			  for $char (@char2){
				  $charcount2{$char} +=1; 	 # making ary of ['A' => 6, ..]
			  }
			  $id2 = &get_id_among_2_2(*charcount1, *charcount2); # gets % id.
			  push (@array_of_ids2, $id2);
			  %charcount2=();
		  }
		  %charcount1=();
	}
	@array_of_ids2;
}

######################################################################################
###########  file and dir handling stuff #################
###############################################################################

#________________________________________________________________________
# Title     : get_full_file_name
# Usage     : $any_path = ${&get_full_dir_path($any_directory)}; or &dir_path('.') for pwd.
# Function  : returns full directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
# Example   :
# Warning   :
# Keywords  : get_long_path_name, get_complete_path_name
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_full_file_name{
	my($pwd)=`pwd`;
	chomp($pwd);
	\$pwd;
	my($full_file_name) = "$pwd\/$_[0]";
	return(\$full_file_name);
}


#________________________________________________________________________
# Title     : dir_path  (same as  pwd_path )
# Usage     : $any_path = &dir_path($any_directory); or &dir_path('.') for pwd.
# Function  : returns directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub dir_path{   my($pwd)=`pwd`;
		chomp($pwd);
		return( \$pwd );
}


#________________________________________________________________________
# Title     : full_pwd_path  (same as dir_path)
# Usage     : $any_path = ${&full_dir_path($any_directory)}; or &dir_path('.') for pwd.
# Function  : returns full directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
# Example   :
# Warning   :
# Keywords  : get_long_path_name, get_complete_path_name
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub full_pwd_path{  my($pwd)=`pwd`;
		chomp($pwd);
		return(\$pwd);
}

#________________________________________________________________________
# Title     : get_full_pwd_path  (same as dir_path)
# Usage     : $any_path = ${&get_full_dir_path($any_directory)}; or &dir_path('.') for pwd.
# Function  : returns full directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
# Example   :
# Warning   :
# Keywords  : get_long_path_name, get_complete_path_name
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_full_pwd_path{
		my($pwd)=`pwd`; 	chomp($pwd);	\$pwd;
}

#________________________________________________________________________
# Title     : get_whole_pwd_path  (same as dir_path)
# Usage     : $any_path = ${&get_whole_dir_path($any_directory)}; or &dir_path('.') for pwd.
# Function  : returns full directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
# Example   :
# Warning   :
# Keywords  : get_long_path_name, get_complete_path_name
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_whole_pwd_path{  my($pwd)=`pwd`; 	chomp($pwd);
		\$pwd;
}

#________________________________________________________________________
# Title     : pwd_path  (same as dir_path)
# Usage     : $any_path = ${&dir_path($any_directory)}; or &dir_path('.') for pwd.
# Function  : returns directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pwd_path{  my($pwd)=`pwd`; 	chomp($pwd);
		return(\$pwd);
}


#________________________________________________________________________
# Title     : get_pwd_dir  (same as pwd_dir_base)
# Usage     : $dir = &get_pwd_dir($anydir); # to return say,  'perl' .
# Function  : returns present working dir base
# Example   :
# Warning   : well tested.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_pwd_dir{  my(@pwd)=split(/\//,`pwd`);  my($dir)=$pwd[$#pwd];
	chomp($dir);   return( \$dir  );
}

#________________________________________________________________________
# Title     : dir_name  (same as pwd_dir_base)
# Usage     : $dir = &pwd_dir($anydir); # to return say,  'perl' .
# Function  : returns present working dir base
# Example   :
# Warning   : well tested.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub dir_name{
	my(@pwd)=split(/\//,`pwd`);  my($dir)=$pwd[$#pwd];  # take last one.
	chomp($dir);    return( \$dir  );
}

#________________________________________________________________________
# Title     : pwd_dir_name  (same as  pwd_dir)
# Usage     : $dir = &pwd_dir($any_absolute_path_dir);
# Function  : returns present working dir name
# Example   : returns 'jong' with the input of '/nfs/ind5/A Biomatic '
# Warning   : well tested.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub pwd_dir_name{
	my(@pwd)=split(/\//,`pwd`); my($dir)=$pwd[$#pwd];
	chomp($dir);
	return (\$dir);
}

#________________________________________________________________________
# Title     : get_pwd_dir_name  (same as  pwd_dir)
# Usage     : $dir = &get_pwd_dir($any_absolute_path_dir);
# Function  : returns present working dir name
# Example   :
# Warning   : well tested.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_pwd_dir_name{
		my(@pwd)=split(/\//,`pwd`);
		my($dir)=$pwd[$#pwd];
		chomp($dir);
		return(\$dir);
}

#________________________________________________________________________
# Title     : get_full_path_dir_names  (same as  pwd_dir)
# Usage     : @full_path_dirs = @{&get_full_path_dir_names(@short_dir_name)};
# Function  : returns full path dir names with given short dir names.
# Example   : with 'jong' it gives '/nfs/ind5/jong', '/nfs/ind4/ccep1/people/A Biomatic '...
#             when 'jong' is in /nfs/ind4/jong/Perl, it returns /nfs/ind4/A Biomatic
# Warning   : when 'jong' is in /nfs/ind4/jong/Perl, it returns /nfs/ind4/A Biomatic
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_full_path_dir_names{
		my($i, $each_dir, @out_full_path_dirs);
		my(@in)=@_;
		my($pwd)=`pwd`;
		chomp($pwd);
		my(@ENV_dirs)=@{&get_all_dirs_from_ENV};
		for ($i=0; $i < @in; $i++){
			 if( ref($in[$i]) eq 'SCALAR' ){
					 for $each_dir( @ENV_dirs ){
							 if( $each_dir =~/${$in[$i]}$/){
									 push(@out_full_path_dirs, $each_dir);
							 }elsif( $each_dir =~/${$in[$i]}/ ){
									 push(@out_full_path_dirs, "$`$&");
							 }  ## when 'jong' is in /nfs/ind4/jong/Perl, it returns /nfs/ind4/
					 }
			 }elsif ( ! ref($in[$i]) ){
					 for $each_dir (@ENV_dirs){
							 if( $each_dir =~/$in[$i]$/){
									 push(@out_full_path_dirs, $each_dir);
							 }elsif( $each_dir =~/$in[$i]/ ){
									 push(@out_full_path_dirs, "$`$&");
							 }
					 }
		 }
		 return(\@out_full_path_dirs);
}



#______________________________________________________________
# Title     : get_extension_names
# Usage     : @ext=@{&get_file_extensions(\@file)}  or
#             $ext=${&get_file_extensions(\$file)}
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : get_file_extension, get_extension, get_file_ext, get_ext_names
#             get_file_extensions
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------
sub get_extension_names{
    my($x, @out_file, $ext, $file, @file, @ext);
    if( ref($_[0]) eq 'ARRAY'){
            push(@file, @{$_[0]});
    }elsif(ref($_[0]) eq 'SCALAR'){
            push(@file, ${$_[0]}) if ${$_[0]}=~/\.\S/; ## at least .xxx  format is required
    }elsif(-s $_[0]){
            push(@file, $_[0]);
    }
    for($x=0; $x < @file; $x ++){
         if( ref($file[$x]) eq 'SCALAR' ){
                 $file = ${$file[$x]};
                 $pos = rindex($file, ".");
                 $ext= substr($file, ($pos+1));
         }else{
                 $file = $file[$x];
                 $pos = rindex($file, ".");
                 $ext= substr($file, ($pos+1));
         }
         push(@ext, $ext);
    }
    if(@ext == 1 ){ return(\$ext[0]) }else{ return(\@ext) }
}



#______________________________________________________________
# Title     : get_file_extensions
# Usage     : @ext=@{&get_file_extensions(\@file)}  or
#             $ext=${&get_file_extensions(\$file)}
# Function  :
# Example   :
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : get_file_extension, get_extension, get_file_ext, get_ext_names
#             get_extension_names
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------
sub get_file_extensions{
		my($x, @out_file, $ext, $file, @file, @ext);
		@file=@{$_[0]} || @_;

		for($x=0; $x < @file; $x ++){
				if( ref($file[$x]) eq 'SCALAR' ){
						$file = ${$file[$x]};
						$pos = rindex($file, ".");
						$ext= substr($file, ($pos+1));
				}else{
						$file = $file[$x];
						$pos = rindex($file, ".");
						$ext= substr($file, ($pos+1));
				}
				push(@ext, $ext);
		}
		if(@ext == 1 ){ \$ext[0] }else{ \@ext }
}


#________________________________________________________________________
# Title     : get_base_names
# Usage     : $base =${&get_base_names(\$file_name)};
#             :   or @bases = &get_base_names(\@files);  # <-- uses `pwd` for abs directory
# Function  : produces the file base name(eg, "evalign"  out of "evalign.pl" ).
#              when xxxx.xx.gz form file is given, it removes gz as well
#
# Example   : $base => 'test'  with 'test.txt' or '/home/dir/of/mine/text.txt'
# Warning   :
# Keywords  : get_base_name{, base_name, file_base_name ,  get_file_base_name
#             get_basename, basename, get_root_name, base , root, get_file_root
# Options   :
# Returns   :
# Argument  : handles both ref and non-ref.
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------
sub get_base_names{
    my($x, $pos, $pos1, @out_file, $file_only, $file, @file, $base, @base, $arg);
    for $arg(@_){
       if($arg eq 'ARRAY'){        push(@file, @{$arg});
       }elsif($arg eq 'SCALAR'){    push(@file, ${$arg});
       }else{                       push(@file, $arg);       }
    }
    for($x=0; $x < @file; $x ++){
         if( ref($file[$x]) ){
              $file = ${$file[$x]};
              $pos1=rindex($file, "/");
              $file_only=substr($file, ($pos1+1));
              if($file_only=~/(\S+\.\S+)\.gz$/){
                     $pos = rindex($1, ".");
                     $base= substr($1, 0, $pos);
              }elsif($file_only=~/^[^\.]+$/){ ## when file does not have '.' in its name
                     $base= $file_only;
              }else{
                     $pos = rindex($file_only, ".");
                     $base= substr($file_only, 0, $pos);
              }
         }else{
              $file = $file[$x];
              $pos1=rindex($file, "/");
              $file_only=substr($file, ($pos1+1));
              if($file_only=~/(\S+\.\S+)\.gz$/){
                     $pos = rindex($1, ".");
                     $base= substr($1, 0, $pos);
              }elsif($file_only=~/^[^\.]+$/){ ## when file does not have '.' in its name
                     $base= $file_only;
              }else{
                     $pos = rindex($file_only, ".");
                     $base= substr($file_only, 0, $pos);
              }
         }
         push(@base, $base);
    }
    if(@base == 1 ){ return(\$base[0]) }else{ return(\@base) }
}


#________________________________________________________________________
# Title     : read_file_names_only
# Usage     : @all_files=@{&read_file_names_only(<dir>, [extension])};
# Function  : read any file names and REMOVES the '.', '..' and dir entries.
#             And then put in array.  This checks if anything is a real file.
#             You can use 'txt' as well as '.txt' as extension
#             You can put multiple file extension (txt, doc, ....)
#               and multiple dir path (/usr/Perl, /usr/local/Perl....)
#               It will fetch all files wanted in all the direc specified
#
#             It can handle file glob eg)
#             @all_files=@{&read_file_names_only(\$abs_path_dir_name, 'G1_*.txt')};
#               for all txt files starting with 'G1_'
#
# Example   : @all_files=@{&read_file_names_only(\$abs_path_dir_name, ..)};
#             @all_files=@{&read_file_names_only(\$dir1, '.pl', '.txt')};
#             @all_files=@{&read_file_names_only(\$dir1, '.', \$dir2, \$dir3, 'e=pl')};
#             @all_files=@{&read_file_names_only(\$abs_path_dir_name, 'G1_*.txt')};
#             @all_files=@{&read_file_names_only(\$abs_path_dir_name, \@target_file_names)};
#
# Warning   : This does not report '.', '..'
#             Only file names are reported. Compare with &read_any_dir
#             extension size should be less than 15 char.
#             It sorts the results!
# Keywords  : filename only, filename_only, read_files_only, read files
#             get_file_names_only, get_files_only, read_files_only
# Options   : "extension name". If you put , 'pl' as an option, it will show
#             files only with '.pl' extension.
#  '-p'      for path also included resulting in '/path/path/file.ext'
#              rather than 'file.ext' in output @array
#  '-s'      for sorting the results
#  e='xxx'  for extention xxx
#  '.pl'    for files extended by '.pl'
#  'pl'     for files extended by 'pl', same as above
#  D=       for dir name input
#  d=       for dir name input
#
# Category  :
# Version   : 3.3
#--------------------------------------------------------------------
sub read_file_names_only{
	my($in_dir, $i, $j, $x, $k, $dir, @final_files, @possible_dirs, $sort_opt, $ext, @extensions,
		 $path_include, @in, $glob_given, @files_globed, @in_dir, $pwd, $extension_given,
		 %target_file_names, @target_file_names, @read_files);
	$pwd=`pwd`; chomp($pwd);
	$in_dir=$pwd;
	@in=@_;

	print "\n# read_file_names_only: input are @in" if $verbose;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Directory entry and opts detection
	#_________________________________________
	for($k=0; $k < @in; $k++){
 	    if   ( $in[$k] eq '.'){ push(@in_dir,$pwd); splice(@in, $k, 1);  $k--; next }
		if( !(ref($in[$k]))){
	        print "\n# read_file_names_only: $in[$k] is not a reference";
		if($in[$k]=~/D=(\S+)/i){
				print "\n# read_file_names_only : $1 is used as input dir ";
				push(@in_dir, $1); splice(@in, $k, 1);    $k--; next;  }
		if( -d "$in[$k]" ){
				print "\n# read_file_names_only: $in[$k] is a dir";
				if($in[$k]=~/\/\S+$/){
					$path_include=1;  ## If the input dir has '/', I assume path should be added to out file names
					print "\n# read_file_names_only: \$path_include is set to 1";
			    }
			#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			# Removes the last slash '/' of input dir name
			#________________________________________________
			if($in[$k]=~/\/$/){   chop($in[$k]);  }
			push(@in_dir, $in[$k]);
			splice(@in, $k, 1);    $k--; next;
		}
		if(!(-f $in[$k]) and $in[$k] =~ /^\-p *$/ ){ ## somehow, ' *' is essential
			$path_include=1;
			splice(@in, $k, 1); $k--;
        }elsif(!(-f $in[$k]) and $in[$k] =~ /^\-s *$/   ){$sort_opt=1; splice(@in, $k, 1); $k--;
		}else{
		    print "\n# (W) read_file_names_only: $in[$k] not a file, nor dir, a file extnsion?\n";
		    if(@temp=$in[$k]=~/([^\,]+)/g){
		       for($t=0; $t< @temp; $t++){
                 if (-d $temp[$t]){        push(@in_dir, $temp[$t]);
		         }elsif(!(-f $temp[$t])){  push(@extensions, $temp[$t]);   }
		       }
		    }
	    }
	 }elsif(ref($in[$k])){
		if(ref($in[$k]) eq 'SCALAR'){
			 if( -d ${$in[$k]}){
				 if(${$in[$k]}=~/\/$/){ chop(${$in[$k]}) }
				 push(@in_dir,${$in[$k]});
				 splice(@in, $k, 1);
				 $k--;
		 }elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-p$/ ){$path_include=1; splice(@in, $k, 1); $k--;
		 }elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-s$/ ){$sort_opt=1; splice(@in, $k, 1); $k--;}
		 }elsif(ref($in[$k]) eq 'ARRAY'){
			 @target_file_names=@{$in[$k]}; splice(@in, $k, 1); $k--;
			 for($x=0; $x < @target_file_names; $x++){  # making a hash out of @array
				 $target_file_names{$target_file_names[$x]}=$target_file_names[$x];
		     }
		}
	 }
	}
	if(@in_dir < 1){ push(@in_dir, $pwd) }

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  File name and extension detection
	#_________________________________________
	for $dir (@in_dir){
        print "\n# read_file_names_only: changing to subdir \'$dir\'" if $verbose;
        chdir($dir);
        print "\n# read_file_names_only: trying to detect extension name from \@in: @in\n" if $verbose;

        for($k=0; $k < @in; $k++){
            if( !(ref($in[$k]))){
                 if($in[$k]=~/\*/){
                     $glob_given=1;
                     #~~~~~~~~~~~~~~~~~~~~~  Reads globbed files and attaches path if opt -p is set
                     if($path_include==1){  @final_files=map{ "$dir/$_" } <$in[$k]>;
                     }else{ @final_files=<$in[$k]>;  }
                     splice(@in, $k, 1); $k--;
                 }elsif(!(-f $in[$k]) and $in[$k] =~/e=\.?(\S+)/){
                     $temp=$1;
                     if($temp=~/\,/){ push(@extensions, split(/\,/, $temp));
                     }else{           push(@extensions, $temp); }
                     splice(@in, $k, 1);  $k--;
                     $extension_given =1;
                 }elsif(!(-f $in[$k]) and $in[$k] =~/\.*(\S+)/){
                     $temp=$1;
                     if($temp=~/^e=$/){ next } ## Empty extension entry case.
                     print "\n# read_file_names_only: pushing $1 as an extension" if $verbose;
                     $extension_given =1; push(@extensions, $temp);
                     splice(@in, $k, 1); $k--;
                 }elsif(!(-f $in[$k]) and $in[$k] =~/^([^\-]{0,8})$/){  ## extension name can not be larger than 8 chars
                     print "\n# read_file_names_only: pushing $1 as an extension" if $verbose;
                     $extension_given =1; $temp=$1;
                     die;
                     if( @temp=$temp=~/(\S+),/g){
                        push(@extensions, @temp);
                     }else{
                        push(@extensions, $1);
                     }
                     splice(@in, $k, 1); $k--;
                 }
            }elsif(ref($in[$k])){
                  if(ref($in[$k]) eq 'SCALAR'){

                      if(${$in[$k]}=~/\*/){
                          $glob_given=1;
                          if($path_include==1){  @final_files=map{ "$dir/$_" } <${$in[$k]}>;
                          }else{ @final_files=<${$in[$k]}> }
                          splice(@in, $k, 1); $k--;
                      }elsif(!(-f ${$in[$k]}) and ${$in[$k]} =~/e=(\S+)/ ){ $extension_given = 1;
                          $temp=$1;
                          if($temp=~/\,/){ push(@extensions, split(/\,/, $temp));
                          }else{           push(@extensions, $temp); }
                          splice(@in, $k, 1);  $k--;
                      }elsif(!(-f ${$in[$k]}) and ${$in[$k]} =~/^\.?(\S+)/ ){$extension_given =1;
                                                      push(@extensions, $1);  splice(@in, $k, 1);  $k--;
                      }
                  }
            }
        }
        chdir($pwd);
	}
	if( $glob_given == 1 and  $extension_given !=1 ){  # when glob input is given only(without any extension input!
		 print "\n# read_file_names_only: You used glob for file name, but without extension name\n" if $verbose;
	 return(\@final_files);
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	#  Main READING PART
	#_________________________________________________
	print "\n# read_file_names_only: \@in_dir is  @in_dir\n";
	for($k=0; $k< @in_dir; $k++){
		 chdir($in_dir[$k]) or die "\n# read_file_names_only: could not get into $in_dir[$k]\n";
	 opendir(DIR1, ".");
				 @read_files = readdir(DIR1);
	 print "\n# read_file_names_only: content of \@read_files in $in_dir[$k] : @read_files\n" if $verbose;
	 if(@read_files < 1){ print "\n# read_file_names_only: ERROR??, \@read_files is empty\n\n\n"; }
	 for($i=0; $i < @read_files; $i ++){
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# If the user has specified the target file names
						#____________________________________________________
	    if( @target_file_names > 0){
           if( -f "$read_files[$i]" and -s $target_file_names{$read_files[$i]} ){ ##
                        if($extension_given ==1 ){
                                for $ext (@extensions){
                                           if( $read_files[$i] =~ /\.$ext$/){
                                                    if($path_include==1){
                                                        push(@final_files, "$in_dir[$k]\/$read_files[$i]" );
                                                    }else{
                                                        push(@final_files, "$read_files[$i]" );
                                                    }
                                           }
                                }
                        }else{ ## reading everything !!!
                            push(@final_files, $read_files[$i]);
                        }
               }
           }else{
               if( -f "$read_files[$i]" ){ ##
                    if($extension_given ==1 ){
                               for $ext (@extensions){
                                        if( $read_files[$i] =~ /\.?$ext$/){
                                                   if($path_include==1){
                                                        push(@final_files, "$in_dir[$k]\/$read_files[$i]" );
                                                   }else{
                                                        push(@final_files, "$read_files[$i]" );
                                                   }
                                        }
                               }
                    }else{ ## reading everything !!!
                         push(@final_files, $read_files[$i]);
                    }
               }
           }
	 }
	 chdir($pwd);
   }
   @final_files=sort @final_files if $sort_opt == 1;
   return(\@final_files);
}




#________________________________________________________________________
# Title     : read_dir_and_file_names_only
# Usage     : @all_dir_and_file=@{&read_dir_and_file_names_only(<dir>, [extension])};
# Function  : read any dir/file names and REMOVES the '.', '..' and dir entries.
#             And then put in array.  This checks if anything is a real file.
#             You can use 'txt' as well as '.txt' as extension
#             You can put multiple file extension (txt, doc, ....)
#               and multiple dir path (/usr/Perl, /usr/local/Perl....)
#               It will fetch all files wanted in all the direc specified
#
#             It can handle file glob eg)
#             @all_files=@{&read_file_names_only(\$abs_path_dir_name, 'G1_*.txt')};
#               for all txt files starting with 'G1_'
#
# Example   : @all_files=@{&read_file_names_only(\$abs_path_dir_name, ..)};
#             @all_files=@{&read_file_names_only(\$dir1, '.pl', '.txt')};
#             @all_files=@{&read_file_names_only(\$dir1, '.', \$dir2, \$dir3, 'e=pl')};
#             @all_files=@{&read_file_names_only(\$abs_path_dir_name, 'G1_*.txt')};
#             @all_files=@{&read_file_names_only(\$abs_path_dir_name, \@target_file_names)};
#
# Keywords  : filename only, filename_only, read_files_only, read files
# Options   : "extension name". If you put , 'pl' as an option, it will show
#             files only with '.pl' extension.
#  '-p'      for path also included resulting in '/path/path/file.ext'
#              rather than 'file.ext' in output @array
#  '-s'      for sorting the results
#  e='xxx'  for extention xxx
#  '.pl'    for files extended by '.pl'
#  'pl'     for files extended by 'pl', same as above
#  D=       for dir name input
#
# Version   : 1.0
#--------------------------------------------------------------------
sub read_dir_and_file_names_only{
		my($in_dir, $i, $j, $x, $k, $dir, @final_files, @possible_dirs, $sort_opt, $ext, @extensions,
			 $path_include, @in, $glob_given, @files_globed, @in_dir, $pwd, $extension_given,
			 %target_file_names, @target_file_names, @read_files);
		$pwd=`pwd`; chomp($pwd);
		$in_dir=$pwd;
		@in=@_;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  Directory entry and opts detection
		#_________________________________________
		for($k=0; $k < @in; $k++){
			 if   ( $in[$k] eq '.'){ push(@in_dir,$pwd); splice(@in, $k, 1);  $k--; next }
			 if( !(ref($in[$k]))){
					if($in[$k]=~/D=(\S+)/){
								print "\n# read_dir_and_file_names_only : $1 is used as input dir ";
								push(@in_dir, $1); splice(@in, $k, 1);    $k--; next;  }
					if( -d "$in[$k]" ){
							print "\n# read_dir_and_file_names_only: $in[$k] is a dir";
							if($in[$k]=~/\/\S+$/){
									$path_include=1;  ## If the input dir has '/', I assume path should be added to out file names
									print "\n# read_dir_and_file_names_only: \$path_include is set to 1";
							}
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# Removes the last slash '/' of input dir name
							#________________________________________________
							if($in[$k]=~/\/$/){   chop($in[$k]);  }
							push(@in_dir, $in[$k]);
							splice(@in, $k, 1);    $k--; next;
					}
			    if(!(-f $in[$k]) and $in[$k] =~ /^\-p *$/ ){ ## somehow, ' *' is essential
				     $path_include=1;
				     splice(@in, $k, 1); $k--;
					}elsif(!(-f $in[$k]) and $in[$k] =~ /^\-s *$/   ){
								$sort_opt=1; splice(@in, $k, 1); $k--;
					}else{
								print "\n# (W) read_dir_and_file_names_only: $in[$k] not a file, nor dir, a file extnsion?\n";
					}
			 }elsif(ref($in[$k])){
					 if(ref($in[$k]) eq 'SCALAR'){
							if( -d ${$in[$k]}){
									if(${$in[$k]}=~/\/$/){ chop(${$in[$k]}) }
									push(@in_dir,${$in[$k]});
									splice(@in, $k, 1);
									$k--;
							}elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-p$/ ){$path_include=1; splice(@in, $k, 1); $k--;
							}elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-s$/ ){$sort_opt=1; splice(@in, $k, 1); $k--;}
					 }elsif(ref($in[$k]) eq 'ARRAY'){
							@target_file_names=@{$in[$k]}; splice(@in, $k, 1); $k--;
							for($x=0; $x < @target_file_names; $x++){  # making a hash out of @array
									$target_file_names{$target_file_names[$x]}=$target_file_names[$x];
							}
					 }
			}
	}
	if(@in_dir < 1){ push(@in_dir, $pwd) }
	if($verbose){
		 print "\n# read_dir_and_file_names_only: Final input directories are : @in_dir";
		 print "\n# read_dir_and_file_names_only: going to \'File name and extension detection\' stage with \@in";
	}

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  File name and extension detection
	#_________________________________________
	for $dir (@in_dir){
			chdir($dir);
			for($k=0; $k < @in; $k++){
			if( !(ref($in[$k]))){
						 if($in[$k]=~/\*/){
									 $glob_given=1;
									 #~~~~~~~~~~~~~~~~~~~~~  Reads globbed files and attaches path if opt -p is set
									 if($path_include==1){  @final_files=map{ "$dir/$_" } <$in[$k]>;
									 }else{ @final_files=<$in[$k]>;  }
									 splice(@in, $k, 1); $k--;
							 }elsif(!(-f $in[$k]) and $in[$k] =~/e=\.?(\S+)/){ $extension_given =1; push(@extensions, $1); splice(@in, $k, 1);$k--;
							 }elsif(!(-f $in[$k]) and $in[$k] =~/\.*(\S+)/){
									 print "\n# read_dir_and_file_names_only: pushing $1 as an extension" if $verbose;
									 $extension_given =1; push(@extensions, $1);
									 splice(@in, $k, 1); $k--;
							 }elsif(!(-f $in[$k]) and $in[$k] =~/^([^\-]{0,8})$/){  ## extension name can not be larger than 8 chars
									 print "\n# read_dir_and_file_names_only: pushing $1 as an extension" if $verbose;
									 $extension_given =1; push(@extensions, $1);
									 splice(@in, $k, 1); $k--;
							 }
					 }elsif(ref($in[$k])){
							 if(ref($in[$k]) eq 'SCALAR'){

									 if(${$in[$k]}=~/\*/){
											 $glob_given=1;
											 if($path_include==1){  @final_files=map{ "$dir/$_" } <${$in[$k]}>;
											 }else{ @final_files=<${$in[$k]}> }
											 splice(@in, $k, 1); $k--;
									 }elsif(!(-f ${$in[$k]}) and ${$in[$k]} =~/e=(\S+)/ ){ $extension_given = 1;
											 push(@extensions, $1); splice(@in, $k, 1);  $k--;
									 }elsif(!(-f ${$in[$k]}) and ${$in[$k]} =~/^\.?(\S+)/ ){$extension_given =1;
											 push(@extensions, $1);  splice(@in, $k, 1);  $k--;
									 }
							 }
					 }
			}
	    chdir($pwd);
	}
	if( $glob_given == 1 and  $extension_given !=1 ){  # when glob input is given only(without any extension input!
		 print "\n# read_dir_and_file_names_only: You used glob for file name, but without extension name\n" if $verbose;
	   return(\@final_files);
	}
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	#  Main READING PART
	#_________________________________________________
	print "\n# read_dir_and_file_names_only: \@in_dir is  @in_dir\n";
	for($k=0; $k< @in_dir; $k++){
		 chdir($in_dir[$k]) or die "\n# read_dir_and_file_names_only: could not get into $in_dir[$k]\n";
	   opendir(DIR1, ".");
		 @read_files = readdir(DIR1);
	   print "\n# read_dir_and_file_names_only: content of \@read_files in $in_dir[$k] : @read_files\n" if $verbose;
	   if(@read_files < 1){ print "\n# read_dir_and_file_names_only: ERROR??, \@read_files is empty\n\n\n"; }
	   for($i=0; $i < @read_files; $i ++){
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# If the user has specified the target file names
				#____________________________________________________
	      if( @target_file_names > 0){
						if( -f "$read_files[$i]" and -s $target_file_names{$read_files[$i]} ){ ##
							 if($extension_given ==1 ){
										for $ext (@extensions){
													 if( $read_files[$i] =~ /\.$ext$/){
																if($path_include==1){
																		push(@final_files, "$in_dir[$k]\/$read_files[$i]" );
																}else{
																		push(@final_files, "$read_files[$i]" );
																}
														 }
												}
										}else{ ## reading everything !!!
																		push(@final_files, $read_files[$i]);
										}
						}
				 }else{
							 if( -f "$read_files[$i]" or -d "$read_files[$i]"){ ##
										if($extension_given ==1 ){
												 for $ext (@extensions){
															if( $read_files[$i] =~ /\.?$ext$/){
																	 if($path_include==1){
																				push(@final_files, "$in_dir[$k]\/$read_files[$i]" );
																	 }else{
																				push(@final_files, "$read_files[$i]" );
																	 }
															}
												 }
										}else{ ## reading everything !!!
												 push(@final_files, $read_files[$i]);
										}
							 }
					}
	 }
	 chdir($pwd);
	 }
	 @final_files=sort @final_files if $sort_opt == 1;
	 return(\@final_files);
}


#________________________________________________________________________________
# Title     : read_file_extension_names_only
# Usage     : %file_ext=%{&read_file_extension_names_only('.')};
# Function  : reads only extension names. It returns the ext as keys
#             and occurrances of them as values of the keys.
# Example   :
# Keywords  : read_file_ext_only, read_file_ext_names_only, read_ext_names_only,
#             read_ext_only
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub read_file_extension_names_only{
	my($in_dir, $i,$k, $dir, @final_files, @possible_dirs, $sort_opt, $ext, @extensions,
	  $path_include, @in, $glob_given, @files_globed, @in_dir, $pwd, $extension_given,
	  %ext_count, @read_files);
	$pwd=`pwd`; chomp($pwd);
	$in_dir=$pwd;
	@in=@_;

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Directory entry and opts detection
	#_________________________________________
	for($k=0; $k < @in; $k++){
	 if   ( $in[$k] eq '.'){ push(@in_dir,$pwd); splice(@in, $k, 1);  $k--; next }
	 if( !(ref($in[$k]))){
		if( -d $in[$k]){
			if($in[$k]=~/\/$/){ chop($in[$k]) }
		    push(@in_dir, $in[$k]); splice(@in, $k, 1);    $k--;
		}elsif(!(-f $in[$k]) and $in[$k] =~ /^\-p *$/ ){ ## somehow, ' *' is essential
			$path_include=1; splice(@in, $k, 1); $k--;
		}elsif(!(-f $in[$k]) and $in[$k] =~ /^\-s *$/   ){$sort_opt=1; splice(@in, $k, 1); $k--; }
	 }elsif(ref($in[$k])){
		if( -d ${$in[$k]}){
			if(${$in[$k]}=~/\/$/){ chop(${$in[$k]}) }
		    push(@in_dir,${$in[$k]});  splice(@in, $k, 1);  $k--;
		}elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-p$/ ){$path_include=1; splice(@in, $k, 1); $k--;
		}elsif(!(-f $in[$k]) and ${$in[$k]} =~ /^\-s$/ ){$sort_opt=1; splice(@in, $k, 1); $k--;}
	 }
	}
	if(@in_dir < 1){ push(@in_dir, $pwd) }
	print "\n# read_file_extension_names_only: input directories are : @in_dir \n" if $verbose;
	print   "# read_file_extension_names_only: going to \'File name and extension detection\' stage\n" if $verbose;


		##########  Main READING PART ##########
		for($k=0; $k< @in_dir; $k++){
			 chdir($in_dir[$k]);
			 opendir(DIR1,"$in_dir[$k]");
			 @read_files = readdir(DIR1);
			 for($i=0; $i < @read_files; $i ++){
					if( -f "$read_files[$i]" ){
							if($read_files[$i]=~/\S\.([^\.]+)$/){
									$ext_count{$1}++;
							}
					}
			 }
			 chdir($pwd);
		}
		return(\%ext_count);
}


#________________________________________________________________________
# Title     : read_dir_names_only
# Usage     : @all_dirs_list = @{&read_dir_names_only(\$absolute_path_dir_name, ....)};
# Function  : read any dir names and and then put in array. If no argument
#             for the target directory, it opens PWD automatically
#             You can specify the length of dir names to choose.
# Example   : @files=@{&read_dir_names_only('n', "s=1", '.')};
# Warning   : This does not report '.', '..'
#             Only file names are reported. Compare with &read_any_dir
# Keywords  : read_dir_only, get_dir_names, get_dir_names_only, get_subdir_names,
# Options   : n   for names only reading(not the full path) , default is full path
#             s=  for the size of dirs name. If you want all the dir names
#                   with a size of 1 char, s=1
# Returns   : one ref. of array.
# Argument  : takes one or more scaler references. ('.', \$path, $path, ... )
# Version   : 3.5
#--------------------------------------------------------------------
sub read_dir_names_only{
  my($in_dir, $i,$k, @possible_dirs, @chopped_pwd_path, @args,
	  @final_files, $full_dir, $pwd, $path,@read_files,
      $size_of_dir_name, @dir_list);
  $pwd=`pwd`;
  chomp($pwd);
  $full_dir=1;
  @args=@_;

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Checking option
  #__________________________________________________
  for($k=0; $k < @args; $k++){
     if( ref($args[$k]) eq 'SCALAR'){
         if( $args[$k] eq 'n' or ${$args[$k]} eq 'n'){
            $full_dir=0;
            print "\n# read_dir_names_only: You put \'n\' option \n";
            splice(@args, $k, 1); $k--;
         }elsif( $args[$k] =~/s=(\d+)/ or ${$args[$k]} =~/s=(\d+)/){
             $size_of_dir_name=$1;
             print "\n# read_dir_names_only : You have put the size of dir names : $size_of_dir_name\n";
             splice(@args, $k, 1); $k--;
         }
	 }
  }

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # When no arg, this opens PWD automatically
  #_________________________________________________
  if(@args == 0){
	 if($full_dir==1){
		 push(@dir_list, $pwd);
	 }else{
		 push(@dir_list, '.');
	 }
	 @final_files=@{&open_and_read_dir_names_only(\@dir_list)};
  }elsif(@args > 0){
	 for($k=0; $k < @args; $k++){
		if(!(ref($args[$k]))){    push(@dir_list, $args[$k]);
        }elsif(ref($args[$k]) eq 'SCALAR' and -d ${$args[$k]}){  push(@dir_list, ${$args[$k]} );
        }elsif(ref($args[$k]) eq 'ARRAY'){    @dir_list=@{$args[$k]};        }
     }
     for($i=0; $i< @dir_list; $i++){
           $in_dir=$dir_list[$i];
           if($in_dir ne '..' and $in_dir !~ /\// ){
               push(@final_files, @{&open_and_read_dir_names_only(\$in_dir)} );
           }elsif($in_dir eq '..' and $full_dir==1){
               print "\n# read_dir_names_only: \"..\" is given to open\n";
               @chopped_pwd_path=split(/\//, $pwd);
               pop(@chopped_pwd_path);
               $in_dir=join('/', @chopped_pwd_path);
               push(@final_files, @{&open_and_read_dir_names_only(\$in_dir)} );
           }elsif($in_dir eq '..'){
               $in_dir = '..';
               push(@final_files, @{&open_and_read_dir_names_only(\$in_dir)} );
               for(@final_files){ $_=~s/\.//; }
           }
     }
     ##########  Main READING PART ##########

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # Embedded subroutine
     #_________________________________________________
     sub open_and_read_dir_names_only{
         my ($i, @final_files, $in_dir, @read_files);
         $in_dir=${$_[0]};
         opendir(DIR1,"$in_dir");
         @read_files = readdir(DIR1);
         if($size_of_dir_name){
             for($i=0; $i < @read_files; $i ++){
                 unless(length($read_files[$i]) == $size_of_dir_name){
                     next;
                 }
                 if($full_dir ==1){
                     $read_files[$i]="$in_dir\/$read_files[$i]";
                 }
                 if( ($read_files[$i] !~ /\/\.\.?$/) && ( -d $read_files[$i]) ){
                      $read_files[$i]=~s/[\.\/]*//; ## removing ./ in front of dirs (in bash)
                      push(@final_files, "$read_files[$i]");
                 }
             }
             return([@final_files]);
         }else{
             for($i=0; $i < @read_files; $i ++){
                 if($full_dir ==1){
                     $read_files[$i]="$in_dir\/$read_files[$i]";
                 }
                 if( ($read_files[$i] !~ /\/\.\.?$/) && ( -d $read_files[$i]) ){
                      $read_files[$i]=~s/[\.\/]*//; ## removing ./ in front of dirs (in bash)
                      push(@final_files, "$read_files[$i]");
                 }
             }
             return([@final_files]);
         }
     }

  }
  return([sort @final_files]);
}





#______________________________________________________________
# Title     : take_file_name
# Usage     : $base_portion =${&take_file_name(\'/dir/file.name')};
# Function  : takes file name portion from long dir/filename
# Example   : will return file.name  from /dir/dir/file.name
#
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : get_file_name_only, extract_file_name, take_file_name_only
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------
sub take_file_name {
	my($pos, $base_portion, $file);
	if( ref($_[0]) eq 'SCALAR' ){  $file=${$_[0]};
	}else{	   $file=$_[0];	}
	$pos = rindex($file, "/");
	$base_portion=substr($file, ($pos+1));
	return (\$base_portion);
}



#______________________________________________________________
# Title     : extract_file_name
# Usage     : $base_portion =${&take_file_name(\'/dir/file.name')};
# Function  : takes file name portion from long dir/filename
# Example   : will return file.name  from /dir/dir/file.name
#
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : get_file_name_only, extract_file_name, take_file_name_only
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------
sub extract_file_name {
    my($pos, $file_name, $file);
	if( ref($_[0]) eq 'SCALAR' ){  $file=${$_[0]};
	}else{	   $file=$_[0];	}
	$pos = rindex($file, "/");
    $file_name=substr($file, ($pos+1));
	return (\$file_name);
}


#______________________________________________________________
# Title     : get_file_dir_name
# Usage     :
# Function  : returns the dir portion of long filename.
#             If file does not have dir portion it returns './'
# Example   : /dir/file.name
#             =>  /dir/
# Warning   : You MUST NOT delete '# options : ..' entry
#              as it is read  by various subroutines.
# Keywords  : get_file_dir_name, take_file_dir_name, take_file_dir_names
# Options   : _  for debugging.
#             #  for debugging.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub get_file_dir_names{
	my($x, @out_file, $file_name, $file, @file, @file_name);
	@file=@{$_[0]} if (ref($_[0]) eq 'ARRAY');
	@file=@_ if !(ref($_[0]) eq 'ARRAY');
	for($x=0; $x < @file; $x ++){
		if( ref($file[$x]) ){
			$file = ${$file[$x]};
			$pos = rindex($file, "/");
			$file_name= substr($file, ($pos+1));
		}else{
			$file = $file[$x];
			$pos = rindex($file, "/");
			$file_name= substr($file, ($pos+1));
		}
		push(@file_name, $file_name);
	}
	if(@file_name == 1 ){ \$file_name[0] }else{ \@file_name }
}


#________________________________________________________________________
# Title     : get_dir_names_only
# Usage     : @all_dirs_list = @{&get_dir_names_only(\$absolute_path_dir_name, ....)};
# Function  : read any dir names and and then put in array.
# Example   :
# Warning   : This does not report '.', '..'
#             Only file names are reported. Compare with &read_any_dir
# Keywords  :
# Options   :
# Returns   : one ref. of array.
# Argument  : takes one or more scaler references. ('.', \$path, $path, ... )
# Category  :
# Version   : 3.1
#--------------------------------------------------------------------
sub get_dir_names_only{
	my($in_dir, $i,$k, @possible_dirs,
	  @final_files, $full_dir, $pwd, $path,@read_files);
	$pwd=`pwd`; chomp($pwd); $full_dir=1;
	for($k=0; $k < @_; $k++){
	 if   ( ($_[$k] eq '.') || !(defined($_[$k]))){  $in_dir=$pwd;  }
	 elsif(!(ref($_[$k]))){   $in_dir=$_[$k];   }
	 elsif(ref($_[$k])){      $in_dir =${$_[$k]};    }
	 if($in_dir =~ /^([\w\-\.]+)$/){  $in_dir="$pwd\/$in_dir"; $full_dir = 0; }
	 else{ $full_dir =1; }
	 ##########  Main READING PART ##########
	 opendir(DIR1,"$in_dir");
	 @read_files = readdir(DIR1);
	 for($i=0; $i < @read_files; $i ++){
		$read_files[$i]="$in_dir\/$read_files[$i]";
		if( ($read_files[$i] !~ /\/\.\.?$/) && ( -d $read_files[$i]) ){
		  push(@final_files, "$read_files[$i]");
		}
	 }
	}
				@final_files= sort @final_files;
				return(\@final_files);
}

#________________________________________________________________________
# Title     : get_subdir_names
# Usage     : @all_sub_dirs_list = @{&read_dir_names_only(\$absolute_path_dir_name, ....)};
# Function  : Gets all subdir and subsubsub...dir names in absolute path names.
# Example   : <output example with   "get_subdir_names.pl /A Biomatic /Perl/Bio_Seq" at prompt
#                  It is an array shown in lines.
#
#             /A Biomatic /Perl/Bio_Seq/Evalign
#             /A Biomatic /Perl/Bio_Seq/Seq_hash_handling
#             /A Biomatic /Perl/Bio_Seq/Apple
#             /A Biomatic /Perl/Bio_Seq/Genome
#             /A Biomatic /Perl/Bio_Seq/Open_xxx_files
#             /A Biomatic /Perl/Bio_Seq/Open_xxx_files/Evalign
#
#             tk
#             ch1
#             sub2
#             sub3
#             xxxx.cong
#             whatever_sub_dir
# Warning   : This does not report '.', '..' ,  Also, this does not show full path
#             Only file names are reported. Compare with &read_any_dir
# Keywords  :
# Options   :
# Returns   : one ref. of array. (NOT full path names), refer  'read_full_dir_names'
# Argument  : takes one or more scaler references. ('.', \$path, $path, ... )
# Category  :
# Version   : 3.0
#--------------------------------------------------------------------
sub get_subdir_names{
	my(@in, $in_dir, $in_dir2, $i, $k, $in_dir, $pwd, @sub_dirs,
		@final_dirs, @read_dirs);
	my($pwd)=`pwd`; chomp($pwd);
	for($k=0; $k< @_ ;$k++){
	  if( !ref($_[$k]) ){
		  push(@in, $_[$k]);    }
	  elsif( ref($_[$k]) eq "ARRAY" ){
		  push(@in, @{$_[$k]});    }
	  elsif( ref($_[$k]) eq "SCALAR" ){
		  push(@in, ${$_[$k]});    }
	  elsif(ref($_[$k]) eq "HASH") {
		  push(@in, %{$_[$k]}); }
	}

	for($k=0; $k < @in; $k++){
	  if ( !ref($in[$k]) ){
		  if( $in[$k] eq '.'){ $in_dir = $pwd; }
		  else{  $in_dir =$in[$k]; }
	  }
	  elsif(ref($in[$k])){  $in_dir =${$in[$k]};  }
	  chop($in_dir) if $in_dir =~ /\/$/;
	  @read_dirs = @{&read_dir_names_only(\$in[$k])};
	  @final_dirs= @read_dirs;
	  for($i=0; $i < @read_dirs; $i ++){
		  push(@final_dirs, @{&get_subdir_names(\$read_dirs[$i])});
	  }
	}
				@final_dirs=sort @final_dirs;  \@final_dirs;
}

#________________________________________________________________________
# Title     : read_full_dir_names
# Usage     : @all_files_list = @{&read_full_dir_names(\$absolute_path_dir_name, ....)};
# Function  :
# Example   : input>> &read_full_dir_names('/nfs/ind4/ccpe1/people/A Biomatic /perl');
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/code
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/tk
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/ch1
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/sub2
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/sub3
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/xxxx.cong
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/whatever
# Warning   : This does not report '.', '..'
#             Only file names are reported. Compare with &read_any_dir
# Keywords  :
# Options   :
# Returns   : one ref. of array.
# Argument  : takes one or more scaler references. ('.', \$abs_path, $path, ... )
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_full_dir_names{
	my($in_dir, $i,$k, @possible_dirs, $full_dir, $path,@read_files, @final_files);
	my($pwd)=`pwd`; chomp($pwd);
	for($k=0; $k < @_; $k++){
	 if   ( ($_[$k] eq '.') || !(defined($_[$k]))){  $in_dir=$pwd;  }
	 elsif( !ref($_[$k]) ){   $in_dir=$_[$k];     }
	 elsif(ref($_[$k]))   {   $in_dir =${$_[$k]}; }
	 if($in_dir =~ /\//){  $full_dir =1;}
	 elsif($in_dir =~ /^([\w\-\.]+)$/){ $in_dir="$pwd\/$in_dir";  }
	 ##########  Main READING PART ##########
	 chop($in_dir) if ($in_dir=~/[\/\\]+$/);
	 opendir(DIR1,"$in_dir");
	 @read_files = readdir(DIR1); shift( @read_files);  shift( @read_files);
	 if( $full_dir==1 ){
		for($i=0; $i < @read_files; $i ++){
		  $read_files[$i]="$in_dir\/$read_files[$i]";
		  if( -d "$read_files[$i]"){
			  push(@final_files, $read_files[$i]);
		  }
		}
	 }elsif($full_dir != 1){
		for($i=0; $i < @read_files; $i ++){
		  $read_files[$i]="$pwd\/$read_files[$i]";
		  if( -d "$read_files[$i]"){
			  push(@final_files, $read_files[$i]);
		  }
		}
	 }
	}
				@final_files=sort @final_files;  \@final_files;
}

#________________________________________________________________________
# Title     : get_full_dir_names
# Usage     : @all_files_list = @{&read_full_dir_names(\$absolute_path_dir_name, ....)};
# Function  :
# Example   : input>> &get_full_dir_names('/nfs/ind4/ccpe1/people/A Biomatic /perl');
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/code
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/tk
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/ch1
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/sub2
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/sub3
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/xxxx.cong
#             /tmp_mnt/nfs/ind4/ccpe1/people/A Biomatic /perl/whatever
# Warning   : This does not report '.', '..'
#             Only file names are reported. Compare with &read_any_dir
# Keywords  :
# Options   :
# Returns   : one ref. of array.
# Argument  : takes one or more scaler references. ('.', \$abs_path, $path, ... )
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_full_dir_names{
	my($in_dir, $i,$k, @possible_dirs, $full_dir, $path,@read_files, @final_files);
	my($pwd)=`pwd`; chomp($pwd);
	for($k=0; $k < @_; $k++){
	 if   ( ($_[$k] eq '.') || !(defined($_[$k]))){  $in_dir=$pwd;  }
	 elsif( !ref($_[$k]) ){   $in_dir=$_[$k];     }
	 elsif(ref($_[$k]))   {   $in_dir =${$_[$k]}; }
	 if($in_dir =~ /\//){  $full_dir =1;}
	 elsif($in_dir =~ /^([\w\-\.]+)$/){ $in_dir="$pwd\/$in_dir";  }
	 ##########  Main READING PART ##########
	 chop($in_dir) if ($in_dir=~/[\/\\]+$/);
	 opendir(DIR1,"$in_dir");
	 @read_files = readdir(DIR1); shift( @read_files);  shift( @read_files);
	 if( $full_dir==1 ){
		for($i=0; $i < @read_files; $i ++){
		  $read_files[$i]="$in_dir\/$read_files[$i]";
		  if( -d "$read_files[$i]"){
			  push(@final_files, $read_files[$i]);
		  }
		}
	 }elsif($full_dir != 1){
		for($i=0; $i < @read_files; $i ++){
		  $read_files[$i]="$pwd\/$read_files[$i]";
		  if( -d "$read_files[$i]"){
			  push(@final_files, $read_files[$i]);
		  }
		}
	 }
	}
	sort @final_files;  \@final_files;
}

#________________________________________________________________________
# Title     : read_any_dir_simple
# Usage     : @file_list = @{&read_any_dir(\$absolute_path_dir_name)};
# Function  : read any dir and REMOVES the '.' and '..' entries. And then put in array.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one ref. of array.
# Argument  : takes one scaler reference.
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub read_any_dir_simple {  				# returns the subdir and files names
		my($in_dir);
		$in_dir=${$_[0]} || $_[0];
		opendir(DIR1,"$in_dir");
		my(@read_files) = readdir(DIR1);
		closedir(DIR1);
		splice(@read_files, 0, 2);  # this gets rid of leading . and ..
		return(\@read_files);                                  # to return arrays
}

#____________________________________________________________
# Title     : read_any_dir
# Function  : read any dir and REMOVES the '.' and '..' entries.
#             And then put in array.
# Usage     : @file_list = @{&read_any_dir(\$absolute_path_dir_name)};
# Argument  : takes one scaler reference.
# Returns   : one ref. of array. for the files in the given directory.
# Keywords  :
# Options   :
# Category  :
# Version   : 1.2
# Warning   :
#----------------------------------------------------------
sub read_any_dir{
		my($in_dir, @possible_dirs, @read_files);
		if( ($_[0] eq '.') || !(defined($_[0]))){
					 $in_dir='.';
		}else{  $in_dir=${$_[0]} || $_[0];      }

		if($in_dir =~ /^([\w\-\.]+)$/){
						$in_dir="\.\/$in_dir";
		}elsif($in_dir =~/\/([\w\-\.]+)$/){
						$in_dir="\.\/$1";  # adjust to pwd.
		}
		opendir(DIR1, "$in_dir" );
		@read_files = readdir(DIR1);
		closedir(DIR1); splice( @read_files, 0, 2 );
		return(\@read_files);
}


#________________________________________________________________________
# Title     : read_any_dir2
# Usage     : @file_list = @{&read_any_dir(\$absolute_path_dir_name, ....)};
# Function  : read any dir and REMOVES the '.' and '..' entries. And then put in array.
# Example   :
# Warning   : This does not report '.', '..', '#xxxx', ',xxxx', etc. only legitimate
#             file and dir names are reported.
# Keywords  :
# Options   :
# Returns   : one ref. of array.
# Argument  : takes one or more scaler references.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_any_dir2{   my($in_dir, $i,$k, @possible_dirs, @read_files);
	for($k=0; $k < @_; $k++){
	 if   ( ($_[$k] eq '.') || !(defined($_[$k]))){    $in_dir='.';  }
	 elsif(!(ref($_[$k]))){   $in_dir=$_[$k];     }
	 elsif(ref($_[$k])){      $in_dir =${$_[$k]};    }

	 if($in_dir =~ /^([\w\-\.]+)$/){  $in_dir="\.\/$in_dir";   # if it is a short dir name
		 unless(-d $in_dir){ $in_dir=${&dir_search_special(\$in_dir)} } }
	 elsif($in_dir =~/\/([\w\-\.]+)$/){ $in_dir="\.\/$1";  # adjust to pwd.
		 unless(-d $in_dir){ $in_dir=${&dir_search_special(\$in_dir)}  }}

	 sub dir_search_special{   my($in_dir)=${$_[0]};  my(@ENV_dir, @probable_dir_list, @dirs,@possible_dirs, $final_dir);
		if($in_dir =~ /\/([\w\.\-]+)$/){   $in_dir = $1; }
		@probable_dir_list=('ALIGN', 'PDB', 'PATH', 'HOME', 'JPO', 'PIRDIR', 'PDBSST','PDBENT',
								  'BLASTDB', 'PIRDIR', 'SWDIR');
		for (@probable_dir_list){ @dirs=split(':', $ENV{$_});
		  for (@dirs){ if (/$in_dir$/){ $final_dir = $_; } }
		}
		if(@possible_dirs <1){  # goes up one level and tries to find dir.
		  my($pwd)=`pwd`; chomp($pwd); my(@temp)=split('/', $pwd);
		  pop(@temp);  my($up_pwd)=join('/', @temp);
		  $in_dir="$up_pwd\/$in_dir";  $final_dir=$in_dir if (-d $in_dir);
		}
		\$final_dir
	 }
	 opendir(DIR1,"$in_dir");
	 @read_files = sort readdir(DIR1);
	 for($i=0; $i < @read_files; $i ++){
		if( ($read_files[$i]=~/^[\W]+$/)||($read_files[$i] =~ /\s+/)){
			splice( @read_files, $i, 1 ); $i--  }
		if( ($read_files[$i]=~/\.\.+/)||($read_files[$i] =~ /\#+/)||($read_files[$i]=~/\,+/)){
			splice( @read_files, $i, 1 ); $i-- }
	 }
	 push(@final_files, @read_files);
	}
	\@final_files;
}



#________________________________________________________________________
# Title     : max_str_value_hash   	#$max = &max_str_value_hash(%array1);
# Usage     : $largest_str_length_of_values = &max_value_hash(%any_hash);
# Function  : gets the largest 'string' length in values of any one hash
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub max_str_value_hash{
	my(%hash)=@_; my($len, $s1, $max);
	foreach $s1 (values %hash){
		$len =length($s1);
		$max = $len  if $len > $max;
	}
	return(\$max);
}

#________________________________________________________________________
# Title     : get_max_hash_pair_by_value
# Usage     : $largest_str_length_of_values = &max_value_hash(\%any_hash);
# Function  : gets the largest 'string' length in values of any one hash
# Example   :
# Warning   :
# Keywords  : get_max_hash_pair, get_largest_hash_pair_by_val,
#             get_max_hash_key_value
#             get_max_hash_num_value, max_hash_value
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_max_hash_pair_by_value{
	my(%hash)=%{$_[0]};
	my($max, %max);
	for (keys %hash){
	   if($hash{$_} > $max){
	      %max=($_, $max);
	   }
	}
	return(\%max);
}

#________________________________________________________________________
# Title     : get_max_hash_value
# Usage     : $largest_str_length_of_values = &max_value_hash(\%any_hash);
# Function  : gets the largest 'string' length in values of any one hash
# Example   :
# Warning   :
# Keywords  : get_max_hash_value, get_largest_hash_value, get_max_hash_key_value
#             get_max_hash_num_value, max_hash_value
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_max_hash_value{
	my(%hash)=%{$_[0]};
	my($max, %max);
	for (keys %hash){
		 if($hash{$_} > $max){
	      $max=$hash{$_};
	   }
	}
	return(\$max);
}



#________________________________________________________________________
# Title     : max_str_key_hash   	#$max = &max_str_value_hash(%array1);
# Usage     : $largest_str_length_of_values = &max_value_hash(%any_hash);
# Function  : gets the largest 'string' length in keys of any one hash
# Example   :
# Warning   :
# Keywords  : largest key length,
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub max_str_key_hash{
	my(%hash)=%{$_[0]};
	my($len,$max);
	#&hash_chk(\%hash);		# checks if %hash is valid.
	foreach $s1 (keys %hash){
		$len = length($s1);
		$max = $len  if $len > $max;
	}
	return($max);
}

#________________________________________________________________________
# Title     : min_string_value_hash  #$max = &min_str_value_hash(%array1);
# Usage     : $small_str_length_of_values = &min_str_value_hash(%any_hash);
# Function  : gets the smallest 'string' length in values of any one hash
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub min_str_value_hash{
	my(%hash)=%{$_[0]};
	&hash_chk(\%hash);		# checks if %hash is valid.
	my($len)=0;
	my(@keys) = keys %hash;
	my($min) = length($hash{$keys[0]});
	for ($s1=1; $s1 <= $#keys; $s1++){
		$len =length($hash{$keys[$s1]});
		$min = $len  if ($len < $min);
	}
	return($min);
}
#________________________________________________________________________
# Title     : min_str_key_hash  #$max = &min_str_value_hash(%array1);
# Usage     : $small_str_length_of_values = &min_str_value_hash(%any_hash);
# Function  : gets the smallest 'string' length in values of any one hash
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub min_str_key_hash{
	my(%hash)=%{$_[0]};
	#&hash_chk(\%hash);		# checks if %hash is valid.
	my($len)=0;
	my(@keys) = keys %hash;
	my($min) = length($keys[0]);
	for ($s1=1; $s1 < @keys; $s1++){
		$len =length($keys[$s1]);
		$min = $len  if ($len < $min);
	}
	return($min);
}
#________________________________________________________________________
# Title     : fasta_append
# Usage     : &fasta_append($name, $string, $output_file);
# Function  : append addtional one fasta format sequence.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fasta_append{
	 my($name, $string, $output_file)=@_;	# $name is the name of seq.
	 open (FASTA_APPEND,">>$output_file");	# $string is the seq string.
	 my($ll)=0;								# $output_file is the name of output.
	 print FASTA_APPEND ">$name\n";			# this appends seq. in one file.
	 $ls2=length($string );
	 for($i=0; $i<$ls2; $i++){
		  $char=substr($string ,$i,1);
		  if(($char ne ' ') && ($char ne '.')){
			  print FASTA_APPEND $char;
			  $ll++;
			  if($ll == 60){
				  $ll=0;
				  print FASTA_APPEND "\n";
			  }
		  }
	 }
	 print FASTA_APPEND "\n";
}

#________________________________________________________________________
# Title     : fasta_output
# Usage     : &fasta_output($dir.$mul_factor.fasta,  $whole_seq, *array_ali, *array1);
# Function  : prints fasta format output which is using $mul_factor
#             $seq is the whole sequence number(largest).
#             $dir.$mul_factor.fasta can be any output name,
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fasta_output{
		  local($dir.$mul_factor.fasta, $seq_number, *array_ali, *array1)=@_;
		  my($output_file) = "$dir.$mul_factor.fasta";
		  my(@keys1)= keys (%array_ali);
		  my(@keys2)= keys (%array1);
		  unlink <"$output_file">;	# removing previous file to prevent appending.
		  foreach $name(keys %array_ali){
					 $dir  = &pwd_dir;
					 $string=$array_ali{$name};
					 print "\n\nchecking fasta write $name, $string\n\n"; &beep;
					 &fasta_append($name, $string, $output_file);
		  }
		  foreach $key1(@keys1){
					 $counter=0;
					 foreach $key2(@keys2){
								if ($key1 eq $key2){
										  splice(@keys2, $counter,1);
								}
								$counter+=1;
					 }
		  }
		  if ( $seq_number => ($#keys2+1) ){
					 $seq_number = $#keys2;
		  }
		  for ($x=0; $x <= $seq_number ;$x++){
					 $name2=$keys2[$x];
					 $string2=$array1{$name2};
					 print "\n seq number is = $seq_number \n";
					 print "\n\nchecking fasta write $name2, $string2\n\n"; &beep;
					 $dir  = &pwd_dir;
					 &fasta_append($name2, $string2, $output_file);
		  }
}
#________________________________________________________________________
# Title     : fasta_out_seq_no
# Usage     : &fasta_out_seq_no($dir, $out_seq_no, $seq, *array2, *array1);
# Function  : prints fasta format output with specified seq no from whole seq. no.
#             $seq is the whole sequence number(largest). $out_seq_no is the target
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub fasta_out_seq_no{
	my($dir, $out_seq_no, $seq_number);
	($dir, $out_seq_no, $seq_number, *array1, *array2)=@_;
	&hash_chk(\%array1);&hash_chk(\%array2);
	%array2    = &hash_substract(*array2, *array1);
	%array_1_2 = &hash_catenate (*array1, *array2);
	&hash_chk(\%array_1_2);
	my($output_file) = "$dir\_$out_seq_no.fasta"; 	# " is essential.
	my(@keys1)= keys (%array1);
	my(@keys2)= keys (%array2);
	my(@keys_1_2) = keys (%array_1_2);
	unlink <"$output_file">;						# this is essential as I use &fasta_append
	if (($#keys1+1) > $out_seq_no){					# if out_seq_no is less than structural
	  for ($no = 0; $no < $out_seq_no; $no++){	# appending first seq. set.
		  my($name1) = $keys1[$no];				# array1 first
		  $dir  = &pwd_dir;
		  my($string1) = $array1{$name1};
		  &fasta_append($name1, $string1, $output_file);
	  }
	}else{
	  for ($no1 = 0; $no1  <= $#keys1; $no1++){	# appending first seq. set.
		  my($name1) = $keys1[$no1];				# array1 first
		  $dir  = &pwd_dir;
		  my($string1) = $array1{$name1};
		  &fasta_append($name1, $string1, $output_file);
	  }
	  for ($no2 = 0; $no2  < ($out_seq_no-$#keys1-1); $no2++){	# appending first seq. set.
		  my($name2) = $keys2[$no2];			# array1 first
		  $dir  = &pwd_dir;
		  my($string2) = $array2{$name2};
		  &fasta_append($name2, $string2, $output_file);
	  }
	}
}
#________________________________________________________________________
# Title     : ctime
# Usage     : $Date = &ctime(time);
# Function  : a simple Perl emulation for the well known ctime(3C) function.
# Example   : $Date = &ctime(time);
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub ctime{
	 @DoW = ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
	 @MoY = ('Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec');

	 local($time) = @_;
	 local($[) = 0;
	 my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);

	 # Determine what time zone is in effect.
	 # Use GMT if TZ is defined as null, local time if TZ undefined.
	 # There's no portable way to find the system default timezone.

	 $TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : '';
	 ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
		  ($TZ eq 'GMT') ? gmtime($time) : localtime($time);

	 # Hack to deal with 'PST8PDT' format of TZ
	 # Note that this can't deal with all the esoteric forms, but it
	 # does recognize the most common: [:]STDoff[DST[off][,rule]]

	 if($TZ=~/^([^:\d+\-,]{3,})([+-]?\d{1,2}(:\d{1,2}){0,2})([^\d+\-,]{3,})?/){
		  $TZ = $isdst ? $4 : $1;
	 }
	 $TZ .= ' ' unless $TZ eq '';

	 $year += 1900;
	 sprintf("%s %s %2d %2d:%02d:%02d %s%4d\n",
		$DoW[$wday], $MoY[$mon], $mday, $hour, $min, $sec, $TZ, $year);
}
#________________________________________________________________________
# Title     : get_time
# Usage     : $Date = &get_time(time);
# Function  : a simple Perl emulation for the well known ctime(3C) function.
# Example   : "Nov30 4:37 1995"
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_time{
	 @DoW = ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
	 @MoY = ('Jan','Feb','Mar','Apr','May','Jun',
				'Jul','Aug','Sep','Oct','Nov','Dec');

	 my($time) = @_;
	 local($[) = 0;
	 local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst,$final_time);

	 # Determine what time zone is in effect.
	 # Use GMT if TZ is defined as null, local time if TZ undefined.
	 # There's no portable way to find the system default timezone.

	 $TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : '';
	 ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
		  ($TZ eq 'GMT') ? gmtime($time) : localtime($time);

	 # Hack to deal with 'PST8PDT' format of TZ
	 # Note that this can't deal with all the esoteric forms, but it
	 # does recognize the most common: [:]STDoff[DST[off][,rule]]

	 if($TZ=~/^([^:\d+\-,]{3,})([+-]?\d{1,2}(:\d{1,2}){0,2})([^\d+\-,]{3,})?/){
		  $TZ = $isdst ? $4 : $1;
	 }
	 $TZ .= ' ' unless $TZ eq '';

	 $year += 1900;
	 ############### This is the original format ##################
	 #$final_time=sprintf("%s %s% 2d %2d:%02d:%02d %s %4d\n",
	 #            $DoW[$wday], $MoY[$mon], $mday, $hour, $min, $sec, $TZ, $year);

	 $final_time=sprintf("%s%2d% 2d:%02d %4d\n",
					  $MoY[$mon], $mday, $hour, $min, $year);
	 return(\$final_time);
}


#________________________________________________________________________
# Title     : get_date_text
# Usage     : @outformat = @{&get_date};  eg result >  (010595 1-May-1995)
# Function  : returns date: $date6d (6 digit format) and
#             $datec (dd-mmm-yyyy format), Tim's version is 'getdate' in th_lib.pl
# Example   : 30-Nov-1995
# Keywords  : get_present_date,
# Options   :
# Returns   : ref of an array for (1-May-1995 and 010595)
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_date_text{
    my($date_alphabet, $date6d, @time, $ty,$tm,$td, $year, $mon, $day);
    @time = localtime(time);
    ($ty,$tm,$td) = ($time[5],$time[4],$time[3]);
    $year = (1900 + $ty); # '20' . $ty;
    $mon = (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)[$tm];
    $day = $td;
    if($day < 10){
        $day = '0' . $day;
    }
    $date_alphabet = $day.'_'.$mon.'_'.$year;
    $tm++;
    if($tm < 10){
        $tm = '0'.$tm;
    }
    if($td < 10){
        $td = '0'.$td;
    }
    $date6d = $td.$tm.$year;
    return (\$date_alphabet);
}


#________________________________________________________________________
# Title     : get_date
# Usage     : @outformat = @{&get_date};  eg result >  (010595 1-May-1995)
# Function  : returns date: $date6d (6 digit format) and
#             $datec (dd-mmm-yyyy format), Tim's version is 'getdate' in th_lib.pl
# Example   : 30-Nov-1995
# Keywords  : get_present_date,
# Options   :
# Returns   : ref of an array for (1-May-1995 and 010595)
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_date{
    my($date_alphabet, $date6d, @time, $ty,$tm,$td, $year, $mon, $day);
    @time = localtime(time);
    ($ty,$tm,$td) = ($time[5],$time[4],$time[3]);
    $year = (1900 + $ty); # '20' . $ty;
    $mon = (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)[$tm];
    $day = $td;
    if($day < 10){
        $day = ' ' . $day;
    }
    $date_alphabet = $day.'_'.$mon.'_'.$year;
    $tm++;
    if($tm < 10){
        $tm = '0'.$tm;
    }
    if($td < 10){
        $td = '0'.$td;
    }
    $date6d = $td.$tm.$year;
    return ([$date_alphabet, $date6d]);
}

#________________________________________________________________________
# Title     : get_date_numeric
# Usage     : @outformat = @{&get_date};  eg result >  (010595 1-May-1995)
# Function  : returns date: $date6d (6 digit format) and
#             $datec (dd-mmm-yyyy format), Tim's version is 'getdate' in th_lib.pl
# Example   : 30-Nov-1995
# Keywords  : get_present_date,
# Options   :
# Returns   : ref of an array for (1-May-1995 and 010595)
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_date_numeric{
    my($date_alphabet, $date6d, @time, $ty,$tm,$td, $year, $mon, $day);
    @time = localtime(time);
    ($ty,$tm,$td) = ($time[5],$time[4],$time[3]);
    $year = (1900 + $ty); # '20' . $ty;
    $mon = (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)[$tm];
    $day = $td;
    if($day < 10){
        $day = ' ' . $day;
    }
    $date_alphabet = $day.'_'.$mon.'_'.$year;
    $tm++;
    if($tm < 10){
        $tm = '0'.$tm;
    }
    if($td < 10){
        $td = '0'.$td;
    }
    $date6d = $td.$tm.$year;
    return (\$date6d);
}



#__________________________________________________________________________
# Title     : if_file_older_than_x_days
# Usage     : if( ${&if_file_older_than_x_days($ARGV[0], $days)} > 0){
# Function  : checks the date of last modi of file given and compares with
#             present time. Substracts diff and returns the actual diff days.
# Example   :
# Keywords  : how_old_file, how_old, is_file_older_than_x_days, file_age,
#             file_age_in_days, check_file_age, check_date
# Options   :
# Returns   : the actual days older, so NON-ZERO, otherwise, 0
# Argument  :
# Version   : 1.4
#----------------------------------------------------------------------------
sub if_file_older_than_x_days{
		my($how_old_days, @stat, $time_diff_in_seconds);
		my $days=1; # default
		if(@_ < 2){ print "\n# if_file_older_than_x_days needs 2 args\n"; die; }
		my $file=${$_[0]} || $_[0];
		$days=${$_[1]} || $_[1];
		unless(-s $file){  print "\n# if_file_older_than_x_days: $file does NOT exist\n"; die; }

		print "\n# (i) if_file_older_than_x_days: running stat\n";

		@stat= stat($file);
		$time_diff_in_seconds = time - (stat $file)[10]; ## inode creation time is got.

		$how_old_days=int($time_diff_in_seconds/86400);

		if($how_old_days > $days and $how_old_days < 10000){
			 print "\n# if_file_older_than_x_days: $file is older($how_old_days)  than $days\n";
			 return(\$days);
		}else{
			 print "\n# if_file_older_than_x_days: $file is NOT older than $days\n";
			 return(0);
		}
}



#________________________________________________________________________
# Title     : array_chk
# Usage     : &array_chk(\@any_array_to_chk);
# Function  : checks if any inputting array is empty or with one element.
# Example   : This is used only with subs which accepts array inputs.
# Warning   :
# Keywords  : array_check
# Options   :
# Returns   : nothing, prints out messages to STDOUT
# Argument  : gets on ref. of array.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub array_chk{  my(@input)=@{$_[0]};
	if (@input == 0){
	 &caller_info;
	 print "\n >>> $0 \n";
	 print "\n >>> Error: Input array to this subroutine was empty\n", chr(7);
	 print "\n To continue prog. type \'y\', or \'n\' to quit (with enter).\n ---->";
	 $key = ${&yes_or_no};
	 if($key ne 'y'){  print "\n !! Aborting the operation !! \n"; die(0); }}
	elsif ($#input == 0){
	 print "\n >>> Warn: Input array to this subroutine was only one, O.K ?\n";
	 print "\n >>> It means your input was not an array at all, probable	error\n";
	 &caller_info;
	 #________________________________________________________
	 # Title    : caller_info
	 # Function : tells you calleing programs and sub's information with file, subname, main, etc
	 # Usage    : &caller_info; (just embed anywhere you want to check.
	 #----------------------------------------------------------------------
	 sub caller_info{	    # caller(1), the num. tells you which info you choose
		my($i)=1;
		while(($pack, $file, $line, $subname, $args) = caller($i++)){
		  my($level) = $i-1;
		  print "\n", chr(169)," This sub info was made by \&caller_info subroutine";
		  print "\n ", chr(164)," Package  from => $pack ";
		  print "\n ", chr(164)," Exe. file was => $file ";
		  print "\n ", chr(164)," Line was  at? => $line (in $file)";
		  print "\n ", chr(164)," Name of  sub? => $subname";
		  print "\n ", chr(164)," How many arg? => $args";
		  print "\n ", chr(164)," Level of sub? => $level (1 is for where \&caller_info is )\n\n";
		}
	 }
	 #________________________________________________________
	 #________________________________________________________
	 # Title    : yes_or_no
	 # returns  : ref. of a Scalar for 'y' or 'n'
	 # Usage    : $yes_or_no = ${&yes_or_no};
	 #---------------------------------------------------------
	 sub yes_or_no{
		my($key)=getc;
		if (($key eq 'y') || ($key eq 'Y')){
		  return(\$key);
		}elsif(($key eq 'n') || ($key eq 'N')){
		  return(\$key);
		}else{
		  print chr(7), "\n Type only (y or n) ----> ";
		  &yes_or_no;
		}
	 }
	 #________________________________________________________
	}
}

#________________________________________________________________________
# Title     : hash_chk
# Usage     : &hash_chk(\%input_hash);
# Function  : checks hash input of any subroutine.
# Example   :
# Warning   :
# Keywords  : hash_check
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_chk{ my(@input)=%{$_[0]};
	if ( @input == 0){
	  &caller_info;
	  print "\n >>> $0 \n", chr(7);
	  print "\n >>> Error: Input hash to this subroutine was empty\n";
	  print "\n To continue prog. type \'y\', or \'n\' to quit (with enter).\n ----> ";
	  $key = ${&yes_or_no};
	  if($key ne 'y'){
		 die(0);
	  }
	}elsif ( @input == 1){
	  &caller_info;
	  print "\n >>> $0 \n", chr(7);
	  print "\n >>> Warn: Input hash to this subroutine was only one, O.K ?\n";
	  print "\n To continue prog. type \'y\', or \'n\' to quit (with enter).\n ----> ";
	  $key = &{&yes_or_no};
	  if($key ne 'y'){
		  die(0);
	  }
	}
}
#________________________________________________________________________
# Title     : hash_output_chk
# Usage     : &hash_output_chk(\%outing_hash);
# Function  : checks hash output of any subroutine.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_output_chk{
	for($i=0; $i<= $#_; $i++){
	 my(%tem)=%{$_[$i]};  my(@keys)=keys %tem;
	 for ($j =0; $j<@keys; $j++){
		unless(($keys[$j]=~/[\s\S]+/)&&($tem{$keys[$j]}=~/[\s\S]+/)){
		  print "\n Err. at Hash_output_chk at $0 \n", chr(7); die;
		}
	 }
	}
}

#________________________________________________________________________
# Title     : n
# Usage     : &n;
# Function  : puts one single new line
# Example   :
# Warning   :
# Keywords  : put_new_line, new_line
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub n{
		print "\n";
}


#________________________________________________________________________
# Title     : cls
# Usage     : &cls;
# Function  : clears screen
# Example   :
# Warning   :
# Keywords  : clear_screen
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub cls{   my($cls) = `clear`;
		print $cls;
}


#________________________________________________________________________
# Title     : seq_comp_percent1
# Usage     : @outarray = &seq_comp_percent1(@any_input_string_array);
# Function  : get string seq identities(a to z). gets array of strings and outs array of % numbers
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one ref. of an array
# Argument  : one ref. of an array
# Category  :
# Version   :
#--------------------------------------------------------------------
sub seq_comp_percent1{ 		# this is affected by seq. length
		  my(@input)=@{$_[0]};
		  my(@array_of_ids1, $id1, @char1, @char2);
		  &array_chk(\@input);
		  @input = sort (@input);
		  $longest_str_size  = &get_long_str_size (@input), "\n";
		  $shortest_str_size = &get_short_str_size(@input), "\n";
		  if (($longest_str_size/$shortest_str_size) > 4){
					 print "\n The shortest string is less than 1/4 of the longest\n";
					 print " This is quite meaningless, but will go on\n";
		  }
		  for ($i = 0; $i <= $#input ; $i++){
					 if ($input[$i]=~/(\W)/){
								print "\n Warn: seq($input[$i] contains non char\n";
								&remove_non_char($input[$i]);
					 }
					 @char1 = split(/|\s+|\.+|\-+/, $input[$i]);  # splitting into char.
					 foreach $char (@char1){
								$charcount1{$char} +=1; # making array of ['A' => 6, 'B'=>2...]
					 }
					 for($j = $i+1 ; $j <= $#input; $j++){
								if ($input[$j]=~/(\W)/){
										  print "\n Warn: seq($input[$i] contains non char\n";
										  &remove_non_char($input[$j]);
								}
								@char2 = split(/|\s+|\.+|\-+/, $input[$j]);  # splitting into
								foreach $char (@char2){
										  $charcount2{$char} +=1; # making array of ['A' => 6, 'B'=>2...]
								}
								$id1 = &get_id_among_2_1(*charcount1, *charcount2); # gets % id.
								# print %charcount1,"\n";
								push (@array_of_ids1, $id1);
								%charcount2=();
					 }
					 %charcount1=();
		  }
		  \@array_of_ids1;
}


#________________________________________________________________________
# Title     : get_id_among_2_1
# Usage     : $id = &get_id_among_2(*charcount1, *charcount2) <- hashes
# Function  : gets the % id of any two sequences, returns in  100.0% format.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub get_id_among_2_1{ 	# 66.67 % if ABC with ABCABC  (due to diff. seq. length.)
	 local(*hash1, *hash2)= @_;
	 my($identity, $no_of_same, $sum_of_same, $av);
	 my(@num_char1)=values %hash1;
	 my(@num_char2)=values %hash2;
	 for $key1 (sort keys %hash1){
					 for $key2 (sort keys %hash2){
								if ($key1 eq $key2){
										  $no_of_same = &min($hash1{$key1},$hash2{$key2});
										  $sum_of_same += $no_of_same;
										  last;
								}
					 }
	 }
	 $identity = $sum_of_same*2/(&sum_array(@num_char1,@num_char2))*100;
	 # print "percent iden = ", $identity, "\n";
}
#________________________________________________________________________
# Title     : get_id_among_2_2
# Usage     : $id = &get_id_among_2(*charcount1, *charcount2) <- hashes
# Function  : gets the % id of any two sequences, returns in  100.0% format.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_id_among_2_2{       #  eg) 50% if ABC with AABBCC or ABCABC
	 local(*hash1, *hash2)= @_;
	 my($identity, $no_of_same, $sum_of_same, $av);
	 #print %hash1,"\n";
	 #print %hash2,"\n";
	 my(@num_char1)=values %hash1;
	 my(@num_char2)=values %hash2;
	 for $key1 (sort keys %hash1){
			for $key2 (sort keys %hash2){
				if ($key1 eq $key2){
					 $no_of_same = &min($hash1{$key1},$hash2{$key2});
					 $sum_of_same += $no_of_same;
					 last;
				}
			}
	 }
	 $seq1=&sum_array(@num_char1);
	 $seq2=&sum_array(@num_char2);
	 $longer_seq = &max($seq1, $seq2);
	 $identity = $sum_of_same/$longer_seq*100;
	 #print "percent iden = ", $identity, "\n";
}

#________________________________________________________________________
# Title     : array_average
# Usage     : $output = &array_average(\@any_array);
# Function  : (the same as average_array)
# Example   :
# Warning   : If divided by 0, it will automatically replace it with 1
# Keywords  : get_array_average, av_array, average_array, get_average_array
#             average_of_array, average_array, get_average_array,
#             get_average_of_array
# Options   :
# Returns   : single scaler digit.
# Argument  : takes one array reference.
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub array_average{
		my(@input)= @{$_[0]};
		my $int_option = ${$_[1]} || $_[1];
		my($item,$average,$num,$sum);
		my $num_of_elem = @input;

		for $item(@input){
			 if( $item =~ /^$/ ){  ## If it matches nothing. '$item == 0' does not work !!!
				$num_of_elem --; ## This is to make sure that the denominator does not
			 }                  ## count blank element. (to get correct element number)
			 else{ $sum += $item;  }
		}
		if($num_of_elem ==0){ $num_of_elem =1; }  ## To prevent 'Division by 0' error
		if($int_option =~ /[\-]*i[nt]*/){
			$average= int( $sum/$num_of_elem );
		}else{   $average = $sum/$num_of_elem }

		return(\$average);
}

#________________________________________________________________________
# Title     : average_array
# Usage     : $output = &average_array(\@any_array);
# Function  : (the same as array_average)
# Example   :
# Warning   : If divided by 0, it will automatically replace it with 1
# Keywords  :
# Options   :
# Returns   : single scaler digit.
# Argument  : takes one array reference.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub average_array{
	my(@input)= @{$_[0]};
	my $int_option = ${$_[1]} if ref($_[1]);
	my $int_option =  $_[1]  if !ref($_[1]);
	my($item,$average,$num,$sum);
	my $num_of_elem = @input;

	for $item(@input){
	 if( $item =~ /^$/ ){  ## If it matches nothing. '$item == 0' does not work !!!
		$num_of_elem --; ## This is to make sure that the denominator does not
	 }                  ## count blank element. (to get correct element number)
	 else{ $sum += $item;  }
	}
	if($num_of_elem ==0){ $num_of_elem =1; }  ## To prevent 'Division by 0' error
	if($int_option =~ /[\-]*i[nt]*/){
	  $average= int( $sum/$num_of_elem );
	}else{   $average = $sum/$num_of_elem }

	return(\$average);
}

#________________________________________________________________________
# Title     : average_of_array (the same as array_average)
# Usage     : $output = &average_of_array(\@any_array);
# Function  :
# Example   :
# Warning   : If divided by 0, it will automatically replace it with 1
#             '$item == 0' does not work !!! in the following
# Keywords  :
# Options   : -int to make the resultant numbers shown in integer
# Returns   : single scaler digit.
# Argument  : takes one array reference.
# Category  :
# Version   : 2.0
#--------------------------------------------------------------------
sub average_of_array{
	my(@input)= @{$_[0]};
	my $int_option = ${$_[1]} if ref($_[1]);
	my $int_option =  $_[1]  if !ref($_[1]);
	my($item,$average,$num,$sum);
	my $num_of_elem = @input;

	for $item(@input){
	 if( $item =~ /^$/ ){  ## If it matches nothing. '$item == 0' does not work !!!
		$num_of_elem --; ## This is to make sure that the denominator does not
	 }                  ## count blank element. (to get correct element number)
	 else{ $sum += $item;  }
	}
	if($num_of_elem ==0){ $num_of_elem =1; }  ## To prevent 'Division by 0' error
	if($int_option =~ /[\-]*i[nt]*/){
	  $average= int( $sum/$num_of_elem );
	}else{   $average = $sum/$num_of_elem }

	\$average;
}
#________________________________________________________________________
# Title     : hash_average
# Usage     : %out=%{&hash_average(\%in)};  or
#             ($out1, $out2)=&hash_average(\%in,\%in2);
# Function  :
# Example   : %in=(1, "13242442", 2, "92479270", 3, "2472937439");
# Warning   :
# Keywords  :
# Options   :
# Returns   : %out =(1, 2.13242, 2, 5.2702, 3, 1.72937439); <-- somethins like
#             numbers. So, undefined array element is not counted
#             This is more correct.
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_average{
	my(@out_av_hash, $v, $sum, $num_of_elem);
	for($v=0; $v< @_; $v++){
	  my(%input)=%{$_[$v]};
	  for(keys(%input)){
		 if($input{$_} =~ /\,/){ $split_char=',' }
		 else{ $split_char='' }
		 my(@num_arr)=split(/$split_char/, $input{$_});
		 $num_of_elem = @num_arr;
		 for $elem(@num_arr){
			 if( $elem == '' ){
				$num_of_elem -- ; ## This is to make sure that the denominator does not
			 }                   ## count blank element. (to get correct element number)
			 else{ $sum += $elem;  }
		 }
		 my($av)=$sum/$num_of_elem;
		 $out_hash{$_}=$av;
		 $sum=0;
	  }
	  push(@out_av_hash, \%out_hash);
	}
	if( @out_av_hash==1 ){  return($out_av_hash[0]); }
	elsif( @out_av_hash > 1){  return(@out_av_hash);  }
}

#________________________________________________________________________
# Title     : get_hash_value_average
# Usage     : %out=%{&get_hash_value_average(\%in)};  or
#             ($out1, $out2)=&hash_average(\%in,\%in2);
# Function  :
# Example   :
# Warning   :
# Keywords  : get_values_average, get_average_hash_value, get_average_value
# Options   :
# Returns   : %out =(1, 2.13242, 2, 5.2702, 3, 1.72937439); <-- somethins like
#             numbers. So, undefined array element is not counted
#             This is more correct.
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_hash_value_average{
	my(@out_av_hash, $i, $v, $sum, $num_of_elem);
	for($v=0; $v< @_; $v++){
	  my (@keys, $sum, $av);
	  my(%input)=%{$_[$v]};
	  @keys=keys %input;
	  for($i=0; $i< @keys; $i++){
		 $sum+=$input{$keys[$i]};
	  }
	  $av=$sum/@keys;
	  push(@out_av_hash, $av );
	}
	if( @out_av_hash==1 ){  return(\$out_av_hash[0]); }
	elsif( @out_av_hash > 1){  return(\@out_av_hash);  }
}



#________________________________________________________________________
# Title     : hash_stat_for_all
# Usage     : %out=%{&hash_average(\%in, \%in2,..)};
# Function  : gets the min, max, av, sum for the whole values of ALL the
#             hashes put in. (grand statistics)
# Example   : %in =(1, "13242442", 2, "92479270", 3, "2472937439");
#             %in2=(1, "28472", 2, "23423240", 3, "123412342423439");
#
#             %in =(name1, "1,3,2,4,2,4,4,2", name2, "9,2,4,7,9,2,7,0");
#
# Warning   :
# Keywords  :
# Options   :
# Returns   : normal array of ($min, $max, $sum, $av)
#             Example  out:>                 |  min max sum  av
#                            -----------------------------------
#                            of the whole    |   0   9  110   6
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_stat_for_all{
	package hash_stat_for_all;
	my($elem,@out_av_hash, @out_array,$v,@num_arr,$sum,$min, $av,$num_all, $max,$split_char);
	for($v=0; $v<@_; $v++){
	  my(%input)=%{$_[$v]};
	  for $name(keys(%input)){
		 if($input{$name} =~ /\,/){ $split_char=',';
		 }else{
		    $split_char='';
		 }
		 @num_arr=split(/$split_char/, $input{$name});
		 for $elem(@num_arr){
			if($elem =~/[\-]*\d+/){
			    $min=$elem unless(defined($min));
				$min =$elem if $elem < $min; $max =$elem if $elem > $max;
				$sum+=$elem; $num_all++;
			}
		 }
	  }
	}
	if($num_all == 0){ $av=0; $sum=0; $min=0; $max=0; }
	else { $av=$sum/$num_all; }
	push(@out_array, ($min, $max, $sum, $av));
	package main;
	return(@out_array);
}

#________________________________________________________________________
# Title     : min
# Usage     : $min = &min (37, 24, 3,1,5, \@array, @array2, \$arr_ref);
# Function  : accepts ref of array, scalar and normal digits to
#             find the min. Only gets numbers. If you put something
#             like 'H333333', it gets digits '333333' only and returns it.
#             this uses RECURSION.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub min{
	my(@in) = @_; my($i, @min, $min);

	for($i=0; $i < @in; $i++){
	 if( (ref($in[$i]) eq 'SCALAR') && (${$in[$i]} =~/([\-]?\d+)/) ){
		push(@min,  $1);    }
	 elsif(ref($in[$i]) eq 'ARRAY'){
		$min=&min(@{$in[$i]});
		push(@min, $min);    }
	 elsif( ( !ref($in[$i]) )&& ($in[$i] =~/([\-]?\d+)/)  ){
		push(@min, $1); }
	}

	for (@min) { $min = $_ if $min > $_; }
	$min;
}

#________________________________________________________________________
# Title     : max
# Usage     : $max = &max (37, 24, 3,1,5, \@array, @array2, \$arr_ref);
# Function  : accepts ref of array, scalar and normal digits to
#             find the min. Only gets numbers. If you put something
#             like 'H333333', it gets digits '333333' only and returns it.
#             this uses RECURSION.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub max{
	my(@in) = @_; my($i, $max, @max, $min);

	for($i=0; $i < @in; $i++){
	 if( (ref($in[$i]) eq 'SCALAR') && (${$in[$i]} =~/([\-]?\d+)/) ){
		push(@max,  $1);    }
	 elsif(ref($in[$i]) eq 'ARRAY'){
		$max = &max(@{$in[$i]});
		push(@max, $max);    }
	 elsif( ( !ref($in[$i]) )&& ($in[$i] =~/([\-]?\d+)/)  ){
		push(@max, $1); }
	}

	for (@max) { $max = $_ if $max < $_; }
	$max;
}
#________________________________________________________________________
# Title     : get_longest_str_size
# Usage     : $long_str_size = ${&get_long_str_size (\@any_array_of_string)};
#             $long_str_size = ${&get_long_str_size (\@any_array_of_string)};
# Function  : get_longest_str_size in an array. eg. get ABCDE among (A, CAB, CDE, ABCDE)
#             When hash is given it processes the values of it.
# Example   :
# Warning   :
# Keywords  : get_the_largest_string_size{, get_largest_string_size,
#             get_largest_str_size{,largest_string_size{, get_largest_string_size_hash
#             get_long_str_size, get_longest_string_size, lonest_string_size
# Options   :
# Returns   :
# Argument  : gets one reference of an array of strings.
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub get_longest_str_size{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my @input;
	if(@hash ==1){
	   @input=values %{$hash{0}};
	}elsif(@array ==1){
	   @input=@{$array[0]};
	}
	my ($factor,$max,$len);
	if( (@input<1)&&(@_ > 1) ){
	  @input=@_;
	}
	if(@num_opt < 1){ @num_opt=0..$#input; $factor=0 }
	else{ $factor =1 }
	print "\nPositions compared are: @num_opt\n" if $debug==1;
	for($j=0; $j < @num_opt; $j++){
		   $len = length($input[$num_opt[$j]-$factor]);
	   $max = $len if ($len > $max);
	}
	return(\$max);
}



#________________________________________________________________________
# Title     : get_shortest_str_size
# Usage     : $short_str_size = &get_short_str_size (\@any_array_of_string);
# Function  : get_shortest_str_size in an array. eg. get A among (A, CAB, CDE, ABCDE)
# Example   :
# Warning   : once debugged. 1st May/95
# Keywords  : get_short_str_size, get_short_string_size, shortest_string_size,
# Options   :
# Returns   :
# Argument  : gets one reference of an array of strings.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_shortest_str_size{
	my(@input)=@{$_[0]}; my($min,$len);
	$min=length($input[0]);
	for ($i = 1; $i <=$#input; $i++){ $len = length($input[$i]); $min = $len if ($len < $min); }
	\$min;
}

#________________________________________________________________________
# Title     : get_id_among_2
# Usage     : $id = &get_id_among_2(\%charcount1, \%charcount2) <- hashes
# Function  : gets the % id of any two sequences
# Example   : %hash1=('A', 30, 'B', 99, 'C', 15 .....)
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  : gets two references of hashes of chars and their occurances.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_id_among_2{  my(%hash1)=%{$_[0]}; my(%hash2)=%{$_[1]};
		my($identity, $no_of_same, $sum_of_same, $av);
	for $key1 (sort keys %hash1){
	$k1 +=1;
		for $key2 (sort keys %hash2){  $k2 +=1;
		if ($key1 eq $key2){
		  $no_of_same = &min($hash1{$key1},$hash2{$key2});
		  $sum_of_same +=$no_of_same;  last;  } } }
	if ($k1 == $k2){  $av = $k1;  }
	else{  $av = &array_average($k1, $k2); }
	$identity = ($sum_of_same/$av)*100;
		}
		return(\$identity);
}

#________________________________________________________________________
# Title     : extract_num_to_array
# Usage     : @my_outarray = &extract_num_to_array($any_input_string);
# Function  : extract only numbers(including negatives) from a string and put into an array
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub extract_num_to_array{
		my($i);
	my($input) =${$_[0]};
	my(@input) =split(/\s+/, $input);
	my(@out_array);
	print "@input", "\n";
	for ($i=0; $i <=$#input; $i++){
		  if ($input[$i] =~ /^(-\d+\.\d+)$/) # for negatives( -3.5555)
		  {
					 push(@out_array	, $1);
		  }
		  elsif ($input[$i] =~ /^(\d+\.\d+)$/)  # for positives ( 33.5534 )
		  {
					 push(@out_array	, $1);
		  }
		  elsif ($input[$i] =~ /^(-\d+)$/) # sor single nega digit ( -1 )
		  {
					 push(@out_array	, $1);
		  }
		  elsif ($input[$i] =~ /^(\d+)$/) # sor single nega digit ( 25 )
		  {
					 push(@out_array	, $1);
		  }
	}
	return(\@out_array);
}
#________________________________________________________________________
# Title     : weighted_average
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub weighted_average{
	 my(@input)=@{$_[0]};
	 my(@array_av_diff,@array_diff, $sum, $num,);
		  my($diff,$weight,$average,$sum_of_av_diffs,$weight_x_input_item);
		  my($final_weighted_av) = 0;
					 for($i=0; $i<=$#input ; $i++){
								for ($j=0; $j<=$#input ; $j++)
								{
										  next if ($i==$j); # remove the self - self. !!
										  $diff=abs($input[$i]-$input[$j]);
										  push (@array_diff, $diff);
								}
								for $item(@array_diff){
								  $sum+=$item;
								}
								$num=$#array_diff+1;
								$average = $sum/$num;

								push(@array_av_diff, $average);
								$average=0; $sum=0;
								@array_diff=();
					 }
					 $sum_of_av_diffs = ${&sum_array(\@array_av_diff)};
					 if ($sum_of_av_diffs == 0){
								$sum_of_av_diffs =1;
								$final_weighted_av = $input[0];
								goto END_point;
					 }
					 for ($k=0; $k <= $#input ; $k++){
								$weight= (($array_av_diff[$k])/$sum_of_av_diffs);
								$weight_x_input_item  = ($input[$k])*$weight;
								$final_weighted_av  = $final_weighted_av + $weight_x_input_item;
					 }
			END_point:
	 \$final_weighted_av;  # for return
}
#________________________________________________________________________
# Title     : weighted_av
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub weighted_av{
	my(@input)=@{$_[0]};
	my(@array_av_diff,@array_diff, $sum, $num,);
		  my($diff,$weight,$average,$sum_of_av_diffs,$weight_x_input_item);
		  my($final_weighted_av) = 0;
					 for($i=0; $i<=$#input ; $i++){
								for ($j=0; $j<=$#input ; $j++)
								{
										  next if ($i==$j); # remove the self - self. !!
										  $diff=abs($input[$i]-$input[$j]);
										  push (@array_diff, $diff);
								}
								for $item(@array_diff){
								  $sum+=$item;
								}
								$num=$#array_diff+1;
								$average = $sum/$num;

								push(@array_av_diff, $average);
								$average=0; $sum=0;
								@array_diff=();
					 }
					 $sum_of_av_diffs = ${&sum_array(\@array_av_diff)};
					 if ($sum_of_av_diffs == 0){
								$sum_of_av_diffs =1;
								$final_weighted_av = $input[0];
								goto END_point;
					 }
					 for ($k=0; $k <= $#input ; $k++){
								$weight= (($array_av_diff[$k])/$sum_of_av_diffs);
								$weight_x_input_item  = ($input[$k])*$weight;
								$final_weighted_av  = $final_weighted_av + $weight_x_input_item;
					 }
			END_point:
	 return(\$final_weighted_av);  # for return
}

#_____________________________________________________________________________
# Title     : sum_digits_in_string
# Usage     :
# Function  :
# Example   :
# Keywords  : add_digits_in_string,
# Options   :
# Author    : Randal
# Category  :
# Version   : 1.0
#-----------------------------------------------------------------------------
sub sum_digits_in_string{
	 my ($sum);
	 my $string=${$_[0]};
	 for (split //, $string){ $sum += $_; }
	 return($sum);
}


#________________________________________________________________________
# Title     : sum_array (the same as array_sum)
# Usage     : $out =  ${&sum_array(\@anyarray)};
# Function  : sum of all the  elements of an array .
# Example   :
# Warning   :
# Keywords  : get_array_sum get_sum_array, get sum of array, get_sum_of_array
# Options   :
# Returns   : a ref. of a scaler.
# Argument  : ref. of an array of numbers.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sum_array{
	my($sum, $item);
	foreach $item(@{$_[0]}){ $sum += $item; }
	return(\$sum);
}

#________________________________________________________________________
# Title     : get_sum_of_array (the same as array_sum)
# Usage     : $out =  ${&sum_array(\@anyarray)};
# Function  : sum of all the  elements of an array .
# Example   :
# Warning   :
# Keywords  : get_array_sum get_sum_array, get sum of array, get_sum_of_array
# Options   :
# Returns   : a ref. of a scaler.
# Argument  : ref. of an array of numbers.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_sum_of_array{
	my($sum, $item);
	foreach $item(@{$_[0]}){ $sum += $item; }
	return(\$sum);
}


#________________________________________________________________________
# Title     : sum_of_array (the same as array_sum)
# Usage     : $out =  ${&sum_of_array(\@anyarray)};
# Function  : sum of all the  elements of an array .
# Example   :
# Warning   :
# Keywords  :
# Options   : -int for integerised output.
# Returns   : a ref. of a scaler.
# Argument  : ref. of an array of numbers.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sum_of_array{
	my $int_option = ${$_[1]} if ref($_[1]);
	my $int_option = $_[1] if !ref($_[1]);
	my($sum, $item);
	foreach $item(@{$_[0]}){
	 $sum += $item; }
	if($int_option =~ /[\-]*i[nt]*/){
	 $sum = int($sum);
	}
	\$sum;
}

#________________________________________________________________________
# Title     : array_sum (the same as sum_array)
# Usage     : $out =  ${&sum_array(\@anyarray)};
# Function  : sum of all the  elements of an array .
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : a ref. of a scaler.
# Argument  : ref. of an array of numbers.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub array_sum{ my($sum, $item);
	foreach $item(@{$_[0]}){ $sum += $item; }
	return(\$sum);
}


#________________________________________________________________________
# Title     : sum_hash_values_of_string
# Usage     : $out = &sum_hash_values_of_string(\%anyhash);
# Function  : sum of all the  numbers in valuse of a hash
# Example   : %hashinput= ( name1, '12..3e',
#                            name2, '...234');
#             $result = 1+2+3+2+3+4 = 15 (from above example)
# Warning   : It only gets digits in the input strings and sums them up.
# Keywords  : sum_hash_string_values, get_sum_hash_string_values, get_hash_value_sum
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub sum_hash_values_of_string{
	my($elements) = join(',', values (%{$_[0]}));
	my(@elements) = split(',',$elements);
	my($sum);
	foreach $item(@elements){ if ($item =~ /[\-\d+]/){ $sum += $item; } }
	return(\$sum);
}

#________________________________________________________________________
# Title     : sum_hash_values
# Usage     : $out = &sum_hash_values(%anyhash);
# Function  : sum of all the  numbers in valuse of a hash
# Example   : %hashinput= ( name1, '12..3e',
#                            name2, '...234');
#             $result = 1+2+3+2+3+4 = 15 (from above example)
# Warning   : It only gets digits in the input strings and sums them up.
# Keywords  : sum_hash_number_values, get_sum_hash_values, get_hash_value_sum
# Options   :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sum_hash_values{
	my($sum);
	my %in_hash=%{$_[0]};
	my @values=values %in_hash;
	foreach (@values){
	   if (/\-?[e\-\d+]/){ $sum += $_;
	   }else{ print "\n# $_ is NON-numeric, exiting\n";
	      die;
	   }
	}
	return(\$sum);
}


#________________________________________________________________________
# Title     : key_ready
# Usage     :
# Function  : detects keyboard input without reading it
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
#             You should check out the Frequently Asked Questions list in
#             comp.unix.* for things like this: the answer is
#             essentially the same.
#             It's very system dependent.  Here's one solution that
#             works on BSD systems:
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub key_ready{  my($rin, $nfd); vec($rin, fileno(STDIN), 1) = 1;
	return $nfd = select($rin,undef,undef,0);
}

#________________________________________________________________________
# Title     : round
# Usage     :
# Function  : gives rounded numbers
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub round{
	my(@numbers);
	my($num);
	@numbers  = @{$_[0]} if ref($_[0]) eq 'ARRAY';
	push(@numbers, ${$_[0]}) if ref($_[0]) eq 'SCALAR';

	for $num (@numbers){
		$num  = int($num + .5);
	}
	if(@numbers > 1){ \@numbers }elsif( @numbers == 1 ){ \$numbers[0] }
}

#________________________________________________________________________
# Title     : round_number
# Usage     :
# Function  : gives rounded integer numbers. 9.5 will be 10, 9.4 will be 9
#             THIS is different from 'trim_nubmers'
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Version   : 1.0
#--------------------------------------------------------------------
sub round_number{
	my(@numbers, $num);
	@numbers  = @{$_[0]} if ref($_[0]) eq 'ARRAY';
	push(@numbers, ${$_[0]}) if ref($_[0]) eq 'SCALAR';

	for $num (@numbers){
		$num  = int($num + .5);
	}
	if(@numbers > 1){ \@numbers }elsif( @numbers == 1 ){ \$numbers[0] }
}


#________________________________________________________________________
# Title     : round_numbers  (same as  round_number )
# Usage     : @output=@{&round_numbers(\@input_numbs)};
#             or  $output=${&round_numbers(\$input_numbs)};
# Function  : gives rounded integer numbers. 9.5 will be 10, 9.4 will be 9
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Authors   : jong@ebi.ac.uk
# Version   : 1.0
#--------------------------------------------------------------------
sub round_numbers{
	my(@numbers, $num);
	@numbers  = @{$_[0]} if ref($_[0]) eq 'ARRAY';
	push(@numbers, ${$_[0]}) if ref($_[0]) eq 'SCALAR';

	for $num (@numbers){
		$num  = int($num + .5);
	}
	if(@numbers > 1){ \@numbers }elsif( @numbers == 1 ){ \$numbers[0] }
}

#________________________________________________________________________
# Title     : trim_number
# Usage     : @output=@{&trim_number(\$input_numb, \$size_of_posi)};
# Function  : gives trimmed numbers (not rounded)
# Example   : given num array( 1.33333, 3.555242424, 0.2342324, 4.9234723747)
#             >>>            (1.33,  3.56,  0.23,  4.92 )
#
# Warning   : If you put '1' with trimming value of 2 it will be '1.00'
# Keywords  : round_fractional_numbers
# Options   :
# Returns   :
# Argument  :
# Authors   : jong@ebi.ac.uk
# Version   : 1.1
#--------------------------------------------------------------------
sub trim_number{
    my($num, $position);
    $num = ${$_[0]} || $_[0];
    if(ref($_[1])){ $position= ${$_[1]}
    }else{ $position=$_[1]; }
    unless($position){ $position=3; }
    $num  = sprintf("%-.${position}f", $num);
    print "\n$num";
	return(\$num);
}


#________________________________________________________________________
# Title     : trim_numbers
# Usage     : @output=@{&trim_numbers(\@input_numbs, \$size_of_posi)};
# Function  : gives trimmed numbers (not rounded)
# Example   : given num array( 1.33333, 3.555242424, 0.2342324, 4.9234723747)
#             >>>            (1.33,  3.56,  0.23,  4.92 )
#
# Warning   : If you put '1' with trimming value of 2 it will be '1.00'
# Keywords  : round_fractional_numbers
# Options   :
# Returns   :
# Argument  :
# Authors   : jong@ebi.ac.uk
# Version   : 1.1
#--------------------------------------------------------------------
sub trim_numbers{
    my(@numbers, $num, $position);
    @numbers = @{$_[0]};
    $num;
    $position= ${$_[1]} || $_[1];
    unless($position){ $position=3; }
	for $num (@numbers){
		$num  = sprintf("%-.${position}f", $num);
	}
	return(\@numbers);
}



#________________________________________________________________________
# Title     : min_elem_array
# Usage     : ($out1, $out2)=@{&min_elem_array(\@array1, \@array2)};
#             ($out1)       =${&min_elem_array(\@array1)          };
# Function  : gets the smallest element of any array of numbers.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more ref. for scalar numbers.
# Argument  : numerical arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub min_elem_array{
	my(@out_min_elem, @input, $min_elem);
	for($i=0; $i< @_; $i++){
	 @input=@{$_[$i]};
	 $min_elem=$input[$#input];
	 for (@input){
		 $min_elem=$_ if ((/[\-\d]+/)&&($_ < $min_elem));
	 }
	 push(@out_min_elem, $min_elem);
	}
	if(@_ == 1){  return( \$min_elem ); }
	elsif(@_ > 1 ){  return( \@out_min_elem ) };
}

#________________________________________________________________________
# Title     : max_elem_array
# Usage     : ($out1, $out2)=@{&max_elem_array(\@array1, \@array2)};
#             ($out1)       =${&max_elem_array(\@array1)          };
# Function  : gets the largest element of any array of numbers.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more ref. for scalar numbers.
# Argument  : numerical arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub max_elem_array{
	my(@out_max_elem, $i, @input, $max_elem);
	for($i=0; $i< @_; $i++){
	 @input=@{$_[$i]}; $max_elem=$input[$#input];
	 for (@input){
		 $max_elem = $_ if ((/[\-\d]+/)&&($_ > $max_elem));    }
	 push(@out_max_elem, $max_elem);}
	if(@_ == 1){ return( \$max_elem ); }
	elsif(@_ > 1 ){  return( \@out_max_elem ) };
}

#________________________________________________________________________
# Title     : max_elem_string_array
# Usage     : ($out1, $out2)=@{&max_elem_array(\@array1, \@array2)};
#             ($out1)       =${&max_elem_array(\@array1)          };
# Function  : gets the largest string length of element of any array of numbers.
# Example   :
# Warning   :
# Keywords  : largest string length of array
# Options   :
# Returns   : one or more ref. for scalar numbers.
# Argument  : numerical arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub max_elem_string_array{
	my(@input, $i, $max_elem);
	@input = @{$_[0]} if ref($_[0]) eq 'ARRAY';
	@input = @_       if ref($_[0]) ne 'ARRAY';
	for($i=0; $i< @input ; $i++){
		 $max_elem = length($input[0]);
		 if (length($input[$i]) > $max_elem){
			 $max_elem = length($input[$i]);
		 }
	}
	\$max_elem;
}

#________________________________________________________________________
# Title     : min_elem_string_array
# Usage     : ($out1, $out2)=@{&max_elem_array(\@array1, \@array2)};
#             ($out1)       =${&max_elem_array(\@array1)          };
# Function  : gets the largest string length of element of any array of numbers.
# Example   :
# Warning   :
# Keywords  : shortest string length of array
# Options   :
# Returns   : one or more ref. for scalar numbers.
# Argument  : numerical arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub max_elem_string_array{
	my(@input, $i,  $min_elem);
	@input = @{$_[0]} if ref($_[0]) eq 'ARRAY';
	@input = @_ unless ref($_[0]) eq 'ARRAY';

	for($i=0; $i< @input ; $i++){
		 $min_elem = length($input[$#input]);
		 if (length($input[$i]) < $min_elem){
			 $min_elem = length($input[$i]);
		 }
	}
	return(\$min_elem);
}


#________________________________________________________________________
# Title     : maximum
# Usage     : $biggest = &maximum(37, 24);
# Function  : another way of finding maximum
# Example   :
# Warning   :
# Keywords  : get_maximum, get_bigger, get_largest
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub maximum{
    if ($_[0] > $_[1]){ $_[0];
	} else{ $_[1];  }
}

#________________________________________________________________________
# Title     : minimum
# Usage     : $biggest = &maximise(37, 24);
# Function  : another way of finding minimum
# Example   :
# Warning   :
# Keywords  : get_minimum, get_minimum_value
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub minimum{
		if ($_[0] > $_[1]){$_[1];
		}else{     $_[0]; }
}



#_____________________________________________________________________
# Title     : get_largest_element
# Usage     : $max=${&get_largest_element(\@array_input)};
# Function  : If strings are given, it gets the largest string elem(by leng)
#             If numbers are given, it gets the largest number elem
#             It automatically checks if string is given
# Example   :
# Keywords  : get_largest_value, get_biggest_value, get_the_largest_element
#             get_maximum_element, get_largest_number,
#             get_largest_number_element, get_longest_element,
#             get_longest_string
# Options   : _  for debugging.
#             #  for debugging.
#             s  for string input (as the second input argument!)
#
# Category  :
# Version   : 1.5
#---------------------------------------------------------------------
sub get_largest_element{
    my(@arr,$string_given, $max, $jump, $i);
    unless(ref($_[0])){ print "\n# get_largest_element needs REF of array\n";
     die;
    }
    @arr=@{$_[0]};
    $string_given=${$_[1]} || $_[1];
    $max=-9999999999999999999;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # $jump is used only to check string is given or not, NO relevant to main algorithm
    #___________________________________________________________________________
    if(@arr > 10000){ $jump=500 }
    elsif(@arr > 1000){ $jump=50 }
    elsif(@arr > 200){ $jump=10 }
    elsif(@arr > 50 ){ $jump=5 }
    elsif(@arr > 10  ){ $jump=2 }
    else{ $jump= 1 }

    #~~~~~~~ Checking if arr is string or not ~~~~~~~~~
    for($i=0; $i < @arr; $i += $jump){
       if(!($arr[$i]=~/^\d+\.\d+$/) and $arr[$i]=~/[a-zA-Z\D]/){
          $string_given='s';
          last;
       }
       if($i > 20){ last }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  Real algorithm starts here
    #_____________________________________
    if($string_given=~/s/){
       for($i=0; $i< @arr; $i++){
            $max=$arr[$i] if length($max) < length($arr[$i]);
       }
    }else{
       for($i=0; $i< @arr; $i++){
            $max=$arr[$i] if $max < $arr[$i];
       }
    }
    return(\$max);
}



#_____________________________________________________________________
# Title     : get_smallest_element
# Usage     : $max=${&get_smallest_element(\@array_input)};
# Function  : If strings are given, it gets the smallest string elem(by leng)
#             If numbers are given, it gets the smallest number elem
#             It automatically checks if string is given
# Example   :
# Keywords  : get_smallest_value, get_biggest_value, get_the_smallest_element
#             get_maximum_element, get_smallest_number,
#             get_smallest_number_element, get_longest_element,
#             get_longest_string
# Options   : _  for debugging.
#             #  for debugging.
#             s  for string input (as the second input argument!)
#
# Category  :
# Version   : 1.5
#---------------------------------------------------------------------
sub get_smallest_element{
    unless(ref($_[0])){ print "\n# get_smallest_element needs REF of array\n";
     die;
    }
    my @arr=@{$_[0]};
    my $string_given=${$_[1]} || $_[1];
    my ($min, $jump, $i);
    $min=10000000000000000000000000;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # $jump is used only to check string is given or not, NO relevant to main algorithm
    #___________________________________________________________________________
    if(@arr > 10000){ $jump=500 }
    elsif(@arr > 1000){ $jump=50 }
    elsif(@arr > 200){ $jump=10 }
    elsif(@arr > 50 ){ $jump=5 }
    elsif(@arr > 10  ){ $jump=2 }
    else{ $jump= 1 }


    #~~~~~~~ Checking if arr is string or not ~~~~~~~~~
    for($i=0; $i < @arr; $i += $jump){
       if(!($arr[$i]=~/^\d+\.\d+$/) and $arr[$i]=~/[a-zA-Z\D]/){
          $string_given='s';
          last;
       }
       if($i > 20){ last }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  Real algorithm starts here
    #_____________________________________
    if($string_given=~/s/){
     for($i=0; $i< @arr; $i++){
            $min=$arr[$i] if length($min) < length($arr[$i]);
     }
    }else{
     for($i=0; $i< @arr; $i++){
         $min=$arr[$i] if $min > $arr[$i];
     }
    }
    return(\$min);
}



#________________________________________________________________________
# Title     : sqrt_array
# Usage     :
# Function  : sqrt all elements of an array
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub sqrt_array{
	my(@input)= @{$_[0]};
	my($sqrt_item);
	foreach $item(@input){ $item = sqrt($item); }
	\@input;
}
#________________________________________________________________________
# Title     : square_array
# Usage     :
# Function  : converts all the elements of an array to squared values.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
sub square_array{ my(@input)= @{$_[0]}; my($sqrt_item);
	foreach $item(@input){ $item = $item*$item; }
	\@input;
}

#________________________________________________________________________
# Title     : sum_of_squared_array
# Usage     : $out = &sum_of_squared_array(@anyarray);
# Function  : sum of all the squared elements of an array .
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub sum_of_squared_array{ my(@input)= @{$_[0]};	my($sqrt_item);	my($sum);
	for $item(@input){ $item = $item*$item; $sum += $item;}
	return(\$sum);
}
#________________________________________________________________________
# Title     : x_mul_y_arrays
# Usage     : @out_array = &x_mul_y_arrays(*array1,*array2);
# Function  : multiplies each item of two arrays .
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub x_mul_y_arrays{
	my(@ar1)=@{$_[0]};
	my(@ar2)=@{$_[1]};
	$num_of_element = ($#ar1 + 1);
	for ($c=0; $c <= $num_of_element;$c++){
	    $multiplied = ($ar1[$c])*($ar2[$c]);
		push(@multiple, $multiplied);
	}
	return(\@multiple);
}
#________________________________________________________________________
# Title     : sum_x_mul_y_arrays
# Usage     : $out = &sum_x_mul_y_arrays(*array1,*array2);
# Function  : sums up multiplied items of two arrays .
#             one to one multiplication(elem 1 of array 1 x elem 1 of array2)
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub sum_x_mul_y_arrays{
	my(@arr1)=@{$_[0]};
	my(@arr2)=@{$_[1]};
	my($sum_xy, $multiplied);
	for ($k=0;$k <=$#arr1;$k++){
	 $multiplied = ($arr1[$k])*($arr2[$k]);
	 $sum_xy += $multiplied; }
	return(\$sum_xy);
}

#________________________________________________________________________
# Title     : corelation_coefficient
# Usage     : $cc = &corelation_coefficient(\@array_not_hash1, \@array_not_hash2);
# Function  : gets corelation_coefficient of two equal length arrays
# Example   :
# Warning   : uses references for ARRAY.
# Keywords  : cc, get_cc, get_corelation_coefficient
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub corelation_coefficient{
	my($final_cc,$av1,$av2,$sum_of_squared_ar1,
		$sum_of_squared_ar2,$sum_of_xy,$upper_half, $under_half);
	my(@array1)=@{$_[0]};
	my(@array2)=@{$_[1]};
	$num_of_elem = @array1;
	$av1=${&array_average(\@array1)};
	$av2=${&array_average(\@array2)};

	$sum_of_squared_ar1=${&sum_of_squared_array(\@array1)};
	$sum_of_squared_ar2=${&sum_of_squared_array(\@array2)};
	$sum_of_xy= ${&sum_x_mul_y_arrays(\@array1,\@array2)};
	$upper_half=($sum_of_xy -($num_of_elem*($av1*$av2)));
	$under_half=sqrt(($sum_of_squared_ar1-($num_of_elem*($av1*$av1)))*($sum_of_squared_ar2-($num_of_elem*($av2*$av2))));

	if ($under_half ==0){ $under_half=1; }
	$final_cc  = $upper_half/$under_half;
	print "\n CC = $final_cc\n";
	return(\$final_cc);
}

#________________________________________________________________________
# Title     : cc
# Usage     : $cc = &cc(\@array_not_hash1, \@array_not_hash2);
# Function  : synonmym of  corelation_coefficient
# Example   :
# Warning   : uses references for ARRAY
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub cc{ my(@array1)=@{$_[0]};  my(@array2)=@{$_[1]};
	my($final_cc, $av1, $av2,$sum_of_squared_ar1, $sum_of_squared_ar2,$sum_of_xy, $upper_half, $under_half);
	$num_of_elem = @array1;
	$av1=&array_average(@array1);    $av2=&array_average(@array2);
	$sum_of_squared_ar1=${&sum_of_squared_array(\@array1)};
	$sum_of_squared_ar2=${&sum_of_squared_array(\@array2)};
	$sum_of_xy= ${&sum_x_mul_y_arrays(\@array1,\@array2)};
	#----- comment out if you do not want STDOUT of these vars. ----#
	print "Number of elem in the array for cc $num_of_elem  ", $num_of_elem,"\n";
	print "Average of array1  ", $av1, "\n";
	print "Average of array2  ", $av2,"\n";
	print "sum_of_squared_ar1 = $sum_of_squared_ar1  ", $sum_of_squared_ar1, "\n";
	print "sum_of_squared_ar2 = $sum_of_squared_ar2  ", $sum_of_squared_ar2, "\n";
	print "sum_of_xy = $sum_of_xy", $sum_of_xy, "\n";
	$upper_half=($sum_of_xy -($num_of_elem*($av1*$av2)));
	$under_half=sqrt(($sum_of_squared_ar1-($num_of_elem*($av1*$av1)))*($sum_of_squared_ar2-($num_of_elem*($av2*$av2))));
	$final_cc  = $upper_half/$under_half;
	\$final_cc;
}

#________________________________________________________________________
# Title     : sd
# Usage     : $sd=${&sd(\@array_of_numbers)};
# Function  :
# Example   :
# Warning   :
# Keywords  : standard deviation, get_standard_deviation,
#             standard_deviation, get_SD, get_sd, stdev
# Options   :
# Returns   : a ref. of a scaler
# Argument  : array references are accepted. outputs scalar single val.
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub sd{
	my(@array)=@{$_[0]};
	my($i, $variance,$average, $deviation,$number,$sum,$standard_deviation,
	  $squared_deviation, $sum_of_squared_deviation );
	for($i=0 ; $i< @array ; $i++){ $sum=$sum+$array[$i]; }
	$average=($sum/@array);
	for($i=0 ; $i< @array ; $i++){ $deviation=($array[$i]-$average);
	 $squared_deviation=($deviation*$deviation);
	 $sum_of_squared_deviation = $sum_of_squared_deviation + $squared_deviation;  }
	$variance=($sum_of_squared_deviation/@array);
	$standard_deviation = sqrt($variance);
	return(\$standard_deviation);
}


#________________________________________________________________________
# Title     : se
# Usage     : $se=${&se(\@array_of_numbers)};
# Function  : gets standard error of any given array
# Example   :
# Warning   :
# Keywords  : standard error, get_standard_error, sterr
# Options   :
# Returns   :
# Argument  : ref. for an array.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub se{
	my(@array)=@{$_[0]};
	my($i,$j,$variance,$average, $deviation,$number,$sum,
	 $standard_deviation,$squared_deviation);
	$number=@array;
	for($i=1; $i<=$number; $i++){ $sum=$sum+$array[$i];  }
	$average=($sum/$number);
	for($j=1;$j<=$number;$j++){  $deviation=($array[$i]-$average);
	 $squared_deviation=($deviation*$deviation);
	 $sum_of_squared_deviation = $sum_of_squared_deviation + $squared_deviation;  }
	$variance=($sum_of_squared_deviation/$number);
	$standard_deviation=sqrt($variance); $standard_error = $standard_deviation/(sqrt($number));
	return(\$standard_error);
}



#________________________________________________________________________
# Title     : remove_non_char
# Usage     : $outstring = &remove_non_char($input_string);
# Function  : removes non chars on any input string. (scaler context)
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub remove_non_char{ my($input)=${$_[0]};$input =~ s/\W//g;
		return(\$input);
}


#________________________________________________________________________
# Title     : numerically
# Usage     : sort numerically (@array);
# Function  : sorts elements by nemerical size.
# Example   :
# Warning   :
# Keywords  : by_digit
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub numerically{
		$a <=> $b;
}

#________________________________________________________________________
# Title     : abs_numerically
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  : numerically_abs, numerically_absolutely
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub abs_numerically{
		abs($a) <=> abs($b);
}

#________________________________________________________________________
# Title     : rev_abs_numerically
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub rev_abs_numerically{
		abs($b) <=> abs($a);
}

#___________________________________________________________________
# Title     : randomise_lines
# Usage     : To randomize th_lib.pl just type &random_lines(300,500,"th_lib.pl");
#             &random_lines(300, 50, "th_lib.pl"); <-- to get 300 lines
#                                                      from 50 numbers
# Function  :
#             outs line numbers with lines
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#---------------------------------------------------------------
sub randomise_lines{
	my($len)=$_[0];
	my($len_1)=$_[1];
	my($inputfile)=$_[2];
	srand(time()^$$);
	for ($i=1;$i<=$len;$i++){
	    $r2=int(rand($len_1));
	    push(@random, $r2);
		 $random{$i}=$random[$i];
	}
	$counter=-1;
	open(IN,"$inputfile");
	while(<IN>){
	    $counter+=1;
	    $input{$counter}=$_;
	}
	for $elem(@random){
		for $key(keys %input){
		   if ($elem == $key){
		     print $key,"\t";
		     print $input{$key};
		   }
		}
	}
}

#___________________________________________________________________
# Title     : pick_colors_randomly
# Usage     : @array = @{&pick_colors_randomly(\$xx)};
# Function  : randomly pick colors. The default is 2 colors returned
#              for Fore and Background of many Tk applications.
# Example   :
# Warning   :
# Keywords  : choose_two_random_colors, choose_colors_randomly,
#             pick_color_randomly pick_array_element_randomly
# Options   : \$number_of_color_you_want
# Returns   :
# Argument  :
# Category  : Tk
# Version   : 1.3
#---------------------------------------------------------------
sub pick_colors_randomly{
    my @colors=qw(cyan bisque steelblue pink yellow white red blue green
                         black violet darkgreen wheat grey20 green4);
    my $num_of_pick = ${$_[0]} || $_[0] || 2 ; #<-- This sets the default 1
    my (@picked, $random_num, $i);
    srand(time()^$$);

    for($i=0; $i<$num_of_pick; $i++){
	   $random_num= int( rand( @colors ) );
	   push(@picked, $colors[$random_num]);
           splice(@colors, $random_num, 1);
    }
    if(@picked > 1){   return(\@picked);
    }else{        	   return(\$picked[0]);	}
}




#___________________________________________________________________
# Title     : pick_random_hash_pairs
# Usage     : @array = @{&pick_random_hash_pairs(\%hash1, \$xx)};
# Function  : randomly pick any num of pairs of hash elements.
#             outs line numbers with lines
#             Default pick number is 1.
# Example   : in signature roation or FVWM rc file menu color rotation.
# Warning   :
# Keywords  : choose_random_hash_pairs
# Options   :
# Returns   : ARRAY ref not HASH  ref
# Argument  :
# Category  :
# Version   : 1.3
#---------------------------------------------------------------
sub pick_random_hash_pairs{
	my %hash = %{$_[0]};
	my @keys = keys %hash;
	my $num_of_pick = ${$_[1]} || $_[1] || 1 ; #<-- This sets the default 1
	my (@pairs, $random_num, $i);
	srand(time()^$$);

	for($i=0; $i<$num_of_pick; $i++){
	 $random_num= int( rand( @keys ) );
	 @pairs=(@pairs, $keys[$random_num], $hash{$keys[$random_num]});
	}
	return(\@pairs);
}


#___________________________________________________________________
# Title     : pick_randomly
# Usage     : @array = @{&pick_random_hash_pairs(\%hash1, \$xx)};
# Function  : randomly pick any num of pairs of hash elements.
#             outs line numbers with lines
#             Default pick number is 1.
# Example   : in signature roation or FVWM rc file menu color rotation.
# Warning   :
# Keywords  : choose_random_hash_pairs, choose_randomly, pick_array_randomly
#             pick_array_element_randomly
# Options   :
# Returns   : ARRAY ref not HASH  ref
# Argument  :
# Category  :
# Version   : 1.3
#---------------------------------------------------------------
sub pick_randomly{
	my @array = @{$_[0]};
	my $num_of_pick = ${$_[1]} || $_[1] || 1 ; #<-- This sets the default 1
	my (@picked, $random_num, $i);
	srand(time()^$$);

	for($i=0; $i<$num_of_pick; $i++){
	   $random_num= int( rand( @array ) );
	   push(@picked, $array[$random_num]);
	}
	if(@picked > 1){   return(\@picked);
	}else{        	   return(\$picked[0]);	}
}



#___________________________________________________________________
# Title     : pick_random_files
# Usage     : @array = @{&pick_random_files(\@files, \$num_of_pick)};
# Function  : randomly pick any num of files given.
# Example   : @array=@{&pick_random_files(\@files, \$num_of_pick)};
# Warning   :
# Keywords  : choose_random_files pick_files_randomly
# Options   :
# Returns   : ARRAY ref not HASH  ref
# Argument  :
# Category  :
# Version   : 1.0
#---------------------------------------------------------------
sub pick_random_files{
	my @files = @{$_[0]};
	my $num_of_pick = ${$_[1]} || $_[1] || 1 ; #<-- This sets the default 1
	my (@out, %count, $random_num, $i);
	srand(time()^$$);
	unless($num_of_pick=~/\d/){
	 $num_of_pick=1;  ## default pick number is 1
	}

	for($i=0; $i<$num_of_pick; $i++){
	 $random_num= int( rand( @files ) );
	 push(@out, $files[$random_num]) unless $count{$random_num};
	 $count{$random_num}++;
	}
	return(\@out);
}


#________________________________________________________________________
# Title     : substract_hash_by_keys
# Usage     : %hash1 = %{&substract_hash(\%hash1, \%hash2)};
# Function  : removes overlapping entries in hashes.
# Example   : %hash1 = %hash1 - %hash2, ==> (4,4)=(2,2, 4,4) - (2,2)
# Warning   :
# Keywords  : substract_hash, substract_hash_by_keys, substract_hash{
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub substract_hash_by_keys{
		my(%hash1)=%{$_[0]};
		my(%hash2)=%{$_[1]};
		grep($hash2{$_} && $hash1{$_} && delete $hash1{$_}, keys %hash2);
		return(\%hash1);
}

#________________________________________________________________________
# Title     : substract_hash_by_values
# Usage     : %hash1 = %{&substract_hash_by_values(\%hash1, \%hash2)};
# Function  : removes overlapping value entries in hashes.
# Example   : %hash1 = %hash1 - %hash2, ==> (4,4)=(2,2, 4,4) - (2,2)
# Keywords  : substract_hash, substract_hash_by_values
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub substract_hash_by_values{
	my(%hash1)=%{$_[0]};
	my(%hash2)=%{$_[1]};
	my($i, $j, @values, @keys);
	@values=values %hash2;
	@keys=keys %hash1;
	for($i=0; $i< @values; $i++){
	 for($j=0; $j < @keys; $j++){
	    if($values[$i] eq $hash1{$keys[$j]}){
		    delete $hash1{$keys[$j]};
	    }
	 }
	}
	return(\%hash1);
}


#________________________________________________________________________
# Title     : substract_array
# Usage     : @subs = @{&substract_array(\@array1, \@array2)};
# Function  : removes any occurances of certain elem. of the first
#             input array with second input array.
# Example   : Following will produce (A K C);
#		@array1= qw( A B K B B C);
#  		@array2= qw( B E D);
#  		@subs = @{&substract_array(\@array1, \@array2)};
# Keywords  : array_subtract, substract_array, ary1_minus_ary2
# Options   :
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------
sub substract_array{
		my(@first)=@{$_[0]};
		my(@second)=@{$_[1]};
		my %counter;
		grep($counter{$_}++, @second );
		return ( [grep(!$counter{$_}, @first)] );
}


#________________________________________________________________________
# Title     : hash_catenate
# Usage     : %output = %{&hash_catenate(\%hash1, \%hash2)};
# Function  : removes overlapping entries in hashes.
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_catenate{
		my(%hash_1)=%{$_[0]};
		my(%hash_2)=%{$_[1]};
		%hash1=(%hash_1, %hash_2);
		return(\%hash1);
}

#________________________________________________________________________
# Title     : merge_hash  (same as hash_catenate)
# Usage     : %output = %{&merge_hash(\%hash1, \%hash2)};
# Function  : removes overlapping entries in hashes.
# Example   :
# Warning   : one bug caught.
# Keywords  : merge_hash_elements,add_hash, merge two hashes.
#             merge hashes, merge_hashes.
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub merge_hash{
		my (%out, $i, $j);
		for($i=0; $i< @_; $i++){
		 %{"hash$i"}=%{$_[$i]};
		 $j=$i+1;
			 %out=(%out, %{"hash$i"}, %{"hash$j"});
		 %{"hash$i"}=();
		 %{"hash$j"}=();
		}
		return(\%out);
}

#________________________________________________________________________
# Title     : superpose_hash
# Usage     : %output = %{superpose_hash(\%template, \%target));
# Function  : superpose hash keys and values to another hash. %target
#             is the superposing hash(new ones will have the values of
#             this target hash. For example, if you superpose
#                (1, 123, 2, 343)
#             to (1, 111, 2, 2222, 3, 3333), you will get
#                (1, 123, 2, 343,  3, 3333) as the result.
#             Template provide blank key entries.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub superpose_hash{
	##########################################################
	my($c, $d, $e, $f, $g, $h, $i, $j, $k, $l, $m, $n, $o, $p, $q, $r,
	  $s, $t, $u, $v, $w, $x, $y, $z,
	  $average1, $dir, $file, $in_dir, $end_found, $entry, $entry_match,
	  $error_rate, $gap_chr, $half_win, $id_compos, $jp_file, $length, $line,
	  $name, $name_found, $name_found, $type_seq, $offset, $option_string,
	  $original_dir, $output, $out_string, $pre, $pwd, $string, $string1,
	  $sum, $sum1, $type_secon, $type_sol, $title_found, $type_DSSP,
	  $type_acc, $variable_string, $win_size,
	  @arg_output, @string, @k, @keys, @names, @out_hash,
	  @out_hash_final, @output_box, @outref, @read_files, @str1, @str2,  @string1,
	  @Tem_keys, @whole_file,
	  %correct_head_box_entry, %dummy, %Final_out, %hash, %input, %out_hash, %out_hash_final,
	  %template,   %target
	 );
	##########################################################
	%template=%{$_[0]};
	%target  =%{$_[1]};
	my(%out_hash);
	@Tem_keys = keys %template;
	for($i=0; $i < @Tem_keys; $i ++){
		$out_hash{$Tem_keys[$i]}= $target{$Tem_keys[$i]};
	}
	return(\%out_hash);
}

#________________________________________________________________________
# Title     : hash_common2
# Usage     : %output = &hash_common($ref1, $ref2);
# Function  :
# Example   : %hashout= %hash1 - %hash2, ==> (4,4)=(2,2, 4,4) - (2,2)
# Warning   : NOT working
# Keywords  :
# Options   :
# Returns   : a ref of a hash.
# Argument  : accepts only two references of hashes
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_common2 {
	my($h1, $h2)=@_;
	my(%h1)=%{$h1};
	my(%h2)=%{$h2};
	my(%h3);
	grep(($h1{$_} eq $h2{$_}) && ($h3{$_}=$h1{$_}) , keys %h1);
	return(\%h3);
}

#________________________________________________________________________
# Title     : remove_dup_in_hash
# Usage     : %out=%{&remove_dup_in_hash(\%input_hash)};
# Function  : removes the duplicate  values of any hashes
# Example   : If %input was
#                (1,1, 2,1, 3,1);
#              The values are the same, so the last key value (3 1) will
#              be the result.
#             If %input was
#                (1,1, 2,1, 3,1, 4,2, 5,2)
#              result=(3 1, 5 2)
#
# Warning   :
# Keywords  : remove_dupplicate_values_in_hash, remove_duplicate_values,
#             remov_hash_dup, remove_duplication_in_hash
# Options   :
# Returns   : one or more hash ref.
# Argument  : one or more hash ref.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub remove_dup_in_hash{
	my(@out_hash_ref, %reverse, $i);
	for($i=0; $i<@_; $i++){
	 if($_[$i] eq 's'){
		$sort_opt=1;
		splice(@_, $i, 1);
		$i--;
	 }elsif(${$_[$i]} eq 's'){
		$sort_opt=1;
		splice(@_, $i, 1);
		$i--;
	 }
	}
	for($i=0; $i<@_; $i++){
	  if(ref($_[$i])  eq 'HASH'){
		  my(%input)=%{$_[$i]};
		  my($key, $val);
		  while (($key,$val) = each %input) {
			 $reverse{$val} = $key;
		  }
		  while(($key, $val) = each %reverse){
			 $reverse2{$val} =  $key ; ## reverse again to normal
		  }
		  push(@out_hash_ref, \%reverse2);
	  }else{
	     print "\n remove_dup_in_hash accepts only hash ref. in $0\n";
		 print chr(7); die;
	  }
	}
	if(@out_hash_ref ==1){ $out_hash_ref[0];
	}elsif(@out_hash_ref >1){@out_hash_ref;}
}

#________________________________________________________________________
# Title     : reverse_hash
# Usage     : %out=%{&reverse_hash(\%input_hash)};
# Function  : exchanges the value and key of any hashes
# Example   :
# Warning   : Takes ALIGNED sequences.
# Keywords  : invert_hash, inverse_hash
# Options   :
# Returns   : one or more hash ref.
# Argument  : one or more hash ref.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub reverse_hash{
	my(@out_hash_ref, %reverse, $i);
	for($i=0; $i<@_; $i++){
	  if(ref($_[$i])  eq 'HASH'){
		  my(%input)=%{$_[$i]};
		  my($key, $val);
		  while (($key,$val) = each %input) {
		     $reverse{$val} = $key;
		  }
		  push(@out_hash_ref, \%reverse);
	  }else{
	     print "\n reverse_hash accepts only hash ref. in $0\n";
		 print chr(7); die;
	  }
	}
	if(@out_hash_ref ==1){ $out_hash_ref[0];
	}elsif(@out_hash_ref >1){@out_hash_ref;}
}

#________________________________________________________________________
# Title     : hash_common
# Usage     : %hash1_value = %{&hash_common(\%hash1, \%hash2,...)};
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : the VALUES OF THE FIRST HASH which occur in later hashes
#             are returned
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_common{
	my(%common)=();
	for($i=0; $i< @_; $i++){  my(%common2)=();
	  if( !(defined(%common) )){ %common=%{$_[$i]}; next;}
	  elsif(defined(%common)){ %h1=%{$_[$i]};
		 for(keys %common){ $common2{$_}=$common{$_} if (defined $h1{$_});}
	  %common=%common2;}  }
	return(\%common);
}

#________________________________________________________________________
# Title     : hash_common_by_keys
# Usage     : %hash1_value = %{&hash_common_by_keys(\%hash1, \%hash2,...)};
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : the VALUES OF THE FIRST HASH which occur in later hashes
#             are returned
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_common_by_keys{
	my(%common)=();
	for($i=0; $i< @_; $i++){
	  my(%common2)=();
	  if( !(defined(%common) )){ %common=%{$_[$i]}; next;}
	  elsif(defined(%common)){ %h1=%{$_[$i]};
		 for(keys %common){ $common2{$_}=$common{$_} if (defined $h1{$_});}
	  %common=%common2;}
	  undef(%common2);  }
	return(\%common);
}

#________________________________________________________________________
# Title     : get_common_hash_keys
# Usage     : @output_array_of_keys = @{&get_common_hash_keys(\%hash1, \%hash2)};
# Function  : gets the common hash keys of two hashes.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_common_hash_keys{
		my @array1 = keys %{$_[0]};
		my @array2 = keys %{$_[1]};
		grep($common{$_}++, @array1);
		my @common_keys=grep($common{$_}, @array2);
		return(\@common_keys);
}


#________________________________________________________________________
# Title     : hash_no_common
# Usage     : %output = &hash_catenate(*hash1, *hash2);
# Function  : removes overlapping entries in hashes.
# Example   : %hashout= %hash1 - %hash2, ==> (4,4)=(2,2, 4,4) - (2,2)
# Warning   : surely working, This grep version is faster than for and defined loop.
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub hash_no_common{
		local(*h1, *h2)=@_;
		grep(($h1{$_} eq $h2{$_}) && delete $h1{$_} && delete $h2{$_},  keys %h1);
		local(%h_no_com) = (%h1, %h2);
}

#________________________________________________________________________
# Title     : beep
# Usage     : &beep;
# Function  :
# Example   :
# Warning   :
# Keywords  : make_beep_sound
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub beep{
		print chr(7);
}

#________________________________________________________________________
# Title     : capitalize_word.pl
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  : capitalise word,  capitalise_word
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub capitalize_word{
	my($sentence, $tmp);
	if(ref($_[0])){
		$sentence=${$_[0]};
	}else{ $sentence=$_[0]; }
	$sentence =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
	return(\$sentence);
}

#________________________________________________________________________
# Title     : capitalize_sentence.pl
# Usage     :
# Function  :
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub capitalize_sentence{
	my($sentence, $tmp);
	if(ref($_[0])){
		$sentence=${$_[0]};
	}else{ $sentence=$_[0]; }
	$sentence =~ s#^\S|\s(\S)#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#ge;
	return(\$sentence);
}


#________________________________________________________________________
# Title     : shift_word_recursively
# Usage     : @new_lines=shift_word_recursively(\@lines, '/'); or
#             @new_lines=shift_word_recursively(\@lines, '\W'); or
#             @new_lines=shift_word_recursively(\@lines, 'a-zA-Z'); or
#             @new_lines=shift_word_recursively(\@lines, '/', 2); <--- for multiple chop unit
#             or $new_line = shift_word_recursively(\$line, '.'); <--- for scalar input.
# Function  : shift lines word by word. This needs delimiter like '/' or '.'
#             and stores the resulting arrays. This is to get all the possible
#             directories.
#             For example, with /nfs/A Biomatic /perl/temp/here  input, you get
#             (  /A Biomatic /perl/temp/here,   /perl/temp/here ,
#             temp/here, /here, )  in an array.
#
# Example   : @new_lines=shift_word_recursively(\@lines, '/-', 2); to chop lines
#             off two words with the two delimiters of '/' and '-'.
#             /jong1/perl-jong2/perl-jong3  will become   /perl-jong2/perl-A Biomatic 3
#             /bin/-kkk/-jjj/-jj will become  /-kkk/-jjj/-jj
#             @out=@{&shift_word_recursively($testline, '/-', 2)};
#             You can use perl regexp patterns for  $delimiter as it is directly
#             used in a pattern matching in the sub. So, you canuse '\W'
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  : SCALAR or ARRAY refs. and delimitor ('/', '.', '-'.....)
#             delimitor can be multi line => '#$%/=.'
#             default delimiter is space ' ';
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub shift_word_recursively{
	my(@in)=@_; my($i, @input_lines, $delimiter, @chopped_line, @output_lines);
	my($multi_chop)=1; ### default is 1 (one word chopping)
	for($i=0; $i < @in; $i++){
	 if(ref($in[$i]) eq 'ARRAY'){
		 push(@input_lines, @{$in[$i]}); }
	 elsif(ref($in[$i]) eq 'SCALAR'){
		 if( length(${$in[$i]}) > 2 ){
			 push(@input_lines, ${$in[$i]}); }
		 elsif( ${$in[$i]} =~ /^\W+$/ ){
			 $delimiter .= ${$in[$i]};  }
		 elsif( ${$in[$i]} =~/^\d$/ ){
			 $multi_chop = $&;  }
		 elsif( length(${$in[$i]}) < 4 ){
			 $delimiter .= ${$in[$i]};  }    }
	 elsif( !ref($in[$i]) ){
		 if( length($in[$i]) > 2 ){
			 push(@input_lines, $in[$i]); }
		 elsif( $in[$i] =~/^\W+$/ ){
			 $delimiter .= $in[$i];  }
		 elsif( $in[$i] =~/^\d$/ ){
			 $multi_chop = $&;  }
		 elsif( length(${$in[$i]}) < 4 ){
			 $delimiter .= $in[$i];  }
	 }
	}

	if( $delimiter =~/^$/ ){ $delimiter = ' '; }  ## default delimiter is space
	for($i=0; $i<@input_lines; $i++){
	  @chopped_line = split(/([$delimiter]+)/, $input_lines[$i]);
	  while(@chopped_line > 1){
		  splice(@chopped_line, 1, $multi_chop*2 );
		  push(@output_lines, join("$1", @chopped_line) );
	  }
	}
	\@output_lines;
}
#________________________________________________________________________
# Title     : shift_word
# Usage     : @new_lines=shift_word(\@lines, '/'); or
#             @new_lines=shift_word(\@lines, '\W'); or
#             @new_lines=shift_word(\@lines, 'a-zA-Z'); or
#             @new_lines=shift_word(\@lines, '/', 2); <--- for multiple chop unit
#             or $new_line = shift_word(\$line, '.'); <--- for scalar input.
# Function  : shift lines word by word. This needs delimiter like '/' or '.'
# Example   : @new_lines=shift_word(\@lines, '/-', 2); to shift off lines two words
#             with the two delimiters of '/' and '-'.
#             /jong1/perl-jong2/perl-jong3  will become   /jong1/perl-A Biomatic 2
#             /bin/-kkk/-jjj/-jj will become  /jong1/perl-A Biomatic 2 by
#             @out=@{&shift_word($testline, '/-', 2)};
#             You can use perl regexp patterns for  $delimiter as it is directly
#             used in a pattern matching in the sub. So, you canuse '\W'
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  : SCALAR or ARRAY refs. and delimitor ('/', '.', '-'.....)
#             delimitor can be multi line => '#$%/=.'
#             default delimiter is space ' ';
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub shift_word{
	my(@in)=@_;
	my($i, @input_lines, $delimiter, @chopped_line, @output_lines);
	my($multi_chop)=1; ### default is 1 (one word chopping)
	for($i=0; $i < @in; $i++){
	 if(ref($in[$i]) eq 'ARRAY'){
		 push(@input_lines, @{$in[$i]}); }
	 elsif(ref($in[$i]) eq 'SCALAR'){
		 if( length(${$in[$i]}) > 3 ){
			 push(@input_lines, ${$in[$i]}); }
		 elsif( ${$in[$i]} =~ /^\W+$/ ){
			 $delimiter .= ${$in[$i]};  }
		 elsif( ${$in[$i]} =~/^\d$/ ){
			 $multi_chop = $&;  }
		 elsif( length(${$in[$i]}) < 4 ){
			 $delimiter .= ${$in[$i]};  }
	 }
	 elsif( !ref($in[$i]) ){
		 if( length($in[$i]) > 3 ){
			 push(@input_lines, $in[$i]); }
		 elsif( $in[$i] =~/^\W+$/ ){
			 $delimiter .= $in[$i];  }
		 elsif( $in[$i] =~/^\d$/ ){
			 $multi_chop = $&;  }
		 elsif( length(${$in[$i]}) < 4 ){
			 $delimiter .= $in[$i];  }    }
	}
	if( $delimiter =~/^$/ ){ $delimiter = ' '; }  ## default delimiter is space
	for($i=0; $i<@input_lines; $i++){
	  @chopped_line = split(/([$delimiter]+)/, $input_lines[$i]);
	  splice(@chopped_line, 1, $multi_chop*2 );  ## *2 is essential.
	  push(@output_lines, join("$1", @chopped_line) );
	}
	return(\@output_lines);
}

#________________________________________________________________________
# Title     : chop_word
# Usage     : @new_lines=chop_word(\@lines, '/'); or
#             @new_lines=chop_word(\@lines, '\W'); or
#             @new_lines=chop_word(\@lines, 'a-zA-Z'); or
#             @new_lines=chop_word(\@lines, '/', 2); <--- for multiple chop unit
#             or $new_line = chop_word(\$line, '.'); <--- for scalar input.
# Function  : chop lines word by word. This needs delimiter like '/' or '.'
# Example   : @new_lines=chop_word(\@lines, '/-', 2); to chop off lines two words
#             with the two delimiters of '/' and '-'.
#             /jong1/perl-jong2/perl-jong3  will become   /jong1/perl-A Biomatic 2
#             /bin/-kkk/-jjj/-jj will become  /jong1/perl-A Biomatic 2 by
#             @out=@{&chop_word($testline, '/-', 2)};
#             You can use perl regexp patterns for  $delimiter as it is directly
#             used in a pattern matching in the sub. So, you canuse '\W'
# Warning   : The returning value is not the chopped off word.
# Keywords  : chop_word_recursively, remove_word, chop_word_one_by_one
# Options   : -w, w, Word, etc,  for getting the chopped off word(s) rather
#             than the original lines minus the word.
# Returns   :
# Argument  : SCALAR or ARRAY refs. and delimitor ('/', '.', '-'.....)
#             delimitor can be multi line => '#$%/=.'
#             default delimiter is space ' ';
# Category  :
# Version   : 2.0
#--------------------------------------------------------------------
sub chop_word{
	my(@in)=@_;
	my($i, @input_lines, $delimiter, @chopped_line, @output,
	  @chopped_word_list, $get_chopped_word_option);
	my($multi_chop)=1; ### default is 1 (one word chopping)
	for($i=0; $i < @in; $i++){
	 if(ref($in[$i]) eq 'ARRAY'){
		 push(@input_lines, @{$in[$i]}); }
	 elsif(ref($in[$i]) eq 'SCALAR'){
		 if( length(${$in[$i]}) > 3 ){  ### the delimiter can be upto 3 chars by
			 push(@input_lines, ${$in[$i]}); }  ## one arg input.
		 elsif( ${$in[$i]} =~ /^\W+$/ ){
			 $delimiter .= ${$in[$i]};  }
		 elsif( ${$in[$i]} =~/^\d$/ ){
			 $multi_chop = $&;  }
		 elsif( ${$in[$i]} =~/^\-?[wW][ord]*$/ ){  ## for -w option
			 $get_chopped_word_option = 1;  }
		 elsif( length(${$in[$i]}) < 4 ){
			 $delimiter .= ${$in[$i]};  }
	 }
	 elsif( !ref($in[$i]) ){
		 if( length($in[$i]) > 3 ){
			 push(@input_lines, $in[$i]); }
		 elsif( $in[$i] =~/^\W+$/ ){
			 $delimiter .= $in[$i];  }
		 elsif( $in[$i] =~/^\d$/ ){
			 $multi_chop = $&;  }
		 elsif( $in[$i] =~ /^\-?[wW][ord]*$/ ){  ## for -w option
			 $get_chopped_word_option = 1;  }
		 elsif( length(${$in[$i]}) < 4 ){
			 $delimiter .= $in[$i];  }
	 }
	}
	if( $delimiter =~/^$/ ){ $delimiter = ' '; }  ## default delimiter is space

	if($get_chopped_word_option == 1){
	  for($i=0; $i< @input_lines; $i++){
		  @chopped_line = split(/([$delimiter]+)/, $input_lines[$i]);
		  push(@output, $chopped_line[$#chopped_line] );
	  }  }
	else{  ## when original lines minus the chopped word are wanted.(default).
	  for($i=0; $i<@input_lines; $i++){
		  @chopped_line = split(/([$delimiter]+)/, $input_lines[$i]);
		  splice(@chopped_line, @chopped_line-$multi_chop*2 );
		  push(@output, join("$1", @chopped_line) );
	  }
	}
	if(@output == 1){ return($output[0]);
	}elsif(  @output > 1 ){ return(@output); }
}

#________________________________________________________________________
# Title     : get_median
# Usage     : $median = ${&get_median(\@array)};
# Function  :
# Example   :
# Warning   :
# Keywords  :  median_array, get_median_array, get_array_median, array_median
# Options   :
# Returns   : \$median
# Argument  : \@array
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_median{
	my(@array)=@{$_[0]};
	$median=( sort { $a <=> $b } @array )[ @array/2 ];
	return(\$median);
}


#________________________________________________________________________
# Title     : array_median
# Usage     : $median = ${&array_median(\@array)};
# Function  :
# Example   :
# Warning   :
# Keywords  :  median_array, get_median_array, get_array_median, array_median
# Options   :
# Returns   : \$median
# Argument  : \@array
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub array_median{
	my(@array)=@{$_[0]};
	my $median=( sort { $a <=> $b } @array )[ @array/2 ];
	return(\$median);
}

#________________________________________________________________________
# Title     : get_median
# Usage     : $median = ${&get_median(\@array)};
# Function  :
# Example   :
# Warning   :
# Keywords  :  median_array, get_median_array, get_array_median, array_median
# Options   :
# Returns   : \$median
# Argument  : \@array
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------
sub get_median{
	my(@array)=@{$_[0]};
	$median=( sort { $a <=> $b } @array )[ @array/2 ];
	return(\$median);
}



#________________________________________________________________________
# Title     : push_if_not_already
# Usage     : @out=@{&push_if_not_already(@mother_array, @adding_array )};
#             @out=@{&push_if_not_already(@mother_array, $adding_scalar)};
# Function  : returns ref. of an array for a list of non-repetitive entry.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : a ref. of an array.
# Argument  : two references. The first should be an array ref. The 2nd can be either
#             scalar or array reference.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub push_if_not_already{
	my($already_in, $already, $i, @push_items_given);
	my(@out_array)=@{$_[0]};
	push(@push_items_given, ${$_[1]}) if(ref($_[1]) eq 'SCALAR');
	@push_items_given=@{$_[1]} if(ref($_[1]) eq 'ARRAY');
	for $already (@out_array){  ## This for is to remove repetitive
	  for ($i=0; $i< @push_items_given; $i++){
		 if($already eq $push_items_given[$i]){ splice(@push_items_given,$i); }
	  }
	}
	push(@out_array,@push_items_given); \@out_array;
}

#________________________________________________________________________
# Title     : replace_lines
# Usage     : &replace_lines(@files, 'removing_string', 'match_str' );
# Function  : replace_lines in any txt files
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub replace_lines{
	my(@in)=@_;
	my($i, $file, @lines);
	my($replacing_lines     ) = pop(@in);
	my($matching_line_string) = pop(@in) unless (-f $in[$#in]);
	print "\n $matching_line_string";
	for $file (@in){
	  open(FILE, "$file");
	  @lines=<FILE>;
	  for($i=0; $i <@lines; $i++){
		  if($lines[$i]=~/$matching_line_string/){
		      print "\n;lkjasljf \n";
			  $lines[$i]="$replacing_lines\n";
		  }
	  }
	  open(NEW_FILE, ">$file");
	  print NEW_FILE @lines;
	}
	close NEW_FILE;
}

#________________________________________________________________________
# Title     : insert_lines_anywhere
# Usage     : &insert_lines_anywhere(\@files, \$inst_str,'after', \@match_str);
# Function  : insert lines anywhere in any txt files. Without any
#              position options(Before, After), it attaches the line
# Example   :
# Warning   : Case Insensitive by default.
# Keywords  : insert_text, insert_lines, insert_something,
#             attach_lines_in_text, attach_lines, insert_text_lines
# Options   :
#   $adding_line= by a=
#   $pattern_match_line= by p=
#   $option_before_or_after= by o=
#
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------
sub insert_lines_anywhere{
		my ($i, @in, $new_lines, $option_string, $number_of_lines_changed, @match_patterns);
		if(ref($_[0]) eq 'ARRAY'){            @in = @{$_[0]}
		}elsif(ref($_[0]) eq 'SCALAR'){        push(@in, ${$_[0]});
		}elsif(ref($_[3]) eq 'SCALAR'){        push(@in, ${$_[0]});
		}else{                                 push(@in, $_[0]);    }
		if(ref($_[1]) eq 'SCALAR'){       $new_lines=${$_[1]};
		}else{                            $new_lines=$_[1];    }

		if(ref($_[2]) eq 'SCALAR'){       $option_string=${$_[2]};
		}else{                            $option_string=$_[2];    }

		if(ref($_[3]) eq 'ARRAY'){        @match_patterns = @{$_[3]}
		}elsif(ref($_[3]) eq 'SCALAR'){   push(@match_patterns, ${$_[3]});
		}else{                            push(@match_patterns, $_[3]);    }

		print "\n# (INFO) I am trying to insert \"$new_lines\" with \@in of @in\n";

		for $file (@in){
				open(FILE, "$file");
				$number_of_lines=@lines=<FILE>;
				print "\n# (INFO) \$number_of_lines for $file is $number_of_lines\n";
				if($option_string =~/^ *A[fter]*/i){
						for($i=0; $i <@lines; $i++){
								for($j=0; $j< @match_patterns; $j++){
									 if(($lines[$i]=~/$match_patterns[$j]/)&&
											($lines[$i+1] !~ /$inserting_lines/i)){
													 $lines[$i]=$lines[$i]."$new_lines\n";
													 $number_of_lines_changed++;
													 last;
									 }
								}
						}
				}elsif( $option_string =~/^ *B[efore]*/i){
						print "\n# (INFO) Before option is set\n";
						for($i=@lines; $i > -1; $i--){
								for($j=0; $j< @match_patterns; $j++){
									 if(($lines[$i]=~/$match_patterns[$j]/)&&
													($lines[$i-1] !~ /$new_lines/i)){
												$lines[$i]="$new_lines\n".$lines[$i];
												$number_of_lines_changed++;
												last;
									 }
								}
						}
				}else{
						print "\n# (INFO) NO option is set. I am attatching the lines at the end\n";
						push(@lines, "$new_lines");
						$number_of_lines_changed=1;
				}
				open(NEW_FILE, ">$file");
				print NEW_FILE @lines;
		}
		print "\n# (INFO) \$number_of_lines_changed is $number_of_lines_changed\n";
		return(\$number_of_lines_changed);
}



#______________________________________________________________________________
# Title     : get_all_possible_pairs_from_array
# Usage     :
# Function  : gets pairs (sorted) from array
# Example   :
# Keywords  : pair_combination, combination, permutation, get_combinatorial_pairs
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   : HASH
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_all_possible_pairs_from_array{
    my(%resulting_pairs_hash);
    @input_array=@{$_[0]};
    for($i=0; $i< @input_array; $i++){
       for($j=$i+1; $j<@input_array; $j++){
          $sorted_pair=join(' ', sort($input_array[$i], $input_array[$j]));
          $resulting_pairs_hash{$sorted_pair}=$sorted_pair;
       }
    }
    return(\%resulting_pairs_hash);
}





#________________________________________________________________________
# Title     : get_all_dirs_from_ENV
# Usage     : my(@default_env_dirs) = @{&get_all_dirs_from_ENV};
# Function  : extracts all the directories from %ENV  setting.
# Example   : my(@default_env_dirs) = @{&get_all_dirs_from_ENV}; in handle_arguments
# Warning   : produces repetitive pathes (ie, can output identical path several times)
# Keywords  :
# Options   : None
# Returns   : a ref. of an array of directories.
# Argument  : NONE
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_all_dirs_from_ENV{
	  my($each_dir, $i, @default_env_dirs);
	  my($pwd)=`pwd`;
	  chomp($pwd);
	  unshift(@default_env_dirs, $pwd);
	  push(@default_env_dirs,  split(/:/, join(":", (values %ENV)) ));
	  for ($i=0; $i < @default_env_dirs; $i++){
		  $each_dir=$default_env_dirs[$i];
		  $each_dir =~ s/^\.$//;
		  unless( -d $each_dir ){
			 splice(@default_env_dirs, $i, 1); $i--;
			 next;
		  }  ## remove if it is not a directory.
		  elsif( (-d $each_dir) && ($each_dir=~/\/$/) ){
			 chop($each_dir);
		  }  ## removing all the last back slash in  .../xxx/
	  }
	  @default_env_dirs=@{&remove_dup_in_array(\@default_env_dirs)};
	  return(\@default_env_dirs);
}


#________________________________________________________________________
# Title     : get_path_dirs_from_ENV
# Usage     : my(@default_env_dirs) = @{&get_path_dirs_from_ENV};
# Function  : extracts path directories from %ENV  setting.
# Example   : my(@default_env_dirs) = @{&get_path_dirs_from_ENV}; in handle_arguments
# Warning   : Replaces '.' to $pwd.
# Keywords  :
# Options   : None
# Returns   : a ref. of an array of directories.
# Argument  : NONE
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub get_path_dirs_from_ENV{
	  my($each_dir, $i, @default_path_dirs);
	  my($pwd)=`pwd`; chomp($pwd);

	  if(defined($ENV{'path'}) )   {  ## if 'path' is used,
		  push(@default_path_dirs, $pwd, split(/:/, $ENV{'path'}) ) }
	  elsif(defined($ENV{'PATH'}) ){  ## if 'PATH' is used,
		  push(@default_path_dirs, $pwd, split(/:/, $ENV{'PATH'})) }
	  elsif(defined($ENV{'Path'}) ){  ## if 'Path' is used,
		  push(@default_path_dirs, $pwd, split(/:/, $ENV{'PATH'})) }

	  for ($i=0; $i < @default_path_dirs; $i++){
		  $each_dir=$default_path_dirs[$i];
		  $each_dir =~ s/^\.$//;
		  unless( -d $each_dir ){
			 splice(@default_path_dirs, $i, 1); $i--; next; }  ## remove if it is not a directory.
		  elsif( (-e $each_dir) && ($each_dir=~/\/$/) ){
			 chop($each_dir);  }  ## removing all the last back slash in  .../xxx/
	  }
	  @default_env_dirs=@{&remove_dup_in_array(\@default_env_dirs)};
	  return(\@default_env_dirs);
}


#________________________________________________________________________
# Title     : handle_arguments_old
# Usage     : my(@in)=&handle_arguments_old(\@input_args);   Do not dereference it.
# Function  : Sub argument handling for opening files with options. General
#             form of 'handle_arguments_xxxx', while xxxx can be files, hashes, arrays,,,,
# Example   :
# Warning   :
# Keywords  :
# Options   : None yet, extendable by adding refs. of something.
# Returns   : an array of refs for file names, hashes, arrays and  the opion string
# Argument  : one single ref. (\@input_args);
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub handle_arguments_old{
	my($i, @in, @out, $k, @names, $chain, $n  );
	my($real_file, $s, @out_hash_ref_list);
	my(@input_options);
	my($default_option_string)='ETSIBHG'; # This is the string for the default option chars.
	my($full_option_string)='ETSIBHGR'; # This is the string of all the option chars.
	my($match_option);  # <-- This is for option handling at prompt. If you put -e -h at
							 #    the prompt, you will have $match_option value of 'EH' to match
	my(@extension_db)=('sst','msf','fasta','jp','fas','aln','brk','pdb', 'rms',
							'dssp', 'hssp', 'fssp', 'phd', 'ent','slx','fa');

	##########################################
	##  Getting just directories from ENV   ##
	##########################################
	my(@default_env_dirs) = @{&get_all_dirs_from_ENV};
	my($pwd)=`pwd`; chomp($pwd);  # This is necessary for full path '$real_file' var.

	if(ref($_[0])){  @in=@{$_[0]}; }elsif(!ref($_[0])){ @in=@_; }

	for($k=0; $k< @in ;$k++){  my($file_found);
	  #######################
	  ##   If it is ref.   ##
	  #######################
	  if( ref($in[$k]) ){
		  if( ref($in[$k]) eq 'SCALAR' ){
			  if ((-f ${$in[$k]})&&(${$in[$k]}=! /\//) ){
					push( @out, \"$pwd\/${$in[$k]}" ); $file_found=1; last; }  # push as a ref.
			  elsif ((-f ${$in[$k]})&&(${$in[$k]}=~ /\//) ){
					push( @out, \"${$in[$k]}" ); $file_found=1; next; }
			  for $ENV_dir (@default_env_dirs){
					 if (-f "$ENV_dir\/${$in[$k]}"){
						 push(@out, \"$ENV_dir\/${$in[$k]}"); $file_found=1; last ;
					 }
			  }
			  if($file_found != 1){ my($ext, $ENV_dir);
				  for $ENV_dir (@default_env_dirs){
					 for $ext (@extension_db){
						 if (-f "$ENV_dir\/${$in[$k]}\.$ext"){
							 push(@out, \"$ENV_dir\/${$in[$k]}\.$ext" ); $file_found=1; last ;  }
					 }
				  }
			  }
		  }
		  elsif( ref($in[$k]) eq 'HASH'  ){ push(@out, $in[$k]);   }
		  elsif( ref($in[$k]) eq 'ARRAY' ){ push(@out, $in[$k]);   }
		  ########################################################################
		  ############  Following is to get option strings              ##########
		  ########################################################################
		  elsif( (ref($in[$k]) eq 'SCALAR') && (length(${$_[$k]}) < 4 )){
			  if(${$in[$k]}=~ /^([\w]+)$/){  ## <-- Adding options to a one string vAR.
				  my($opt)=$1; $opt=~tr/a-z/A-Z/; $match_option  .= $opt; next;
			  }
		  }
	  }
	  #######################
	  ##  If it is no ref. ##
	  #######################
	  elsif( !ref($in[$k]) ){  my($file_found);
			if( (-f $in[$k])&&($in[$k] =!/\//) ){
				 push( @out, \"$pwd\/$in[$k]" ); next; }
			elsif( (-f $in[$k])&&($in[$k] =~/\//) ){
				 push( @out, \"$in[$k]" );  next; }
			for $ENV_dir (@default_env_dirs){
				 if (-f "$ENV_dir\/$in[$k]"){
					push(@out, \"$ENV_dir\/$in[$k]"); $file_found=1; last ;
				 }
			}
			if($file_found != 1){ my($ext, $ENV_dir);
			  X2: for $ENV_dir (@default_env_dirs){
					  for $ext (@extension_db){
						  if (-f "$ENV_dir\/$in[$k]\.$ext"){
							 push(@out, \"$ENV_dir\/$in[$k]\.$ext" ); $file_found=1; last X2;  }
					  }
					}
			}
			elsif( length($in[$k]) < 4 ){   # <<-- number 3 limits the option char size.
			  if($in[$k]=~ /^([\w]+)$/){ ## <-- Adding options to a one string vAR.
				 local($opt)=$1; $opt=~tr/a-z/A-Z/; $match_option  .= $opt; next;
			  }
			}
	  }
	} ## <<-- End of for loop
	if($match_option =~ /^$/){
	  $match_option = $default_option_string;  } # <<-- When there is no options given, use full options.
	return(@out, $match_option); # The last elem. is the option string
}


#________________________________________________________________________
# Title     : move_files
# Usage     :
# Function  : read any file names and REMOVES the '.', '..' and dir entries.
#             And then removes them
# Options   : "extension name". If you put , 'pl' as an option, it will show
#             files only with '.pl' extension.
#  '-p'      for path also included resulting in '/path/path/file.ext'
#              rather than 'file.ext' in output @array
#  '-s'      for sorting the results
#  e='xxx'  for extention xxx
#  '.pl'    for files extended by '.pl'
#  'pl'     for files extended by 'pl', same as above
#  D=       for dir name input
#  d=       for dir name input
#
# Version   : 1.3
#--------------------------------------------------------------------
sub move_files{
	my(@in, $i, $j, $e, $f, $k, $dir_1, $dir_2, @dir_1, @dir_2, $extension, @extensions,
	   @final_files, $pwd, $num_of_files_moved);
	$pwd=`pwd`; chomp($pwd);
	@in=@_;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#  Directory entry and opts detection
	#_________________________________________
	for($k=0; $k < @in; $k++){
       if ($in[$k]=~/d=(\S+)/ and -d $1){
           $dir_1=$1;
           if($dir_1=~/\,/){   @dir_1=split(/\,/, $dir_1);
           }else{              push(@dir_1, $dir_1); }
       }elsif($in[$k]=~/t=(\S+)/){
           unless(-d $1){ mkdir($1, 0777); }
           $dir_2=$1;
           if($dir_2=~/\,/){     @dir_2=split(/\,/, $dir_2);
           }else{                push(@dir_2, $dir_2); }
       }elsif($in[$k]=~/e=(\S+)/){
           $extension=$1;
           if($extension=~/\,/){
              @extensions=split(/\,/, $extension);
           }else{ push(@extensions, $extension); }
       }elsif( ref($in[$k]) eq 'ARRAY' ){
           @files=@{$in[$k]}; splice (@in, $k, 1); $k--;
       }
    }
    unless($dir_1){ $dir_1='.'; @dir_1=('.'); }
    unless($dir_2){ die "\n I need destination directory(t=) to move files with the given extension\n\n"; }
    unless($extension){
       if(@files){ $move_given_files='f';
       }else{      $move_all_files='a' }
    }
    print "\n Summary: \"@extensions\" , @dir_2, @dir_1 \n";
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	#  Main READING PART
	#_________________________________________________
	print "\n# (1) move_files: \@dir_1 is  @dir_1 with \"@extensions\"\n";
	for($k=0; $k< @dir_1; $k++){
         chdir($dir_1[$k]) or die "\n# move_files: could not get into $dir_1[$k]\n";
         if($move_given_files and @files){
             for($j=0; $j< @dir_2; $j++){
                for($f=0; $f < @files; $f++){
                   &copy_files("$dir_1[$k]\/$files[$f]", "$dir_2[$j]\/$files[$f]");
                   unlink("$dir_1[$k]\/$files[$f]");
                   push(@final_files, "$dir_1[$k]\/$read_files[$f]");
                }
             }
         }else{
             opendir(DIR1, ".");
             @read_files = readdir(DIR1);
             if(@read_files < 1){ print "\n# move_files: ERROR??, \@read_files is empty\n\n\n"; }
             if($move_all_files){
                for($j=0; $j< @dir_2; $j++){
                   for($f=0; $f < @read_files; $f++){
                      $file="$dir_1[$k]\/$read_files[$f]";
                      if(-f $file){
                          &copy_files($file, "$dir_2[$j]\/$read_files[$f]");
                          unlink($file);
                          push(@final_files, $file);
                      }
                   }
                }
             }else{
                for($j=0; $j< @dir_2; $j++){
                   for($f=0; $f < @read_files; $f++){
                      for($e=0; $e < @extensions; $e++){
                          if($read_files[$f]=~/\.$extensions[$e]$/){
                             $file="$dir_1[$k]\/$read_files[$f]";
                             if(-f $file){
                                 &copy_files("$dir_1[$k]\/$read_files[$f]", "$dir_2[$j]\/$read_files[$f]");
                                 unlink("$dir_1[$k]\/$read_files[$f]");
                                 push(@final_files, "$dir_1[$k]\/$read_files[$f]");
                             }
                          }
                      }
                   }
                }
             }
         }
         chdir($pwd);
   }
   $num_of_files_moved=@final_files;
   print "\n# (2) $num_of_files_moved files have been moved to \"@dir_2\" directory \n\n";
   return(\@final_files);
}



#________________________________________________________________________
# Title     : mv
# Usage     : &mv( \$srcFile, \$dstFile); or  &mv( $srcFile, $dstFile);
#             or &mv(FILEHANDLE1, FILEHANDLE2),  or  &mv(FILEHANDLE1, $output)
# Function  : moves files fast, replacement of 'system("mv xxx xxxx"); '
# Example   : mv("mv.pl", *STDOUT);  # This will print mv.pl contents to your screen.
# Keywords  : move files fast. mv_file, mv_files, move_files, move_file
# Options   :
# Argument  : 2 references of file name or  2 file names.
# Warning   : 27 times slower than 'mv' at prompt.  using system is 32 times slower
# Category  :
# Author    : Larry Wall, Jong
# Version   : 1.4
#--------------------------------------------------------------------
sub mv{
		croak(" Usage:  &mv($file1, $file2)" ) unless(@_ >= 2);

		my($in)=$_[0];
		my($out)=$_[1];

		if( (ref($in) eq 'GLOB') || (ref($in) eq 'FileHandle')){
			*IN_CP = *$in; }  ## for  \*STDOUT like input
		elsif( ref(\$in) eq 'GLOB'){
			*IN_CP = $in;  }
		else{ open(IN_CP, "<$in") or die "Can't open output $in: $!\n";  }

		if( (ref($out) eq 'GLOB') || (ref($_[1]) eq 'FileHandle')){
			*OUT_CP = *$out;   }
		elsif( ref(\$out) eq 'GLOB'){  print "\n2\n";
			*OUT_CP = $out;  ## for  *STDOUT like input
		}else{  open(OUT_CP, ">$out") or die "Can't open output $out: $!\n";  }

		my ($access,$mod) = (stat IN_CP)[8,9];
		syswrite(OUT_CP, $buf, $len) while $len = sysread(IN_CP, $buf, 8192);
		close IN_CP;
		close OUT_CP;
		unlink($in);
		utime $access, $mod, $dstFile;
}

#________________________________________________________________________
# Title     : copy_files
# Usage     : &copy_files( \$srcFile, \$dstFile); or  &cp( $srcFile, $dstFile);
#             or &cp(FILEHANDLE1, FILEHANDLE2),  or  &cp(FILEHANDLE1, $output)
# Function  : copies files fast, replacement of 'system("cp xxx xxxx"); '
# Example   : cp("cp.pl", *STDOUT);  # This will print cp.pl contents to your screen.
# Keywords  : copy files fast. cp_file, cp_files, copy_files, copy_file, cp
# Options   :
# Argument  : 2 references of file name or  2 file names.
# Warning   : 27 times slower than 'cp' at prompt.  using system is 32 times slower
# Category  :
# Author    : Larry Wall, Jong
# Version   : 1.7
#--------------------------------------------------------------------
sub copy_files{
    die (" Usage: copy_files ($file1, $file2)" ) unless(@_ >= 2);

    my($in)=${$_[0]} || $_[0];
    my($out)=${$_[1]} || $_[1];

    if( (ref($in) eq 'GLOB') || (ref($in) eq 'FileHandle')){
                                    *IN_CP = *$in; }  ## for  \*STDOUT like input
    elsif( ref(\$in) eq 'GLOB'){
                                    *IN_CP = $in;  }
    else{ open(IN_CP, "<$in") or warn "Can't open output $in: $!\n";  }

    if( (ref($out) eq 'GLOB') || (ref($_[1]) eq 'FileHandle')){
                                    *OUT_CP = *$out;   }
    elsif( ref(\$out) eq 'GLOB'){  print "\n2\n";
                                    *OUT_CP = $out;  ## for  *STDOUT like input
    }else{  open(OUT_CP, ">$out") or warn "Can't open output $out: $!\n";  }

    my ($access,$mod) = (stat IN_CP)[8,9];
    syswrite(OUT_CP, $buf, $len) while $len = sysread(IN_CP, $buf, 8192);
    close(IN_CP);
    close(OUT_CP);
    utime $access, $mod, $dstFile;
}



#________________________________________________________________________
# Title     : cp
# Usage     : &cp( \$srcFile, \$dstFile); or  &cp( $srcFile, $dstFile);
#             or &cp(FILEHANDLE1, FILEHANDLE2),  or  &cp(FILEHANDLE1, $output)
# Function  : copies files fast, replacement of 'system("cp xxx xxxx"); '
# Example   : cp("cp.pl", *STDOUT);  # This will print cp.pl contents to your screen.
# Keywords  : copy files fast. cp_file, cp_files, copy_files, copy_file
# Options   :
# Argument  : 2 references of file name or  2 file names.
# Warning   : 27 times slower than 'cp' at prompt.  using system is 32 times slower
# Category  :
# Author    : Larry Wall, Jong
# Version   : 1.7
#--------------------------------------------------------------------
sub cp{
    die (" Usage: cp ($file1, $file2)" ) unless(@_ >= 2);

    my($in)=${$_[0]} || $_[0];
    my($out)=${$_[1]} || $_[1];

    if( (ref($in) eq 'GLOB') || (ref($in) eq 'FileHandle')){
                                    *IN_CP = *$in; }  ## for  \*STDOUT like input
    elsif( ref(\$in) eq 'GLOB'){
                                    *IN_CP = $in;  }
    else{ open(IN_CP, "<$in") or warn "Can't open output $in: $!\n";  }

    if( (ref($out) eq 'GLOB') || (ref($_[1]) eq 'FileHandle')){
                                    *OUT_CP = *$out;   }
    elsif( ref(\$out) eq 'GLOB'){  print "\n2\n";
                                    *OUT_CP = $out;  ## for  *STDOUT like input
    }else{  open(OUT_CP, ">$out") or warn "Can't open output $out: $!\n";  }

    my ($access,$mod) = (stat IN_CP)[8,9];
    syswrite(OUT_CP, $buf, $len) while $len = sysread(IN_CP, $buf, 8192);
    close(IN_CP);
    close(OUT_CP);
    utime $access, $mod, $dstFile;
}




#________________________________________________________________________
# Title     : wh
# Usage     :
# Function  : shows the path for a file you want
#             similar to which in UNIX
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   :
#--------------------------------------------------------------------
for $file (@ARGV){
	for $dir (split(/:/, $ENV{PATH})){
	 -e ($path="$dir/$file") && print "$path\n";
	}
}

#________________________________________________________________________
# Title     : condense_script
# Usage     : condense_script.pl  xxxxxx.pl
# Function  : makes compact size subroutines of developed perl codes
# Example   : condense_script.pl th_lib.pl th-test.pl xxx xxxx ....
# Warning   : The only condition is that you need to have 'sub xxxxx' from the
#             first column and the last '}' should be again at the first column
#             This is due to the pattern matching for any sub routines.
# Keywords  :
# Options   : None
# Returns   : xxxxxx.pl.out  but sub routines condensed.
# Argument  : one or more files.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub condense_script{
	my($k, $f, @in, $file, $outfile, $format_found);
	my($sub_contents, $sub_found); $sub_found=0; $format_found=0;
	for($k =0; $k < @_; $k++){
	 if(ref($_[$k]) eq 'ARRAY'){
		 @in = @{$_[$k]};
	 }
	}
	for $f (@in){
	 open(FILE, "$f");
	 $outfile = "$f"."\.exe";
	 open(FILE_OUT, ">$outfile"); $|=1;
	 while(<FILE>){
		if(/^#!\//){ print FILE_OUT "$_"; next;}
		if(/^\#/){ next; }
		if(/^[\s]*$/){ next; }
		#$_ =~ s/(.+)\#.*$/$1/g;
		if(/^format +[\w]* *\=/){ $format_found =1; $_="\n$_"; }
		if(/^\.[\#.]*$/){ $format_found =0; $_="$_\n";}
		if( (/^\} *$/) || (/^\} *\#.*/) ){
		  chomp($_);
		  print FILE_OUT "$sub_contents\}";
		  $sub_found =0; $sub_contents =''; next;}
		if(/^sub +(\w+) *\{/){
		  $_ =~s/[ ]+$//;
		  $sub_contents .= $_;
		  $sub_found=1; next;}
		if($sub_found == 0){
		  print FILE_OUT "$_"; next;  }
		if($sub_found==1){
		  if($format_found == 0){
			 #chomp($_);
			 $_ =~s/^[ ]+//g;
			 $_ =~s/[ ]+$//g;
			 #$_ =~s/(\W)\s+(\W)/$1$2/g;
			 #$_ =~s/\s*(\{)\s*/$1/g ;
			 #$_ =~s/(\})[\s]*$/$1/g;
			 $_ =~s/[\s]*(\})/$1/g;
			 $_ =~s/\t//g;
		  }
		  $sub_contents .= $_; next;
		}
	 }
	}
}

#________________________________________________________________________
# Title     : initialize_code   28/11/1995, jong, /nfs/ind5/A Biomatic /Perl/Utils
# Usage     : &initialze_code;
# Function  : initialize all developing codes by putting Header section infor
# Example   :
# Warning   : This writes over the program you run (itself). temp file is ini_code.temp
# Keywords  :
# Options   :
# Returns   : None
# Argument  : None
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub initialize_code{
	my($user)=getlogin();      my($perl_version) = "Perl$]";
	my($date)=${&get_time(time)};    my($pwd)=`pwd`;   chomp($date, $pwd);
	my($i, @header, @whole_prog, $sepa_line,$date_line,$auth_line);
	my($head_found)=0;
	$sepa_line1 = "#"."_"x88;
	$sepa_line2 = "#"."-"x88;
	$| =1;  ## <<--  no buffer
	my(@head)=( "$sepa_line1\n",
				  "\# Title    : $0  by $pwd, Last Mod: $date\n",    	# 1
				  "\# Function : \n",                     			# 2
				  "\# Usage    : $0 @ARGV\n",            	 		# 3
				  "\# Argument : @ARGV\n",                			# 4
				  "\# Example  : \n",                     			# 5
				  "\# Argument : \n",                     			# 6
				  "\# Returns  : \n",                     			# 7
				  "\# Options  : \n",                     			# 8
				  "\# Tips     : \n",                     			# 9
				  "\# Author   : by $user\n",             			# 10
# Version  :
				  "\# Warning  : $perl_version\n",        			# 11
				  "$sepa_line2\n",    );

	open(SELF, "<$0");
	@whole_prog = <SELF>;

	for ($i=1; $i < @whole_prog; $i++){
	  if( ($whole_prog[$i]=~ /^#_+$/)&&($whole_prog[$i+1] =~ /^(# +[Tt]itle +: *)([\w\.\-]+pl) +/) ){
	  ###############################################################
		  $head_found =1;
		  if($0 == $2){
			  $whole_prog[$i+1] ="$1$0 , $pwd, Last Mod: $date\n"; $i++; next;  } }
	  ###############################################################
	  elsif( ($whole_prog[$i]=~ /^#_+$/)&&($whole_prog[$i+1] =~ /^(# +[Tt]itle +: *)$/) ){
		  $whole_prog[$i+1] ="$1$0 , $pwd, Last Mod $date\n"; $i++; next; }
	  ###############################################################
	  elsif(($whole_prog[$i]=~ /^#_+$/) &&
			  ($whole_prog[$i+1] =~/^(# +[Tt]itle +[:] *[\w\-\.]+ *[Last Mod:]* +[\d+\/\d+\/\d+], +\w+)/)){
		  $i++; next;    }   # <-- when the date is in 11/11/95 format,
	  elsif(($whole_prog[$i]=~ /^#_+$/) &&
			  ($whole_prog[$i+1] =~/^(# +[Tt]itle +[:] *[\w\-\.]+ *[Last Mod:]* +[\d+\-\w+\-\d+], +\w+)/)){
		  $i++; next;    }   # <-- when the date is in 1-Nov-1995 format,
	  elsif(($whole_prog[$i]=~ /^#_+$/) &&                   # Nov30 4:39 1995
			  ($whole_prog[$i+1] =~/^# +[Tt]itle +[:] *[\w\-\.]+ *[Last Mod:]* +[\w+\d+ +\d+:\d+ +\d+]/)){
		  $i++; next;    }   # <-- when the date is in Nov30 4:39 1995 format,
	  ###############################################################
	  elsif( $whole_prog[$i] =~ /^# +[Uu]sage +[:] +$/ ){
		  $whole_prog[$i] = "# Usage    : $0 @ARGV\n"; next;    }
	  ###############################################################
	  elsif( ($head_found==1)&&($whole_prog[$i]=~ /^# +[Ww]arning +:/) &&
				($whole_prog[$i+1] =~ /^#\-+$/) ){  $head_found=2; last; } }
	  ###############################################################

	#####################
	###  Final writing ##
	#####################
	if(   $head_found ==2 ){
	  open (SELF, ">$0"); print SELF @whole_prog; close; }
	elsif($head_found ==0){
	  open (SELF, ">$0"); splice(@whole_prog, 1, 0, @head); print SELF @whole_prog; close; }
}

#________________________________________________________________________
# Title     : parse_persus_file_input
# Usage     : @out_subs=@{&parse_persus_file_input(\@file, $separate_hash_entry_opt)}; or
#             %out_subs=%{&parse_persus_file_input(\@file)};
# Function  : retunrns ALL subroutines with the keys as subroutine names
#             with version like ('show_array2.2' => 'subroutine in one string')
#             It reports the subroutines not found in searched file(s)
# Example   :
# Warning   :
# Keywords  : read_perl_subroutines
# Options   : 'nv' for no version attachment in the keys of returning hash of subroutines
#             'r'  for getting remnant file content rather than the sub routines
#             't'  for leaving the original file without the sub routines taken.
#     $separate_hash_entry_opt=s by s
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#--------------------------------------------------------------------
sub parse_persus_file_input{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($each_sub, %out_subs, %left_out, @lib, $ver, $real_sub_entry_found,
           %final_out_subs, %out_subs, $separate_hash_entry_opt, $long_subname,
           @final_separate_entry_out);
    if($char_opt=~/s/){ $separate_hash_entry_opt = 's';
           print "\n# (INFO) \$separate_hash_entry_opt opt is set"
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parsing input files of perl programs
    #_____________________________________________
    for($i=0; $i < @file; $i++){
				 print "\n# (INFO) Opening $file[$i] to read subroutines\n";
				 open(LIB_FILE, "<$file[$i]")|| die  "\n $file[$i]  <- $! \n";
				 @lib =<LIB_FILE>;

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
				 #  This for loop does not allow return until each sub is finished
				 #_____________________________________________________________________
				 for($j=0; $j < @lib; $j++){
						 my(%out_subs_separate);

						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
						 # Reading the first delimiter line and 'Title' line altogether
						 #_______________________________________________________________
						 if( ($lib[$j]=~/^#+[_\-\*]{10,120} *$/)
									and $lib[$j+1]=~/^(#+ *title *: *([\w\-\.]+))/i ){

									$long_subname=$1;
									$sub_name=$2;
									if($sub_name=~/\.pl$/){ next } ## to avoid the very first headbox

									if($separate_hash_entry_opt){
											 $out_subs_separate{'Title'}=$sub_name;
									}else{
											 $out_subs{"$sub_name"}.="$lib[$j]$long_subname\n";
									}
									$j+=2;

									#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
									# Until I hit end of headbox or sub {} line
									#________________________________________________
									until( $lib[$j]=~/^#+[\-\*_]{10,160} *$/ or
												 $lib[$j]=~/^sub +\w[\w\.]+/ ){
												$lib[$j]=~s/( *)$//;  #<-- removing ending space
												#"""""""""""""""""""""""""""""""""""
												#  Taking version no.
												#___________________________________
												if( ($char_opt !~ /nv/i) && ($lib[$j]=~/^# *version *: *([\d+\.\d+]*) */i) ){
													 if( $1=~/^[ ]*$/){ $ver = '1.0'; }     ##  make null to 1.0
													 elsif( $1=~/^(\d+)$/){ $ver = "$1\.0"; } ### make  2   to 2.0
													 elsif($1=~/^([\d+\.\d+]+)$/){ $ver = $1; } ##  assign version
												}
												if($separate_hash_entry_opt and $lib[$j]=~/^# *(\S\S\S+) *: *(.*)$/){
													 $sub_entry=$1;
													 $out_subs_separate{$sub_entry}=$2;
													 $j++;
												}elsif($separate_hash_entry_opt and $lib[$j]=~/^#  +(.*)$/){
													 $out_subs_separate{$sub_entry}.="    $1\n";
													 $j++;
												}else{
													 $out_subs{"$sub_name"}.="$lib[$j]";
													 $j++;
												}
									 }
									 $out_subs{"$sub_name"}.="$lib[$j]";
									 $j++;    ## essential to remove #------------- line
							 }

							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
							 # Reading sub {   } part , the Content part
							 #__________________________________________
							 if($lib[$j]=~/^sub {1,9}([\w\-]+) *\{/){
									 print "\n# (INFO) Found sub $1\{  \tline ";
									 $sub_name=$1;
									 $out_subs{"$sub_name"}.="$lib[$j]";
									 $out_subs_separate{'Content'}.="$lib[$j]";
									 $j++;
									 until($lib[$j]=~/^\}/){
											 $out_subs{"$sub_name"}.="$lib[$j]";
											 $out_subs_separate{'Content'}.="$lib[$j]";
											 $j++;
											 print "\n# (INFO) reading in the content of sub" if $verbose;
									 }
									 $out_subs{"$sub_name"}.="$lib[$j]";  ## to fetch '}'
									 $out_subs_separate{'Content'}.="$lib[$j]";  ## to fetch '}'
									 $j++;
									 unless(defined($ver)){ $ver = '1.0' }
									 unless($char_opt=~/nv/i){ ## if No version attachment option is set
											 $final_out_subs{"$sub_name$ver"}=$out_subs{$sub_name};
											 $out_subs_separate{'Version'}=$ver;
									 }
									 print "\n# (INFO) Pushing the read lines for one sub to \@final_separate_entry_out";
									 push(@final_separate_entry_out, \%out_subs_separate);
							 }
					 }##------- for @lib loop

					 if($char_opt =~/[rt]/i){
							$left_out{$file[$i]}.=$lib[$j]; ## Remnant file content of the operation
					 }
	   close LIB_FILE;
	   if($char_opt =~/t/i){ ## t is for takeout(take the subroutine out of the original file!!
	       open (LIB_FILE, ">$file[$i]");
	       print LIB_FILE $left_out{$file[$i]};
	       close LIB_FILE;
	   }
					 print $final_out_subs;

	}#""""""""""""" end of for (@file)

	if($char_opt =~ /r/i){
	   return( \%left_out ); # to get the files sans the subroutines.
	}else{
	   if($separate_hash_entry_opt){
							if(@final_separate_entry_out==1){
	          return( $final_separate_entry_out[0]);
	      }else{
	          print "\n\n# (INFO) returning multiple subroutine read";
	          return(\@final_separate_entry_out);
	      }
	   }else{
	      return( \%final_out_subs );
	   }
	}
}

#______________________________________________________________________________
# Title     : parse_cgi_input
# Usage     :
# Function  :
# Example   :
# Keywords  : parse_httpd_server_input, decode_HTTPD_input,
#             decode_URI, decode_encoded_URI, parse_and_assign_URI_variables
#             parse_CGI_input
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.4
#------------------------------------------------------------------------------
sub parse_cgi_input{
    my($i, @input_data, $input, %input_from_httpd_server, $USER_name, $seq_dir_name);
    print "\n#<br> (i) Running parse_cgi_input<br>, Please WAIT!\n";
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Checks if the method is POST and process
    #_____________________________________________________
    if($ENV{'REQUEST_METHOD'} =~/POST/i){
         #print "<br># (i) REQUEST_METHOD was POST <br>";
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Reading in the INPUT from httpd server
         #_____________________________________________________________
         read(STDIN, $input, $ENV{'CONTENT_LENGTH'});
         @input_data=split(/\&/, $input); ## httpd output is a long line of string
         #print "<br> processing \@input_data : @input_data<br>";

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```~~~
         # Assigning the given input from HTTPD server to variables
         #____________________________________________________________
         for($i=0; $i< @input_data; $i++){
                 if($input_data[$i]=~/^ *(\S+)= *(.+) *$/){ ## sub_content=sub ssss{ }
                         $key=$1; $content=$2;
                         $input_from_httpd_server{$key}=$content;
                         #print "<br>$input_from_httpd_server{$key}, YES input for \"$input_from_httpd_server{$key}\" ";
                         $input_from_httpd_server{$key}=~s/\+/ /g;
                         $input_from_httpd_server{$key}=~s/\%40/\@/g;
                         $input_from_httpd_server{$key}=~s/\%09/\t/g;  # %09 is tab
                         $input_from_httpd_server{$key}=~s/\%23/\#/g;
                         $input_from_httpd_server{$key}=~s/\%24/\$/g;
                         $input_from_httpd_server{$key}=~s/\%26/\&/g;
                         $input_from_httpd_server{$key}=~s/\%2B/\+/g;
                         $input_from_httpd_server{$key}=~s/\%27/\'/g;
                         $input_from_httpd_server{$key}=~s/\%28/\(/g;
                         $input_from_httpd_server{$key}=~s/\%29/\)/g;
                         $input_from_httpd_server{$key}=~s/\%3A/\:/g;
                         $input_from_httpd_server{$key}=~s/\%2F/\//g;
                         $input_from_httpd_server{$key}=~s/\%2C/\,/g;
                         $input_from_httpd_server{$key}=~s/\%3B/\;/g;
                         $input_from_httpd_server{$key}=~s/\%7D/\}/g;
                         $input_from_httpd_server{$key}=~s/\%7B/\{/g;
                         $input_from_httpd_server{$key}=~s/\%0D\%0A/\n/g;  ## g is for globally
                 }else{
                         print "<br>$input_data[$i], No input for \"$input_data[$i]\" ";
                 }
         }

    }else{
         print "\n# (E) error at parse_cgi_input, the REQUEST_METHOD $ENV{'REQUEST_METHOD'} is not POST\n";
         print "\n\<\/html\>\n";
         die;
    }
    $USER_name=${&get_username};
    $pwd_dir_name=${&get_pwd_dir};
    $input_from_httpd_server{'PWD'}=$pwd_dir_name;
    $input_from_httpd_server{'USER'}=$USER_name;
    return(\%input_from_httpd_server);
}



#______________________________________________________________________________
# Title     : decode_URI_and_return_variables
# Usage     :
# Function  :
# Example   :
# Keywords  : parse_httpd_server_input, decode_HTTPD_input, parse_cgi_input
#             decode_URI, decode_encoded_URI, decode_passed_URI,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.2
#------------------------------------------------------------------------------
sub decode_encoded_URI{
		my($i, @input_data, $input, %input_from_httpd_server);
		print "\n# (i) Running parse_cgi_input\n";
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Checks if the method is POST and process
		#_____________________________________________________
		if($ENV{'REQUEST_METHOD'} eq "POST"){
			 print "<br># (i) REQUEST_METHOD was POST <br>";
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # Reading in the INPUT from httpd server
			 #_____________________________________________________________
			 read(STDIN, $input, $ENV{'CONTENT_LENGTH'});
			 @input_data=split(/\&/, $input); ## httpd output is a long line of string
			 print "<br> processing \@input_data : @input_data<br>";

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```~~~
			 # Assigning the given input from HTTPD server to variables
			 #____________________________________________________________
			 for($i=0; $i< @input_data; $i++){
					 if($input_data[$i]=~/^ *(\S+)= *(.+) *$/){ ## sub_content=sub ssss{ }
							 $key=$1; $content=$2;
							 $input_from_httpd_server{$key}=$content;
							 print "<br>$input_from_httpd_server{$key}, YES input for \"$input_from_httpd_server{$key}\" ";
							 $input_from_httpd_server{$key}=~s/\+/ /g;
							 $input_from_httpd_server{$key}=~s/\%40/\@/g;
							 $input_from_httpd_server{$key}=~s/\%09/\t/g;  # %09 is tab
							 $input_from_httpd_server{$key}=~s/\%23/\#/g;
							 $input_from_httpd_server{$key}=~s/\%24/\$/g;
							 $input_from_httpd_server{$key}=~s/\%26/\&/g;
							 $input_from_httpd_server{$key}=~s/\%2B/\+/g;
							 $input_from_httpd_server{$key}=~s/\%27/\'/g;
							 $input_from_httpd_server{$key}=~s/\%28/\(/g;
							 $input_from_httpd_server{$key}=~s/\%29/\)/g;
							 $input_from_httpd_server{$key}=~s/\%3A/\:/g;
							 $input_from_httpd_server{$key}=~s/\%2F/\//g;
							 $input_from_httpd_server{$key}=~s/\%2C/\,/g;
							 $input_from_httpd_server{$key}=~s/\%3B/\;/g;
							 $input_from_httpd_server{$key}=~s/\%7D/\}/g;
							 $input_from_httpd_server{$key}=~s/\%7B/\{/g;
							 $input_from_httpd_server{$key}=~s/\%0D\%0A/\n/g;  ## g is for globally
					 }else{
							 print "<br>$input_data[$i], No input for \"$input_data[$i]\" ";
					 }
			 }
		}else{
			 print "\n# (E) error\n";
			 die;
		}
		return(\%input_from_httpd_server);
}




#________________________________________________________________________
# Title     : parse_arguments
# Usage     : &parse_arguments; or  (file1, file2)=@{&parse_arguments};
# Function  : Parse and assign any types of arguments on prompt in UNIX to
#             the various variables inside of the running program.
#             This is more visual than getopt and easier.
#             just change the option table_example below for your own variable
#             setttings. This program reads itself and parse the arguments
#             according to the setting you made in this subroutine or
#             option table in anywhere in the program.
#             It also imports the ENV variables to your program.
#
# Example   : &parse_arguments(1);
#             @files=@{&parse_arguments(1)};
# Warning   : HASH and ARRAY mustn't be like = (1, 2,3) or (1,2 ,3)
# Keywords  : pass_arguments
# Options   : '0'  to specify that there is no argument to sub, use
#              &parse_arguments(0);
#             parse_arguments itself does not have any specific option.
#             '#' at prompt will make a var  $debug set to 1. This is to
#              print out all the print lines to make debugging easier.
#
#             'e=xxxx' for filtering input files by extension xxxx
#
# Returns   : Filenames in a reference of array
#             and input files in an array (file1, file2)=@{&parse_arguments};
# Argument  : uses @ARGV
# Category  :
# Version   : 2.2
#--------------------------------------------------------------------
sub parse_arguments{
		my( $c, $d, $f, $arg_num, $option_table_seen, $n, $option_filtered,
				$option_table_example, $input_line, @input_files,
				$extension);

		&import_ENV_vars; # this enables  $PDB40D automatically assigns the shell var value of $ENV{'PDB40D'}

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#   Checks if there were arguments
		#_______________________________________________________
		if( @ARGV < 1 ){ #<-- If Argument is not given at prompt
				for(@_){  ## this means, parsearguments do not need any argus. So no need to parse anything
						if($_ eq '0'){  last;
						}elsif($_ =~/(\d+)/){ print "\n# (Error) $0 requires $1 number of prompt arguments\n";
								 print "  To get help type \"$0  h\"\n\n\n ";  print chr(7); die;
						}else{
								 print "\n (i) parse_arguments: $_ was given as argument input\n";
								 print chr(7); #<-- This is beeping
								 print "  To get help type \"$0  h\"\n\n\n ";
						}
				}
		}else{  print "\n# (i) parse_arguments:  The program arguments were @ARGV\n"; }

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  If there is only one prompt arg. and is [-]*[hH][elp]*, it calls
		#   &default_help and exits
		#___________________________________________________________________
		if( @ARGV == 1  and  $ARGV[0] =~ /^[\-]*[hH\?][elp ]*$/ ){ print "\n# (i) You put \"@ARGV\" as OPT. Showing help:\n";
					&show_default_help;
					print "\n# (i) Program Normally finished \n\n";
					die;
		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#   Some DEFAULT $debug variables for debugging purposes
		#__________________________________________________________
		&set_debug_option;


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  Checking some input options like 'e=txt' for extension filtering
		#_____________________________________________________________________
		for($i=0; $i< @_; $i++){
				if($_[$i]=~/e=(\S+)/){
										push(@extension, $1);
						}elsif($_[$i]=~/^[\-]?r$/){ ## reversing file order in return stage
						$reverse_out_file_name_order='r';
				}elsif($_[$i]=~/^[\-]*[hH\?][elp ]*$/){ print "\n# (i) You put $_[$i] as OPT. Showing help: ";
						&show_default_help; }
		}

		for($f=0; $f < @ARGV; $f++){
				 if( $ARGV[$f] =~ /\w+[\-\.\w]+$/ and -f $ARGV[$f] ){
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# When extension is defined, filter files by it
							#____________________________________________
							if(@extension > 0){
									for($e=0; $e < @extension; $e++){
															$extension=$extension[$e];
															if($ARGV[$f]=~/\S\.$extension/){
																			push(@input_files, $ARGV[$f] );
															}else{ next }
											}
							}else{
											push(@input_files, $ARGV[$f] );
											next;
							}
				 }
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#     Reading the running program script
		#_______________________________________________________
		&assign_options_to_variables;
		if($HELP == 1){ &default_help }
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# reverse order if 'r' opt is set
		#_____________________________________________
		if($reverse_out_file_name_order){
				@input_files=reverse(@input_files);
		}
		return(\@input_files);
}


#________________________________________________________________________
# Title     : assign_options_to_variables
# Usage     : &assign_options_to_variables(\$input_line);
# Function  : Assigns the values set in head box to the variables used in
#             the programs according to the values given at prompt.
#             This produces global values.
#             When numbers are given at prompt, they go to @num_opt
#              global variable. %vars global option will be made
#
# Example   : When you want to set 'a' char to a variable called '$dummy' in
#             the program, you put a head box commented line
#             '#  $dummy    becomes  a  by  -a '
#             Then, the parse_arguments and this sub routine will read the head
#             box and assigns 'a' to $dummy IF you put an argument of '-a' in
#             the prompt.
# Warning   : This is a global vars generator!!!
# Keywords  :
# Options   : '#' at prompt will make a var  $debug set to 1. This is to
#              print out all the print lines to make debugging easier.
# Returns   : Some globaly used variables according to prompt options.
#             @num_opt,
#
# Argument  : None.
# Version   : 2.8
#--------------------------------------------------------------------
sub assign_options_to_variables{
		my($i, %vars, $j, $op, $z, $n, $symb, $value, $var, %val, @val, $ARG_REG,
			 $option_table_example, @input_options, $first_border_and_title, $sym, @arg);

		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#      Defining small variables for option table reading
		#________________________________________________________________________
		my($g)='gets';                my($if)='if';
		my($is)='is';                 my(@input_files);
		my($o)='or';   my(@arguments) = sort @ARGV;

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#  Assigning global arguments(@num_opt, %vars) variables
		#_______________________________________________________________
		for($i=0; $i< @arguments; $i++){
				 print "\n# \"$arguments[$i]\"";
				 if(($arguments[$i]=~/^(\-?\d+[\.\d+]?)$/)&&   ### it mustn't be a file
						 ( !(-f $arguments[$i]) ) ){                ### getting NUM opt
						 push(@num_opt, $1);
				 }elsif( $arguments[$i]=~/^(\S+)=(\S+)$/){
						 $vars{$1}=$2;
						 print "\n# (1) assign_options_to_variables: Your variable option for \"$1\" is \"$2\"\n";
				 }elsif( $arguments[$i]=~/^(\S+)=[\'\"]([ \S]+)[\'\"]$/){ # just in case Shell fails
						 $vars{$1}="$2";
				 }elsif( $arguments[$i]=~/^(\S+)=([ \S]+)$/){
						 $vars{$1}="$2";
				 }
		}


		#""""""""""""""""""""""""""""""""""""""""""""""""""
		#   Some DEFAULT $debug variables for debugging purposes
		#__________________________________________________________
		&set_debug_option;

		#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		#   The main processing of self
		#_______________________________________________________________
		open(SELF, "$0");    ## opens the program you ran to get the options table.
		while(<SELF>){

			 if( $first_border_and_title > 5 ){  ## This is to make it read only the first headbox.
						last;                            #  $first_border_and_title is an incremental counter.
			 }elsif( /^ *#[_\*\-]{15,}$/ and /^ *# *[Tt][itle]*[ :]*/ ){
						$first_border_and_title++;
						print __LINE__, "# assign_options_to_variables : Title line found\n" if $debug eq 1;
			 }elsif(/^ {0,5}#\s{1,50}([\$\%\@].+)$/){
						$op = $1;  ## $op is for the whole input option line which has $xxxx, @xxx, %xxxx format
						$op =~ s/^(\W\w+.+)(\s+\#.*)$/$1/;  ## This is removing any comments in the line.
						#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
						## matching the following line input format.
						## $av_sc_segment     becomes    a  by  a  # To smooth the SC rates. Gets the averages of
						## $ARG_REG is for arguments regular expression variable.
						##  This reg. exp. matches = 'a or A or E or e' part
						##  which represents alternative prompt arguments possibilities. \=$b$g$is$e$set
						#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# These are optional argument flag like (-a as well as a)
						#__________________________________________________________
						$ARG_REG ='(\S*) *[or=\,]* *(\S*) *[=or\,]* *(\S*) *[=or\,]* *(\S*) *[=or\,]* *(\S*)';

						if(#$op=~/^([\$\@\%])([\w\-]+)\s{0,25}[=|$g|$is](\s+)[bB]y +$ARG_REG/
							 #or
							 $op=~/^([\$\@\%])([\w\-]+)\s{0,25}[=|$g|$is]\s*[\$\@\%]?(\S*) *[bB]y +$ARG_REG/){
																						## $sym     $var        becomes          a [$a...]       by       a -a -A
								 my $sym = $1;  #### The symbols like ($, @, %), '$' in the above.
								 my $var = $2;  #### Actual variable name 'var' from $var, 'av_sc_segment' in the above.
								 my $val = $3;  #### The becoming value  first 'a' in the above.
								 my @arg = ($4, $5, $6, $7, $8);  ## The alternative prompt arguments, second 'a' in the above..
								 print "\n $sym $var $val \n" if $debug==1;
								 print "\n \@arg are @arg \n" if $debug==1;

								 #""""""""""""""""""""""""""""""""""""""""""""""""""""
								 #  Going through the PROMPT args.
								 #""""""""""""""""""""""""""""""""""""""""""""""""""""
								 for($z=0; $z < @arguments; $z++){     ## $arguments[$z]  is from @ARGV
											print "\n# Prompt:  \"$arguments[$z]\"\n" if $debug;
											if($arguments[$z]=~/^\-\w+$/){
													 $arguments[$z] =~ s/\-//;
											}
											for ($i=0; $i < @arg; $i ++ ){
													 if( ("$arg[$i]" eq "$arguments[$z]" )&& ($arg[$i] !~ /\=/)
															 && ($sym eq '$') ){
															 ${"$var"}="$val";
															 if($debug == 1){
																			 print __LINE__," \$${var} is set to \"$1\"\n";
															 }

													 }#'''''''''''''''' $arg = by s=  syntax ~~~~~~~~~~~~~~~~~~~~~~~~~~~
													 elsif( ( $arg[$i] =~ /^(\w+) *\=/ ) &&
															 ( $arguments[$z] =~ /^${1}= *([ \S]+)$/) &&  ## NOTE  '[ \S]+' not \S+
															 ( $sym eq '$') ){
																 ${"$var"}="$1";
																 print "\n# I am assigning $1 to $var\n";
																 if($debug eq 1){ print __LINE__,"\$${var} is set to \"$1\"\n";  }
													 }
											}
								 }
						 }
					}
		 }
		 close(SELF);
}


#________________________________________________________________________________
# Title     : import_ENV_vars
# Usage     :
# Function  : You can use any ENV set variables directly in your
#             program. So, you can say $USER instead of $ENV{'USER'}
# Example   :
# Keywords  : import_Env_vars, import_ENV_variables, set_ENV_variables
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub import_ENV_vars{
		my($caller_package, $env_var_name);
		$caller_package=caller;
		foreach  $env_var_name (keys %ENV){
						 ${"${'caller_package'}::${'env_var_name'}"}=$ENV{$env_var_name}; ## ' ' are necessary
		}
		print "\n# import_ENV_vars: ALL the ENV settings are imported to $0 program\n" if $verbose;
}

#________________________________________________________________________
# Title     : read_head_box
# Usage     : %entries = %{&read_head_box([\$file_to_read, \@BOXED ] )};
# Function  : Reads the introductory header box(the one you see on top of sub routines of
#             Jong's programs.). Make a hash(associative array) to put entries
#             and descriptions of the items. The hash values have new lines '\n' are
#             attached, so that later write_head_box just sorts Title to the top
#             and prints without much calculation.
#             This is similar to read_head_box, but
#             This has one long straight string as value(no \n inside)
#             There are two types of ending line one is Jong's #---------- ...
#             the other is Astrid's  #*************** ...
# Example   : Output is something like
#             ('Title', 'read_head_box', 'Tips', 'Use to parse doc', ...)
# Warning   :
# Keywords  : open_head_box, open_headbox, read_headbox
# Options   : 'b' for remove blank lines. This will remove all the entries
#             with no descriptions
# Returns   : A hash ref.
# Argument  : One or None. If you give an argu. it should be a ref. of an ARRAY
#              or a filename, or ref. of a filename.
#             If no arg is given, it reads SELF, ie. the program itself.
# Version   : 2.8
#--------------------------------------------------------------------
sub read_head_box{
	my($i, $c, $d, $j, $s, $z, @whole_file, $title_found, %Final_out,
	  $variable_string, $TITLE, $title, @keys, $end_found, $line, $entry,
	  $entry_match, $End_line_num, $remove_blank,  $title_entry_null,
	  $end_found, $Enclosed_entry, $Enclosed_var, $blank_counter,
	  $title_entry_exist, $entry_value, $temp_W, $Warning_part, $class
	);

	if(ref($_[0]) eq 'ARRAY'){ ## When array is given
	  @whole_file = @{$_[0]};
	}elsif(-e ${$_[0]}){       ## When filename is given in a ref
	  open(FILE, "${$_[0]}");
	  @whole_file=(<FILE>);
	}elsif(-e $_[0]){          ## When filename is given
	  open(FILE, "$_[0]");
	  @whole_file=(<FILE>);
	}elsif( $_[0] eq 'b'){          ## When filename is given
	  $remove_blank = 1;
	}elsif( ${$_[0]} eq 'b'){          ## When filename is given
	  $remove_blank = 1;
	}else{
	  open(SELF, "$0");
	  @whole_file=(<SELF>);
	}
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	for($i=0; $i<@whole_file; $i++){
	 $whole_file[$i] =~ tr/\t/ {7}/;  ## This is quite important to some parsing!!!
	 #########################################
	 ##  The first and second line of box 1 ##
	 #########################################
	 if( ($whole_file[$i]=~/^#[_\*\~\-\=]{20,}$/)&&    ##  '#______' is discarded
		 ($whole_file[$i+1]=~/ *\# {0,3}([TitlNam]+e) {0,8}: {1,10}([\w\.:]*) *(\S*)/i) ){
		 $TITLE = $1;
		 $title = "$2\n";
								 if($title=~/(\w+)\:\:\w+ *$/){   $class=$1; }
		 $Final_out{'Warning'}.="$3\n";
		 $entry_match=$TITLE; ## The very first $entry_match is set to 'Title' to prevent null entry
		 if($TITLE =~ /^Title|Name$/i){   #
			  if( ($title=~/^\s+$/)||( $title eq "\n") ){
				  $title_entry_null =1;  $title = '';  }    }
		 $Final_out{$TITLE}=$title;
		 $title_found ++ ;   $i++;  ## << this is essential to prevent reading the same line again.
		 last if $title_found > 1;    }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ## The first and second line of box 2, #__________ or #**************
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&($whole_file[$i]=~/^#[_\*]{20,}$/)&&
		 ($whole_file[$i+1]=~/^# {1,3}(\w{1,6}\s{0,2}\w+) {0,7}: {1,5}(.*) */i) ){
		 $title_found ++ ;        $i++;
		 $entry_match=$1;       $entry_value=$2;
		 $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;  ## Capitalize words
		 $Final_out{$entry_match}.= "$entry_value\n";
		 last if $title_found > 1;  next;   }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ##  'Enclosed' : section. After this, everything is read without discrimination ##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($Enclosed_entry == 1)&&($whole_file[$i] =~/^#{1,} {1,}(.*)$/) ){
		 $Final_out{$Enclosed_var}.= "$1\n";    }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ##  With proper entry 1 : for  'eg)'
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&($title_found==1)&&
		 ($whole_file[$i]=~ /^# {1,12}(eg ?\)) {0,8}(.*)/i)){
		 $entry_match='Example';
		 $Final_out{$entry_match}.= "$2\n";
	 }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ##  With PROPER entry 2 : descriptins like. 'Ussage : ssssssxxjkk  kj'
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&($title_found==1)&&
		 ($whole_file[$i]=~ /^# {1,2}(\w{1,4}\s{0,2}\w{1,7}) {0,8}[:\)] {0,6}(.*) */i)){
		 $entry_match=$1;       $entry_value=$2;
		 $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
		 $Final_out{$entry_match}.= "$entry_value\n";
		 if($entry_match=~/^(Enclosed?)$/i){
			  $Enclosed_entry = 1;  $Enclosed_var=$1;        }    }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 #  With proper entry 3 : descriptins like. 'Ussage :', But blank description ##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&($title_found==1)&&
		 ($whole_file[$i]=~ /^# {1,2}(\w{1,4}\s{0,2}\w{1,7}) {0,8}[:\)]( {0,})$/i)){
		 $entry_match=$1;       $entry_value=$2;
		 $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
		 $Final_out{$entry_match}.= " $entry_value\n";
		 if($entry_match=~/^(Enclosed?)$/i){
			  $Enclosed_entry = 1;  $Enclosed_var=$1;      }    }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 #  $option variable matching                ##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1) && ($title_found==1) &&
		 ($whole_file[$i]=~ /^# {1,15}([\$\@]\w+ +[\w=\>]+ +\S+ \w+ \S+ *.*)/ )){
		 $Final_out{$entry_match} .= "$1\n";  }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ###  all space line matching                 ##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&  ##<----- If blank line is matched. Take the line
		 ($title_found==1)&&($whole_file[$i]=~/^# {0,}$/) ){
		 $blank_counter++;
		 if($blank_counter > 2){ $blank_counter--; }
		 else{ $Final_out{$entry_match}.= " \n";  }     }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ###  Anything after 3 space to 12 positions  ##
	 ###  To match 'examples' etc. INC. ':'       ##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&
		 ($title_found==1)&&($whole_file[$i]=~/^#( {2,12})(.+)/) ){
		 $Final_out{$entry_match}.= "$1$2\n"; $blank_counter=0; }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ###  Anything after 1 space to 11 positions  ##
	 ###  To match 'examples' etc. EXC. ':'       ##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($end_found != 1)&&
		 ($title_found==1)&&($whole_file[$i]=~/^# {1,12}([^:.]+)/) ){
		 $Final_out{$entry_match}.= "$1\n"; $blank_counter=0;}

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 ###-------End of the read_box reading--------##
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( ($title_found==1)&&
		 ($whole_file[$i]=~ /^#[\~\=\*\-]{15,}/)){  ## to match '#-----..' or '#******..'(Astrid's)
		 $End_line_num = $i;       $end_found++;
		 last;      }

	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 #  <<<<  Check if there is option table >>>>  #
	 #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 elsif( (/^#{10,} option table of this program   #{10,}/)&&($end_found >=1) &&($title_found==1)){
		 $option_tb_found++; ### This is a global var.
	 }
	} ## < End of for loop


	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	### If title is not there at all     ####
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	@keys=keys %Final_out;
	for(@keys){
	  if(/^Title$/i){    ## No Entry of Title at all??
		  $TITLE =$&;
		  $title_entry_exist = 1;
		  if($Final_out{$_}=~/^ *$/){   ## if Title => Null or just space
			  $title_entry_null = 1;    }  }  }

	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	### When title entry is not there    ####
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if( $title_entry_exist != 1){
		for($s=$End_line_num+1; $s < $End_line_num+20; $s++){
			if( $whole_file[$s] =~ /^sub {1,5}([\w\.]+) {0,6}\{/){
				$Final_out{'Title'} = "$1\n";   last;       }
			elsif( $whole_file[$s] =~/^#________________________+/){
				#######################################
				## Uses running file name as titile  ##
				#######################################
				$Final_out{'Title'} = "$0";     last;
			}else{
				#######################################
				## Uses running file name as titile  ##
				#######################################
				$Final_out{'Title'} = "$0";
			}
		}
	}
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	### When title is blank              ####
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	elsif($title_entry_null ==1){  ## It looks for 'sub xxxxx{ ' line to get title
		### $End_line_num is the last line read.
		for($s = $End_line_num+1; $s < $End_line_num+20; $s++){
			if( $whole_file[$s] =~ /^sub {1,5}(\w+\.*\w*) {0,7}{/){
				$Final_out{$TITLE} = "$1\n";    last;     }
			elsif( $whole_file[$s] =~/^#________________________+/){
				#######################################
				## Uses running file name as titile  ##
				#######################################
				$Final_out{$TITLE} = "$0";     last;
			}else{
				#######################################
				## Uses running file name as titile  ##
				#######################################
				$Final_out{$TITLE} = "$0";
			}
		}
	}
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	## Error handling, if no head box is found   ####
	#"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if($title_found < 1){ print "\nFatal: No headbox found by read_head_box2 sub.\n";  }
	return(\%Final_out);
}               ##<<--- ENd of the sub read_head_box





#________________________________________________________________________
# Title     : read_first_head_box
# Usage     : %entries = %{&read_first_head_box(\$file_to_read )};
# Function  : Reads the header box(the one you see on top of sub routines of
#             Jong's programs.)
#             There are two types of ending line one is Jong's #---------- ...
#             the other is Astrid's  #*************** ...
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 2.0
#--------------------------------------------------------------------
sub read_first_head_box{
	my($title_found, %Final_out, $variable_string, $end_found, $line,
	  $entry, $entry_match );

	open(SELF, "${$_[0]}");
	my(@whole_file)=(<SELF>);
	for(@whole_file){
	 if($title_found > 2){ ### This is to stop reading the file while it has found a box
		 last;              ### already.
	 }elsif( / *\# *([Tt]*itle) *\: *(.*)$/){
		 $Final_out{$1}=$2;
		 $title_found ++
	 }elsif( ($end_found != 1)&&($title_found==1)&&(/^\#(         +[:]* +)(.+)$/) ){
		 $Final_out{$entry_match}.= "\n $1$2";
		# attaches to the last @entry_list element(ref)
	 }elsif( ($end_found < 1)&&($title_found==1)&&(/ *\# *(\w\w\w+) *\: *(.*)/)){
		 $entry_match=$1;
		 ${"count$1"}++;
		 if( ${"count$1"} > 1){
			 $Final_out{$1}.="\n             $2";
		 }else{
			 $Final_out{$entry_match}.= $2; }

	 ### Following is when entry line '# $certain_var = 1 by t'
	 }elsif( ($end_found != 1) && ($title_found==1) && (/^\# *([\$\@\%]+.+)/) ){
		 $line = $1;
		 if($entry_match =~ /[Oo]ption/){  ## if last entry was '# Option :', attach the variable directly.
			 $Final_out{$entry_match} .= "\n             $line";
		 }else{                            ## if last entry wasn't '# Option :', find Option
			 for $entry (keys %Final_out){  ##  and attach the variable to it
				 if ($entry =~ /[Oo]ption/){
					 $Final_out{$entry} .= "\n             $line";
				 }
			 }
		 }
	 }elsif( ($title_found==1)&&(/ *\#[\*\-]{12,}/)){  ## to match '#-----..' or '#*******..'(Astrid's)
		 $end_found++;
	 }elsif( (/^#{10,} option table of this program   #{10,}/)&&($end_found >=1) &&($title_found==1)){
		 $option_tb_found++; ### This is a global var.
	 }
	}
	\%Final_out;
}                  ##<<--- ENd of the sub read_first_head_box


#________________________________________________________________________
# Title     : read_head_boxes
# Usage     : %entries = %{&read_head_box(\$file_to_read, ,,, )};
# Function  : Reads the introductory header box(the one you see on top of sub routines of
#             Jong's programs.). Make a hash(associative array) to put entries
#             and descriptions of the items.
# Example   : @hashes = @{&read_head_boxes(@ARGV)};
#             $num_of_sub = @hashes;
#             print "\n Number of subs was $num_of_sub\n";
# Warning   :
# Keywords  :
# Options   :
# Returns   : A hash ref.
# Argument  : one or more filenames
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------
sub read_head_boxes{
	my($i, $c, $d, $j, $s, $z, @whole_file, $title_found, %Final_out,
	  $variable_string, $TITLE, $title, @keys, $end_found, $line, $entry,
	  $entry_match, $End_line_num, $remove_blank,  $title_entry_null,
	  $end_found, $Enclosed_entry, $Enclosed_var, $blank_counter,
			$title_entry_exist, $entry_value, $temp_W, $Warning_part, @arr_of_hash,
			%temp, %temp2
	);

	for($s=0; $s < @_; $s ++){
	 if( -s $_[$s]){
				my %temp;
		open (IN, "$_[$s]");
		my @whole_file=<IN>;
				my ($end_found, $blank_counter, $TITLE, $title, $entry_match );

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  Reading the whole line of each file
				#_______________________________________
		for($i=0; $i< @whole_file; $i++){
						$whole_file[$i] =~ tr/\t/ {7}/ if($whole_file[$i] =~/\t/);  ## This is important!, converting tab to space
						if( $whole_file[$i]=~/^#_{50,}|#\*{50,}|#\-{50,}|#\~{50,}|#{50,0}$/ and
								$whole_file[$i+1]=~/ *\# {0,3}([Titl]+e) {0,8}: {0,10}([\-\w\.:]*) *(.*)/i ){
								$end_found = 0;
								$TITLE = $1;
								$title = "$2\n";
								$entry_match=$TITLE;
								if($TITLE =~ /^Title$/i){   # title name is given ?
										if( $title=~/\S/ ){
												$temp{$TITLE}=$title;
												$title_found =1 ;
												$i++; next;
										}else{
												$title_entry_null =1;
												$title = '';
										}
								}
						}elsif( !$end_found and $title_found and                ## for eg) line
							 $whole_file[$i]=~ /^# {1,12}(eg ?\)) {0,8}(.*)/i ){
									 $entry_match='Example';
									 $temp{$entry_match}.= "$2\n";
						}elsif( !$end_found and $title_found  and           ## matching the most
							 $whole_file[$i]=~ /^# {0,2}(\w{1,5}\s{0,2}\w{1,7}) {0,8}[:\)] {0,5}(.*) */i ){
									$entry_match=$1;
									$entry_value=$2;
									$entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
									$temp{$entry_match}.= ": $entry_value\n";
						}elsif( !$end_found and $title_found  and
									$whole_file[$i]=~ /^# {0,15}([\$\@]\w+ +[\w=\>]+ +\S+ \w+ \S+ *.*)/ ){
									$temp{$entry_match} .= "$1\n";
						}elsif( ($end_found != 1)&&               ## Blank match
							 ($title_found==1)&&($whole_file[$i]=~/^# {0,}$/) ){
									$blank_counter++;
									if($blank_counter > 2){ $blank_counter--; }
									else{ $temp{$entry_match}.= "\n";  }
						}elsif( ($end0_found != 1)&&               ## matching lines without entry.
							 ($title_found==1)&&($whole_file[$i]=~/^#( {1,12})(.+)/) ){
									$temp{$entry_match}.= "$1$2\n";
									$blank_counter=0;
						}elsif( ($end_found != 1)&&
							 ($title_found==1)&&($whole_file[$i]=~/^# {1,12}([^:.]+)/) ){
									$temp{$entry_match}.= "$1\n";
									$blank_counter=0;
						}elsif( $title_found and $whole_file[$i]=~ /^#[\*\-]{20,}/){       ## to match '#-----..' or '#*******..'(Astrid's)
									$End_line_num = $i;
									$end_found=1;
									$title_found = 0;
									my %temp2=%temp;     ## my is essential here!
									push(@arr_of_hash, \%temp2);
									%temp=();
						}
		}
	 }

	}
	return(\@arr_of_hash);
}

#________________________________________________________________________
# Title     : read_head_box2
# Usage     : %entries = %{&read_head_box(\$file_to_read )};
# Function  : Reads the header box(the one you see on top of sub routines of
#             Jong's programs.). This is similar to read_head_box, but
#             This has one long straight string as value(no \n inside)
#             There are two types of ending line one is Jong's #---------- ...
#             the other is Astrid's  #*************** ...
# Example   : Output is something like
#             ('Title', 'read_head_box', 'Tips', 'Use to parse doc', ...)
# Warning   :
# Keywords  :
# Options   : 'b' for remove blank lines. This will remove all the entries
#             with no descriptions
# Returns   : A hash ref.
# Argument  : One or None. If you give an argu. it should be a ref. of an ARRAY
#              or a filename, or ref. of a filename.
#             If no arg is given, it reads SELF, ie. the program itself.
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------
sub read_head_box2{
	my($i, @whole_file, $title_found, %Final_out, $variable_string,
	  $end_found, $line, $entry, $entry_match, $remove_blank, $j );

	if(ref($_[0]) eq 'ARRAY'){ ## When array is given
	  @whole_file = @{$_[0]};
	}elsif(-e ${$_[0]}){       ## When filename is given in a ref
	  open(FILE, "${$_[0]}");
	  @whole_file=(<FILE>);
	}elsif(-e $_[0]){          ## When filename is given
	  open(FILE, "$_[0]");
	  @whole_file=(<FILE>);
	}elsif( $_[0] eq 'b'){          ## When filename is given
	  $remove_blank = 1;
	}elsif( ${$_[0]} eq 'b'){          ## When filename is given
	  $remove_blank = 1;
	}else{
	  open(SELF, "$0");
	  @whole_file=(<SELF>);
	}

	########################################################################
	for($i=0; $i<@whole_file; $i++){
	 if( ($whole_file[$i]=~/^#________+$/)&&
		 ($whole_file[$i+1]=~/ *\# *(\w+\s{0,2}\w+) *\: *([\w\.\w]+) */) ){
		 my($entry)=$1;
		 my($title) = "$2\n";
		 $Final_out{$entry}=$title;
		 $title_found ++ ;
		 $i++;  ## << this is essential to prevent reading the same line again.
		 last if $title_found > 1;    }


	 elsif( ($end_found != 1)&&($title_found==1)&&
			  ($whole_file[$i]=~ /^# +(\w\w+\s{0,2}\w+) +:(.*)/)){
		 $entry_match=$1;
		 my($value) = "$2\n";
		 ${"count$1"}++;     ### If there were more than 2 identical entries
		 if( ${"count$1"} > 1){
			 $Final_out{$entry_match}.="$value\n"; ### When there are two or more idential entry
		 }
		 else{
			 if(($value eq '')||($value eq ' ')){
				 unless( $remove_blank == 1){
					 $value= " \n";
				 }
			 }
			 unless( $Final_out{$entry_match} eq $value ){    ## when the entry is not described,
				 $Final_out{$entry_match}.= "$value\n";
			 }
		 }  }

	 elsif( ($end_found != 1)&&
		 ($title_found==1)&&($whole_file[$i]=~/^# (.+)$/) ){
		 $Final_out{$entry_match}.= "$1\n"; ## To make a long string line.
	 } # attaches to the last @entry_list element(ref)

	 elsif( ($end_found != 1)&&  ##<--------- If blank line is matched. Take the line
		 ($title_found==1)&&($whole_file[$i]=~/^# *$/) ){
		 $Final_out{$entry_match}.= " \n"; ## To make a long string line.
	 }  # attaches to the last @entry_list element(ref)

	 elsif( ($end_found != 1) && ($title_found==1) &&
		 ($whole_file[$i]=~ /^# +([\$\@\%]+.+)/ )){
		 $Final_out{$entry_match} .= "$1\n";

	 }elsif( ($title_found==1)&&
		 ($whole_file[$i]=~ / *\#[\*\-]{14,}/)){  ## to match '#-----..' or '#*******..'(Astrid's)
		 $end_found++;
		 last;
	 }elsif( (/^#{10,} option table of this program   #{10,}/)&&($end_found >=1) &&($title_found==1)){
		 $option_tb_found++; ### This is a global var.
	 }
	}
	if($title_found < 1){
	  print "\nFatal:  No headbox found by read_head_box2 sub.\n";  }
	\%Final_out;
}                  ##<<--- ENd of the sub read_head_box

#________________________________________________________________________
# Title     : read_all_head_boxes
# Usage     : %entries = %{&read_all_head_box(\$file_to_read )};
# Function  : Reads the header boxes(the one you see on top of sub routines of
#             Jong's programs.)
#             There are two types of ending line one is Jong's #---------- ...
#             the other is Astrid's  #*************** ...
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_all_head_boxes{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($title_found, $Title, $TITLE, $title_found, $end_found, $entry_match,
	 %count, $line, $entry, @boxes);
	if( -e $file[0] ){  ### If file is given it opens the file to find correct_head_box
	  open(OPEN_FILE, "$file[0]");  ## If not given, it uses running script to find it.
	}else{   open(OPEN_FILE, "$0"); }

	my(@whole_file)=(<OPEN_FILE>);

	for(@whole_file){
	 if( / *\# *([Tt][IiTtLlEe]+) *\: *([\w+\.\w+]*)/){
		 $Title = $1;
		 $TITLE = $2;
		 ${"$TITLE"}{$Title}=$TITLE;
		 $title_found = 1;
		 $end_found   = 0;
	 }elsif( ($end_found == 0)&&($title_found==1)&&(/^\#(         +[:]* +)(.+)$/) ){
		 ${"$TITLE"}{$entry_match}.= "\n $1$2";
		# attaches to the last @entry_list element(ref)
	 }elsif( ($end_found == 0 )&&($title_found==1)&&(/ *\# *(\w{3,11}) *\: *(.*)/)){
		 $entry_match=$1;
		 $count{"$TITLE$1"} ++;
		 if( $count{"$TITLE$1"} > 1){
			 ${"$TITLE"}{$1}.="\n             $2";
		 }else{
			 ${"$TITLE"}{$entry_match}.= $2; }

	 ### Following is when entry line '# $certain_var = 1 by t'
	 }elsif( ($end_found != 1) && ($title_found==1) && (/^\# *([\$\@\%]+.+)/) ){
		 $line = $1;
		 if($entry_match =~ /[Oo]ption/){  ## if last entry was '# Option :', attach the variable directly.
			 ${"$TITLE"}{$entry_match} .= "\n             $line";
		 }else{                            ## if last entry wasn't '# Option :', find Option
			 for $entry (keys %{"$TITLE"}){  ##  and attach the variable to it
				 if ($entry =~ /[Oo]ption/){
					 ${"$TITLE"}{$entry} .= "\n             $line";
				 }
			 }
		 }
	 }elsif( ($title_found==1)&&(/ *\#[\*\-]{12,}/)){  ## to match '#-----..' or '#*******..'(Astrid's)
		 $end_found = 1; $title_found=0;
		 push(@boxes, \%{"$TITLE"});

	 }elsif( (/^#{10,} option table of this program   #{10,}/)&&($end_found >=1) &&($title_found==1)){
		 $option_tb_found++; ### This is a global var.
	 }
	}
	if(@boxes > 1){ \@boxes; }
	elsif( @boxes==1){ $boxes[0]; }
}                  ##<<--- ENd of the sub read_head_box

#____________________________________________________________________
# Title    : correct_head_box
# Function : Makes headbox in right and updated format. The most
#            updated headbox format is very this headbox. So, to
#            change all other headbox format, change this first.
# Usage    : just type correct_head_box.pl with a file name.
# Example  : correct_head_box.pl Bio.pl
# Argument : a filename
# Returns  :
# Options  :
# Version  : 1.1
# Keywords :
# Warning  :
#---------------------------------------------------------------
sub correct_head_box{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

	## Reading self and the template headbox in this subroutine.
	my %correct_head_box_entry = %{&read_correct_head_box()};
	for($p=0; $p < @file; $p++){
	  $in_file = $file[$p];

	  ##""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	  ##  Make backup of the input file
	  ##""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	  &cp( "$in_file", "$in_file\.bak$$");
	  print "\n $in_file\.bak$$ is created as a backup \n\n";
	  print chr(7);

	  ##""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	  ##  Open files
	  ##""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	  open(TARGET, "$in_file\.bak$$");
	  open(RESULT, ">$in_file");

	  my(@whole_file) = <TARGET>;
	  my(@keys) = keys %correct_head_box_entry;

	  for($i=0; $i < @whole_file; $i++){   ## <= going through the whole lines
		  my(@BOX);
		  if(($whole_file[$i] =~ /^#___________+/)&&
			  ($whole_file[$i+1] =~ /^# {0,4}([\w+\s*\w+]+) {0,4}: {0,9}([\w+\.\w+]*)/ ) ){
			  my($sub_name)=$2;
			  until( ($whole_file[$i] =~ /^sub +([\w\.]+) *\{/)||($whole_file[$i] =~ /^#\-{15,}/)
			  || ($whole_file[$i] =~ /^#\*{15,}/) ){
				  push(@BOX, $whole_file[$i]);
				  $i++;
			  }

			  ### To get the sub name by reading  'sub xxxxxxx{ ' line after #---------
			  for($z=$i; $z < $i+5; $z++){
				  if($whole_file[$z]=~/^sub +([\w\.]+) *\{/){
					  $sub_name=$1;
					  last;
				  }
			  }

			  my(%Final_out)=%{&read_head_box(\@BOX)};  ## Putting into a hash
			  ### Now I have %Final_out and %correct_head_box_entry
			  my(%correct) =%{&superpose_hash(\%correct_head_box_entry, \%Final_out)};
			  print RESULT @{&write_head_box(\%correct)};

			  until($whole_file[$i]=~/^sub +([\w\.]+) *\{/){  $i++ }
			  if($whole_file[$i]=~/^sub +([\w\.]+) *\{/){
				  until( $whole_file[$i] =~ /^}/){
					  print RESULT $whole_file[$i];
					  $i++;
				  }
				  print RESULT $whole_file[$i];
			  }
		  }elsif($whole_file[$i]=~/^sub +([\w\.]+) *\{/){  ### When there is no headbox at all.
			  $correct_head_box_entry{'Title'}=$1;
			  $correct_head_box_entry{'Version'}='1.0';
			  $correct_head_box_entry{'Author'}=getlogin;
			  print RESULT @{&write_head_box(\%correct_head_box_entry)};
			  print RESULT $whole_file[$i++];
			  until( $whole_file[$i] =~ /^}/){
				  print RESULT $whole_file[$i];
				  $i++;
			  }
			  print RESULT $whole_file[$i];

		  }else{  print RESULT $whole_file[$i]; }
	  }
	}
}

#________________________________________________________________________
# Title     : read_correct_head_box
# Usage     :
# Function  : This reads correct_head_box only.
# Example   :
# Keywords  : read_update_head_box, read update headbox
# Options   : v  for verbose message printing.
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_correct_head_box{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%Final_out, $title_found, $end_found, $entry_match, $title, $TITLE,
	 $blank_counter, $end_found);
	my $UID = getlogin;

	if( -e $file[0] ){  ### If file is given it opens the file to find correct_head_box
	  open(OPEN_FILE, "$file[0]");  ## If not given, it uses running script to find it.
	}else{   open(OPEN_FILE, "$0"); }

	my(@whole_file)=(<OPEN_FILE>);
	my($correct_head_box_name)  = 'correct_head_box';

	DO_IT_AGAIN_WITH_DIFF_NAME:
	for($i=0; $i < @whole_file; $i ++){

	 $whole_file[$i] =~ tr/\t/ {7}/;  ## This is quite important to some parsing!!!

	 #######################################
	 ##  The first and second line of box ##
	 #######################################
	 if( ($whole_file[$i]=~/^#____________+$/)&&    ##  '#______' is discarded
		 ($whole_file[$i+1]=~/ *\# {0,3}([TitlNam]+e) {0,8}: ([read_]*correct_head_box[\.pl]*)/i) ){
		 $TITLE = $1;
		 $title = "$2\n";
		 if($TITLE =~ /^Title|Name$/i){   #
			  if( ($title=~/^\s+$/)||( $title eq "\n") ){
				  $title_entry_null =1;
				  $title = '';
			  }
		 }
		 $Final_out{$TITLE}=$title;
		 $title_found ++ ;
		 $i++;  ## << this is essential to prevent reading the same line again.
		 last if $title_found > 1;    }

	 ############################################################################
	 ## The first and second line of box 2
	 ############################################################################
	 elsif( ($end_found != 1)&&($whole_file[$i]=~/^#____________+$/)&&
		 ($whole_file[$i+1]=~/^# {1,3}(\w{1,6}\s{0,2}\w+) {0,7}: {1,5}(.*) */) ){
		 $title_found ++ ;
		 $i++;
		 $entry_match=$1;
		 $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
		 $Final_out{$entry_match}.= "$2\n";
		 last if $title_found > 1;  next;   }

	 ##################################################################################
	 ##  'Enclosed' : section. After this, everything is read without discrimination ##
	 ##################################################################################
	 elsif( ($Enclosed_entry == 1)&&($whole_file[$i] =~/^#{1,} {1,}(.+)$/) ){
		 $Final_out{$Enclosed_var}.= "$1\n";    }

	 ############################################################################
	 ##  With proper entry 1 : descriptins like. 'Ussage : ssssssxxjkk  kj'      ##
	 ############################################################################
	 elsif( ($end_found != 1)&&($title_found==1)&&
		 ($whole_file[$i]=~ /^# {1,2}(\w{1,4}\s{0,2}\w{1,7}) {0,8}: {1,5}(.*) */)){
		 $entry_match=$1;
		 $entry_match =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e;
		 $Final_out{$entry_match}.= "$2\n";
		 if($entry_match=~/^(Enclosed*)$/i){
			 $Enclosed_entry = 1;  $Enclosed_var=$1;
		 }
	 }

	 ##############################################################################
	 ##  With proper entry 2 : descriptins like. 'Usage :', But blank description ##
	 ##############################################################################
	 elsif( ($end_found != 1)&&($title_found==1)&&
		 ($whole_file[$i]=~ /^# {1,2}(\w{1,4}\s{0,2}\w{1,7}) {0,9}: {0,}$/)){
		 $entry_match=$1;
		 $Final_out{$entry_match}.= "\n";
		 if($entry_match=~/^(Enclosed*)$/i){
			 $Enclosed_entry = 1;  $Enclosed_var=$1;
		 }
	 }

	 ###############################################
	 ### $option variable matching                ##
	 ###############################################
	 elsif( ($end_found != 1) && ($title_found==1) &&
		 ($whole_file[$i]=~ /^# {1,15}([\$\@]\w+ +[\w=\>]+ +\S+ \w+ \S+ *.*)/ )){
		 $Final_out{$entry_match} .= "$1\n";  }

	 ###############################################
	 ###  all space line matching                 ##
	 ###############################################
	 elsif( ($end_found != 1)&&  ##<----- If blank line is matched. Take the line
		 ($title_found==1)&&($whole_file[$i]=~/^# {0,}$/) ){
		 $blank_counter++;
		 if($blank_counter > 2){ $blank_counter--; }
		 else{ $Final_out{$entry_match}.= " \n";  }
	 }

	 ###############################################
	 ###  Anything after 3 space to 12 positions  ##
	 ###  To match 'examples' etc. INC. ':'       ##
	 ###############################################
	 elsif( ($end_found != 1)&&
		 ($title_found==1)&&($whole_file[$i]=~/^# {2,12}(.+)/) ){
		 $Final_out{$entry_match}.= "$1\n"; $blank_counter=0; }

	 ###############################################
	 ###  Anything after 1 space to 11 positions  ##
	 ###  To match 'examples' etc. EXC. ':'       ##
	 ###############################################
	 elsif( ($end_found != 1)&&
		 ($title_found==1)&&($whole_file[$i]=~/^# {1,12}([^:.]+)/) ){
		 $Final_out{$entry_match}.= "$1\n"; $blank_counter=0;}

	 ###############################################
	 ###-------End of the read_box reading--------##
	 ###############################################
	 elsif( ($title_found==1)&&
		 ($whole_file[$i]=~ /^#[\*\-]{15,}/)){  ## to match '#-----..' or '#*******..'(Astrid's)
		 $End_line_num = $i;
		 $end_found++;
		 last;      }

	 ###############################################
	 #  <<<<  Check if there is option table >>>>  #
	 ###############################################
	 elsif( (/^#{10,} option table of this program   #{10,}/)&&($end_found >=1) &&($title_found==1)){
		 $option_tb_found++; ### This is a global var.
	 }
	}
	@keys=keys %Final_out;
	for($i=0; $i < @keys; $i++){
	  if(   $keys[$i] =~/^Example/i){    $Final_out{$keys[$i]}=''; }
	  elsif($keys[$i] =~/^Version/i){    $Final_out{$keys[$i]}=''; }
	  elsif($keys[$i] =~/^Function/i){   $Final_out{$keys[$i]}=''; }
	  elsif($keys[$i] =~/^Options/i){    $Final_out{$keys[$i]}=''; }
	  elsif($keys[$i] =~/^Keywords/i){   $Final_out{$keys[$i]}=''; }
	  elsif($keys[$i] =~/^Class/i){      $Final_out{$keys[$i]}=''; }
	  elsif($keys[$i] =~/^Author/i){     $Final_out{$keys[$i]}=$UID; }
	}
	return(\%Final_out);
}

#____________________________________________________________________
# Title    : write_head_box
# Function : gets a hash ref. and writes the head box for a subroutine
# Usage    :
# Example  :
# Argument :
# Returns  :
# Options  : v  for verbose representation. This will print boxes on STDOUT
#            n  for no '#' leader.
# Version  : 2.2
# Keywords : write_headbox
#---------------------------------------------------------------
sub write_head_box{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($KL)=9;  my($VL)=60; ## key length( like in  # Title )  ## value length
	$num = 80;
	if($char_opt =~ /n/i){
	  $CS=' '; ## Comment symbol. For help display, you can change into ' '
	}else{
	  $CS='#'; ## Comment symbol. Default head_box display.
	}
	for($x=0; $x < @hash; $x++){
		my(%input) = %{$hash[$x]};  my(@keys)= sort (keys %input);
		my(@out);
		###########################################################################
		##  PUTTING an order in the printout entries. To make 'Title' come first
		###########################################################################
		for($i=0; $i < @keys; $i++){
		  if($keys[$i]=~/^Title/i){
			  $temp=$keys[0];	   $keys[0]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Enclosed?/i){
			  $temp=$keys[$#keys];	   $keys[$#keys]=$keys[$i];   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Usage$/i){
			  $temp=$keys[1];	   $keys[1]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Function/i){
			  $temp=$keys[2];	   $keys[2]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Example/i){
			  $temp=$keys[3];	   $keys[3]=$keys[$i];	   $keys[$i]=$temp;
		  }elsif($keys[$i]=~/^Version/i){
			  $temp=$keys[$#keys-2];  $keys[$#keys-2]=$keys[$i];   $keys[$i]=$temp;
			  #### To make null version value to '1.0'
			  if($input{$keys[$#keys-2]}=~/^ *$/){ $input{$keys[$#keys-2]}='1.0'; }
		  }elsif($keys[$i]=~/^Warning/i){
			  $temp2=$keys[$#keys-1]; $keys[$#keys-1]=$keys[$i];   $keys[$i]=$temp2;
		  }
		}
		############################################################
		##       Writing starting line                            ##
		############################################################
		my($start_line) = "$CS".'_'x"$num"."\n";
		if( $char_opt =~ /v/i){
			print $start_line;      }

		my($Enclosed_came);  ## <<-- This should be HERE !
		for( $i =0; $i < @keys; $i++){  #### @keys has been sorted before.
		  my($Len) = length($input{$keys[$i]});  $delimiter = ':';
		  my($entry) = $keys[$i];
		  $entry =~ s#^\S#(($tmp = $&) =~ tr/[a-z]/[A-Z]/,$tmp)#e; ## capitalizing word
		  if($entry=~/^Enclosed?$/i){ $Enclosed_came = 1; }
		  my(@input) = split(/\n+/, $input{$keys[$i]});
		  if(@input > 0){
			  for($j =0; $j < @input; $j++){
				 ## If NO entry name(blank) is given    ##
				 if($j > 0){  ## If the value is a multi line.
					  $entry = '';   $delimiter=' ';    }
				 if( $char_opt =~ /v/i){
					  ######################################################################
					  ###  This is to reduce the entry length of Enclosed content lines   ##
					  ######################################################################
					  if( ($Enclosed_came==1)&&($entry eq '') ){ $KL=2; $VL=80; }
					  printf("$CS %-${KL}s $delimiter %-${VL}s\n", $entry , $input[$j]);    }
				 if( ($Enclosed_came==1)&&($entry eq '') ){ $KL=2; $VL=80; }
				 $out[$k++]=sprintf("$CS %-${KL}s $delimiter %-${VL}s\n", $entry , $input[$j]);
				 if($entry=~/^Enclosed?/){ $Enclosed_came = 1; }   }}
		  ######################################################################
		  ##   If the entries have null descriptions, just print entries  ######
		  ######################################################################
		  elsif(@input ==0){
				 if( $char_opt =~ /v/i){
					  printf("$CS %-${KL}s $delimiter %-${VL}s\n", $entry , ' ');   }
				 $out[$k++]=sprintf("$CS %-${KL}s $delimiter %-${VL}s\n", $entry , ' ');
		  }
		}
		############################################################
		##       Writing  Ending  line                            ##
		############################################################
		$end_line = "$CS".'-'x"$num"."\n";
		if( $char_opt =~ /v/i){   print $end_line;   }
		unshift(@out, $start_line);   push(@out, $end_line);   push(@Final_out, \@out);
	}
	if(@Final_out > 1){ @Final_out; }
	elsif( @Final_out==1){ $Final_out[0] }
} #<--- END of write_head_box



#________________________________________________________________________
# Title     : read_option_table
# Usage     :
# Function  : Reads the option table made by Jong in any perl script. The
#             option table is a box with separators.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub read_option_table{
	my($table_found, @option_tb, $head, );
	 open(SELF, "${$_[0]}");
	 while(<SELF>){
		if( (/^ *#+/) && ( $table_found== 1) ){
		  push (@option_tb, "$_");
		}elsif( ($table_found != 1)&&(/^ *\#+ *[Oo]ption *[Tt]able */) ){
			$table_found=1; $head="############## Option Table  \"$0\"\n"; ##
			push(@option_tb, $head);
		}
		if( ($table_found==1)&&(/^ *###################+ *$/)){  ### to find the end point of reading
			$table_found =0; last; }
	 }
	 return(\@option_tb);
}


#________________________________________________________________________
# Title     : show_default_help
# Usage     : &show_default_help;  usually with 'parse_arguments' sub.
# Function  : Prints usage information and others when invoked. You need to have
#             sections like this explanation box in your perl code. When invoked,
#             show_default_help routine reads the running perl code (SELF READING) and
#             displays what you have typed in this box.
#             After one entry names like # Function :, the following lines without
#             entry name (like this very line) are attached to the previous entry.
#             In this example, to # Function : entry.
# Example   : &show_default_help2; &show_default_help2(\$arg_num_limit);   &show_default_help2( '3' );
#             1 scalar digit for the minimum number of arg (optional),
#             or its ref. If this defined, it will produce exit the program
#             telling the minimum arguments.
# Warning   : this uses format and references
# Keywords  : default_help, show_headbox_help, show_help
# Options   :
# Returns   : formated information
# Argument  :
# Category  :
# Version   : 3.6
#--------------------------------------------------------------------
sub show_default_help{
		 my($i, $pwd, $date, $perl_dir, $arg_num_limit, $head ,$arg_num_limit, $key_press, $e, $help_item,
			 @entries, @entries_I_want_write, $option_tb_found, $extension, $logname,
			 $use_Tk, $tmp, %entries );
		 $logname=getlogin();
		 $pwd =`pwd`;
		 $date=`date`;
		 chomp($date,$pwd);
		 my($not_provided)="--- Value not provided ---\n";
		 my($file_to_read) = $0;

		 for($i=0; $i < @_; $i ++){
				if((ref($_[$i]) eq 'SCALAR')&&(${$_[$i]} =~ /^\d$/)){
						 $arg_num_limit = ${$_[$i]};
				}elsif( (!(ref($_[$i]))) && ($_[$i] =~ /^\d$/)){
						 $arg_num_limit = $_[$i];
				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# Check input arg to see if it was for Tk
				#___________________________________________________
				elsif(ref($_[$i]) eq 'HASH'){
						 @hash_arg_input=%{$_[$i]};
						 for($j=0; $j<@hash_arg_input; $j++){
								 if($hash_arg_input[$j]=~/(TkValue|label2|Configure|scrollbar|checkbutton|frame|Palette)/){
										 $use_Tk='Tk';
								 }
						 }
				}
		 }
		 %entries = %{&read_head_box(\$file_to_read )};

		 if($option_tb_found ==1){
				@option_tb=@{&read_option_table(\$file_to_read)};
		 }

		 @entries = keys %entries;
		 for $help_item (@entries){
				if( $entries{$help_item}=~/^[\W]*$/  and  !defined($entries{$help_item}) ){
						$entries{$help_item}= $not_provided;
				}
		 }

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
		 #  Writing the format <<<<<<<<<<<
		 #________________________________________
		 $~ =DEFAULT_HELP_HEADER;     write;   ## <<--  $~ is the selection operator
		 $~ =DEFAULT_HELP_FORM_1;

		 @entries_I_want_write=sort keys %entries;

		 for ( @entries_I_want_write ){  write  }

		 print chr(7);  print "_"x72,"\n\n";

		 if(@ARGV < $arg_num_limit){ print "\* $0 fataly needs $arg_num_limit arguments\n\n" }

		 if(  $option_tb_found == 1){
				#########  Printing the OPTION table contents <<<<<<<<<<<<
				print "  Press \"Return\" key to see what options $logname\'s \n\n    \"$0\" take... \n";
															$key_press=getc();
				print @option_tb, "\n"x2 if(@option_tb > 0);
		 }
format DEFAULT_HELP_HEADER  =
_____________________________________________________________________
		  __  __      ______     __          _____
		 /\ \/\ \    /\  ___\   /\ \        /\  _ `\
		 \ \ \_\ \   \ \ \__/   \ \ \       \ \ \L\ \
		  \ \  _  \   \ \  _\    \ \ \       \ \ ,__/
		   \ \ \ \ \   \ \ \/___  \ \ \_____  \ \ \/
		    \ \_\ \_\   \ \_____\  \ \______\  \ \_\
		     \/_/\/_/    \/_____/   \/______/   \/_/ V 3.5`
_____________________________________________________________________
.

format DEFAULT_HELP_FORM_1 =
 @<<<<<<<<<: @*
 $_,        $entries{$_}
.

}



#________________________________________________________________________
# Title     : default_help
# Usage     : &show_default_help2;  usually with 'parse_arguments' sub.
# Function  : Prints usage information and others when invoked. You need to have
#             sections like this explanation box in your perl code. When invoked,
#             show_default_help routine reads the running perl code (SELF READING) and
#             displays what you have typed in this box.
#             After one entry names like # Function :, the following lines without
#             entry name (like this very line) are attached to the previous entry.
#             In this example, to # Function : entry.
# Example   : &show_default_help2; &show_default_help2(\$arg_num_limit);   &show_default_help2( '3' );
#             1 scalar digit for the minimum number of arg (optional),
#             or its ref. If this defined, it will produce exit the program
#             telling the minimum arguments.
# Warning   : USE show_default_help, This is not action oriented
# Keywords  : default_help
# Options   :
# Returns   : formated information
# Argument  :
# Category  :
# Version   : 3.4
#--------------------------------------------------------------------
sub default_help{
	my($i, $perl_dir, $arg_num_limit, $head ,$arg_num_limit, $key_press, $e,
	  @entries, @entries_I_want_write, $option_tb_found, $extension, $logname, $tmp );
	$logname=getlogin();
	my($pwd)=`pwd`;
	my($date)=`date`;
	chomp($date,$pwd);
	my($not_provided)="--- not provided ---\n";
	my($file_to_read) = $0;

	for($i=0; $i < @_; $i ++){
	  if((ref($_[$i]) eq 'SCALAR')&&(${$_[$i]} =~ /^\d$/)){
		  $arg_num_limit = ${$_[$i]};  }
	  elsif( (!(ref($_[$i]))) && ($_[$i] =~ /^\d$/)){
		  $arg_num_limit = $_[$i];     }
	}
	my %entries = %{&read_head_box(\$file_to_read )};
	if($option_tb_found ==1){
	 @option_tb=@{&read_option_table(\$file_to_read)};
	}

	@entries = keys %entries;
	foreach $help_item (@entries){
	  ${$help_item}= $not_provided if( ${$help_item}=~/^[\W]*$/  and  !defined(${$help_item}) );
	}
	#""""""""""""""""""""""""""""""""""""""""
	#########  Writing the format <<<<<<<<<<<
	#""""""""""""""""""""""""""""""""""""""""
	$~ =HEADER_HELP;
	write;   ## <<--  $~ is the selection operator
	$~ =DEFAULT_HELP_FORM;

	@entries_I_want_write=sort keys %entries;

	for( @entries_I_want_write ){  write  }

	print chr(7);  print "_"x72,"\n\n";

	if(@ARGV < $arg_num_limit){ print "\* $0 fataly needs $arg_num_limit arguments\n\n" }

	if(  $option_tb_found == 1){
	 #########  Printing the OPTION table contents <<<<<<<<<<<<
	 print "  Press \"Return\" key to see what options $logname\'s \n\n    \"$0\" take... \n";
				 $key_press=getc();
	 print @option_tb, "\n"x2 if(@option_tb > 0);
	}
format HEADER_HELP  =
_____________________________________________________________________
		  __  __      ______     __          _____
		 /\ \/\ \    /\  ___\   /\ \        /\  _ `\
		 \ \ \_\ \   \ \ \__/   \ \ \       \ \ \L\ \
		  \ \  _  \   \ \  _\    \ \ \       \ \ ,__/
		   \ \ \ \ \   \ \ \/___  \ \ \_____  \ \ \/
		    \ \_\ \_\   \ \_____\  \ \______\  \ \_\
		     \/_/\/_/    \/_____/   \/______/   \/_/ V 3.1`
_____________________________________________________________________
.
format DEFAULT_HELP_FORM =
 @<<<<<<<<<: @*
 $_,        $entries{$_}
.
}

#________________________________________________________________________________________
# Title     : print_seq_in_block
# Usage     : &print_seq_in_block (\$block_leng, 'i',\%h1, 'sort', \%h2, \%hash3,,,);
# Function  : gets many refs  for one scalar  or hashes and prints
#               the contents in lines of \$block_leng(the only scalar ref. given) char.
# Options   : 'o' or 'O' => ordered hash print,
#             'n' or'N' => no space between blocks.
#             's' or 'S' => printout sorted by seq names.
#             'i' or 'I' => interlaced print.(this requires identical names in hashes)
#             'v' or 'V' => show sequence start number at each line
#             'g' or 'G' => with gap chars between  aa residues
#              l= for block length. Default is 60 char
#              t= for specifying the length of seq names shown
#              t  for truncating seq names shwn to 12 chars.
#              f= for file output  eg. f=XXXXXX.issa
#   $FILE_HANDLE= by F=
#   $EXclude_these_entries= by E=
#   $NO_screen_print=Q by Q
#
#              r=digit-digit  (eg. 10-70) to take only the defined region of sequences
#            digit-digit  (eg. 10-70) to take only the defined region of sequences
#
#            just digit  for block length
#
#             (all options can be like \$sort
#             while $sort has 's' as value. naked number like 100 will be the
#             block_length. 'i' or 'I' => interlaced print.(this requires
#             identical names in hashes)
# Warning   :
# Keywords  : print_sequence_in_block print_alignment_in_block
# Example   : If there are 3 hashes output will be; (in the order of \%hash3, \%hash2, \%hash1)
#             >> 1st Hash        >> 2nd Hash         >> 3rd Hash
#             Name1  THIS-IS-    Name123  eHHHHHHH   Name123  12222223
#
#             You will get;
#                            Name1    THIS-IS-
#                            Name123  eHHHHHHH
#                            Name123  12222223
#
#             Example of ( no option, DEFAULT )  # Example of ('i' or 'I' option,
#                                                                INTERLACE )
#             6taa           ----ATPADWRSQSIY    #   6taa       ------ATPADWRSQSIY
#             2aaa           ------LSAASWRTQS    #   6taa       ------CCHHHHCCCCEE
#             1cdg           APDTSVSNKQNFSTDV    #   6taa       ------563640130000
#
#             6taa           ------CCHHHHCCCC    #   2aaa       ------LSAASWRTQSIY
#             2aaa           ------CCHHHHCCCC    #   2aaa       ------CCHHHHCCCCEE
#             1cdg           CCCCCCCCCCCCCCCC    #   2aaa       ------271760131000
#
#             6taa           ------5636401300    #   1cdg       APDTSVSNKQNFSTDVIY
#             2aaa           ------2717601310    #   1cdg       CCCCCCCCCCCCCCCCEE
#             1cdg           6752327236000000    #   1cdg       675232723600000000
#
#             Example of('s' or 'S' option,SORT) # Example of ('o' or 'O' option,
#                                                        ORDERED by input hashes )
#             1cdg           APDTSVSNKQNFSTDV    #   6taa       ------ATPADWRSQSIY
#             2aaa           ------LSAASWRTQS    #   2aaa       ------LSAASWRTQSIY
#             6taa           ------ATPADWRSQS    #   1cdg       APDTSVSNKQNFSTDVIY
#
#             1cdg           CCCCCCCCCCCCCCCC    #   6taa       ------CCHHHHCCCCEE
#             2aaa           ------CCHHHHCCCC    #   2aaa       ------CCHHHHCCCCEE
#             6taa           ------CCHHHHCCCC    #   1cdg       CCCCCCCCCCCCCCCCEE
#
#             1cdg           6752327236000000    #   6taa       ------563640130000
#             2aaa           ------2717601310    #   2aaa       ------271760131000
#             6taa           ------5636401300    #   1cdg       675232723600000000
#
# Argument  : many refs  for hash (one for bottm, one for top, etc,top hash is usually
#               to denote certain caculations or results of the bottom one
# Category  :
# Version   : 2.1
#-----------------------------------------------------------------------------------
sub print_seq_in_block{
    my($c, $d, $e, $f, $k, $i, $s, $t,@in,$gapped, $graphical_rep_of_str,
        $put_reliability_line, $final_output_pred_name,$long_seq, @temp,
        %input0,%input1,%input2,%input3,%input4, @names0, @names1, @names2, @names3,
        $intl,$z,$diff,$offset, $truncate_name_to_10_char, $trunc_name_to, $block_range,
        $write_out_file, $bl, $sort, $n_space, $ordered, $gap_char, @seq_names,
        $na,$larg,$names,$seq, $visual_num, $n, @in_ar, $bl_passed, %first_hash,
        $FILE_HANDLE, $EXclude_these_entries, %EXclude_these_entries, $NO_screen_print);
    $bl=60; $n=13;
    $sort=$larg=$n_space=$ordered=0; $gap_char ='-';

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # ARG handling, Pretty ugly?
    #__________________________________________________________________
    for($k=0; $k< @_ ;$k++){
        if( !ref($_[$k]) ){    # when inputs are not ref.
             if($_[$k]=~ /^[\-]*([\d]{1,4})$/){   $bl=$1 if $1>0; $bl_passed=1 if $1>0; next;}  #<--   option handling
             if($_[$k]=~ /^[\-sS]$/)   {          $sort =    1; next;}
             if($_[$k]=~ /^Q$/)   {               $NO_screen_print = 1; next;}
             if($_[$k]=~ /^[\-nN]$/)   {          $n_space = 1; next;}
             if($_[$k]=~ /^[\-iI]$/)   {          $intl =    1; next;}
             if($_[$k]=~ /^[\-]*[g]+/i){          $gapped   =  1; next;}
             if($_[$k]=~ /^[\-]*[v]+/i){          $visual_num =  1; next;}
             if($_[$k]=~ /^[\-]*l *= *(\d+)/i){   $bl =  $1; next;}
             if($_[$k]=~ /[r=]?(\d+\-\d+)$/i){    $block_range = $1; next;}                 # options, be it number or
             if($_[$k]=~ /^[\-]*t=(\d+)/i){       $trunc_name_to = $1; next;}                 # options, be it number or
             if($_[$k]=~ /^[\-]*[t]/i) {          $truncate_name_to_10_char = 1; next;}                 # options, be it number or
             if($_[$k]=~ /f=(\S+)/) {             $write_out_file = $1; next;}                 # options, be it number or
             if($_[$k]=~ /F=(\S+)/) {             $FILE_HANDLE = $1; $write_out_file=1; next; }
             if($_[$k]=~ /E=(.+)/) {             $EXclude_these_entries = $1; next; }
             if($_[$k]=~ /^[\-oO]$/){             $ordered = 1;      }
        }elsif( ref($_[$k]) eq "SCALAR" ){     #<--   option handling
             if(${$_[$k]}=~ /^[\-]*([\d]{1,4})$/){$bl=$1 if $1>0; $bl_passed=1 if $1>0; next;}      # the scalar input
             if(${$_[$k]}=~ /^[\-sS]$/){          $sort = 1;next;}                 # should shorter than 5
             if(${$_[$k]}=~ /^Q$/){               $NO_screen_print = 1; next;}
             if(${$_[$k]}=~ /^[\-nN]$/){          $n_space = 1;next;}              # to be recognized as
             if(${$_[$k]}=~ /^[\-iI]$/){          $intl = 1;next;}                 # options, be it number or
             if(${$_[$k]}=~ /^[\-]*[g]/i){        $gapped =   1; next;}                 # options, be it number or
             if(${$_[$k]}=~ /^[\-]*[v]/i){        $visual_num = 1; next;}                 # options, be it number or
             if(${$_[$k]}=~ /^[\-]*l *= *(\d+)/i){$bl =  $1; next;}
             if(${$_[$k]}=~ /[r=]?(\d+\-\d+)$/i){ $block_range = $1; next;}                 # options, be it number or
             if(${$_[$k]}=~ /^[\-]*t=(\d+)/i){    $trunc_name_to = $1; next;}                 # options, be it number or
             if(${$_[$k]}=~ /^[\-]*[t]$/i){       $truncate_name_to_10_char = 1; next;}                 # options, be it number or
             if(${$_[$k]}=~ /f=(\S+)/i){          $write_out_file = $1; next;}                 # options, be it number or
             if(${$_[$k]}=~ /F=(\S+)/){           $FILE_HANDLE = $1; $write_out_file=1; next; }
             if(${$_[$k]}=~ /E=(.+)/){           $EXclude_these_entries = $1; next; }
             if(${$_[$k]}=~ /^[o]$/i){            $ordered = 1; }                  # or chars.
        }
        elsif(ref($_[$k]) eq "HASH") {  push(@in,  $_[$k]); } #<-- seqn handling hash
        elsif(ref($_[$k]) eq "ARRAY"){  push(@in, &convert_arr_and_str_2_hash($_[$k], $k));} #<-- conv array to hash.
        elsif(ref($_[$k]) eq "SCALAR"){ push(@in, &convert_arr_and_str_2_hash($_[$k], $k));} #<-- conv array to hash.
    }

    if($write_out_file and !$FILE_HANDLE){
        $FILE_HANDLE='FILE_OUT';
        open($FILE_HANDLE, ">$write_out_file") || die ;
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # These hash key entries will be removed in the printing out as these are not sequence names and values
    #________________________________________________________________________________________________________
    if($EXclude_these_entries=~/\w\W\w/){
        %EXclude_these_entries= map { $EXclude_these_entries{$_}=$_; } split(/\W+/, $EXclude_these_entries);
    }else{
        $EXclude_these_entries{$EXclude_these_entries}=$EXclude_these_entries;
    }
    print $FILE_HANDLE "\n# Created by print_seq_in_block sub in $0\n\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #  HASH input handling
    #_____________________________________________________
    for($k=0; $k< @in; $k++){
         if(ref($in[$k]) eq "HASH"){
              %first_hash=%{$in[$k]};
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``~
              # If the hash is a form of advanced sec. str one. Like Predator output file
              #________________________________________________________________________________
              if($first_hash{0}->[0]=~/\w$/){
                  $put_reliability_line='r';
                  &write_pred_files(\%first_hash, $final_output_pred_name,
                                    $graphical_rep_of_str, "$put_reliability_line", 's');
                  splice(@in, $k, 1); $k--;
                  next;
              }
              %{"input$k"}=%{$in[$k]};

              if($sort == 1){   ## When the keys should be sorted.
                         $keys_long= join("", keys(%{"input$k"}) );   ## makes a string of keys to do the next
                         if ($keys_long =~ /[\d\.]+/){                ## see if there is digit.
                                         @{"names$k"}= sort {$a<=>$b} keys(%{"input$k"}); # numerical sort of keys(seq names)
                         }elsif($keys_long =~ /[\w\.\,]+/){          ## if there is no digits,
                                         @{"names$k"}= sort keys(%{"input$k"});  ## do the normal string sort
                         }
              }elsif($sort != 1){  @{"names$k"}= keys(%{"input$k"});   }
              if($gapped != 1){
                   for($i=0; $i< @{"names$k"}; $i++){
                     if(${"input$k"}{${"names$k"}[$i]} =~ /\,/){ ${"input$k"}{${"names$k"}[$i]}=~ s/\,//g;  }
                   }
              }
         }
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Getting the largest sequence length size ($larg)
         #______________________________________________________
         @temp=keys %{"input$k"};
         for($i=0; $i<@temp; $i++){
            if(ref(${"input$k"}{$temp[$i]}) eq 'ARRAY'){
               if(@{${"input$k"}{$temp[$i]}} > $larg){   $larg=@{${"input$k"}{$temp[$i]}};  }
            }else{
               if(length(${"input$k"}{$temp[$i]}) > $larg){ $larg=length(${"input$k"}{$temp[$i]}) }
            }
         }
	}

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
	#     Following is to make ends of sequences neat and crop seq defined by $block_range, (eg. 10-70)
	#__________________________________________________________________________________________________
	for($z=0; $z < @in; $z++){
         for($t=0;$t < @{"names$z"}; $t ++ ){
             $na=${"names$z"}[$t];
             if($block_range=~/(\d+)\-(\d+)/){
                 $start=$1; $length=$2-$1;
                 if($length < 0){   print "# $na \t \$block_range: $block_range, WRONG !, $2 is less than $1 !!!\n", chr(7); }
                 ${"input$z"}{$na}=substr(${"input$z"}{$na}, $start, $length);      }
             $s=${"input$z"}{$na};
             $larg=length($s) if length($s)> $larg;
             $n=length($na) if length($na) > $n;
             if($s =~ /\-/){ $gap_char='-'; }elsif( $s =~ /\./){  $gap_char='.';  }
             if (length($s)<$larg){
                 $offset=length($s);
                 $diff=$larg-$offset;  substr($s,$offset,$larg)="$gap_char"x$diff;
             }
         }
	} print "\n" unless $NO_screen_print;

	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#     Following is the core code for making block printing
	#_______________________________________________________________________
	if($ordered== 1){
         $bl=$larg if (($larg < 60)&&($bl_passed != 1));
         for($c=0; $c < @in; $c++){
             for($k=0; $k < $larg; $k += $bl){
                 for($i=0; $i < @{"names$c"}; $i++){
                     $names= ${"names$c"}[$i];
                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # When the seq is a ref. of array, make it a string
                     #__________________________________________________
                     if(ref(${"input$c"}{$names}) eq 'ARRAY'){
                        $seq=join('', @{${"input$c"}{$names}});
                     }
                     $seq= substr( ${"input$c"}{$names},  $k,  $bl);
                     $seq=join(" ", split(/\,/, $seq)) if $gapped == 1;
                     if($visual_num==1){
                        printf ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) unless $NO_screen_print;
                        printf $FILE_HANDLE ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) if $write_out_file;
                     }else{
                        printf ("\%\-$n\s \%\-$bl\s\n", $names, $seq) unless $NO_screen_print;
                        printf $FILE_HANDLE ("\%\-$n\s \%\-$bl\s\n", $names, $seq) if $write_out_file;
                     }
                 }print "\n" unless($n_space == 1 or $NO_screen_print);
             }print "\n" unless $NO_screen_print;
         }
	}elsif($intl==1){   ## When Interlace option is set
         $bl=$larg  if (($larg < 50)&&($bl_passed != 1));
         for($k=0; $k < $larg; $k+=$bl){
              for($i=0; $i < @{"names0"}; $i++){
                  for($c=0; $c <= $#in; $c++){
                       $names=${"names$c"}[$i];
                       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                       # When the seq is a ref. of array, make it a string
                       #__________________________________________________
                       if(ref(${"input$c"}{$names}) eq 'ARRAY'){
                          $seq=join('', @{${"input$c"}{$names}});
                       }
                       $seq=substr(${"input$c"}{$names}, $k, $bl);
                       $seq=join(" ", split(/\,/, $seq)) if $gapped == 1;
                       if($visual_num==1){
                            printf ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) unless $NO_screen_print;
                            printf $FILE_HANDLE ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) if $write_out_file;
                       }else{
                            printf ("\%\-$n\s \%\-$bl\s\n", $names, $seq) unless $NO_screen_print;
                            printf  $FILE_HANDLE ("\%\-$n\s \%\-$bl\s\n", $names, $seq) if $write_out_file;
                       }
                  }print "\n" unless($n_space ==1 or $NO_screen_print);
              }print "\n" unless $NO_screen_print;
         }print "\n" unless($n_space ==1 or $NO_screen_print);
	}else{
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#           This is the default
		#___________________________________________________________
        for($k=0; $k < $larg; $k+=$bl){
            $bl=$larg if (($larg < 50) and ($bl_passed != 1));
            for($c=0; $c < @in; $c++){  # $n is the name space size
                 @seq_names = @{"names$c"};
                 for($i=0; $i < @seq_names; $i++){
                      $names=$seq_names[$i];
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # Excluding specified (by E=) seq entries
                      #_____________________________________________________________________
                      if($EXclude_these_entries{$names}){ next; }
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # When the seq is a ref. of array, make it a string
                      #__________________________________________________
                      if(ref(${"input$c"}{$names}) eq 'ARRAY'){
                         $long_seq=join('', @{${"input$c"}{$names}});
                      }else{
                         $long_seq=${"input$c"}{$names};
                      }
                      $seq=substr($long_seq, $k, $bl);

                      $seq=join(" ", split(/\,/, $seq)) if $gapped == 1;
                      if($visual_num==1){
                          if($trunc_name_to=~/(\d+)/){   $n=$1; $truncate_name_to_10_char=0;
                              $names=substr($names, 0, $n);
                              printf ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) unless $NO_screen_print;
                              printf $FILE_HANDLE ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) if $write_out_file;
                          }elsif($truncate_name_to_10_char){      $names=substr($names, 0, 12);
                              printf ("%-12s  %4d \%\-$bl\s\n", $names, ($k+1), $seq)  unless $NO_screen_print;
                              printf  $FILE_HANDLE ("%-12s  %4d \%\-$bl\s\n", $names, ($k+1), $seq) if $write_out_file;
                          }else{
                              printf ("\%\-$n\s %4d %-\$bl\s\n", $names, ($k+1), $seq) unless $NO_screen_print;
                              printf $FILE_HANDLE ("\%\-$n\s %4d \%\-$bl\s\n", $names, ($k+1), $seq) if $write_out_file;
                          }
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      #   >> Typical DEFAULT, down here! <<
                      #________________________________________
                      }else{
                          if($trunc_name_to=~/(\d+)/){
                              $n=$1;
                              $truncate_name_to_10_char=0;
                              $names=substr($names, 0, $n);
                              printf ("\%\-$n\s \%\-$bl\s\n", $names, $seq) unless $NO_screen_print;
                              printf $FILE_HANDLE ("\%\-$n\s \%\-$bl\s\n", $names, $seq) if $write_out_file;
                          }elsif($truncate_name_to_10_char){      $names=substr($names, 0,12);
                              printf ("%-12s  \%\-$bl\s\n", $names, $seq) unless $NO_screen_print;
                              printf $FILE_HANDLE ("%-12s  \%\-$bl\s\n", $names, $seq) if $write_out_file;
                          }else{
                              printf ("\%\-$n\s \%\-$bl\s\n", $names, $seq) unless $NO_screen_print;
                              printf  $FILE_HANDLE ("\%\-$n\s \%\-$b\s\n", $names, $seq) if $write_out_file;
                          }
                      }
                 }print "\n" unless($n_space ==1 or $NO_screen_print);
            }
            print "\n" unless $NO_screen_print;
            print $FILE_HANDLE "\n";
		}
	}
}







#________________________________________________________________________
# Title     : print_seq_in_columns
# Usage     : &print_seq_in_block (\$block_leng, 'i',\%h1, 'sort', \%h2, \%hash3,,,);
# Function  : gets many refs  for one scalar  or hashes and prints
#               the contents in lines of \$block_leng(the only scalar ref. given) char.
# Example   :  With command 'print_seq_in_columns.pl c2 s2', you get:
#
#		    name1 11111111  name1 22222
#		    name2 11        name2 2222222
#		    name3 1111111   name3 22222
#		    name4 11111     name4 2222
#		    name5 11111     name5 222
#
#		    name1 3333      name1 4444
#		    name2 3333      name2 444
#		    name3 333       name3 4
#		    name4 333       name4 4444
#		    name5 3333      name5 4444444
#
# Warning   :
# Keywords  :
# Options   : c, i, s
# Returns   :
# Argument  : many refs  for hash (one for bottm, one for top, etc,top hash is usually
#               to denote certain caculations or results of the bottom one
# Category  :
# Version   : 1.1
#---------------------------------------------------------------------------
sub print_seq_in_columns{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my($column_num, $bl_passed, @in_ar, $packed, $diff,$offset, $entry_match,
	  $gap_chr, $intl, $line, $na, $name, $larg,$names,$seq, $n_space, $offset,
	  $ordered, $output, $out_string, $pre, $pwd, $sort, $string, $tmp, $temp,
	  $title_found, $win_size, @arg_output, @in, @string, @k, @keys, @names,
	  @out_hash, @out_hash_final, @output_box, @outref, @read_files, @temp,
	  %hash, %input, %out_hash_final, $single_column, $largest_elem_count   );
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


	$gap_char='-';

	sub numerically{ $a <=> $b; }

	######################################
	####    Sub argument handling     ####
	######################################
	if($char_opt =~/n/i){      $n_space    = 1; }
	if($char_opt =~/i/i){      $intl       = 1; }
	if($char_opt =~/s(\d+)/i){ $sp         = $1  }
	if($char_opt =~/c(\d+)/i){ $column_num = $1  }
	if($char_opt =~/c[^\d]/i){ $column_num = 1 ; } ## If just -c is given, you print single column
	if($num_opt  =~/(\d+)/i){ $bl  = $1; $bl_passed=1 if $1>0;}
	$column_num = @hash unless( defined ($column_num)  );
	$column_num = @hash if( $column_num > @hash);
	$column_num = 1 if $column_num < 1;  ## To make  '-c0' as -c1.
	if(defined($sp)){  $sp =" "x$sp }else{ $sp='  '; }


	#########  HASH input handling ############
	## This part assigns hash keys into @names1, @names2, etc, according to the no. hash input.
	for($k=0; $k<@hash; $k++){
		 %hash=%{$hash[$k]};
		 if($sort == 1){      ## <<< this does automatic numerical handling >>>>
			 $keys_long=join("", keys %hash );
			 if ($keys_long =~ /[\d\.]+/){
				 @{"names$k"}= sort numerically keys %hash; }   # numerical sort
			 elsif($keys_long =~ /[\w\.\,]+/){
				 @{"names$k"}= sort keys(%hash);  # normal sort
			 }
		 }
		 else{
			  @{"names$k"}= keys(%hash);
			  $largest_elem_count=@{"names$k"} if (@{"names$k"} > $largest_elem_count);
		 }
		 #### IF sequence is like   'A,B,C,D,E,..' delimited by ',',  remove ','
		 for($i=0; $i< @{"names$k"}; $i++){
				  $string = $hash{${"names$k"}[$i]};
				  $larg=length($string) if $larg < length($string);
				  if($string =~ /\,/){
					  $string=~ s/\,//g;
				  }
		}

	}
	## The output of above part is nothing more than  @names1, @names2, ...


	######################################
	####### Sub argument handling ########
	######################################

	for($z=0; $c < @hash ; $c++){
	 %hash = %{$hash[$c]};
	 for($t=0;$t< @{"names$c"};$t++){
		 $s=$hash{${"names$c"}[$t]};
		 $bl = $larg if($bl_passed != 1);
		 $n = length($na)+1 if length($na) > $n;
		 if($s =~ /\-/){ $gap_char='-'; }elsif( $s =~ /\./){  $gap_char='.';  }
		 if (length($s)<$larg){
			 $offset=length($s);
			 $diff=$larg-$offset;
			 substr($s,$offset,$larg)="$gap_char"x$diff;
		 }
	 }
	}
	if($intl==1){
	  $bl=$larg if ($bl_passed != 1);
	  for($k=0; $k < $larg; $k+=$bl){
			 for($c=0; $c < @hash; $c++){  # $n is the name space size
				%hash = %{$hash[$c]};
				for($i=0; $i < @{"names$c"}; $i++){
					 $names=${"names$c"}[$i];
					 $seq  =substr($hash{$names},$k,$bl);
					 printf ("%-${n}s %-${bl}s  ", $names, $seq);
				}
				print "\n" unless($n_space ==1);
			 }
			 print "\n";
	  }
	}
	#######################################################
	###   This is the default printing part.
	#######################################################
	else{     # bl is the column width. should be at least 1
	  $bl=$larg if ($bl_passed != 1);
	  for($k=0; $k < $larg; $k+=$bl){
		  # following is for various column number printing
		  for($m=0; $m < @hash; $m+=$column_num){
			  for($i=0; $i < $largest_elem_count ; $i++){
				  for($c=$m; $c < $column_num+$m; $c++){
					  %hash = %{$hash[$c]};
					  @keys = keys (%hash);
					  $names= $keys[$i];
					  #print "\n$names ====> \n";
					  $seq=substr($hash{$names}, $k, $bl);
					  printf ("%-${n}s %-${bl}s${sp}", $names, $seq);
				  }
				  print "\n";
			  }
			  print "\n" if @names0 > 1;
		  }
	  }
	  print "\n" unless($n_space ==1);
	}
}

#________________________________________________________________________
# Title     : convert_arr_and_str_2_hash
# Usage     : ($hash1, $hash2)=&convert_arr_and_str_2_hash(\$input, \$input2, '1', '2'.. );
#             * This is the combination of convert_string_to_hash & convert_array_to_hash
# Function  : makes hash(es) out of array(s)
#             if ordering digit(s) is put, it orders the keys according to it.
#             if ordering digit is not increased by one, the difference is used
#             as the increasing factor. No option results in
#             array_1, array_2, array_3...
#
# Example   : &print_seq_in_block(&convert_arr_and_str_2_hash(\@input,\@input2,\@input3 ));
#             &convert_arr_and_str_2_hash(\$input1,\$input2, '2' );
#             results in; (ordering starts from the given '2')
#                          array_2       input1 arraystring
#                          array_3       input2 arraystring
#
#             one more exam
#                          string_6       This is st                  and 3 strings)
#                          string_10      This is st
#                          array_2        111233434242
#                          array_6        111233434242
#                          array_10       111243424224
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more ref. of hashes.
# Argument  : one or more ref. of arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub convert_arr_and_str_2_hash{ my(@out_ref_hash_str,@s,$i,@w,@c,$diff,$c);
	undef(%temp); undef(%temp2);
	for($i=0; $i<@_; $i++){
	 if ( (ref($_[$i]) eq 'SCALAR')&&(${$_[$i]}=~/^([\d]{1,5})$/) ){
		 push(@c, $1);      }
	 elsif( (ref($_[$i]) eq 'SCALAR')){
		 push(@s, ${$_[$i]});     }
	 elsif( (ref($_[$i]) eq 'ARRAY')){
		 push(@w, join("", @{$_[$i]}));    }
	 elsif( (!ref($_[$i])) && ($_[$i]=~/^([\d]{1,5})$/)){
		 push(@c, $1);      }
	 else{ print "\n There is an odd arg. check convert_arr_and_str_2_hash in $0\n\n";
		print chr(007);   die;  }  }
	for($i=0; $i<@s; $i++){ my($string)=$s[$i]; my(%temp); ###### array handling
	  if(defined($c[$i])){ $temp{"string_$c[$i]"}=$string;
		  push( @out_ref_hash_str, \%temp); $c=$c[$i]; $diff =$c[$i]-$c[$i-1];      }
	  elsif( !(defined($c[$i])) ){
		  if($diff ==0){	$c=$c+$diff+1; }else{ ($c=$c+$diff) };
		  $temp{"string_$c"}=$string; push( @out_ref_hash_str, \%temp);   } }
	for($i=0; $i<@w; $i++){ my($string)=$w[$i]; my(%temp2);###### string handling
	  if(defined($c[$i])){ $temp2{"array_$c[$i]"}=$string; push( @out_ref_hash_str, \%temp2);
		  $c=$c[$i]; $diff =$c[$i]-$c[$i-1];      }
	  elsif( !(defined($c[$i])) ){
		  if($diff ==0){	$c=$c+$diff+1; }else{ ($c=$c+$diff) };
		  $temp2{"array_$c"}=$string;  push( @out_ref_hash_str, \%temp2); } }
	if( @out_ref_hash_str == 1 ){ return($out_ref_hash_str[0] ); }
	elsif(@out_ref_hash_str > 1){ return(@out_ref_hash_str);}
}

#________________________________________________________________________
# Title     : convert_string_to_hash
# Usage     : ($hash1, $hash2)=&convert_string_to_hash(\$input, \$input2, '1', '2'.. );
# Function  : makes hash(es) out of string(s)
#             if ordering digit(s) is put, it orders the keys according to it.
#             if ordering digit is not increased by one, the difference is used
#             as the increasing factor. No option results in
#             string_1, string_2, string_3...
#
# Example   : &print_seq_in_block(&convert_string_to_hash(\$input,\$input2,\$input3 ));
#             &convert_string_to_hash(\$input1,\$input2, '2' );
#             results in; (ordering starts from the given '2')
#                          string_2       input1 string
#                          string_3       input2 string
#
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more ref. of hashes.
# Argument  : one or more ref. of arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub convert_string_to_hash{ my(@out_ref_hash_str)=(); my($i, @w, @c);
	my($diff, $c);
	for($i=0; $i<@_; $i++){
	 if ( (ref($_[$i]) eq 'SCALAR')&&(${$_[$i]}=~/^([\d]{1,5})$/) ){
		 push(@c, $1);
	 }
	 elsif( (ref($_[$i]) eq 'SCALAR')){
		 push(@w, ${$_[$i]});
	 }
	 elsif( (!ref($_[$i])) && ($_[$i]=~/^([\d]{1,5})$/)){
		 push(@c, $1);
	 }
	}
	for($i=0; $i<@w; $i++){   my($string)=$w[$i];
	  if(defined($c[$i])){
		  ${"hash_str$i"}{"string_$c[$i]"}=$string;  my(%temp)=%{"hash_str$i"};
		  push( @out_ref_hash_str, \%temp);
		  $c=$c[$i]; $diff =$c[$i]-$c[$i-1];
	  }
	  elsif( !(defined($c[$i])) ){
		  if($diff ==0){	$c=$c+$diff+1; }else{ ($c=$c+$diff) };
		  ${"hash_str$i"}{"string_$c"}=$string;  my(%temp)=%{"hash_str$i"};
		  push( @out_ref_hash_str, \%temp);
	  }
	}
	if( @out_ref_hash_str == 1 ){ return($out_ref_hash_str[0] ); }
	elsif(@out_ref_hash_str > 1){ return(@out_ref_hash_str);}
}

#________________________________________________________________________
# Title     : convert_array_to_hash
# Usage     : ($hash1, $hash2)=&convert_array_to_hash(\$input, \$input2, '1', '2'.. );
# Function  : makes hash(es) out of array(s)
#             if ordering digit(s) is put, it orders the keys according to it.
#             if ordering digit is not increased by one, the difference is used
#             as the increasing factor. No option results in
#             array_1, array_2, array_3...
#
# Example   : &print_seq_in_block(&convert_array_to_hash(\@input,\@input2,\@input3 ));
#             &convert_array_to_hash(\$input1,\$input2, '2' );
#             results in; (ordering starts from the given '2')
#                          array_2       input1 arraystring
#                          array_3       input2 arraystring
#
# Warning   :
# Keywords  :
# Options   :
# Returns   : one or more ref. of hashes.
# Argument  : one or more ref. of arrays
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub convert_array_to_hash{
    my(@out_ref_hash_str, $i, @w, @c, $diff, $c);
	for($i=0; $i<@_; $i++){
       if ( (ref($_[$i]) eq 'SCALAR')&&(${$_[$i]}=~/^([\d]{1,5})$/) ){  push(@c, $1);
       }elsif( (ref($_[$i]) eq 'ARRAY')){                  push(@w, $_[$i]);
       }elsif( (!ref($_[$i])) && ($_[$i]=~/^([\d]{1,5})$/)){       push(@c, $1);
       }
	}
	for($i=0; $i<@w; $i++){   my($string)=join("", @{$w[$i]});
	  if(defined($c[$i])){
		  ${"hash_str$i"}{"array_$c[$i]"}=$string;
		  my(%temp)=%{"hash_str$i"};
		  push( @out_ref_hash_str, \%temp);
		  $c=$c[$i]; $diff =$c[$i]-$c[$i-1];
	  }elsif( !(defined($c[$i])) ){
		  if($diff ==0){	$c=$c+$diff+1; }else{ ($c=$c+$diff) };
		  ${"hash_str$i"}{"array_$c"}=$string;
		  my(%temp)=%{"hash_str$i"};
		  push( @out_ref_hash_str, \%temp);
	  }
	}
	if( @out_ref_hash_str == 1 ){ return($out_ref_hash_str[0] ); }
	elsif(@out_ref_hash_str > 1){ return(@out_ref_hash_str);}
}
#________________________________________________________________________
# Title     : remove_dup_in_array
# Usage     : @out2 = @{&remove_dup_in_array(\@input1, \@input2,,,,)};
#             @out1 = &remove_dup_in_array(\@input1 );
# Function  : removes duplicate entries in an array. You can sort the
#             result if you wish by 's' opt. Otherwise, result will keep
#             the original order
# Example   : (1,1,1,1,3,3,3,3,4,4,4,3,3,4,4);  --> (1,3,4);
# Warning   :
# Keywords  : merge array elements, remove_repeting_elements,
#             remove_same_array_elements, remove_redundancy, remove_redundant_elements
#             remove_duplication_in_array, delete_dup_in_array
# Options   :
#   s  for sorting the array output
# Returns   : one or more references.
# Argument  : one or more refs for arrays or one array.
# Category  :
# Version   : 1.7
#--------------------------------------------------------------------
sub remove_dup_in_array{
    my($i, $sort_opt, @out_ref, @nondup,%duplicate, @orig, @out_ref);
    my @in=@_;
    for($i=0; $i<@in; $i++){
            if($in[$i] eq 's'){
                                         $sort_opt=1;  splice(@in, $i, 1); $i--;
            }elsif( ref($in[$i]) eq 'SCALAR'  and  ${$in[$i]} eq 's' ){
                                         $sort_opt=1;  splice(@in, $i, 1); $i--;
            }
    }
    for($i=0; $i<@in; $i++){
            undef(%duplicate);
            if(ref($in[$i]) eq 'ARRAY'){    @orig = @{$in[$i]};    }
            else{ @orig=@in }
            @nondup = grep { ! $duplicate{$_}++ } @orig;    ## NOTE -> $_
            if($sort_opt==1){ @nondup= sort @nondup }
            push(@out_ref, \@nondup);
    }
    if(@out_ref ==1){ return($out_ref[0]);}
    elsif(@out_ref >1){  return(@out_ref);}
}

#________________________________________________________________________
# Title     : remove_text
# Usage     : &remove_text(\@input_array_of_filenames);
# Function  : finds patterns of text and replaces them in multiple input files
# Example   :
# Warning   : This produces a temporary file and rename it...
# Class     :
# Keywords  :
# Options   :
# Package   :
# Reference :
# Returns   : nothing
# Tips      :
# Argument  : reference of one array of file names in pwd
# Todo      :
# Author    : jong
# Category  :
# Version   : 1.3
# Enclosed  :
#--------------------------------------------------------------------
sub remove_text{
	my ( @input_files );
	$|=1;
	my $old=shift ;
	my $new='';
	@input_files=@_;
	my($file);

	for $file(@input_files){
	 open (IN, "$file");
	 my @lines=<IN>;
	 close(IN);
	 open (OUT, ">$file");
	 for $line(@lines){
			 $line=~s/$old//g;
			 print OUT $line;
	 }
	 close OUT;
	 if($file =~/\.pl$/){ chmod 0755, $file; } # this makes it execu..
	}
}




#____________________________________________________________________
# Title     : remove_elements_by_pattern
# Usage     : @out2 = @{&remove_elements_by_pattern(\@input1, \@input2,,,,)};
#             @out1 = @{&remove_elements_by_pattern(\@input1 )};
# Function  : removes elements by pattern in the array
# Example   :  @TARGET=qw(1 % $ ^ # A B 4444 44 4 4 3 33 3 11 A 3 4 4 7 AB);
#              @remove=qw(\W);  # removes all the non word stuff
#              @remove2=qw(\d );
#              @out=@{&remove_elements_by_pattern(\@TARGET, \@remove,\@remove2)};
# Warning   :
# Keywords  : remove_this_elements, remove_these_elements, remove_elements
#             remove_elements_by_position, kill_array_elements, kill_elements
#             take_away_elements, remove_array_elements
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays. The first array is always the
#             only target.
# Category  :
# Version   : 1.2
#-----------------------------------------------------------------
sub remove_elements_by_pattern{
	my ($i, $j, $k, @elem);
	my @TARGET=@{$_[0]};
	if(@_ < 2){
	 print __LINE__, "\n remove_elements_by_pattern in $0 needs 2 array refs \n\n";
	 die;
	}
	for($i=1; $i< @_; $i++){
	 if(ref($_[$i]) eq 'ARRAY'){
		push(@elem, @{$_[$i]});
	 }elsif(ref($_[$i]) eq 'SCALAR'){
		push(@elem, ${$_[$i]});
	 }else{
		push(@elem, $_[$i]);
	 }
	}
	for($j=0; $j<@TARGET; $j++){
	 for($k=0; $k<@elem; $k++){
		if($TARGET[$j] =~ /$elem[$k]/){
			splice(@TARGET, $j, 1);
			$j--;
		}
	 }
	}
	return(\@TARGET);
}


#____________________________________________________________________
# Title     : remove_elements_by_name
# Usage     : @out2 = @{&remove_elements_by_name(\@input1, \@input2)};
#             @out1 = @{&remove_elements_by_name(\@input1, \$name )};
# Function  : removes elements by name in the array
# Example   : ( two input:  (1,2,3,4,4,4,5,5,6,7), (1,3,4)  --> (2,5,5,6,7);
# Warning   :
# Keywords  : remove_this_elements, remove_these_elements, remove_elements
#             remove_elements_by_position, kill_array_elements, kill_elements
#             take_away_elements
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays. The first array is always the
#             only target. The removing elements can be scalar ref or
#             just scalar.
# Category  :
# Version   : 1.1
#-----------------------------------------------------------------
sub remove_elements_by_name{
	my ($i, $j, $k, @elem);
	my @TARGET=@{$_[0]};
	if(@_ < 2){
	 print __LINE__, "\n remove_elements_by_name in $0 needs 2 array refs \n\n"
	}
	for($i=1; $i< @_; $i++){
	 if(ref($_[$i]) eq 'ARRAY'){
		push(@elem, @{$_[$i]});
	 }elsif(ref($_[$i]) eq 'SCALAR'){
		push(@elem, ${$_[$i]});
	 }else{
		push(@elem, $_[$i]);
	 }
	}
	for($j=0; $j<@TARGET; $j++){
	 for($k=0; $k<@elem; $k++){
		if($TARGET[$j] eq $elem[$k]){
			splice(@TARGET, $j, 1);
			$j--;
		}
	 }
	}
	return(\@TARGET);
}

#____________________________________________________________________
# Title     : remove_elements_by_position
# Usage     : @out2 = @{&remove_elements_by_position(\@input1, \@input2,,,,)};
#             @out1 = @{&remove_elements_by_position(\@input1 )};
# Function  : removes elements by name in the array
# Example   : ( two input:  (1,2,3,4,5,6,7), (1,3,4)  --> (2 5 6 7);
# Warning   : Position 1 means $array[0]
# Keywords  : remove_this_elements, remove_these_elements, remove_elements
#             remove_elements_by_position, kill_array_elements, kill_elements
#             take_away_elements
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays. The first array is always the
#             only target.
# Category  :
# Version   : 1.1
#-----------------------------------------------------------------
sub remove_elements_by_position{
	my ($i, $j, $k, @position);
	my @TARGET=@{$_[0]};
	if(@_ < 2){
	 print __LINE__, "\n remove_elements_by_position in $0 needs 2 array refs \n\n"
	}
	for($i=1; $i< @_; $i++){
	 if(ref($_[$i]) eq 'ARRAY'){
		push(@position, @{$_[$i]});
	 }elsif(ref($_[$i]) eq 'SCALAR'){
		push(@position, ${$_[$i]});
	 }else{
		push(@position, $_[$i]);
	 }
	}
	for($j=0; $j<@position; $j++){
	 splice(@TARGET, $position[$j], 1);
	}
	return(\@TARGET);
}



#________________________________________________________________________
# Title     : merge_array
# Usage     : @out2 = @{&merge_array(\@input1, \@input2,,,,)};
#             @out1 = @{&merge_array(\@input1 )};
# Function  : removes duplicate entries in an array. If you put
#             more than one array as inputs, it will produce references of
#             arrays merged singly. Each resulting array is independant.
#             CF. merge_many_arrays
# Example   : (1,1,1,1,3,3,3,3,4,4,4,3,3,4,4);  --> (1,3,4);
# Warning   :
# Keywords  : merge array elements, merge_array_elements,
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub merge_array{
	my(@out_ref, %duplicate, $i, @nondup, @orig, @out_ref);
	for($i=0; $i< @_; $i++){
	  undef(%duplicate);
	  if(ref($_[$i]) eq 'ARRAY'){    @orig = @{$_[$i]};    }
	  @nondup = grep { ! $duplicate{$_}++ } @orig;
	  push(@out_ref, \@nondup);  }
	if(@out_ref == 1){ return($out_ref[0]);
	}elsif(@out_ref > 1){  return(@out_ref);}
}

#______________________________________________________________
# Title     : make_one_array
# Usage     : @array_one=@{&make_one_array(\@input_array_1, \@input_array_2)};
# Function  : makes one array from several
# Example   : (1,2,3,4,5),(6,7,8,9,10)-----> (1,2,3,4,5,6,7,8,9,10)
# Warning   : This does not remove duplicate entries.
# Keywords  : make_one_array, make_one_from_several
# Options   :
# Returns   : An array reference
# Argument  : Two or more refs for arrays.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------
sub make_one_array {
	my(@final_array, $i);
	for ($i=0; $i<@_; $i++) {
	  if(ref($_[$i]) eq 'ARRAY'){
		  push(@final_array, @{$_[$i]});
	  }elsif(ref($_[$i]) eq 'SCALAR') {
		  push(@final_array, $_[$i]);
	  }else{ next; }
	}
	return(\@final_array);
}


#________________________________________________________________________
# Title     : get_multiple_array_entry
# Usage     : @out2 = @{&merge_array(\@input1, \@input2,,,,)};
#             @out1 = @{&merge_array(\@input1 )};
# Function  : Gets any multiple array entry in a given array. If more than
#             one array is given, each array will have a reference return.
# Example   : (1,1,1,1,3,3,3,3,4,4,4,3,3,4,4);  --> (1,3,4);
#             if you put two arrays(1,1,1,3,3, 100) and (2,2, 4,4, 100), you will get
#             references of arrays( 1,3) and (2,4) ignoring single array entries.
# Warning   :
# Keywords  : multiple entry array, get_common_entry_array
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays.
# Category  :
# Version   :
#--------------------------------------------------------------------
sub get_multiple_array_entry{
	my(@out_ref, %duplicate, $i, @orig, @common, @out_ref);
	for($i=0; $i< @_; $i++){
	  undef(%duplicate);
	  if(ref($_[$i]) eq 'ARRAY'){    @orig = @{$_[$i]};    }
	  @common = grep { $duplicate{$_}++ } @orig;
	  push(@out_ref, \@common);  }
	if(@out_ref == 1){ return($out_ref[0]);
	}elsif(@out_ref > 1){  return(@out_ref);}
}

#________________________________________________________________________
# Title     : get_common_array_entry
# Usage     : @out2 = @{&get_common_array_entry(\@input1, \@input2,,,,)};
#             @out1 = @{&get_common_array_entry(\@input1 )};
# Function  : Gets any common array entry in given arrays. If one single array
#             is given, mutiply occurring entries in the array will be returned.
# Example   : (1,1,1,2,3,3,3,4)                 --> (1,3);
#             (1,2,3) (1,2,3,4,5)               --> (1,2,3);
#             (1,2,3,4,5) (1,2,3,4,5) (3,4,5,6) --> (4,5);
# Warning   : accepts only references of arrays(others are ignored).
# Keywords  : multiple entry array, get_common_entry_array, multiply array,
#             get_common_array_elements, get_common_array_element,
#             get_dup_array_elements,
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays.
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------
sub get_common_array_entry{
	my(@out_ref, %duplicate, $i, @pooled_big_array, @common);
	for($i=0; $i< @_; $i++){
	  undef(%duplicate);
	  if(ref($_[$i]) eq 'ARRAY'){
		  $array_no ++;
		  push(@pooled_big_array, @{$_[$i]});
	  }
	  @common = grep { $duplicate{$_}++ } @pooled_big_array;
	}
	return(\@common);
}

#________________________________________________________________________
# Title     : merge_many_arrays
# Usage     : @out2 = @{&merge_many_arrays(\@input1, @inputX, \@input2,,,,)};
#             @out1 = @{&merge_many_arrays(\@input1 )};
# Function  : removes duplicate entries in multiple array inputs.
# Example   : (1,1,1,1,3,3), (1,3,3,4,4,4,3,3,4,4);  --> (1,3,4);
# Warning   : synonym of  remove_dup_in_array
# Keywords  : merge array elements from multiple arrays. merge_array_elements
# Options   :
# Returns   : one reference.
# Argument  : one or more refs for arrays. or just arrays.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub merge_many_arrays{
	my(@out_ref, %duplicate,$i, @orig, @out_ref);
	for($i=0; $i<@_; $i++){   undef(%duplicate);
	  if(ref($_[$i]) eq 'ARRAY'){    @orig = (@orig, @{$_[$i]});
	  }else{ push(@orig, $_[$i]); }
	}
	@nondup = grep { ! $duplicate{$_}++ } @orig;
	return(\@nondup)
}


#________________________________________________________________________
# Title     : remove_repetitives_in_array
# Usage     : @out2 = @{&remove_repetitives_in_array(\@input1, \@input2,,,,)};
#             @out1 = @{&remove_repetitives_in_array(\@input1 )};
# Function  : removes duplicate entries in an array. If you put
#             more than one array as inputs, it will produce references of
#             arrays merged singly. Each resulting array is independant.
#             CF. merge_many_arrays
# Example   : (1,1,1,1,3,3,3,3,4,4,4,3,3,4,4);  --> (1,3,4);
# Warning   : synonym of  remove_dup_in_array
# Keywords  : remove_dup_in_array, merge array elements, remove_duplicates,
# Options   :
# Returns   : one or more references.
# Argument  : one or more refs for arrays.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub remove_repetitives_in_array{
	my(@out_ref, %duplicate,$i, @orig, @out_ref);
	for($i=0; $i<@_; $i++){   undef(%duplicate);
	  if(ref($_[$i]) eq 'ARRAY'){    @orig = @{$_[$i]};    }
	  @nondup = grep { ! $duplicate{$_}++ } @orig;
	  push(@out_ref, \@nondup);  }
	if(@out_ref ==1){ return($out_ref[0]);}
	elsif(@out_ref >1){  return(@out_ref);}
}



#________________________________________________________________________
# Title     : filter_hash_by_num_value
# Usage     : ($ref1, $ref2, $ref3)=&filter_hash_by_num_value(\%h1, \$thres,...);
# Function  : returns hash refs. after filtering with threshold value.
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub filter_hash_by_num_value{
	my(%output, $i, $input,$j);
	for($i=0; $i < @_; $i++){
	 if   ( ref($_[$i]) eq 'HASH'  ){  %{"input$j"}=%{$_[$i]}; $j++; }
	 elsif( ref($_[$i]) eq 'SCALAR'){  $input      =${$_[$i]}; }
	 elsif( ref($_[$i]) eq 'ARRAY' ){  @{"input$i"}=@{$_[$i]}; }
	 elsif( !( ref($_[$i]) ) )      {
		 if( $_[$i] =~ /^([\.\d]+)$/){  $input  = $1;} }
	 else {   print "\n The input to handle_args has problem \n"; die;  }  }
	for($i=0; $i < $j; $i++){
	  my(@keys)= keys %{"input$i"}; my($threshold)=$input;
	  for $key (@keys){
		 if(${"input$i"}{$key} > $threshold){ ${"output$i"}{$key}=${"input$i"}{$key};} }
	  push(@out_hash_ref, \%{"output$i"});  }
	if(@out_hash_ref == 1){ return($out_hash_ref[0]); }
	elsif(@out_hash_ref > 1){ return(@out_hash_ref); } package main;
}

#________________________________________________________________________
# Title     : dir_search_single  (refer dir_search for a list of possible dirs)
# Usage     : $output_best_possible_dir = ${&dir_search_single(\$input_name)};
# Function  : With given full path or single name for a dir. it returns
#             the full path dir name. If it fails to find in pwd or given
#             specified path, it tries to search PATH, HOME etc..
# Example   :
# Keywords  :
# Options   :
# Returns   : one Ref. for an array.
# Argument  : One Ref. for a scalar.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub dir_search_single{
	my($in_dir)=${$_[0]};
	my(@ENV_dir,$pwd,@temp,@probable_dir_list, @dirs,@possible_dirs,$final_dir_found);
	if (!(-d $in_dir)){
		if ($in_dir =~/^[\w\.\-]+$/){ $pwd=`pwd`; chomp($pwd);
			 if(-d "$pwd\/$in_dir" ){
				 $final_dir_found = "$pwd\/$in_dir";
			 }
			 elsif( !(-d "$pwd/$in_dir" ) ){
				 @temp=split('/', $pwd); # goes up one level.
				 pop(@temp);
				 $up_pwd=join("/", @temp);
				 if (-d "$up_pwd\/$in_dir"){
					$final_dir_found=$in_dir ;
				 }elsif( !(-d "$up_pwd/$in_dir" ) ){
					 @probable_dir_list=('JPO','ALIGN','PDB','PATH','HOME','PIRDIR',
						  'PDBSST','PDBENT', 'BLASTDB', 'PIRDIR', 'SWDIR');
					 for $elem (@probable_dir_list){
						 @dirs=split(/:/, $ENV{$elem});
						 for (@dirs){
							if (/$in_dir$/){  # if $in_dir matches with a set dir.
								$final_dir_found=$_;
							}elsif( -d "$_\/$in_dir"){
								$final_dir_found="$_\/$in_dir";
							}
						 }
					 }
				 }#<---}elsif( !(-d "$up_pwd/$in_dir" ) ){
			 }
		}elsif($in_dir =~ /\/([\w\.\-]+)$/){ # if it is a full path.
			  $in_dir = $1;
			  if(-d "$pwd\/$in_dir" ){
				  $final_dir_found = "$pwd\/$in_dir"; last;
			  }elsif( !(-d "$pwd\/$in_dir" ) ){
				  $in_dir="$up_pwd\/$in_dir";
				  $final_dir_found=$in_dir if (-d $in_dir); last;
			  }else{
				  for (@probable_dir_list){
					  @dirs=split(':', $ENV{$_});
					  for (@dirs){
						 if (/$in_dir$/){
							$final_dir_found=$_; last;
						 }
					  }
				  }
			  }
		 }
	}else{  # If the input dir is there as it is!! (no need to process)
		$final_dir_found = $in_dir;
	}
	return(\$final_dir_found);
}
#________________________________________________________________________
# Title     : dir_search  (look at dir_search_single for one dir lookup)
# Usage     : @output_possible_dirs = @{&dir_search(\$input_name)};
# Function  : With given full path or single name for a dir. it returns
#             the full path dir name. If it fails to find in pwd or given
#             specified path, it tries to search PATH, HOME etc..
# Example   :
# Warning   :
# Keywords  :
# Options   :
# Returns   : one Ref. for an array.
# Argument  : One Ref. for a scalar.
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------
sub dir_search{
		my($in_dir)=${$_[0]};
		my(@ENV_dir, @probable_dir_list, @dirs,@possible_dirs);
		if($in_dir =~ /\/([\w\.\-]+)$/){
		  $in_dir = $1;
		}
		@probable_dir_list=('PDB', 'PATH', 'HOME', 'JPO', 'PIRDIR', 'PDBSST','PDBENT',
								  'BLASTDB', 'PIRDIR', 'SWDIR');
		for (@probable_dir_list){
		  @dirs=split(':', $ENV{$_});
		  for (@dirs){
			 if (/$in_dir$/){
				push(@possible_dirs, $_);
			 }
		  }
		}
		if(@possible_dirs <1){  # goes up one level and tries to find dir.
		  my($pwd)=`pwd`; chomp($pwd);
		  my(@temp)=split('/', $pwd);
		  pop(@temp);
		  my($up_pwd)=join("/", @temp);
		  $in_dir="$up_pwd\/$in_dir";
		  push(@possible_dirs, $in_dir) if (-d $in_dir);
		}
		return(\@possible_dirs);
}

#__________________________________________________________________________
# Title     : break_down_clu_file
# Usage     : &break_down_clu_file(\@file);
# Function  : breaks down the single linkage cluster into smaller clusters
# Example   : INPUT looks like this:>
#
# Cluster 1330106       # Ori:9    Sub:6    From:133
#   1  1 EC2987          1-332       1
#   1  1 HI0530          1-338       1
#   1  1 MJ1130          5-302       1
#   1  1 SLR0807         3-333       1
#   1  1 D09_ORF319      6-312       1
#   1  1 MG046           6-307       1
# Cluster 1330203       # Ori:9    Sub:3    From:133
#   1  1 SLL1063         16-209      1
#   1  1 HI0388          4-236       1
#   1  1 EC1764          2-224       1
# Cluster 1330302       # Ori:9    Sub:2    From:133
#   1  1 EC2987          1-118       1
#   1  1 HI0388          4-104       1
#
# Keywords  : split_clu_files
# Options   :
#
#  pattern= 'Cluster'
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub break_down_clu_file{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my $pattern='Cluster';
	my($pattern_found, $clu_name, $clu_file_name);

	if($vars{'pattern'}=~/\S/){
	   $pattern = $vars{'pattern'};
	}
	for($i=0; $i< @file; $i++){
	   open(F, "$file[$i]");
	   while(<F>){
		   if(/$pattern +(\S+) +\# +Ori\:\S+ +\S+ +\S+/){
			  $pattern_found=1;
			  $clu_name=$1;
			  $clu_file_name="$clu_name\.clu";
			  open(CLU, ">$clu_file_name");
			  print CLU $_;
			  next;
		   }
		   if($pattern_found==1 and / +\d+ +\d+ +\S+ +/){
		      print CLU $_;
		      next;
		   }
	   }
	}


}

#__________________________________________________________________________
# Title     : exchange_query_with_match_in_msp
# Usage     : @exchanged_msp=@{&exchange_query_with_match_in_msp(\@file)};
# Function  :
# Example   :
# Keywords  : exchange_mspa_columns, open_and_exchange_query_with_match_in_msp,
#             open_mspa_files_with_exchange_of_columns
# Options   :
#          R     for NO range attachment in Name only return option (n)
#          e=    for evalue threshhold, if e=1, ignores all which are over 1
#          s=    for score threshhold if t=100, ignores all which are less 100
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#----------------------------------------------------------------------------
sub exchange_query_with_match_in_msp{

	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%exchanged_msp, @sorted_by_query_seq_names, $Evalue_thresh,
	   $Score_thresh,  @new_mspa_lines, $single_entry, @sorted_by_query_seq_names,
	    @single_entry, %seq_name_occur);
	$Evalue_thresh = 10; ### default very high evalue
	$Score_thresh  = 1;

	if($vars{'s'}=~/^\d+$/){ $Score_thresh= $vars{'s'} }
	if($vars{'e'}=~/^\S+$/){ $Evalue_thresh= $vars{'e'} }
	if($vars{'ro'}=~/\S+/) { $remove_orphans=$vars{'ro'} }

	$open_mspa_files_x_opt = 'x';
	if($char_opt=~/n/){ $names_only='n' }
	%exchanged_msp=%{&open_mspa_files(@file, $open_mspa_files_x_opt, $names_only,
					  "s=$Score_thresh", "e=$Evalue_thresh" )};

	@new_mspa_lines=values %exchanged_msp;
	#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	# sorting dthe MSP lines at the 5th column
	#_________________________________________________________________
	@sorted_by_query_seq_names= map{ $_->[0] } sort {$a->[1] cmp $b->[1]}
								map {/^\d+ +\S+ +\d+ +\d+ +(\S+)/ && [$_, $1] } @new_mspa_lines;

	##~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	##  Removing single entry (orphan sequence) Final removing
	##________________________________________________________
	if($remove_orphans=~/ro/){
	   for($i=0; $i< @sorted_by_query_seq_names; $i++){
		   if($sorted_by_query_seq_names[$i]=~/^\d+ +\S+ +\d+ +\d+ +(\S+)_\d*\-?\d*/){
			  $seq_name_occur{$1}++;
			  next;
		   }elsif($sorted_by_query_seq_names[$i]=~/^\d+ +\S+ +\d+ +\d+ +(\S+)/){
	 			  $seq_name_occur{$1}++;
			  next;
		   }
	   }
	   @keys=keys  %seq_name_occur;
	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	   # Getting the names of single entry. @keys will have them
	   #______________________________________________________________
	   for($i=0; $i< @keys; $i++){
		   if($seq_name_occur{$keys[$i]} < 2){
			  push(@single_entry, $keys[$i]);
	       }
	   }
	   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	   # Removing single entry (orphan sequence) Final removing
	   #________________________________________________________
	   for($i=0; $i< @sorted_by_query_seq_names; $i++){
		  for($j=0; $j < @single_entry; $j++){
			 $single_entry=$single_entry[$j];
			 if($sorted_by_query_seq_names[$i]=~/^\d+ +\S+ +\d+ +\d+ +($single_entry)_?\d*\-?\d*/){
				 splice(@sorted_by_query_seq_names, $i, 1);
				 $i--;
				 splice(@single_entry, $j, 1);
				 $j--;
			 }
		  }
	   }
	}
	return(\@sorted_by_query_seq_names);
}

#_______________________________________________________________________________
# Title     : run_stride_on_pdb_files
# Usage     : &run_stride_on_pdb_files(\$input_dir);
#                     $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : run_stride_on_pdb_files,
# Options   :
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.4
#---------------------------------------------------------------------------
sub run_stride_on_pdb_files{
		my ($realfile1, $file, $new_fasta_name, %pdb_seq, @Big_PDB_DB,
			 $min_seq_leng_accepted, @read_files, $original_dir);
		$original_dir = ${$_[0]} || $_[0];  ## $dir[0] is a ref. $original_dir

		if($_[1]=~/m=(\d+)/){    $min_seq_leng_accepted=$1 }else{ $min_seq_leng_accepted=0 }

		#print "\n# opendir_and_go_in_and_do_something: original dir is $original_dir";
		@read_files=@{&read_any_dir_simple(\$original_dir)};
		chomp($pwd=`pwd`);
		foreach $file(@read_files){
				$realfile1="$original_dir/$file";
				print "\n# (i) \$realfile1 is $realfile1";
				if( -d "$realfile1" ){  ## If it is a directory.
						print "\n     # (i) \$realfile1: $realfile1 is dir";
						$num=@Big_PDB_DB=(@Big_PDB_DB, &opendir_and_go_in_and_do_something($realfile1) );   # RECURSION occurrs here!!
						print "\n# (i) NUMBER of \@Big_PDB_DB elem is $num ---------\n";
				}elsif (-f $realfile1){     #<<------ This is where things match
						@dir=split(/\//, $realfile1);
						$dir=$dir[($#dir-1)];  # $dir is the name of directory in where you are.

						###  put any program which does something here #################################
						print "\n          # (i) \$realfile1: $realfile1 is file";
						if($realfile1=~/\S\/(\w+)\.brk$/){
							 $out_stride_file_name="$original_dir\/"."$1\.stride";
							 if(-s "$original_dir\/"."$1\.stride"){
									 # ("$original_dir\/"."$1\.stride"); # removing old style filename
							 }else{
									 system("stride $realfile1 > $out_stride_file_name");
							 }
							 print "\n# (i) Output will be $out_stride_file_name";
							 push(@Big_PDB_DB, $out_stride_file_name);
						}else{
							 print "\n# $realfile1 does not match \/\\S\\\/(\\w\+)\\.brk\$\/\n";
						}
						next;
				}elsif (-l $realfile1){
						print "\n\n$realfile1 is linked, skipping. \n";
						next;
				}else{  print "\n# (i) ODD?? "; next;  }
		}
		return(@Big_PDB_DB);
}



#______________________________________________________________________________
# Title     : run_rasmol_for_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  : rasmol2_6, run_rasmol2_6
# Options   :
# Author    : holm@ebi.ac.uk, jong@ebi.ac.uk
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub run_rasmol_for_DALI{
    local($cd1,$fsspfile,$stereo,@cd2list, @dolist,%inlist,%data,$invariants,$invariant,$acc,$resno,$seq,
          %coreset,%blocks);
    ($cd1,$fsspfile,$stereo,@cd2list)=@_;

        # read equivalences & print blocks
        open(IN,$fsspfile) || die "FATAL can't open $fsspfile\n";
        while(<IN>) { last if (/^## EQUIVALENCES/); } undef(@lines);
        while(<IN>) {
                next if(/STRID/);
                last if(/^##/);
                last if(/^\/\//);
                last if(!/\w/);
                ($iali)=/^\s+(\d+):\s+\S+\s+\S+\s+/;
                if(!defined($block{$iali})) {$block{$iali}=$_;}
                else {$block{$iali}.=$_;}
#               print "block $iali -> $block{$iali}\n";
        }
        close(IN);

        if($stereo eq 'left-right') { $stereo='set stereo 6'; }
        elsif($stereo eq 'right-left') { $stereo='set stereo -6'; }
        elsif($stereo eq 'mono') { $stereo='stereo off'; }

        print "Content-type: application/x-rasmol\n\n";
        print "load inline\nset ambient 70\nbackground gray\ncolours chain\n$stereo\n";
        print "echo ***** Notation *****\necho blue=query structure\necho thick=structurally equivalent core\necho balls=invariant amino acid type\n";

        foreach(@cd2list) {
                $_=~s/[\s\-]+//g;
                push(@dolist,$_);
        }
        $chainid='ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789';
        #
        # colour chains; show common core by backbone thickness; cpk invariant
        #
        foreach $ido ($[..$#dolist) {
                $chain=substr($chainid,$ido,1);
                print "select :$chain\nbackbone 10\n";
                print "echo chain $chain = $dolist[$ido]\n";
                $chain{$dolist[$ido]}=$chain;
        }


        $set=0; $iseg=0;
        foreach $x (@dolist) {
          # print "echo $x -> $alino{$x} -> \n$block{$alino{$x}}\n";
          foreach(split("\n",$block{$alino{$x}})) {
              #    print "echo $x -> $alino{$x}\n";
              #  1: 1vol-A 1vol-A     1 -  97 <=>    1 -  97   (ALA A 113 - ILE A 209 <=> ALA A 113 - ILE A 209) -> (113,209,113,209)
                ($from,$to,$fromx,$tox)=
      /\d+: \S+\s+\d[\w\- ]+\s+.*\(\w{3} .\s*(\w+) - \w{3} .\s*(\w+) <=> \w{3} .\s*(\w+) - \w{3} .\s*(\w+)\)/;

                $chainx=$chain{$x};
                #     print "echo $_ -> ($from,$to,$fromx,$tox)\n";
                print "select ",$fromx,"-",$tox,":$chainx\nbackbone 80\n";
                print "select ",$from,"-",$to,":A\nbackbone 80\n"; # cd1=union
                if(!defined($coreset{$chainx})) {
                        $coreset{$chainx}="define core$chainx$set $fromx\-$tox\:$chainx";
                } else {$coreset{$chainx}.=",$fromx\-$tox\:$chainx"; }
                if(!defined($coreset{"A$set"})) {
                        $coreset{"A$set"}="define coreA$set $from-$to:A ";
                } else {$coreset{"A$set"}.=",$from-$to:A";}
                $iseg++; if($iseg>5) { $set++; $iseg=0; }
          }
        }

        if($domain) {
                $cd=substr($cd1,$[,4);
                ($x,$idom)=split(/\:/,$cd1); $x=~s/[\s\-]+//g;
                if(length($x)<5) { $ch=' '; } else { $ch=substr($cd1,$[+4,1); }
        } else {
                $cd1=~s/[\s\-]+//g;
                $cd=substr($cd1,$[,4);
                if(length($cd1)<5) { $ch=' '; } else { $ch=substr($cd1,$[+4,1); }
        }
        $cdx=$cd; if(!$ch) {$ch=' ';}
        ($nres,%data)=&read_fssp_alignment_only($cdx,$ch);
        #    print "read_fssp_ali returned $nres residues for $cdx chain $ch\n";
        $invariants=''; $n=0;
        foreach $i (1..$nres) {
                ($acc,$resno,$seq,$alistring)=split(/:/,$data{$i});
                $resno=~s/\d //; $resno.=":a";
                $seq=~tr/a-z/C/;
                $invariant=1;
                $tst='';
                foreach (@cd2list) {
                        $j=$alino{$_};
                        $k=($j-1)*3; # alistring uses 3 chars per sequence
                        $x=substr($alistring,$k,1); $x=~tr/a-z/C/;
                        $tst.=$x;
                        $invariant=($x eq $seq);
                        last if(!$invariant);
                }
                if($invariant) {
                        if($invariants) { $invariants.=','.$resno; }
                        else { $invariants=$resno; }
                        $n++;
                }
                if($n>0) {
                        $invariants=~s/ //g;
                        print "select $invariants\ncpk 300\nlabel %m%r\n";
                        $n=0; $invariants='';
                }
                #if($invariant) { print "echo ires: $i ",substr($alistring,0,5)," $resno $seq $tst $invariant $invariants\n"; }
        }
        print "select none\n";

        print "exit\n";
        $iatm=0;
        foreach $ido ($[..$#dolist) {
                $chain=substr($chainid,$ido,1);
                $cd2=$dolist[$ido];
#               print "chain $ido=$cd2 -> $chain\n";
                if($domain) {
                        $cd=substr($cd2,$[,4);
                        ($x,$idom)=split(/\:/,$cd2); $x=~s/[\s\-]+//g;
                        if(length($x)<5) { $ch2=' '; } else { $ch2=substr($cd2,$[+4,1); }
                } else {
                        $cd2=~s/[\s\-]+//g;
                        $cd=substr($cd2,$[,4);
                        if(length($cd2)<5) { $ch2=' '; } else { $ch2=substr($cd2,$[+4,1); }
                }
                $cd2=$dolist[$ido];
                if(!defined($summary{$cd2})) { print $query->h1("no summary $cd2 -> $summary{$cd2}"); next; }
                &read_matrix($cd2,$fsspfile);
                # fetch coordinates from PDB file
                $cd=substr($cd2,0,4);
                $x=&opendbfile(0, $cd, %pdbdir);
                next if($x>0);
                # transform coordinates in ATOM and HETATM records
                while(<IN>) {
                  last if(/^ENDMDL/);
                  if(/^ATOM  / || /^HETATM/) {
                        if($grepca) { next unless (/CA  /||/CA \w/);}
                        # next unless (/CA  /||/CA \w/||/N   /||/N  \w/||
                        #       /C   /||/C  \w/||/O   /||/O  \w/); # keep simple
                        chop($line=$_);
                        next unless ($ch2 eq substr($line,21,1));
                        $_=substr($line,30,24);
                        ($a,$b,$c)=
                        /^.*\s+([\d- ]+[.][\d]+)\s+([\d- ]+[.][\d]+)\s+([\d- ]+[.][\d]+).*$/;
                        $x=$t[0]+($u[0]*$a)+($u[1]*$b)+($u[2]*$c);
                        $y=$t[1]+($u[3]*$a)+($u[4]*$b)+($u[5]*$c);
                        $z=$t[2]+($u[6]*$a)+($u[7]*$b)+($u[8]*$c);
                        $iatm++;
                        printf "%6s%5d%10s%1s%8s%8.3f%8.3f%8.3f%26s\n",
                                substr($line,0,6),$iatm,substr($line,11,10),
                                $chain,substr($line,22,8),$x,$y,$z,substr($line,54,26);
                  } else { print $_ unless $grepca; }
                }
                close(IN);
        }
}



#______________________________________________________________________________
# Title     : run_DALI
# Usage     :
# Function  :
# Example   :
# Keywords  : dodali
# Options   :
# Author    : holm@ebi.ac.uk, jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub run_DALI {
    my($ARCHRDB,$FSSPPATH, $DALI_EXE, %class, $class, @domains, %protlist,
       $domain, $cd1, $idom, %neibors, @list, @x, $list, %list);

    $ARCHRDB=${$_[0]};
    $FSSPPATH=${$_[1]};
    $DALI_EXE=${$_[2]};

    open(IN,"<$ARCHRDB") || die "\n run_DALI :  Can not open $ARCHRDB \n\n";
	while(<IN>) {
		if(/^(\d+)\.\s+\S+\s+(\S+)/) {
            $class=$1;
            (@domains)=split(/\,/,$2);
            foreach(@domains) { $class{$_}=$class; $protlist{$class}.="$_ "; }
		}
	}
	close(IN);

    foreach $domain (keys(%class)) {
        ($cd1,$idom)=split(/\:/, $domain);
		next if($idom==1);

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# get neighbours from fssp
		#_________________________________________
        $fsspfile="$FSSPPATH/$cd1\_$idom\.fssp";
        open(IN,"<$fsspfile") || die "\n run_DALI :  Can not open  $fsspfile\n\n";;
		while(<IN>) { last if(/^  NR. STRID1/); }

		while(<IN>) {
			last if(!/\d/ or /^##/);
			($cd2,$jdom)=/^\s*\d+\: \S+\s+(\S+).* S \s+(\d*) /;
			$class=$class{"$cd2\:$jdom"};
			$neibors{$class}=1;
		}
		close(IN);

        foreach(keys(%neibors)) { push(@list,$_); }
        (@x)=sort { $a <=> $b } @list;
		print "multidomain=$cd1\:$idom (class ",$class{"$cd1\:$idom"},") neibor classes= @x\n";
		undef(%list);
		foreach $class (@x) {
			foreach (split(/\s+/,$protlist{$class})) { ($cd)=/^(\w+)\:/; $list{$cd}=1; }
		}
		(@x)=sort keys(%list);
		print "$#x chains: @x\n";
		# shortlist chains for Dali_exe
        ($list)=join(' ',@x);
		$chains{$cd1}.="$list ";
	}

	foreach $cd1 (keys(%chains)) {
		next if(-s "$cd1\.x"); ## hack
		foreach (split(/\s+/,$chains{$cd1})) { $list{$_}=1; }
		(@x)=keys(%list);
		print "run_DALI: RUN DALI on $cd1 against $#x chains: @x\n";
		if( @x > 2 ) {
			open(OUT,">list");
			foreach(@x) {
				next if(length($_)>5 or $_ eq $cd1);
				print OUT "$_\n";
			}
			close(OUT);
            &system_cmd($DALI_EXE, $cd1, 'list');
			unlink( "dali.lock" ); # in case of crash
		}
	}
    return(\%class, \%chains, \%neibors, \%list, \%protlist);
}




#______________________________________________________________________________
# Title     : run_dpx_parallel
# Usage     :
# Function  : dpx recalculates Z score based on the new unfolding tree and
#             writes a new structural alignments(dccp): DCCP writer, DALI originally
#             wrote DCCP.
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub run_dpx_parallel {
	local ($npara,$sleeptime)=@_;
	local ($command,$i,@lists);
	print ">>> run_dpx_parallel($npara,$sleeptime)\n";
	# write shell scripts
    print "$_ -> $lists[$_]\n";

    if(-s $FORT_13_SEL_file){ unlink($FORT_13_SEL_file) }

    @representative_FSSP_entries=keys %representative_FSSP_entries;
    foreach $cd1 (@representative_FSSP_entries){
        print "rm -f fort.13\ncat $DCCPDIR$cd1\.dccp | $BIN_PATH/pipeforwarder.pl $FDATDIR DCCP $zcutoff_load13 0 | $dpx1exe\ncat fort.13 >> $FORT_13_SEL_file\n";
        system("rm -f fort.13\ncat $DCCPDIR$cd1\.dccp | $BIN_PATH/pipeforwarder.pl $FDATDIR DCCP $zcutoff_load13 0 | $dpx1exe\ncat fort.13 >> $FORT_13_SEL_file");
    }
    print "\n Finished with run_dpx_parallel \n\n";
}




#______________________________________________________________________________
# Title     : run_fasta_sequence_search
# Usage     : $gzipped_mspa_file=${&run_fasta_sequence_search("a=$algorithm",
#                        "O=$out_file_mspa_name", "File=$temp_file_name", "u=$upper_expect_limit",
#                        "DB=$sequence_DB", "k=$k_tuple", "$machine_readable")};
#
# Function  : runs FASTA or SSEARCH algorithm (given by a= option)
# Example   :
# Keywords  : run_ssearch_sequence_search, do_fasta_sequence_search,
#             do_fasta_search, run_fasta_ssearch_sequence_search
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             i= to get file base(root) name. same as File=
#             m  for MSP format directly from FASTA or Ssearch result than through sso_to_msp to save mem
#             s  for the big single output (msp file output I mean)
#             s= for the single big msp file name
#             O= for Out file name, same as s=
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             d  for very simple run and saving the result in xxxx.gz format in sub dir starting with one char
#             r  for reverse the query sequence
#             R  for attaching ranges of sequences
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             E= for $Evalue_thresh
#             l= for $lower_expect_limit
#             a= for choosing either fasta or ssearch algorithm
#             d= for defining the size of subdir made. 2 means it creates
#                    eg, DE while 1 makes D
#             d  for $make_gz_in_sub_dir_opt, putting resultant sso files in gz format and in single char subdir
#             D  for $make_mspa_in_sub_dir_opt, convert sso to msp and put in sub dir like /D/, /S/
#             n  for new format to create new msp file format with sso_to_msp routine
#          PVM=  for PVM run of FASTA (FASTA only)
#             M  for machine readable format -m 10 option
#             M= for machine readable format -m 10 option
#             N  for 'NO' do not do any processing but, do the searches only.
#       FILE_AGE for defining the age of file in days to be overwritten.
# Author    : Jong Park, jong@salt2.med.harvard.edu, for commercial use, ask me.
# Category  :
# Version   : 1.7
#------------------------------------------------------------------------------
sub run_fasta_sequence_search{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my($algorithm, $upper_expect_limit, $sequence_DB, $k_tuple, $machine_readable,$create_sso,
         @mspa_from_temp, $gzipped_mspa_file, @temp, $temp_file_name, $add_range,
         $out_file_mspa_name, $input_file_name, $out_file_sso_name,
         $gzipped_sso_file, $machine_readable, $Evalue_thresh);
    $algorithm='fasta';    $out_file_mspa_name='default_out_file.msp';
    $upper_expect_limit=1;              $sequence_DB=$ENV{'NRDB_FASTA'};
    $k_tuple=1;            $machine_readable='M';
    $upper_expect_limit=1; $lower_expect_limit=0;
    $Score_thresh=100;

    if($vars{'O'}=~/\S+/){ $out_file_mspa_name  = $vars{'O'}            };
    if($vars{'E'}=~/\S+/){ $Evalue_thresh      = $vars{'E'}            };
    if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
    if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
    if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'} unless($algorithm=~/ssearch/);  };             ## Bug fix <-- ssearch does not like $ktuple set
    if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}; if($algorithm=~/ssearch/i){ $k_tuple='';}  }; ## Bug fix <-- ssearch does not like ktuple
    if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
    if($vars{'r'}=~/\S+/){ $add_range          = 'r'                   };
    if($vars{'s'}=~/\S+/){ $single_big_msp     = 's'                   };
    if($vars{'DB'}=~/\S+/){            $sequence_DB=$vars{'DB'} ;
            if(-s $sequence_DB){
            }elsif(-s "../$sequence_DB"){  $sequence_DB= "../$sequence_DB"
            }elsif(-s "../../$sequence_DB"){  $sequence_DB= "../../$sequence_DB";
            }else{
                    print "\n# (ERROR) do_sequence_search: You set DB param, but I can\'t find $sequence_DB\n";
                    die;
            }
    }else{  print "\n# (ERROR) do_sequence_search: I need DB param defined, sorry, aborting\n"; }

    if(    $vars{'FILE'}=~/(\S+)/i){ $input_file_name = $1;
    }elsif($vars{'File'}=~/(\S+)/i){ $input_file_name = $1; }
    if($vars{'FILE_AGE'}=~/\S+/){ $age_in_days_of_out_file= $vars{'FILE_AGE'};  };
    if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
    if($vars{'Query'}=~/\S+/){      %seq_input = %{$vars{'Query'}}};
    if($vars{'u'}    =~/\S+/){ $upper_expect_limit          = $vars{'u'}            };
    if($vars{'PVM'}  =~/\S+/){ $PVM_FASTA_run  = $vars{'PVM'}; print "\n# PVM opt is set\n";     };
    if($vars{'M'}  =~/\S+/){ $machine_readable = $vars{'M'};           };

    if($char_opt=~/r/){    $add_range          = 'r' }
    if($char_opt=~/o/){    $over_write         = 'o' }
    if($char_opt=~/c/){    $create_sso         = 'c' }
    if($char_opt=~/s/){    $single_big_msp     = 's'; print "\n# Single file opt is set\n"; }
    if($char_opt=~/M/){    $machine_readable   = 'M' }
    if($char_opt=~/N/){    $No_processing      = 'N'; $create_sso='c'; }
    #print "\n# (INFO) run_fasta_sequence_search: $algorithm,$out_file_mspa_name,$input_file_name,$upper_expect_limit,DB=$sequence_DB,$k_tuple,$machine_readable\n";

    if(!$algorithm or !$input_file_name or !$sequence_DB){
         print "\n# (ERROR) One of \$sequence_DB, \$input_file_name, \$algorithm is missing\n";
         die;
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # (1) Machine readable opt for fasta and ssearch set ??
    #____________________________________________________
    if($machine_readable=~/M/){
       #print "\n \$machine_readable for FASTA/SSEARCH is SET\n";
       if(-x "./Bin/$algorithm"){
              #print "\n# (INFO) Running $algorithm -m 10 -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple\n";
              @temp=`./Bin/$algorithm -m 10 -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple`;
         }else{
              #print "\n# (INFO) Running $algorithm -m 10 -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple\n";
              @temp=`$algorithm -m 10 -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple`;
         }
    }else{
       print "\n \$machine_readable for FASTA/SSEARCH is NOT set\n";
       if(-s "./Bin/$algorithm"){
                 #print "\n# (INFO) Running $algorithm -m 10 -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple\n";
                 @temp=`./Bin/$algorithm -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple`;
         }else{
                 #print "\n# (INFO) Running $algorithm -m 10 -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple\n";
                 @temp=`$algorithm -H  -E $upper_expect_limit $input_file_name $sequence_DB $k_tuple`;
         }
    }

    #print "\n# (i) \@temp has ", scalar(@temp), " lines @temp!\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # (2) @temp is parsed directly by open_sso_files to make MSP hashes
    #_______________________________________________________________________
    @mspa_hashes_from_temp = @{&open_sso_files(\@temp, $add_range, "u=$upper_expect_limit", "l=$lower_expect_limit")};

    if(@mspa_hashes_from_temp < 1){
        print "\n# (ERROR) run_fasta_sequence_search : Error, something is wrong with open_sso_files, LINE=", __LINE__, "\n";
        die;
    }else{
        print "\n# (i) run_fasta_sequence_search: Good, \@mspa_from_temp has ",scalar(@mspa_hashes_from_temp), " hashes !\n";
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Following is JUST to prevent empty @mspa_hashes_from_temp due to low upper expec or any error
    #___________________________________________________________________________________________
    @mspa_from_temp= values %{$mspa_hashes_from_temp[0]};
    if($mspa_from_temp[0]=~/\S{3}/){
        #print "\n# (i) run_fasta_sequence_search: Good, \@mspa_from_temp has ",scalar(@mspa_hashes_from_temp), " lines !\n";
    }else{
        #print "\n# (E) the content of \@temp has @temp\n";
        open(SSO_FILE_TO_DEBUG, ">$input_file_name\.$algorithm\.sso");
        for(@temp){ print SSO_FILE_TO_DEBUG $_ }; close(SSO_FILE_TO_DEBUG);
        $upper_expect_limit=$upper_expect_limit*10;
        @mspa_hashes_from_temp = @{&open_sso_files(\@temp, $add_range, "u=$upper_expect_limit", "l=$lower_expect_limit")};
        @mspa_from_temp= values %{$mspa_hashes_from_temp[0]};
        if($mspa_from_temp[0]=~/\S{3}/){ print "\n# (I) I set \$upper_expect_limit to $upper_expect_limit, to run save open_sso_files sub \n";
        }else{
             print "\n I tried to run open_sso_files again with hihger \$upper_expect_limit, but failed, dying \n";
             die;
        }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # (3) Writing MSP file, and gzipping if possible
    #________________________________________________
    open(MSP_RUN_FASTA, ">$out_file_mspa_name") or die "\n# (ERROR) $out_file_mspa_name could not be open\n";
    @mspa_from_temp= map {$_->[0]} sort { $a->[1] <=> $b->[1]} map { [$_,  ($_=~/^\S+ +(\S+)/) ] } @mspa_from_temp; # sorting by the E-value
    print MSP_RUN_FASTA "# Written by $0 : run_fasta_sequence_search sub, from \@mspa_from_temp $algorithm used\n";
    for(@mspa_from_temp){   print MSP_RUN_FASTA $_;    }
    close MSP_RUN_FASTA;
    $gzipped_mspa_file=${&compress_files_by_gzip($out_file_mspa_name)};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # (4) making SSO file if asked : 'c' option
    #__________________________________________________
    if($create_sso){
         $seq_name=${&get_base_names($input_file_name)};
         if($algorithm=~/ssearch/){
                $out_file_sso_name="$seq_name\.ssso";
                $out_file_sso_name_gz="$seq_name\.ssso\.gz";
         }elsif($algorithm=~/fasta/){
                $out_file_sso_name="$seq_name\.fsso";
                $out_file_sso_name_gz="$seq_name\.fsso\.gz";
         }
         open(SSO, ">$out_file_sso_name");
         for(@temp){  print SSO $_;  }; close (SSO);
         if($machine_readable){
                 $out_file_msso_name="$seq_name\.msso";
                 &cp( $out_file_sso_name, $out_file_msso_name);
         }
         @gzipped_sso_files=@{&compress_files_by_gzip($out_file_sso_name, $out_file_msso_name)};

    }
    if(-s $gzipped_mspa_file and !(-s $out_file_mspa_name)){
         #print "\n# (INFO) $gzipped_mspa_file is found and will be returned";
         return(\$gzipped_mspa_file);
    }elsif(-s $out_file_mspa_name){
         #print "\n# (INFO) $out_file_mspa_name is found and will be returned";
         return(\$out_file_mspa_name);
    }
}## end of run_fasta_sequence_search



#______________________________________________________________________________
# Title     : run_herta_search_program
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
#   $HERTA_algorithm_type=     by M=
#   $HERTA_open_gap_penalty=   by A=
#   $HERTA_extend_gap_penalty= by B=
#   $HERTA_coded_seq1=         by P=
#   $HERTA_coded_seq2=         by Q=
#   $HERTA_coded_seq1_rv       by p=
#   $HERTA_coded_seq2_rv       by q=
#   $HERTA_Matrix_name=        by R=
#   $Query_sequences=          by Q=
#   $DB_sequences=             by D=
#   $raw_matrix_name=          by X=
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.3
#------------------------------------------------------------------------------
sub run_herta_search_program{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my(@scores, @codes, $count, $out_matrix_name, $algorithm, $HERTA_algorithm_type,
       $openning_gap_penalty, $elongation_gap_penalty, $coded_seq1,
       $coded_seq2, $coded_Matrix_name, $HERTA_coded_seq1_rv, $HERTA_coded_seq2_rv,
       $coded_seq1_rv, $coded_seq2_rv, $output_herta_file_rv, $raw_matrix_name,
       %DB_input, %seq_input, $HERTA_open_gap_penalty, $HERTA_extend_gap_penalty,
       $query_seq, $DB_seq);

    $HERTA_algorithm_type    ='lss_dipeptide';
    $HERTA_open_gap_penalty  =10;
    $HERTA_extend_gap_penalty=1;

    if($vars{'M'}=~/(\S+)/){ $algorithm=$1 } # gss_dipeptide, lss_dipeptide
    if($vars{'A'}=~/(\S+)/){ $openning_gap_penalty=$1 }
    if($vars{'B'}=~/(\S+)/){ $elongation_gap_penalty=$1 }
    if($vars{'P'}=~/(\S+)/){ $coded_seq1=$1 }
    if($vars{'Q'}=~/(\S+)/){ $coded_seq2=$1 }
    if($vars{'p'}=~/(\S+)/){ $coded_seq1_rv=$1 }
    if($vars{'q'}=~/(\S+)/){ $coded_seq2_rv=$1 }
    if($vars{'R'}=~/(\S+)/){ $coded_Matrix_name=$1 }
    if($vars{'F'}=~/(\S+)/){ $Query_sequences=$1 }
    if($vars{'D'}=~/(\S+)/){ $DB_sequences=$1 }
    if($vars{'X'}=~/(\S+)/){ $raw_matrix_name=$1 }

    unless(-s $coded_Matrix_name){
       print "\n $0: run_herta_search_program, \$coded_Matrix_name ($coded_Matrix_name) not here!, will check AA_matrix.matx \n";
       if(-s $raw_matrix_name and !(-b $raw_matrix_name)){
           $HERTA_Matrix_name=${&encode_residue_exchange_matrix("$raw_matrix_name")};
       }elsif( !(-e $raw_matrix_name) and -b "$coded_Matrix_name"){  $coded_Matrix_name="$coded_Matrix_name";
       }elsif(-s "AA_matrix.matx"){  $coded_Matrix_name="AA_matrix.matx";
       }else{                    die "\n \$coded_Matrix_name and \$raw_matrix_name are not given/found \n";       }
    }else{
       print "\n Using \$coded_Matrix_name : $coded_Matrix_name, GOOD!!\n\n";
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Openning $Query_sequences and $DB_sequences
    #_____________________________________________________
    #print "\n(1) Reading and writing $Query_sequences and $DB_sequences sequences \n\n";
    %seq_input=%{&open_fasta_files(\$Query_sequences)};
    %DB_input =%{&open_fasta_files(\$DB_sequences)};
    &write_fasta_seq_by_seq(\%seq_input, 'e'); ## e makes skip writing when file already
    &write_fasta_seq_by_seq(\%DB_input, 'e'); ## e makes skip writing when file already
    @Query_seq_names= sort keys %seq_input;
    @DB_seq_names   = sort keys %DB_input;

    for($i=0; $i< @Query_seq_names; $i++){
        $query_seq=$Query_seq_names[$i];
        $query_seq_file="$query_seq\.spfa";
        for($j=0; $j< @DB_seq_names; $j++){
           $DB_seq=$DB_seq_names[$j];
           $DB_seq_file="$DB_seq\.spfa";
           if($query_seq eq $DB_seq){ next }
           $sorted_pair=join('_', sort($query_seq, $DB_seq));

           #print "\n  (2) \$sorted_pair is $sorted_pair, encoding $query_seq_file and $DB_seq_file";
           $sorted_pair_seqs{$sorted_pair}++;

           unless($sorted_pair_seqs{$sorted_pair} > 2){
              ($coded_seq1, $coded_seq1_rv,
               $coded_seq2, $coded_seq2_rv)=@{&encode_fasta_sequences($query_seq_file, $DB_seq_file)};

               #print "\n  (3) Coded seqs are: $coded_seq1, $coded_seq2, $coded_seq1_rv, $coded_seq2_rv";
               $base1=${&get_base_names($coded_seq1)};
               $base2=${&get_base_names($coded_seq2)};
               $base1_rv=${&get_base_names($coded_seq1_rv)};
               $base2_rv=${&get_base_names($coded_seq2_rv)};

               $output_herta_file   ="$base1\_$base2\.herta";
               $output_herta_file_rv="$base1\_$base2_rv\.herta";

               #print "\n  (4) OUT herta files will be: $output_herta_file, $output_herta_file_rv\n";

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Running forward ($coded_seq1 <-> $coded_seq2)
               #________________________________________________
               #print "\n  (5) Running herta with $coded_seq1 $coded_seq2\n Now running $coded_seq1 <=> $coded_seq2_rv";
               system("herta -M $algorithm -A $openning_gap_penalty -B $elongation_gap_penalty -P $coded_seq1 -Q $coded_seq2 -R $coded_Matrix_name > $output_herta_file");
               if(-s $output_herta_file){ #print "\n $output_herta_file is written with A=$openning_gap_penalty\n";
               }else{  die "\n $output_herta_file does not exist, something is wrong \n\n"; }

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Running backward ($coded_seq1 <-> $coded_seq2_rv)
               #________________________________________________
               system("herta -M $algorithm -A $openning_gap_penalty -B $elongation_gap_penalty -P $coded_seq1 -Q $coded_seq2_rv -R $coded_Matrix_name > $output_herta_file_rv");
               if(-s $output_herta_file_rv){ #print "\n $output_herta_file is written with A=$openning_gap_penalty\n";
               }else{  die "\n $output_herta_file does not exist, something is wrong \n\n"; }

               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
               # Writing alignment
               #____________________________________________________________
               &show_alignment_for_herta($output_herta_file,
                                         $query_seq_file, $DB_seq_file,
                                         $query_seq,      $DB_seq);
           }
        }
    }
}


#__________________________________________________________________________
# Title     : do_self_blastp_search
# Usage     : &do_blastp_search(\@file);
# Function  :
# Example   :
# Warning   :
# Keywords  : run_blastp, run_blastp_seq_search, blastp_seq_search, blastp_search,
#             do_blast_search
# Options   :
#   r  for reverseing enquiry sequences
#   T= for Blastp T param
#   S= for Blastp S param
#   B= for Blastp B param
#   V= for Blastp V param
#   E= for Blastp E param
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.3
#----------------------------------------------------------------------------
sub do_self_blastp_search{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 ######## default parameter for BLASTP ##########
		 $T=1;
		 $B=10000;
		 $S=1;
		 $V=10000;
		 $E=10000; # expectation Max E value is 10000
		 ######## default parameter for BLASTP ##########
		 my($seq, $name, $flag, $input_file, @output_blast_files);
		 if($vars{'T'}=~/\S/){  $T=$vars{'T'} }
		 if($vars{'B'}=~/\S/){  $T=$vars{'B'} }
		 if($vars{'S'}=~/\S/){  $T=$vars{'S'} }
		 if($vars{'V'}=~/\S/){  $T=$vars{'V'} }
		 if($vars{'E'}=~/\S/){  $T=$vars{'E'} }

		 $input_file = $file[0];

		 open(FF, "$input_file");
		 open(F, ">$input_file_whole_rev_self.bla");
		 while(<FF>){
			if( /^(\w+)$/ and $flag ==1 ){
							$seq.=$1; next;
			}
			if($reverse_enquiry=~/r/){
							$seq=reverse($seq);
			}
			if($seq =~/\w+/){
					if($reverse_enquiry=~/r/){
									print FILE_FAS "\>$name_rev\n$seq\n";
					}else{
									print FILE_FAS "\>$name\n$seq\n";
					}
					close(FILE_FAS); ## <<--- This is essential
					if(-s "$input_file\.ahd"  and -s "$input_file\.atb" and -s "$input_file\.bsq"){
								 system("blastp $input_file $fas_file -sort_by_pvalue T=$T B=$B S=$S E=$E V=$V > $bla_file");
					}else{
								 system("setdb $input_file");
								 system("blastp $input_file $fas_file -sort_by_pvalue T=$T B=$B S=$S E=$E V=$V > $bla_file");
					}
					print "# do_self_blastp_search: $input_file: $fas_file: \n Blastp Parameters T=$T B=$B S=$S E=$E\n\n";
					$seq='';
					$flag =0;
					unlink($fas_file);
					push(@output_blast_files, $bla_file);
			}
			if(/^\>(\S+)/){
					$name = $1;
					$flag =1 ;
					if($reverse_enquiry=~/r/){
								 $name="$name\_rv";
								 $fas_file = "$name.fasta";
								 $bla_file = "$name.bla";
					}else{
								 $fas_file = "$name.fasta";
								 $bla_file = "$name.bla";
					}
					#lc($bla_file);
					open(FILE_FAS, ">$fas_file");
					next;
			}
		 }
		 close(FF);
		 close(F);
		 unlink("$input_file\.ahd", "$input_file\.atb", "$input_file\.bsq");
		 return(\@output_blast_files);
}

#________________________________________________________________________
# Title     : show_options
# Usage     : &show_options;  usually with 'parse_arguments' sub.
# Function  :
# Example   :
# Keywords  : display_options, show_help_options, show_argument_options,
#             show_options_in_headbox, show_prompt_options
# Options   :
# Category  :
# Version   : 1.4
#--------------------------------------------------------------------
sub show_options{
			my($i, $help_item, @keys, $perl_dir, $arg_num_limit, $head ,$arg_num_limit,
				 @entries_I_want_write );
			my($logname)=getlogin();
			my($pwd)=`pwd`;
			my($date)=`date`;
			chomp($date,$pwd);
			my($not_provided)="--- not provided ---\n";
			my($file_to_read) = $0;

			for($i=0; $i < @_; $i ++){
				if((ref($_[$i]) eq 'SCALAR')&&(${$_[$i]} =~ /^\d$/)){
								$arg_num_limit = ${$_[$i]};  }
				elsif( (!(ref($_[$i]))) && ($_[$i] =~ /^\d$/)){
								$arg_num_limit = $_[$i];     }
			}
			my %entries = %{&read_head_box(\$file_to_read )};
			if($option_tb_found ==1){
			 @option_tb=@{&read_option_table(\$file_to_read)};
			}
			foreach $help_item (keys %entries){
				 ${$help_item}= $not_provided if( (${$help_item}=~/^[\W]*$/)||( !defined(${$help_item})) );
			}
			#""""""""""""""""""""""""""""""""""""""""
			#########  Writing the format <<<<<<<<<<<
			#""""""""""""""""""""""""""""""""""""""""
			$~ =HEADER_HELP_SHOW_OPTIONS;
			write;   ## <<--  $~ is the selection operator
			$~ =DEFAULT_HELP_FORM_SHOW_OPTIONS;

			@entries_I_want_write=('Options');

			for( @entries_I_want_write ){  write  }

			print chr(7);  print "_"x72,"\n";

			if(@ARGV < $arg_num_limit){ print "\* $0 fataly needs $arg_num_limit arguments\n\n" }

			if(  $option_tb_found == 1){
			 #########  Printing the OPTION table contents <<<<<<<<<<<<
			 print "  Press \"Return\" key to see what options $logname\'s \n\n    \"$0\" take... \n";
							 $key_press=getc();
			 print @option_tb, "\n"x2 if(@option_tb > 0);
			}
format HEADER_HELP_SHOW_OPTIONS  =

**---------------------------------------------------------------------
	O P T I O N S  (I am &show_options)
**--------------------------------------------------------------------
.
format DEFAULT_HELP_FORM_SHOW_OPTIONS =
 @<<<<<<<<<: @*
 $_        $entries{$_}
.
}



#______________________________________________________________________________
# Title     : self_self_search
# Usage     : &self_self_search(\@file, $over_write, $mspa_directly_opt, $create_sso, $single_big_msp);
# Function  : self_to_self input database search with reverse query as an option
# Example   : &self_self_search(\@file, $over_write, $mspa_directly_opt, $create_sso, $single_big_msp);
# Warning   :
# Keywords  : do_self_self_search, self_self_sequence_search, self_self_seq_search,
#             self_to_self_search, self_to_rev_self_search, self_to_reversed_self_search
#             search_self, search_self_seq, search_self
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             m  for MSP format directly from FASTA or Ssearch result than through sso_to_msp to save mem
#             s  for the big single output (msp file output I mean)
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             r  for reverse the query sequence
#             R  for attaching ranges of sequences
#             b  for doing in batch. Reads all the seqs in memory at one time
#             m10 for machine readable form
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             l= for $lower_expect_limit
#             a= for choosing either fasta or ssearch algorithm
#             d= for defining the size of subdir made. 2 means it creates
#                    eg, DE while 1 makes D
#             d  for $make_gz_in_sub_dir_opt, putting resultant sso files in gz format and in single char subdir
#             D  for $make_mspa_in_sub_dir_opt, convert sso to msp and put in sub dir like /D/, /S/
#             n  for new format (msp2 format)
# Category  :
# Version   : 2.4
#-------------------------------------------------------------------------------
sub self_self_search{ ## look at search_self now!
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my (%fasta_seqs, $new_format, $over_write, $upper_expect_limit, $lower_expect_limit,
	    $Score_thresh, $margin, $single_big_msp, $sequence_DB, $create_sso, $k_tuple,
	    $mspa_directly_opt, $machine_readable, $make_gz_in_sub_dir_opt, $sub_dir_size,
	    $do_in_batch, $make_mspa_in_sub_dir_opt, $new_format, $machine_readable,
	    $add_range, $reverse_sequence, $sub_dir_head, $num_of_seq_in_fa_file );
	my $algorithm='fasta';
	$mspa_directly_opt='m';
 	$sub_dir_size=2;          # default
	#$single_big_msp ='s';
	#$create_sso='c';
	$upper_expect_limit=2;
	$k_tuple=1;

	if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}            };
	if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
	if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
	if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'}            };
	if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
	if($vars{'m'}=~/\d+/){ $margin             = $vars{'m'}            };
	if($vars{'d'}=~/\d+/){ $sub_dir_size       = $vars{'d'}            };
	if($vars{'s'}=~/\S+/){ $single_big_msp     = 's'                   };
	if($vars{'DB'}=~/\S+/){            $sequence_DB=$vars{'DB'} ;
						 if(-s $sequence_DB){
	     }elsif(-s "../$sequence_DB"){     $sequence_DB= "../$sequence_DB"
	     }elsif(-s "../../$sequence_DB"){  $sequence_DB= "../../$sequence_DB" }
	}
	if($vars{'File'}=~/\S+/){ $input_file_name = $vars{'File'};
	     unless (-s $input_file_name){
	        print "\n# self_self_search : there is no $input_file_name in pwd (given by \"File=\")";
						 };
	}
	if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
	if($vars{'u'}         =~/\S+/){ $E_val     = $vars{'u'}            };
	if($char_opt=~/R/){    $add_range          = 'r' }
	if($char_opt=~/o/){    $over_write         = 'o' }
	if($char_opt=~/c/){    $create_sso         = 'c' }
	if($char_opt=~/s/){    $single_big_msp     = 's'; print "\n# Single file opt is set\n"; }
	if($char_opt=~/m/){    $mspa_directly_opt   = 'm' }
	if($char_opt=~/M/){    $machine_readable   = 'M' }
	if($char_opt=~/d/){$make_gz_in_sub_dir_opt = 'd' } # for simple search and storing in gz file (sso file will be zipped
	if($char_opt=~/D/){$make_mspa_in_sub_dir_opt= 'D' } # for simple search and storing msp file
 	if($char_opt=~/b/){    $do_in_batch        = 'b' } # for reading in all the
	if($char_opt=~/n/){    $new_format         = 'n' }
	if($char_opt=~/r/){ $reverse_sequence      = 'r'  };

	if($do_in_batch=~/b/){
	    for($i=0; $i< @file; $i++){
		my $input_db_file=$file[$i];
		%fasta_seqs=%{&open_fasta_files(\$input_db_file)};
								$num_of_seq_in_fa_file=keys %fasta_seqs;
		if($reverse_sequence){ ## reverse the query seqs.
		    %fasta_seqs=%{&reverse_sequences(\%fasta_seqs)};
		}
		print "\n# self_self_search : \$do_in_batch is set with DB=$input_db_file, File=$input_db_file\n";
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  Main sequence search
		#___________________________________________________
		 my @file_created=@{&do_sequence_search(\%fasta_seqs,
																		 "d=$sub_dir_size",
																			"DB=$sequence_DB",
																			"File=$input_db_file",
																			$single_big_msp,
																			$over_write,
																			"u=$upper_expect_limit",
																			"l=$lower_expect_limit",
																			"k=$k_tuple",
																			$add_range,
																			$create_sso,
																			"t=$Score_thresh",
																			"m=$margin",
																			"a=$algorithm",
																			$mspa_directly_opt,
																			$machine_readable,
																			$new_format )};
		  print "\n# File created: @file_created \n";
	    }
	}else{ ## reads in the big database file continously
	    print "\n# self_self_search : without \'b\' option \n";
	    my $make_gz_in_sub_dir_opt='d';
	    my ($ori_seq_name, $first_char, $seq_file_mspa_name,  $seq, $seq_name, $first_char);
	    for($i=0; $i< @file; $i++){
							 my $input_db_file=$file[$i];
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
							 # Paranoic check of file
							 #____________________________________
	       unless(-s  $file[$i]){
									 if(-s "../$file[$i]"){    $input_db_file="../$file[$i]";
									 }elsif( -s "../../$file[$i]"){  $input_db_file="../../$file[$i]";
											 print "\n# self_self_search : I found $file[$i] at ../../ ";
									 }
							 }else{
									 print "\n# self_self_search : I found $file[$i] " if $debug;
							 }

							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # Let's open the given FASTA file
							 #_________________________________________
							 open(FASTA, "$file[$i]");
	       while(<FASTA>){
									 if( /\> *((\w\S)\S*)/ ){
											 $num_of_seq_in_fa_file++;  $ori_seq_name=$1;
											 if($seq=~/\S/ and $seq_name=~/\S/){
													 $seq_file_name="$seq_name\.fasta";
													 $seq_file_mspa_name="$seq_name\.msp";
													 $seq_file_mspa_gz_name="$seq_name\.msp\.gz";
													 $first_char=substr("\U$seq_name", 0, $sub_dir_size);
													 if( !$over_write
																and (-s "$first_char\/$seq_file_mspa_name" or -s "$first_char\/$seq_file_mspa_gz_name") ){
																print "\n# $first_char\/$seq_file_mspa_name already exists ";
																$seq='';
													 }else{
																if($reverse_sequence){ ## reverse the query seqs.
																		 print "\n# self_self_search : Reverse option is set RRRRRRRRRRR ";
																		 %fasta_seqs=%{&reverse_sequences( {"$seq_name", "$seq"} )};
																}else{
																		 %fasta_seqs=("$seq_name", "$seq");
																}
																$sequence_DB=$file[$i];
																#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
																# Calling do_sequence_search sub
																#________________________________________________
																&do_sequence_search(\%fasta_seqs,
																						 "DB=$sequence_DB" ,
																						 "File=$seq_file_name",
																						 $create_sso, $single_msp, $over_write,
																						 "u=$upper_expect_limit",
																						 "$make_gz_in_sub_dir_opt",
																						 $mspa_directly_opt,
																						 "l=$lower_expect_limit",
																						 "k=$k_tuple",
																						 $make_mspa_in_sub_dir_opt,
																						 "d=$sub_dir_size");
																 $seq='';
													 }print "\n";
												}
												$seq_name=$ori_seq_name;
									 }elsif(eof){ ## END of if( /\> *((\w\S)\S*)/ ){
											$seq.=$_;
											if($seq=~/\S/ and $seq_name=~/\S/){
												 $seq_file_name="$seq_name\.fasta";
												 $seq_file_mspa_name="$seq_name\.msp";
																																 $first_char=substr("\U$seq_name", 0, $sub_dir_size);
												 if( -s "$first_char\/$seq_file_mspa_name" and !$over_write ){
																 print "\n# $first_char\/$seq_file_mspa_name already exists ";
												 }else{
																																								 if($reverse_sequence){ ## reverse the query seqs.
																																																 %fasta_seqs=%{&reverse_sequences( {"$seq_name", "$seq"} )};
																																								 }else{ %fasta_seqs=("$seq_name", "$seq"); }
																																								 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
																																								 # Calling do_sequence_search sub
																																								 #________________________________________________
																																								 &do_sequence_search(\%fasta_seqs, "DB=$sequence_DB" , "File=$seq_file_name", $create_sso,
																																																 $single_msp, $over_write, "u=$upper_expect_limit",  "$make_gz_in_sub_dir_opt", $mspa_directly_opt,
																																																 "l=$lower_expect_limit", "k=$k_tuple", $make_mspa_in_sub_dir_opt, "d=$sub_dir_size");
																																								 $seq='';
																																 }print "\n";
			      }
			  }elsif(/^(\w+)$/){
				  $seq.=$1;
			  }
		   }
		   close FASTA;
	   }
	 }
	 return(\$num_of_seq_in_fa_file);
}


#______________________________________________________________________________
# Title     : search_self
# Usage     : &search_self(\@file, $over_write, $mspa_directly_opt,
#                                      $create_sso, $single_big_msp);
# Function  : self_to_self input database search with reverse query as an option
# Example   : &search_self(\@file, $over_write, $mspa_directly_opt,
#                                 $create_sso, $single_big_msp);
# Warning   :
# Keywords  : do_search_self, self_self_sequence_search, self_self_seq_search,
#             self_to_self_search, self_to_rev_self_search, self_to_reversed_self_search
#             search_self, search_self_seq
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             m  for MSP format directly from FASTA or Ssearch result
#                       than through sso_to_msp to save mem
#             s  for the big single output (msp file output I mean)
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             r  for reverse the query sequence
#             R  for attaching ranges of sequences
#             b  for doing in batch. Reads all the seqs in memory at one time
#             m10 for machine readable form
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             l= for $lower_expect_limit
#             a= for choosing either fasta or ssearch algorithm
#             d= for defining the size of subdir made. 2 means it creates
#                    eg, DE while 1 makes D
#             d  for $make_gz_in_sub_dir_opt, putting resultant sso files
#                       in gz format and in single char subdir
#             D  for $make_mspa_in_sub_dir_opt, convert sso to msp and
#                      put in sub dir like /D/, /S/
#             n  for new format (msp2 format)
# Category  :
# Version   : 2.6
#-------------------------------------------------------------------------------
sub search_self{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my (%fasta_seqs, $new_format, $over_write, $upper_expect_limit,
	    $lower_expect_limit, $Score_thresh, $margin, $single_big_msp,
	    $sequence_DB, $create_sso, $k_tuple, $mspa_directly_opt,
	    $machine_readable, $make_gz_in_sub_dir_opt, $sub_dir_size,
	    $do_in_batch, $make_mspa_in_sub_dir_opt, $new_format, $machine_readable,
	    $add_range, $reverse_sequence, $sub_dir_head, $num_of_seq_in_fa_file,
	    @file_created );
	my $algorithm='fasta';
	$mspa_directly_opt='m';
	$sub_dir_size=2;          # default
	#$single_big_msp ='s';
	#$create_sso='c';
	$upper_expect_limit=2;
	$k_tuple=1;

	if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}            };
	if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
	if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
	if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'}            };
	if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
	if($vars{'m'}=~/\d+/){ $margin             = $vars{'m'}            };
	if($vars{'d'}=~/\d+/){ $sub_dir_size       = $vars{'d'}            };
	if($vars{'s'}=~/\S+/){ $single_big_msp     = 's'                   };
	if($vars{'File'}=~/\S+/){ $input_file_name = $vars{'File'};
							unless (-s $input_file_name){
										 print "\n# search_self : there is no $input_file_name in pwd (given by \"File=\")";
							};
	}
	if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
	if($vars{'u'}         =~/\S+/){ $E_val     = $vars{'u'}            };
	if($char_opt=~/R/){    $add_range          = 'r' }
	if($char_opt=~/o/){    $over_write         = 'o' }
	if($char_opt=~/c/){    $create_sso         = 'c' }
	if($char_opt=~/s/){    $single_big_msp     = 's'; print "\n# Single file opt is set\n"; }
	if($char_opt=~/m/){    $mspa_directly_opt   = 'm' }
	if($char_opt=~/M/){    $machine_readable   = 'M' }
	if($char_opt=~/d/){$make_gz_in_sub_dir_opt = 'd' } # for simple search and storing in gz file (sso file will be zipped
	if($char_opt=~/D/){$make_mspa_in_sub_dir_opt= 'D' } # for simple search and storing msp file
 	if($char_opt=~/b/){    $do_in_batch        = 'b' } # for reading in all the
	if($char_opt=~/n/){    $new_format         = 'n' }
	if($char_opt=~/r/){ $reverse_sequence      = 'r'  };

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (1) Do in batch option uses memory for seq storage or use given %hash
				#__________________________________________________________________
	if($do_in_batch=~/b/ or @hash > 0){ ## @hash has %sequences,
							my($input_db_file, $sequence_DB, @file_created);
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
							# (1.1) When file (fasta) is given
							#______________________________________________
							for($i=0; $i< @file; $i++){
										$input_db_file = $sequence_DB = $file[$i];
										%fasta_seqs=%{&open_fasta_files(\$input_db_file)};
										$num_of_seq_in_fa_file=keys %fasta_seqs;
										if($reverse_sequence){ ## reverse the query seqs.
													%fasta_seqs=%{&reverse_sequences(\%fasta_seqs)};
										}
										print "\n# (1) search_self : \$do_in_batch is set with DB=$sequence_DB, File=$input_db_file\n";
										#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
										#  Main sequence search
										#___________________________________________________
										MAIN_SEARCH1:
										@file_created=@{&do_sequence_search(\%fasta_seqs,
													 "d=$sub_dir_size",
													 "DB=$sequence_DB", "File=$input_db_file",
													 $single_big_msp,   $over_write,
													 "u=$upper_expect_limit",
													 "l=$lower_expect_limit",
													 "k=$k_tuple",      $add_range,
													 $create_sso,"t=$Score_thresh", "m=$margin", "a=$algorithm",
													 $mspa_directly_opt, $machine_readable,
													 $new_format )};
							}

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# (1.2) If seq was given as hash
							#_________________________________________________________
							for($h=0; $h< @hash; $h++){
										 %fasta_seqs=%{$hash[$h]};
										 $num_of_seq_in_fa_file=keys %fasta_seqs;
										 print "\n# search_self : Hiya!, You put $num_of_seq_in_fa_file \%hash sequences\n\n";
										 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````
										 # Making the self target big DB file
										 #______________________________________________________
										 $sequence_DB=$input_db_file='Self_search_DB.fasta';
										 &write_fasta(\%fasta_seqs, \$sequence_DB);
										 if($reverse_sequence){ ## reverse the query seqs.
													 %fasta_seqs=%{&reverse_sequences(\%fasta_seqs)};
										 }
										 @file_created=@{&do_sequence_search(\%fasta_seqs,
																			"d=$sub_dir_size",
																			"DB=$sequence_DB", "File=$input_db_file",
																			$single_big_msp,   $over_write,
																			"u=$upper_expect_limit",
																			"l=$lower_expect_limit",
																			"k=$k_tuple",      $add_range,
																			$create_sso,"t=$Score_thresh", "m=$margin", "a=$algorithm",
																			$mspa_directly_opt, $machine_readable,
																			$new_format )};
							}
							print "\n# File created: \@file_created \n";

				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (2)  reads in the big database file continously
				#__________________________________________________________________
				else{   print "\n# (2) search_self : without \'b\' option \n\n";
						 my $make_gz_in_sub_dir_opt='d';
						 my ($ori_seq_name, $first_char, $seq_file_mspa_name,  $seq, $seq_name, $first_char);
						 for($i=0; $i< @file; $i++){
									my $input_db_file=$sequence_DB=$file[$i];
									unless(-s  $file[$i]){
											 if(-s "../$file[$i]"){    $input_db_file="../$file[$i]";
											 }elsif( -s "../../$file[$i]"){  $input_db_file="../../$file[$i]";
														 print "\n# search_self : I found $file[$i] at ../../ ";
											 }
								 }else{
											 print "\n# search_self : I found $file[$i] " if $debug;
								 }
								 open(FASTA, "$file[$i]");
								 while(<FASTA>){
												if( /\> *((\w\S)\S*)/ ){
															$num_of_seq_in_fa_file++;
															$ori_seq_name=$1;
															if($seq=~/\S/ and $seq_name=~/\S/){
																	 $seq_file_name="$seq_name\.fasta";
																	 $seq_file_mspa_name="$seq_name\.msp";
																	 $seq_file_mspa_gz_name="$seq_name\.msp\.gz";
																	 $first_char=substr("\U$seq_name", 0, $sub_dir_size);
																	 if( !$over_write and (-s "$first_char\/$seq_file_mspa_name" or -s "$first_char\/$seq_file_mspa_gz_name") ){
																				print "\n# $first_char\/$seq_file_mspa_name already exists ";
																				$seq='';
																	 }else{
																				if($reverse_sequence){ ## reverse the query seqs.
																							print "\n# search_self : Reverse option is set RRRRRRRRRRR ";
																							%fasta_seqs=%{&reverse_sequences( {"$seq_name", "$seq"} )};
																				}else{ %fasta_seqs=("$seq_name", "$seq"); }

																							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
																							# Calling do_sequence_search sub
																							#________________________________________________
																							MAIN_SEARCH2:
																							@file_created=@{&do_sequence_search(\%fasta_seqs,
																									 "DB=$sequence_DB" ,
																									 "File=$seq_file_name",
																									 $create_sso,
																									 $single_msp,
																									 $over_write,
																									 "u=$upper_expect_limit",
																									 "$make_gz_in_sub_dir_opt",
																									 $mspa_directly_opt,
																									 "l=$lower_expect_limit",
																									 "k=$k_tuple",
																									 $make_mspa_in_sub_dir_opt,
																									 "d=$sub_dir_size")};

																						 $seq='';
																	}print "\n";
														}
														$seq_name=$ori_seq_name;
												}elsif(eof){
														 $seq.=$_;
														 if($seq=~/\S/ and $seq_name=~/\S/){
																		$seq_file_name="$seq_name\.fasta";
																		$seq_file_mspa_name="$seq_name\.msp";
																		$first_char=substr("\U$seq_name", 0, $sub_dir_size);
																		if( -s "$first_char\/$seq_file_mspa_name" and !$over_write ){
																						print "\n# $first_char\/$seq_file_mspa_name already exists ";
																		}else{
																					if($reverse_sequence){ ## reverse the query seqs.
																													%fasta_seqs=%{&reverse_sequences( {"$seq_name", "$seq"} )};
																					}else{ %fasta_seqs=("$seq_name", "$seq"); }
																					#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
																					# Calling do_sequence_search sub
																					#________________________________________________
																					goto MAIN_SEARCH2;
																		}print "\n";
														 }
												}elsif(/^(\w+)$/){
																$seq.=$1;
												}
								 }
								 close FASTA;
						}
			 }
			 return(\@file_created);
}



#__________________________________________________________________________
# Title     : make_cdf_file
# Usage     : @file=@{&parse_arguments(1)};
# Function  : gets all the clu files and producesf one xxxx.cdf file
#             CDF file is a fasta database file with all the clu domains are
# Example   :
# Keywords  : make_cdf_file_with_clu, clu_to_cdf, clu_2_cdf
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub make_cdf_file{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my ($DB, %seq, $seq_with_range, @seq_to_fetch_with_open_fasta_files);
	 if($vars{'DB'}=~/\S/){  $DB=$vars{'DB'}  }
	 for($i=0; $i< @file; $i++){
	  open(CLU, "$file[$i]");
	  while(<CLU>){
		if(/  1  1 (\S+) +(\S+) +\d+/){
		   $seq_with_range="$1\_$2";
		   push(@seq_to_fetch_with_open_fasta_files, $seq_with_range);
		}
	  }
	 }
	 %seq=%{&open_fasta_files($DB, \@seq_to_fetch_with_open_fasta_files)};
	 &write_fasta(\%seq, "all6_clu.cdf");
	 print "\n# all6_clu.cdf  is written \n";
}

#______________________________________________________________________________
# Title     : make_seq_index_file
# Usage     : @idx_files_made=@{&make_seq_index_file(\@file)};
# Function  : creates xxxx.fasta.idx file and makes a link to pwd. If @file contains
#              names with .idx extension already, it will not put another idx
#              index to it.
# Example   :
# Keywords  : make_fasta_seq_index_file, create_seq_index_file, make_idx_file,
#             create_idx_file, create_seq_idx_file, make_index_file, create_index_file
#             make_sequence_index_file, create_sequene_index_file
# Options   :
# Category  :
# Version   : 1.4
#----------------------------------------------------------------------------
sub make_seq_index_file{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(@index_files_made, $fasta_db_input, $fasta_db_idx, %index);
	print "\n# make_seq_index_file : input \@file was @file\n";

	for($i=0; $i< @file; $i++){
		$fasta_db_input=$file[$i];
		if($fasta_db_input !~/\S+\.idx$/){
			$fasta_db_idx="$fasta_db_input.idx";
		}

		open(FASTA_DB, "$fasta_db_input");
		open(FASTAIDX, ">$fasta_db_idx");

 	    print FASTAIDX "# fasta_index for $fasta_db_input\n";
		while(<FASTA_DB>){
			if(/^\> {0,4}(\S+) */){
				$index{$1}=tell(FASTA_DB);
				print FASTAIDX "\n$1 $index{$1}";
			}
		}
		close(FASTA_DB);
		close(FASTAIDX);
		if(-s $fasta_db_idx){
			print "\n# The size of $fasta_db_idx is more than 0, looks O.K. \n";
			push(@index_files_made, $fasta_db_idx);
			system("ln -s $fasta_db_idx .");
		}else{
		    print "\n# The size of $fasta_db_idx is less than 0, ERROR??\n";
		}
	}
	if(@file < 2){
	   return( \$fasta_db_idx );
	}else{
	   return(\@index_files_made);
	}
}


#__________________________________________________________________________
# Title     : randomise_file_contents
# Usage     : &randomise_file_contents(@ARGV);
# Function  :
# Example   :
# Keywords  :
# Options   :
#   V for NON-verbose
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub randomise_file_contents{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 srand(time()^$$);

	 for($i=0; $i< @file; $i++){
	   my $file=$file[$i];
	   open F, "$file" || die "Quickly:$!\n";
	   my @lines = <F>;
	   close F;

	   open F1, ">randomized_file.txt" || die "Quickly:$!\n";
	   for(@lines){
				 printf F1 splice(@lines,rand(@lines),1);
		 printf    splice(@lines,rand(@lines),1) unless $char_opt=~/V/;
	   }
	   close F1;
	   print "\n# randomized_file.txt  is written \n";
	 }
}

#_____________________________________________________________________
# Title     : search_palindromes
# Usage     : search_palindromes(\%seq, [\%seq2]);
# Function  :
# Example   :
# Warning   :
# Keywords  : find_palindromes, get_palindromes, find_palindrome, GetPalindrom
# Options   :
#  min=  for miniumum palindrome size
#   p    for putting the position of the start of the palindrome
# Returns   :
# Argument  :
# Category  :
# Version   : 1.2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sub search_palindromes{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%hash, $min_len, %palindromes);
	if($vars{'min'}=~/\d/){ $min_len=$vars{'min'} };

	$min_len=5 unless $min_len;
	$perfection_cut = 0.8;

	for($i=0; $i< @hash; $i++){
	   %hash=%{$hash[$i]};
	   @seq_names=keys %hash;
	   print "\n# @seq_names\n";
	   for($j=0; $j < @seq_names; $j++){
		  my(@pals);
		  $string=$hash{$seq_names[$j]};
		  $len= $initial_length = length($string);
		  print "\n# \$len is $len";
		  while($len > $min_len) {
			 do{
				$str = substr($string, $pos, $len); # Extract current string
				$str_leng=length($str);
				$str_2 = $str ^ reverse($str);  # ^ bitwise operator checks identity in the identical position
				$occur= $str_2 =~ tr/\000/:/;
				$ratio=$occur/$str_leng;
				if($ratio >  $perfection_cut){
					if($char_opt=~/p/){
						if($pals[$#pals]=~/$str/){ $pos++; next; }; # skipping palindrome inside palindrome
						push(@pals, "$pos\_$str");
						$pos++;
					}else{
						if($pals[$#pals]=~/$str/){ $pos++; next; }; # skipping palindrome inside palindrome
						push(@pals, "$str  $ratio");
						$pos++;
					}
				}else{
					$pos++;
				}
			 }while ($pos+$len < $initial_length); # until we hit the end of the string

			 # Not done yet, make a smaller substring and try again. This loop will terminate
			 # when the substring is too small.
			 $len --;
			 $pos = 0;
		  }
		  @pals=@{&remove_dup_in_array(\@pals)};
		  $palindromes{$seq_names[$j]}=\@pals;
	   }
	}
	return(\%palindromes);
}


#__________________________________________________________________________
# Title     : filter_by_string_length
# Usage     : %out=%{&filter_by_string_length(\%hash, [100], ["cutoff=100"])};
# Function  :
# Example   :
# Keywords  : filter_hash_by_string_length
# Options   :
#  cutoff_min= by cutoff_min=
#  c=  by c=     # the same as cutoff_min
#
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub filter_by_string_length{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	if($vars{'cutoff_min'}=~/\d+/){ $cutoff_min=$vars{'cutoff_min'}
	}elsif($vars{'c'}=~/\d+/){ $cutoff_min=$vars{'c'}
	}elsif($num_opt[0]){
	   $cutoff_min=$num_opt[0];
	}else{
	   $cutoff_min=50;
	}
	print "\n# \$cutoff_min used is $cutoff_min Anything less than this will go\n";

	for($i=0; $i< @hash; $i++){
	   my %hash=%{$hash[$i]};
	   @keys= keys %hash;
	   for($j=0; $j< @keys; $j++){
		    if(length($hash{$keys[$j]}) < $cutoff_min){
				   print "\n $keys[$j] has less than $cutoff_min length, removed";
			     delete( $hash{$keys[$j]} );
		    }
	   }
	   push(@out_hash, \%hash);
	}
	if(@out_hash > 1){
	   print "\n# returning \@out_hash as there were more than two hash input\n";
	   return(@out_hash);
	}else{
	   print "\n# returning \$out_hash[0] as there was one hash input\n";
	   return($out_hash[0]);
	}
}



#__________________________________________________________________________
# Title     : filter_seq_DB_by_seq_length
# Usage     :
# Function  :
# Example   :
# Keywords  : filter_seq_file_by_seq_length
# Options   :
#  cutoff_min= by cutoff_min=
#  c=  by c=     # the same as cutoff_min
# Returns   :
# Argument  :
# Category  :
# Version   : 1.1
#----------------------------------------------------------------------------
sub filter_seq_DB_by_seq_length{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my(%seq, $cutoff_min, $out_file_name);
	if($vars{'cutoff_min'}=~/\d+/){ $cutoff_min=$vars{'cutoff_min'}
	}elsif($vars{'c'}=~/\d+/){ $cutoff_min=$vars{'c'}
	}elsif($num_opt[0]){
	   $cutoff_min=$num_opt[0];
	}else{
	   $cutoff_min=50;
	}
	print "\n# \$cutoff_min used is $cutoff_min. Anything less than this will go\n";

	for($i=0; $i< @file; $i++){
	   $base=${&get_base_names($file[$i])};
	   $out_file_name="$base\_filtered_by_size_$cutoff_min\.fasta";
	   %seq=%{&open_fasta_files($file[$i])};
	   %seq=%{&filter_by_string_length(\%seq, "cutoff_min=$cutoff_min")};
	   print "\n# writing $out_file_name \n";
	   &write_fasta(\%seq, $out_file_name);
	}

}

#__________________________________________________________________________
# Title     : remove_dup_seq_entry
# Usage     : &remove_dup_seq_entry(\@file);  # while @file has 'xxx.fasta'
# Function  :
# Example   :
# Keywords  : remove_duplicated_sequence_entries, remove_dup_sequence_entry
#             remove_dup_seq_entries, remove_dup_sequences
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub remove_dup_seq_entry{

	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($base, %seq, $out_file_name);

	for($i=0; $i< @file; $i++){
	   $base=${&get_base_names($file[$i])};
	   %seq=%{&open_fasta_files($file[$i])};
	   $out_file_name="$base\_non_dup.fasta";
	   &write_fasta($out_file_name, \%seq);
	   print "\n# open_fasta_files does not read dup seqs ignoring later ones\n";
	   print "\n# $out_file_name is written \n";
	}
}

#__________________________________________________________________________
# Title     : sort_files_by_size
# Usage     : @sorted=@{&sort_files_by_size(\@files)};
# Function  : sort files by size and returns the ref of the array
# Example   :
# Keywords  : sort_file_by_size, sort_by_file_size, sort_by_size
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub sort_files_by_size{
		my @in_files;
		if(ref $_[0] eq 'ARRAY'){
		@in_files = @{$_[0]};
		}else{
		@in_files = @_;
		}

		my @sorted = sort { (-s $a) <=> (-s $b) } @in_files;
		return(\@sorted);
}

#__________________________________________________________________________
# Title     : make_fasta_files_from_mspa_1_files
# Usage     : &make_fasta_files_from_mspa_1_files(\@files);
#
# Function  : creates fasta files for each query seq in xxxx.mspa_1 file
# Example   : &make_fasta_files_from_mspa_1_files(\@files, "E=0.081", "l=0");
#             &make_fasta_files_from_mspa_1_files(\@files,
#		                  "E=$E_thresh",
#		                  "Seq_Source_DB=$seq_source_db",
#		                  "l=$lower_expect_limit",
#		                  "i=$cut_off_increase_factor",
#		                   $over_write_file);
# Keywords  :
# Options   :
#   $seq_source_db= by "Seq_Source_DB=xxxxx.fasta"
#   $E_thresh = by E=  #  E value cutoff
#   u= for $upper_expect_limit
#   l= for $lower_expect_limit
#   $over_write_file=o by o -o
#   $cut_off_increase_factor = by i=
#   s for selfless fasta out put (removes the original self seq among intermediates)
#
# Category  :
# Version   : 1.3
#----------------------------------------------------------------------------
sub make_fasta_files_from_mspa_1_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	 my $owl_db_fasta         = $ENV{'OWL_FASTA'};
	 my $owl_db_fasta_idx     = $ENV{'OWL_FASTA_INDEX'};
	 my $pdbd40_old_seq_fasta = $ENV{'PDB40D_OLD_FASTA'};
	 my @files=@groups_you_want;
	 my ($base, @keys);
	 my $default_search_method='hmmls';
	 my $E_thresh = 0.081;
	 my $upper_expect_limit = $E_thresh;
	 my $lower_expect_limit = 0;
	 my $cut_off_increase_factor=0.0000001;
	 my ($over_write_file);

	if(-s $vars{'Seq_Source_DB'} ){ $Seq_Source_DB = $vars{'Seq_Source_DB'}
	}else{	$Seq_Source_DB=$owl_db_fasta;   # default source db is owl.
	}
	if( $vars{'E'}=~/\S/ ){ $E_thresh=$vars{'E'}
	}else{ $E_thresh=0.081 }
	if($vars{'u'}=~/\S+/){ $upper_expect_limit = $vars{'u'}            };
	if($vars{'l'}=~/\S+/){ $lower_expect_limit = $vars{'l'}            };
	if($vars{'i'}=~/\S+/){ $cut_off_increase_factor = $vars{'i'}       };
	if($char_opt=~/o/){    $over_write_file='o'; }
	if($char_opt=~/s/){    $selfless='s'; }
	 my @groups_to_process= @file;

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 #  MAIN function
	 #____________________________________________________
	 for($i=0; $i < @groups_to_process; $i++){
		 my($base, %seq_with_region, @seq_to_fetch, $out_file_name,
			$out_msf_name, $mspa_1_file, $first_line_found, $rename_sequences,
			%seq_hash, %match_seq_count, %NULL_evalue_seq_count, %seq_hash_count);

		 $base          = ${&get_base_names($groups_to_process[$i])};
		 $mspa_1_file    = "$base\.mspa_1";
		 %match_seq_count=();

		 print "\n# $base, $final_out_msp is to be processed ";

		 open(MSP1, "$mspa_1_file") || open(MSP1, "../$mspa_1_file") and print "\n# I found $mspa_1_file in ../$mspa_1_file ";

		 while(<MSP1>){
			if(/^ *\S+ +(\S+) +\d+ +\d+ +(\S+) +(\d+) +(\d+) +((\S+)[\_\d+\-\d+]?)/){
				$each_seq=$2;
				$match_seq=$6;
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				#  Let's make sure there is at least one seq (self)
				#_____________________________________________________
				if($seq_hash_count{$each_seq} < 1 and $selfless !~/s/ ){
					$seq_hash{$each_seq}.="$2 ";
					$seq_hash_count{$each_seq}++;
				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# When self sequence is not allowed
				#____________________________________________________
				if($each_seq eq $match_seq and $selfless=~/s/){ next };

				if( $1 < $upper_expect_limit  and  $1 >= $lower_expect_limit ){
				   $seq_hash{$each_seq}.="$5 ";
				   $match_seq_count{$each_seq}++;

				   $NULL_evalue_seq_count{$each_seq}++;
				   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				   #  If there are more than 10 0 evalue matches, ignore 0 evalue matches from now
				   #______________________________________________________________________________
				   if($NULL_evalue_seq_count{$each_seq} > 10){ $lower_expect_limit += 0.000000000000000000000001;
				   }

				   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				   #  If there are more than 500 matches, raise the lower limit evalue
				   #______________________________________________________________________________
				   if($match_seq_count{$each_seq} > 500 and $match_seq_count{$each_seq} <= 1200 ){
					  $lower_expect_limit += $cut_off_increase_factor; ## usually 0.00000001
					  $upper_expect_limit -= $cut_off_increase_factor; ## usually 0.00000001
					  print "\n# $2 $match_seq_count{$2} Low limit  cut, incrmnted by $cut_off_increase_factor, $lower_expect_limit, ovr 500 seqs ";
					  print "\n# $2 $match_seq_count{$2} High limit cut, decrmnted by $cut_off_increase_factor, $lower_expect_limit, ovr 500 seqs ";
				   }elsif($match_seq_count{$each_seq} > 1200){
					  $lower_expect_limit += $cut_off_increase_factor*10;
					  $upper_expect_limit -= $cut_off_increase_factor*50; ## usually 0.00000001
					  print "\n# $2 $match_seq_count{$2} Low limit  cut, incrmnted by $cut_off_increase_factor, $lower_expect_limit, ovr 500 seqs ";
					  print "\n# $2 $match_seq_count{$2} High limit cut, decrmnted by $cut_off_increase_factor, $lower_expect_limit, ovr 500 seqs ";

				   }else{
					  $lower_expect_limit=$vars{'l'}; ## get the very original l value if next match
				   }
				}
			}
		 }
		 close MSP1;
		 my @keys=keys %seq_hash;
		 for($k=0; $k< @keys; $k++){
			$enquiry=$keys[$k];
			@seq_to_fetch=split(/\s+/, $seq_hash{$enquiry});
			$out_file_name = "$base\_$enquiry\_less\_$E_thresh\.fasta";
			$rename_sequences='r'; # to change real seq names to '1, 2 , 3, 5,,,';
			my $num_seq_to_fetch=@seq_to_fetch;
			if( !(-s $out_file_name) or $over_write_file ){
				print "\n# fetching for $out_file_name ($num_seq_to_fetch seq)\n";
				my %seq_with_region=%{&fetch_sequence_from_db(\@seq_to_fetch,
															   $owl_db_fasta,
															   $owl_db_fasta_idx  )};
				&write_fasta(\%seq_with_region, \$out_file_name, $rename_sequences );
			}else{
				$skipped++;
			    print "\n# skipping $out_file_name ";
			}
		 }
		 print "\n# ", scalar @keys;
	 }

	 print "\n#", scalar @groups_to_process;
	 print "\n# \$skipped : $skipped\n";

}

#__________________________________________________________________________
# Title     : remove_dup_match_in_mspa_files
# Usage     : @out=@{&remove_dup_match_in_mspa_files(\@file)};
# Function  : removes the exact duplicates in MSP files
# Example   :
# Keywords  : remove_redundancy_in_mspa_files, remove_redundant_matches_in_msp
#             remove_redundant_matches, make_non_redundant_mspa_files
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.4
#----------------------------------------------------------------------------
sub remove_dup_match_in_mspa_files{
		my($i);
		my @file=@{$_[0]};
	 my $dup_allowance=1;
	 for($i=0; $i < @file; $i++){
	  $msp=$file[$i];
	  open(MSP, "$msp");
	  my @MSP=<MSP>;
	  close MSP;
	  for($j=0; $j < @MSP; $j++){
		 if($MSP[$j]=~/\d+ +\S+ +\S+ +\d+ +\d+ +\S+ +\d+ +\d+ +(\S+)/ or
			$MSP[$j]=~/\S+ +\d+ +\d+ +\d+ +\S+ +\S+ +\d+ +\d+ +(\S+)/ or
		    $MSP[$j]=~/^\S+ +\S+ +\d+ +\d+ +\S+ +\d+ +\d+ +(\S+)/){  # for old style msp
			$count{$1}++;
			if($count{$1} > $dup_allowance){
				splice(@MSP, $j, 1);
				$j--;
				$count{$1}--;
			}
		 }
	  }
	  open(MSP, ">$msp");
	  print MSP @MSP;
	  close MSP;
	  push(@final_out_ref, \@MSP);
	 }
	 if(@final_out_ref > 1){
	  return(\@final_out_ref);
	 }else{
	  return($final_out_ref);
	 }
}


#__________________________________________________________________________
# Title     : filter_intermediates_by_E_value
# Usage     : @filtered_mspa3=@{&filter_intermediates_by_E_value(\@mspa3,
#                                           "E1=$E_value1", "E2=$E_value2")};
# Function  : filters intermediate sequences according to the E value
#              thresholds and returns the lines in an array
# Example   :
# Keywords  :
# Options   :
# Returns   :
# Argument  :
# Category  :
# Version   : 1.0
#----------------------------------------------------------------------------
sub filter_intermediates_by_E_value{
		my (@filtered_lines, $i, $j, $E_value1, $E_value2);
		my @input_interm_lines=@{$_[0]};
		if($_[1]=~/E1=(\S+)/){
			$E_value1=$1;
		}
		if($_[2]=~/E2=(\S+)/){
			$E_value2=$1;
		}

		for($i=0; $i< @input_interm_lines; $i++){
		 if($input_interm_lines[$i]=~/\S+ +\d+ +(\S+) +\S+ +\d+ +(\S+) +\S+/){
						if($1 < $E_value1 and $2 < $E_value2){
							 push(@filtered_lines, $input_interm_lines[$i]);
						}
		 }
		}
		return(\@filtered_lines);
}

#______________________________________________________________________________
# Title     : make_interaction_network_PML_file_Y2H
# Usage     : $0 pdb100d_1_48.mpfa nonred_scid_interacts_JONG.y2hin psi_pdbisl_merge_assign.strass
# Function  :
# Example   : &make_interaction_network_PML_file_Y2H(@ARGV );
#   y2hin file: nonred_scid_interacts_JONG.y2hin
#
#     YMR229C YGL171W
#     YBR0832 YDR227W
#     YAL001C YDR362C
#
#   strass file: psi_pdbisl_merge_assign.strass
#     YAL003W-206 121-180 d1b64__-91 6-65 2e-24
#     YAL005C-642 388-600 d1dkza_-219 1-209 5e-95
#     YAL005C-642 1-364 d1dkgd_-383 1-369 1e-167
#     YAL011W-638 181-273 d1br0__-120 13-120 3e-07
# Keywords  : BIT
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub make_interaction_network_PML_file_Y2H{
    my($PDBG_file, $pml_file, $base, $file, $y2hin_file, %Superfam_ORF, $strass_file,
       $sfinp_file, @ORF1, @ORF2, %non_dup, %superfam_next, $orf,$pdbd,
       @superfam_matched1, @superfam_matched2, $arc_line, @superfams,
       %PDBD_lookup, %ORF_inter, $superfam, $class_type, $i, $j, $k,
       $file1, $file2, $file3, $file4, @files, %superfam_PDBD, $orf_region, $orf);
    $file1=${$_[0]} || $_[0];   $file2 =${$_[1]} || $_[1];
    $file3=${$_[2]} || $_[2];   $file4 =${$_[3]} || $_[3];

    @files=($file1, $file2, $file3, $file4);
    for($i=0; $i< @files; $i++){
       $file=$files[$i];
       if($file=~/\.pdbg|mpfa/){  $PDBG_file=$file;
       }elsif($file=~/\.y2hin/){  $y2hin_file=$file;
       }elsif($file=~/\.strass/){ $strass_file=$file; }
    }
    $base=${&get_base_names(\$y2hin_file)};
    $sfinp_file="$base\.sfinp";
    open(SFINP, ">$sfinp_file") || die;
    $pml_file="$base\.pml";
    open(PDBG_FILE, "<$PDBG_file") || die "\n Can not open $PDBG_file \n\n";
    while(<PDBG_FILE>){
       if(/^\>([de](\d\w\w\w)\S+)\s+(((\d+)\.\d+)\.\d+)/){
           $PDBD_name=$1;           $PDB_ID=$2;
           $superfam=$3;           $fold_type=$4;
           $class_type=$5;
           $PDBD_lookup{$PDBD_name}=$superfam;
       }
    }
    close(PDBG_FILE);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Reading str in. dom. pair from SCOP
    #___________________________________________________________
    $SFINP_PDBD="result_pair_skip_str_inter.sfinp";
    open(SFINP_PDBD, "$SFINP_PDBD") || die "\n I need $SFINP_PDBD \n";
    while(<SFINP_PDBD>){
        if(/^(\d\S+)\s+(\d\S+)/){
            $superfam1=$1;            $superfam2=$2;
            if($superfam2=~/\d\.\d/){
                $superfam1=~s/\./_/g; $superfam2=~s/\./_/g;
            }
            if($superfam1=~/\S/ and $superfam2=~/\S/){
                #print "$superfam1 $superfam2\n";
                push(@{$superfam_PDBD{$superfam1}}, $superfam2);
                push(@{$superfam_PDBD{$superfam2}}, $superfam1);
            }
        }
    }
    close(SFINP_PDBD);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Reading in Physical domain interaction pairs to make the table
    #__________________________________________________________________
    open(STRASS_FILE, "<$strass_file") || die;
    while(<STRASS_FILE>){
       if(/(\S+)\-\d+\s+(\S+)\s+(\S+)\-\d+\s+\S+\s+(\S+)/){
           $orf=$1;
           $orf_region="$1\_$2";
           $pdbd=$3; $eval=$4;
           if($eval < 0.001){
              if($PDBD_lookup{$pdbd}){
                 $superfam=$PDBD_lookup{$pdbd};
                 $total_PDBD_matched++;
                 push(@{$ORF_inter{$orf}}, $superfam);
                 #print "\n $1 @{$ORF_inter{$1}} ";
                 push(@{$Superfam_ORF{$superfam}}, $orf_region);
              }
           }else{ next }
       }
    }
    close(STRASS_FILE);

    $date=${&get_date_text()};
    $pml_file="EVIPA_Y2H\_SF\_$date\.pml";
    open(PML_FILE, ">$pml_file") || die ; ## protein interaction versitility
    @all_superfams=sort keys %Superfam_ORF;
    for($i=0; $i< @all_superfams; $i++){
       @ORFs=@{&remove_dup_in_array($Superfam_ORF{$all_superfams[$i]})};
       print "\n $i  @ORFs";
       print PML_FILE "node $all_superfams[$i]\t0 0 @ORFs\n";
    }


    open(Y2H_FILE, "<$y2hin_file") || die ;
    while(<Y2H_FILE>){
        if(/^(\S+)\s+(\S+)/){
            $orf1=$1;
            $orf2=$2;
            $ORF_count{$orf1}++; $ORF_count{$orf2}++;
            @ORF1=sort @{$ORF_inter{$orf1}};
            @ORF2=sort @{$ORF_inter{$orf2}}; ## has 2.2.1 , 2.1.1, etc
            $orf_num1=@ORF1=@{&remove_dup_in_array(\@ORF1)};
            $orf_num2=@ORF2=@{&remove_dup_in_array(\@ORF2)};
            #print "\n$orf_num1 $orf_num2";
            if(@ORF1 and @ORF2){
                for($i=0; $i< @ORF1; $i++){
                    $superfam1=$ORF1[$i];
                    $superfam1=~s/\./_/g;
                    for($j=0; $j< @ORF2; $j++){
                       $superfam2=$ORF2[$j];
                       $superfam2=~s/\./_/g;
                       $superfam_count{$superfam1}++;
                       $superfam_count{$superfam2}++;
                       if($superfam1 and $superfam2){
                           @sorted=sort($superfam1, $superfam2);
                           $SFINP{"@sorted"}++;
                       }

                       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                       # Checking real interaction based on SCOP PDBD interation
                       #___________________________________________________________
                       if(($orf_num1 > 0 and $orf_num2 > 1) or ($orf_num1 > 1 and $orf_num2 > 0)
                           and $superfam_PDBD_line !~/$superfam2/){
                           $superfam_PDBD_line="@{$superfam_PDBD{$superfam1}} @{$superfam_PDBD{$superfam2}}";
                           #print "\n$superfam_PDBD_line \n";
                           $ORF_ORF_but_NOT_domain_domain++;
                           next;
                       }else{
                           $ORF_ORF_but_AND_domain_domain++;
                       }
                       $superfam_count_filtered{$superfam1}++;
                       $superfam_count_filtered{$superfam2}++;

                       if($superfam1 and $superfam2){
                           @sorted=sort($superfam1, $superfam2);
                           $SFINP_filtered{"@sorted"}++;
                       }
                    }
                }
            }
        }
    }
    close(Y2H_FILE);
    %superfam_pair=%SFINP_filtered;

    @superfams=sort keys %superfam_pair;

    for($i=0; $i< @superfams; $i++){
       $edge_strength= $superfam_pair{$superfams[$i]};
       unless($superfams[$i]=~/\S+/){ next; }
       $superfams[$i]=~/(\S+)\s+(\S+)/;
       $edge_orig=$1;
       $edge_dest=$2;
       $edge_orig=~s/\./_/g;
       $edge_dest=~s/\./_/g;
       $edge_id="$edge_orig\_$edge_dest";
       $arc_line=sprintf("arc %-17s %-9s %-9s %-9s %s\n", $edge_id, $edge_orig, $edge_dest, $edge_strength);
       print PML_FILE $arc_line;
       print $arc_line;

    }
    print "\n";
    print PML_FILE "\n";
    close(PML_FILE);
    print "\n# \$pml_file $pml_file is produced \n";

}




#___________________________________________________________________________________
# Title     : make_intermediate_sequence_library
# Usage     : &make_intermediate_sequence_library(
#                                    "FASTA_DB=$source_db_fasta",
#                                    "E=$evalue_thresh",
#	                                 "MSP_DIR=$mspa_seq_file_dir",
#	                                 "s=$score_thresh",
#	                                 "p=$pdbg_file",
#	                                 $overwrite,
#         	                      );
# Function  : extracts intermediate sequences from OWL/NRDB/RSDB fasta database to
#             make intermediate seq library
#             This looks for /gn0/jong/DB/PDB/PDB95D_against_OWL/E/$mspa_file_gz
#                and         /gn0/jong/DB/PDB/PDB95D_against_OWL/D/$mspa_file_gz
#                or          ~/Proj/Bio/PDB_ISL/PDB_ISL_1_48/Msp_files
#            The directory contains EACH individual MSP files (not big catted one)
# Example   :
# Keywords  : make_PDB_ISL_for_each_supermaily, make_interm_lib,
#             make_intermediate_library, compile_interm_library, create_interm_library,
#             make_ISS_LIB_file, make_isl make_PDB_ISL make_DDD_ISL
# Options   :
#      'FASTA_DB' for sequence source fasta file  eg:  "FASTA_DB=$source_db_fasta"
#      o  for overwrite option (overwrites 1.2.3.fa like file)
#      MSP_DIR= for mspa seq file result directory
#      m=       for mspa seq file result direc (same as MSP_DIR)
#      e=       for E value thresh
#   $pdbg_file= by p=
#      E=       for E value thresh
#      s=       for score thresh
#
# Returns   :
# Argument  :
# Category  :
# Version   : 2.4
#-----------------------------------------------------------------------------------
sub make_intermediate_sequence_library{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my(%hash_superfam, @pdbd_seqs, @superfamily, @members, @files, $over_write, $mspa_file_gz,
         $mspa_seq_file_dir, $mspa_file, $mspa_file_long, $mspa_file_gz_long,
         $pdbd_seq_long, $final_merged_ISL_fasta,$pdbg_file, $pwd , $range_start,
         $range_stop, $source_db_fasta, $evalue_thresh, $score_thresh,
         $range_thresh, $percent_id_thresh, %PDBD, $DB_fasta_size, %DB_fasta);
    if(-s $ENV{'NRDB_FASTA'}){
       $source_db_fasta=$ENV{'NRDB_FASTA'}; ## general default
    }elsif(-s $ENV{'RSDB_FASTA'}){
       $source_db_fasta=$ENV{'NRDB_FASTA'}; ## general default
    }
    $evalue_thresh=0.01; #  default
    $score_thresh=70;     #  default
    $range_thresh=10;
    $percent_id_thresh=0.95;
    print "\n# (i) Running sub of: make_intermediate_sequence_library\n";

    if($vars{'FASTA_DB'}=~/\S+/){  $source_db_fasta=$vars{'FASTA_DB'} }
    if($vars{'MSP_DIR'}=~/\S+/){   $mspa_seq_file_dir=$vars{'MSP_DIR'} }
    if($vars{'p'}=~/\S+/){         $pdbg_file=$vars{'p'}; print "\n# (i) $vars{'p'} is given \n"; } ## PDBG file input
    if($vars{'m'}=~/\S+/){         $mspa_seq_file_dir=$vars{'m'} }
    if($vars{'DB'}=~/\S+/){        $source_db_fasta=$vars{'DB'} }
    if($vars{'E'}=~/\S+/){         $evalue_thresh=$vars{'E'} }
    if($vars{'e'}=~/\S+/){         $evalue_thresh=$vars{'e'} }
    if($vars{'s'}=~/\S+/){         $score_thresh=$vars{'s'} }
    if($char_opt=~/o/){            $over_write='o' }

    if( !(-s $pdbg_file )){
        print "\n# (W) Is your pdbg file given to me? \n\n";
        if(-s $file[0]){            $pdbg_file=$file[0];
        }else{            die "\n# (E) I can not find \$pdbg_file \n";        }
    }else{
        print "\n# (i) \$pdbg_file $file[0] does exist, GOOD! \n";
    }

    print "\n# (1) make_intermediate_sequence_library: \$evalue_thresh is $evalue_thresh, opening $pdbg_file file\n";

    open(PDBG, "$pdbg_file");
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Collecting sequence members for superfamilies
    #_______________________________________________
    while(<PDBG>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # SCOP based PDBG file reading
       #___________________________________________________
       if(/\>(\S+)\s+(\d+\.\d+\.\d+)\.\d+\.\d+/){
            $super_family=$2;
            $hash_superfam{$super_family} .=" $1"; ## %hash_superfam has 'd1cus_ d2eng_ ...'
            $PDBD{$1}=$super_family;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # DDD based PDBG file reading
       #________________________________________________
       }elsif(/\>(\S+)\s+(D.C.\d+\.\d+\.\d+)\s+([\d \-]+)/){
            $super_family=$2;  ## superfamily is unifamily in DDD
            $hash_superfam{$super_family} .=" $1"; ## %hash_superfam has 'd1cus_ d2eng_ ...'
            $PDBD{$1}=$super_family;
       }
    }
    close (PDBG);
    open(ERROR_LIST, ">ERROR_LIST.log")|| die "\n Can not open ERROR_LIST.log \n";
    $DB_fasta_size= -s $source_db_fasta;
    if($DB_fasta_size < 450000000){ # if it is less than 450MB, I read it into memory !!
        print "\n Openning BIG $source_db_fasta file \n";
        %DB_fasta=%{&open_fasta_files(\$source_db_fasta)};
    }
    @superfamily=sort keys %hash_superfam;
    unless(@superfamily){  die "\n# (E) \@superfamily is too small to go on \n\n"; }
    $pwd=`pwd`; chomp($pwd);
    chdir($mspa_seq_file_dir);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # collecting superfamily member sequences from PDBG in order to store in a hash
    #____________________________________________________________________________________
    for($i=0; $i< @superfamily; $i++){
       my (%interm_hash, %seq, $out_fasta_file,  $superfamily, @pdbd_seqs);
       $superfamily=$superfamily[$i];
       @pdbd_seqs=split(/\s+/, $hash_superfam{$superfamily});
       $out_fasta_file="$superfamily[$i]\.mpfa"; #<----------------- final output file name like 1.2.1.fa
       if(-s $out_fasta_file and !$over_write){
           print "\n# (1) make_intermediate_sequence_library: $out_fasta_file Already EXISTS and no o opt. skipping\n";
           next;
       }
       if(@pdbd_seqs){      print "\n# (i) \@pdbd_seqs for $superfamily is: @pdbd_seqs\n";
       }else{               print "\n# (E) \@pdbd_seqs is empty, strange, error in making $out_fasta_file \n\n";
       }

       for($j=0; $j< @pdbd_seqs; $j++){
             my (@mspa_content, $evalue, $sub_dir, $percentage_id, $range_length, $pdbd_seq, $pdbd_seq_long);
             $pdbd_seq=$pdbd_seqs[$j];
             $pdbd_seq_long="pdb\_$pdbd_seqs[$j]";

             if($pdbd_seq=~/^\s*$/){  next; }

             $mspa_file="$pdbd_seq\.mspa";
             $mspa_file_gz="$pdbd_seq\.mspa\.gz";
             $mspa_file_long="pdb\_$pdbd_seq\.mspa";        ##  to handle Sarah's pdb_ prefixed pdbd files
             $mspa_file_gz_long="pdb\_$pdbd_seq\.mspa\.gz"; ##  to handle Sarah's pdb_ prefixed pdbd files

             print "# (i)      I am processing each $mspa_file  <- subroutine:make_intermediate_sequence_library\n";
             if($mspa_file_gz=~/^([\ddec])\S/ or $mspa_file_long=~/pdb_([dec])\S/){
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~`
                  # Trying to locate the search result file as like 'd1hlb__.mspa.gz' in various dirctory
                  #_______________________________________________________________________________________
                  $sub_dir1="\U$1";  # If I have stored the MSP files in some SUB directories
                  $sub_dir2="$1"; ## just in case the subdir name was not in capital

                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # When the MSP files are in the given MSP direcotyr
                  #__________________________________________________________
                  if(-s $mspa_file){
                       open(MSP_FILE, "$mspa_file");  @mspa_content=<MSP_FILE>; close (MSP_FILE);
                  }elsif(-s $mspa_file_long){
                       open(MSP_FILE, "$mspa_file_long"); @mspa_content=<MSP_FILE>; close (MSP_FILE);
                       print "\n# (i) \@mspa_content is read \n";
                  }elsif( -s "$mspa_seq_file_dir\/$sub_dir1/$mspa_file_long"){
                       open(MSP_FILE, "$mspa_seq_file_dir\/$sub_dir1/$mspa_file_long"); @mspa_content=<MSP_FILE>; close (MSP_FILE);
                       print "\n# (i) \@mspa_content is read \n";
                  }elsif( -s "$mspa_seq_file_dir\/$sub_dir2/$mspa_file_long"){
                       open(MSP_FILE, "$mspa_seq_file_dir\/$sub_dir2/$mspa_file_long"); @mspa_content=<MSP_FILE>; close (MSP_FILE);
                       print "\n# (i) \@mspa_content is read \n";
                  }elsif( -s "$mspa_seq_file_dir\/$mspa_file_long"){
                       open(MSP_FILE, "$mspa_seq_file_dir\/$mspa_file_long"); @mspa_content=<MSP_FILE>; close (MSP_FILE);
                       print "\n# (i) \@mspa_content is read \n";
                  }elsif( -s "$mspa_seq_file_dir\/$mspa_file_long"){
                       open(MSP_FILE, "$mspa_seq_file_dir\/$mspa_file_long"); @mspa_content=<MSP_FILE>; close (MSP_FILE);
                       print "\n# (i) \@mspa_content is read \n";
                  }elsif( -s $mspa_file_gz){ @mspa_content=`gunzip -c $mspa_file_gz`;
                  }elsif( -s "./$sub_dir1/$mspa_file_gz"){  @mspa_content=`gunzip -c ./$sub_dir1/$mspa_file_gz`;
                  }elsif( -s "./$sub_dir2/$mspa_file_gz"){  @mspa_content=`gunzip -c ./$sub_dir2/$mspa_file_gz`;
                  }elsif( -s $mspa_file_gz_long){ @mspa_content=`gunzip -c $mspa_file_gz_long`;
                  }elsif( -s "./$sub_dir1/$mspa_file_gz_long"){  @mspa_content=`gunzip -c ./$sub_dir1/$mspa_file_gz_long`;
                  }elsif( -s "./$sub_dir2/$mspa_file_gz_long"){  @mspa_content=`gunzip -c ./$sub_dir2/$mspa_file_gz_long`;
                  }elsif( -s "$mspa_seq_file_dir\/$sub_dir1/$mspa_file_gz"){
                           @mspa_content=`gunzip -c $mspa_seq_file_dir\/$sub_dir1/$mspa_file_gz`;
                  }elsif( -s "$mspa_seq_file_dir\/$sub_dir2/$mspa_file_gz"){
                           @mspa_content=`gunzip -c $mspa_seq_file_dir\/$sub_dir2/$mspa_file_gz`;
                  }elsif( -s "$mspa_seq_file_dir\/$sub_dir1/$mspa_file_gz_long"){
                           @mspa_content=`gunzip -c $mspa_seq_file_dir\/$sub_dir1/$mspa_file_gz_long`;
                  }elsif( -s "$mspa_seq_file_dir\/$sub_dir2/$mspa_file_gz_long"){
                           @mspa_content=`gunzip -c $mspa_seq_file_dir\/$sub_dir2/$mspa_file_gz_long`;
                  }else{
                       warn "# (E) PWD is ", `pwd`, "$mspa_seq_file_dir\/$sub_dir2, $mspa_seq_file_dir\/$sub_dir1\n";
                       warn "# (E) make_intermediate_sequence_library ($superfamily): I can not find $mspa_file_gz or $mspa_file\n";
                  }

                  print "\n# (i) Now I have finished reading in ONE mspa file for $pdbd_seq ($superfamily) into \@mspa_content\n";

                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`~`
                  # Processing each MSP line
                  #_______________________________________________________________________________________
                  my ($identical_one_added, $interm_seq);
                  for($k=0; $k< @mspa_content; $k++){ ## NEW MSP format
                      if($mspa_content[$k]=~/^\s*(\S+)\s+(\S+)\s+(\S+)\s+\d+\s+\d+\s+[pdb_]*$pdbd_seq[_\d+\-\d+]*\s+(\d+)\s+(\d+)\s+(\S+)/){ # [pdb_]* is for Sarah's pdb_ prefix
                          #if($pdbd_seq eq $6){ next }  ## this is to exclude the same seq match
                          $evalue=$2;               $percentage_id=$3;
                          $range_length=$5-$4;      $score =$1;  $interm_seq=$6; $range_start=$4, $range_stop=$5;

                          if($interm_seq=~/(\S+)_\d+\-\d+/){ $interm_seq=$1; } ## PDBG entries are: e1pya.1a, d1lfda_

                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # (1) I stop taking Intermediates if I find the SCOP classifications of query and match PDBDs are diff
                          #______________________________________________________________________________________________________
                          if($PDBG{$interm_seq} and $PDBG{$interm_seq} ne $PDBG{$pdbd_seq} ){
                              print "\n STOP taking Intermediates: $pdbd_seq $PDBG{$interm_seq} <-> $interm_seqlast $PDBG{$pdbd_seq} \n";
                          }

                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # (2) I stop taking Intermediates if I find the scores and E-value are bad
                          #______________________________________________________________________________________________________
                          if($evalue < $evalue_thresh and $range_length > $range_thresh and $score > $score_thresh){
                              if($percentage_id <= $percent_id_thresh){  ## to keep one pdb seq ($percentage_id=1)
                                  unless($interm_seq=~/^d\d\S/){  # to remove entries like:  d1abc_10-20_d2acb__ (two pdb seqs)
                                      $interm_hash{$superfamily} .=" $interm_seq\_$range_start\-$range_stop\_$pdbd_seq";
                                  }
                              }elsif($percentage_id ==1 and $identical_one_added < 1){  ## this is to prevent more than 1 100% id seq
                                  $interm_hash{$superfamily} .=" $interm_seq\_$range_start\-$range_stop\_$pdbd_seq";
                                  $identical_one_added++;
                              }
                          }
                      }elsif($mspa_content[$k]=~/^ *(\d+)\s+(\S+)\s+\d+\s+\d+\s+$pdbd_seq\s+(\d+)\s+(\d+)\s+(\S+)/){
                          $evalue=$2;              $score=$1;
                          $range_length=$4-$3;     $interm_seq=$5;
                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # (1) I stop taking Intermediates if I find the SCOP classifications of query and match PDBDs are diff
                          #______________________________________________________________________________________________________
                          if($PDBG{$interm_seq} and $PDBG{$interm_seq} ne $PDBG{$pdbd_seq} ){
                              print "\n STOP taking Intermediates: $pdbd_seq $PDBG{$interm_seq} <-> $interm_seqlast $PDBG{$pdbd_seq} \n";
                          }
                          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                          # (2) I stop taking Intermediates if I find the scores and E-value are bad
                          #______________________________________________________________________________________________________
                          if($evalue < $evalue_thresh and $range_length > $range_thresh
                              and $score > $score_thresh){
                              $interm_hash{$superfamily} .=" $interm_seq\_$3\-$4\_$pdbd_seq";
                          }
                      }
                  }

             }

        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #
        #__________________________________
        $family_name=$superfamily[$i];
        @members=@{ &remove_similar_seqlets($interm_hash{$superfamily[$i]}) };

        chdir($pwd); ## have to come back to fech seq and write 1.1.1.mpfa etc

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
        # Fetching the seq segments from DB file
        #________________________________________________
        if($DB_fasta_size < 450000000){ # 450 MB
           for($k=0; $k<@members; $k++){
              if($members[$k]=~/(\S+)\_(\d+)\-(\d+)\_(\S+)/){ ## >1zeiE1_3-53_d1igl__
                 $interm_seq=$1; $range_start=$2-1; $range_leng=$3-$2+1;
                 $seq_fasta=$DB_fasta{$interm_seq}; $pdbd_seq=$4;
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Due to a bug and some duplicate entries in RSDB, I check if the seqlet size is correct one more time.
                 #___________________________________________________________________________________________________________
                 $seq_fasta=substr($seq_fasta, $range_start, $range_leng);
                 if(length($seq_fasta) == $range_leng){
                     #print "\n \$range_leng $range_leng -> $seq_fasta\n";
                     unless($pdbd_seq=~/\d+\.\d+\.\d+/){
                         $members[$k].="_$PDBD{$pdbd_seq}";
                     }
                     $seq{$members[$k]}=$seq_fasta;
                 }else{
                     print ERROR_LIST ">$members[$k]\n$seq_fasta\n";
                 }
              }
           }
        }else{
           %seq=%{&fetch_sequence_from_db($source_db_fasta, \@members, "t=$evalue_thresh")};
        }
        &write_fasta(\%seq, $out_fasta_file);
        %seq=();
        chdir($mspa_seq_file_dir);

     }
     close(ERROR_LIST);
     chdir($pwd); ## have to come back to fech seq and write 1.1.1.mpfa etc
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # Merging (Compiling) the superfamily fasta files into one
     #_________________________________________________
     $final_merged_ISL_fasta=${&merge_superfam_fasta_files_for_ISL}; ## returns the final compiled_interm_lib.fa file name
     system("nrdb -l30 -n1 -o $final_merged_ISL_fasta\.nrdb $final_merged_ISL_fasta ");
     return( \$final_merged_ISL_fasta);
}



#________________________________________________________________________________
# Title     : read_machine_readable_sso_lines
# Usage     : @out_refs=@{&read_machine_readable_sso_lines(\@SSO, $get_alignment,
#                           $create_sso, $upper_expect_limit,$new_format, $lower_expect_limit,
#                           $attach_range_in_names, $attach_range_in_names2)};
# Function  :
# Example   :
# Keywords  : read_m10_sso_lines read_msso_lines
# Options   : a c r r2 n
#   $get_alignment=a by a  <-- for merge_sequence_alignments.pl etc
#             u= for upper E value limit
#             l= for lower E value limit
# Category  :
# Version   : 1.9
#--------------------------------------------------------------------------------
sub read_machine_readable_sso_lines{
     my ($upper_expect_limit, $lower_expect_limit)=(50,0);
     my (%match, $name_range, @out_refs, $query_found, $query_sq_stop, $query_sq_start, $match_found, $get_alignment,
            $match_seq, $match_found2, $i, $j,$match_found3, $overlap, $sw_score, $match_sq_start, $match_sq_stop, $match_seq2, $sw_ident, $name_range, $query_seq,
            $al_display_start, $original_target_seq, $match_seq_count, @SSO, $attach_range_in_names, $attach_range_in_names2, $new_format, %temp,
            $original_Q_sq_start, $original_Q_sq_stop, $gap_char_num,  $original_M_sq_start, $original_M_sq_stop, $match_align_leng, $query_align_leng);

     for($i=0; $i< @_; $i++){
             if($_[$i]=~/u=(\S+)/){    $upper_expect_limit=$1 }
             elsif(ref($_[$i]) eq 'ARRAY'){ @SSO=@{$_[$i]};   }
             elsif($_[$i]=~/l=(\S+)/){ $lower_expect_limit=$1 }
             elsif($_[$i]=~/^c *$/){     $create_sso = 'c'; print "\n# read_machine_readable_sso_lines: \$create_sso is set"; }
             elsif($_[$i]=~/^a *$/){     $get_alignment='a'; }
             elsif($_[$i]=~/^ *r *$/){   $attach_range_in_names='r' }
             elsif($_[$i]=~/^r2 *$/){    $attach_range_in_names2='r2' }
             elsif($_[$i]=~/^n *$/){     $new_format='n' }
     }
     $attach_range_in_names='r';
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # Matching each machine readable line
     #_______________________________________________
     for($j=0; $j< @SSO; $j++){
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  >S33700_annexin
        #_________________________________________________________
        if($SSO[$j]=~/^ {1,3}\>(\S+)/){
             $query_seq=$query_seq_original=$1; $j+=4;
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  >>>S33700_annexin.fasta, 339 aa vs ../test_set.mpfa library
        #_________________________________________________________________________________
        }elsif($SSO[$j]=~/\>\>\> *(\S+)\,? +(\d+) +/){  ## >>>  line
             $query_found=1;  $query_seq_leng=$2;  ## Ignoring the $1, as file name can be different from rea seq names
             $j+=5;
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        #  >>S33700_annexin I; annexin repeat homology. [ Rattus norvegicus (Norway rat) ]
        #______________________________________________________________________________________
        }elsif( $query_found==1 and $SSO[$j]=~/^ {0,2}\>\>(\w[\S\-\.]+)([\.prot\,\:]*) */ ){ ##
             $match_found=1;
             $match_seq_count++;

             $al_display_start=0; ##<--- This is necessary in reading the sequence lines to return alignment with 'a' option

             if(length($2)>0){  print "\n# read_machine_readable_sso_lines: Seq name has this special char \"$2\". I ignore it"; }
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             #  Changing the CASE according to the option
             #_____________________________________________
             if($uppercase_seq_name eq 'U'){
                  $match_seq="$1"; $match_seq="\U$match_seq";  ## make it uppercase
             }elsif($lowercase_seq_name eq 'L'){
                  $match_seq="$1"; $match_seq="\L$match_seq"; ## make it lowercase
             }else{ $match_seq="$1";  } ## make it uppercase

             $query_seq=$query_seq_original; ## >>> BUG FIX <<< this resets ASSS_30-123 to ASSS, so that NO incremental ranges in query

        }elsif($match_found and $SSO[$j]=~/^ *\; +sw_score *\:\s+(\S+)/i){  $sw_score =$1;
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  ; sw_expect:  line NOT exists in pair comparison
        #___________________________________________________________
        }elsif($match_found and $SSO[$j]=~/^\; +\w+_expect\:? +(\S+)/){
            #~~~~~~~~~~~~~~~~~~~~~~~
            # Filtering by E val
            #_______________________
            if( $1 > $upper_expect_limit or $1 < $lower_expect_limit ){
                    $match_found=0; next;
            }else{ $expect =$1; }
        }elsif($match_found and $SSO[$j]=~/^\; +sw_ident\: +(\S+)/){  $sw_ident =$1;
        }elsif($match_found and $SSO[$j]=~/^ *\; +sw_overlap\: +(\S+)/){  $overlap=$1;

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  Matching ">d2admb__17-3 368 aa .." which is QUERY
        #_________________________________________________________
        }elsif($match_found and $SSO[$j]=~/^ {0,2}\>(\w[\S\-\.]+)([\.prot\,\:]*)/){
            $match_found2=1;        $match_found=0;
            if( length($2)>0 ){  print "\n# read_machine_readable_sso_lines: Seq name has this special char \"$2\". I ignore it"; }
        }elsif($match_found2==1 and $SSO[$j]=~/\; +sq_len\: +(\S+)/){
            $query_sq_len=$1;
        }elsif($match_found2==1 and $SSO[$j]=~/\; +al_start\: +(\S+)/){
            $query_sq_start=$abs_query_seq_start=$1;
        }elsif($match_found2==1 and $SSO[$j]=~/\; +al_stop\: +(\S+)/){
            $query_sq_stop=$1;
            $query_align_leng=$query_sq_stop-$query_sq_start+1;
        }elsif($match_found2 and $SSO[$j]=~/\;\s+al_display_start: +(\d+)/){
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # Following is important to keep track of the abs seq start point ($abs_query_seq_start=al_start-al_display_start)
            #______________________________________________________________________________________________________________________________
            $abs_query_seq_start-=$1;

            $al_display_start++;
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
            # When REGIONS are noted, record the original range info and adjust according to the alignment
            #___________________________________________________________________________________________________
            if($query_seq=~/^(\S+)_(\d+)\-(\d+)$/){
                 $query_seq=$1;
                 $original_Q_sq_start=$2;
                 $original_Q_sq_stop =$3;
                 $query_sq_start +=$2-1 ;
                 $query_sq_stop  +=$2-1;
                 $query_seq="$query_seq\_$query_sq_start\-$query_sq_stop";
            }elsif($query_seq){
                $query_seq="$query_seq\_$query_sq_start\-$query_sq_stop" if $attach_range_in_names;
            }else{
               print "\n \$query_seq is empty for \n\n"; die;
            }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  Matching ">RPOP_NEUCR_50-433" which is MATCH
        #_________________________________________________________
        }elsif($match_found2 and $SSO[$j]=~/^ {0,2}\>(\w[\S\-\.]+)([\.prot\,\:]*) *[\d+]*/){
            $match_found3=1;
            $match_found2=0;
            $match_seq   =$1;
            if(length($2)>0){  print "\n# open_sso_files: Seq name has this special char \"$2\". I ignore it"; }
        }elsif($match_found3 and $SSO[$j]=~/\; +sq_len\: +(\S+)/){
                 $match_sq_len=$1;
        }elsif($match_found3 and $SSO[$j]=~/\; +al_start\: +(\d+)/){
                 $match_sq_start=$abs_match_seq_start=$1;
        }elsif($match_found3 and $SSO[$j]=~/\; +al_stop\: +(\d+)/){
                 $match_sq_stop=$1;
                 $match_align_leng=$match_sq_stop-$match_sq_start+1;
        }elsif($match_found3 and $SSO[$j]=~/\; +al_display_start: +(\d+)/){
                $match_found3=0;

                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # Following is important to keep track of the abs seq start point
                #________________________________________________________________________
                $abs_match_seq_start-=$1;

                $al_display_start++;
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # To prevent Null SWscore and Eval
                #___________________________________________________
                if(!$expect){   $expect='0.0';
                        if((!$sw_score and $expect==0) or $sw_ident > 0.8){ $sw_score=1000; }
                }
                #~~~~~~~~~~~~~~~~~~~~~~~~~
                # Attaching the ranges  (under NO e option)
                #_________________________
                if($attach_range_in_names){
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # Checks margin opt and adds it
                      #__________________________________
                      if($margin=~/\d+/){
                           if($match_sq_start < $margin){  $match_sq_start=1;
                           }else{          $match_sq_start-=$margin;   }
                           $match_sq_stop += $margin;
                      }
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # adding the offset for names with ranges
                      #__________________________________________________
                      if($match_seq=~/^(\S+)_(\d+)\-(\d+)$/){
                           $match_seq=$1;
                           $original_M_sq_start=$2;
                           $original_M_sq_stop =$3;
                           $match_sq_start +=$2-1;
                           $match_sq_stop  +=$2-1;
                           $match_seq="$match_seq\_$match_sq_start\-$match_sq_stop";
                      }
                      $name_range=$match_seq;

                      if($original_target_seq=~/\S+/){ $query_seq=$original_target_seq } # for PVM version out
                      if($new_format=~/n/){  # under NO e option
                          $match{$name_range}=sprintf("%s %s %s %s %s %s %s %s %s\n",
                          $query_seq, $query_sq_start, $query_sq_stop, $sw_score, $expect, $sw_ident,
                          $match_sq_start, $match_sq_stop, $name_range);
                      }else{
                          $match{$name_range}=sprintf("%-5s %-9s %-6s %-4s %-5s %-30s %-4s %-5s %s\n",
                          $sw_score, $expect, $sw_ident, $query_sq_start, $query_sq_stop, $query_seq,
                          $match_sq_start, $match_sq_stop, $name_range);
                      }
              }else{
                   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   # Checks margin opt and adds it
                   #__________________________________
                   if($margin=~/\d+/){
                           if($match_sq_start < $margin){  $match_sq_start=1;
                           }else{                          $match_sq_start-=$margin; }
                           $match_sq_stop += $margin;
                   }
                   if($original_target_seq=~/\S+/){ $query_seq=$original_target_seq } # for PVM version out

                   if($new_format=~/n/){
                           $match{$match_seq}=
                                sprintf("%s %s %s %s %s %s %s %s %s\n",
                                $query_seq, $query_sq_start, $query_sq_stop, $sw_score, $expect, $sw_ident,
                                $match_sq_start, $match_sq_stop, $match_seq);
                   }else{
                           $match{$match_seq}=sprintf("%-5s %-9s %-6s %-4s %-5s %-30s %-4s %-5s %s\n",
                               $sw_score, $expect, $sw_ident, $query_sq_start, $query_sq_stop, $query_seq,
                               $match_sq_start, $match_sq_stop, $match_seq);
                   }
              }
        }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # When 'a' option set, for getting sequences to show alignment
        #________________________________________________________________
        if($get_alignment and $al_display_start==1 and $SSO[$j]=~/^([\w\-]+) *$/){
                 ${"match_alignment\_$match_seq_count"}{"$query_seq"} .= $1;
        }elsif($get_alignment and $al_display_start==2 and $SSO[$j]=~/^([\w\-]+) *$/){
                 ${"match_alignment\_$match_seq_count"}{"$match_seq"} .= $1;
        }elsif($get_alignment and ($SSO[$j]=~/^ *\;al_cons\:/ or $SSO[$j]=~/\<\<\</)){
                 $al_display_start=0;
                 #print ${"match_alignment\_$match_seq_count"}{"$query_seq"} , "\n";
                 #print ${"match_alignment\_$match_seq_count"}{"$match_seq"} , "\n";
                 my %temp=%{"match_alignment\_$match_seq_count"};
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Getting seq segments Matched !!
                 #_______________________________________________________________
                 $Q_fragment_start=$query_sq_start-$original_Q_sq_start;
                 $M_fragment_start=$match_sq_start-$original_M_sq_start;
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # (1) When Q alignment starts with gap> '-----XXXXX' + 'ADFAYXXXXX', remove gaps
                 #__________________________________________________________________________________
                 if($temp{$query_seq}=~/^(\-+)\w/){
                         $leading_gap_leng=length($1);
                         #print "\n\$leading_gap_leng : $leading_gap_leng $abs_query_seq_start, $abs_match_seq_start, $query_align_leng, $match_align_leng\n";

                         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         # Number of gap char is important as the al_start and al_stop of FASTA does not include gap leng
                         #_______________________________________________________________________________________________________________
                         $temp{$query_seq}=substr($temp{$query_seq}, $leading_gap_leng+$abs_query_seq_start, ); ## <-- step 1
                         $gap_char_num=$temp{$query_seq}=~tr/\-/\-/;                       ## <-- step 2
                         $temp{$query_seq}=substr($temp{$query_seq}, 0, $query_align_leng+$gap_char_num); ## <-- step 3
                         $temp{$match_seq}=substr($temp{$match_seq}, $leading_gap_leng+$abs_query_seq_start, $query_align_leng+$gap_char_num);
                         #print "\n$temp{$query_seq}\n$temp{$match_seq} $query_align_leng + $gap_char_num \n"; #die;
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # (2) When M alignment starts with gap> '-----XXXXX' + 'ADFAYXXXXX', remove gaps
                 #____________________________________________________________________________________
                 }elsif($temp{$match_seq}=~/^(\-+)\w/){
                      $leading_gap_leng=length($1);
                      #print "\n\$leading_gap_leng : $leading_gap_leng $abs_query_seq_start, $abs_match_seq_start, $query_align_leng, $match_align_leng\n";

                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # Number of gap char is important as the al_start and al_stop of FASTA does not include gap leng
                      #_______________________________________________________________________________________________________________
                      $temp{$query_seq}=substr($temp{$query_seq}, $leading_gap_leng+$abs_match_seq_start, ); ## <-- step 1
                      $gap_char_num=$temp{$query_seq}=~tr/\-/\-/;                       ## <-- step 2
                      $temp{$query_seq}=substr($temp{$query_seq}, 0, $query_align_leng+$gap_char_num); ## <-- step 3
                      $temp{$match_seq}=substr($temp{$match_seq}, $leading_gap_leng+$abs_match_seq_start, $query_align_leng+$gap_char_num);
                      #print "\n$temp{$query_seq}\n$temp{$match_seq} $query_align_leng + $gap_char_num \n"; #die;
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # (3) When Alignment is like> 'YYY----XXzz' + 'YYYDFAYXXzz'
                 #____________________________________________________________________________
                 }else{
                      #print "\n $abs_query_seq_start, $abs_match_seq_start, \$query_align_leng $query_align_leng, $match_align_leng\n";
                      $temp{$query_seq}=substr($temp{$query_seq}, $abs_query_seq_start, );
                      $gap_char_num=$temp{$query_seq}=~tr/\-/\-/;
                      $temp{$query_seq}=substr($temp{$query_seq}, 0, $query_align_leng+$gap_char_num);
                      $temp{$match_seq}=substr($temp{$match_seq}, $abs_match_seq_start, $query_align_leng + $gap_char_num);
                      #print "\n$temp{$query_seq}\n$temp{$match_seq} $query_align_leng + $gap_char_num $match_align_leng $gap_char_num\n"; die;
                 }
                 push(@out_refs, \%temp );
                 %{"match_alignment\_$match_seq_count"}=();
            }
     } ## <-- for($j=0; $j< @SSO; $j++)
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # If create sso option is set, it creates SSO files(array input case)
     #________________________________________________________________________
     if( $create_sso and !$get_alignment){
         open (SSO2, ">$query_seq\.msso");
         print SSO2 @SSO, "\n";
         print "\n# read_machine_readable_sso_lines : $query_seq\.msso file  is created by \"c\" opt ";
         close SSO2
     }
     unless($get_alignment){
         push(@out_refs, \%match);
     }
     return(\@out_refs);
}




#_________________________________________________________________________________
# Title     : read_sso_lines
# Usage     : &read_sso_lines([@sso], $create_sso, $attach_range_in_names,
#                 $attach_range_in_names2, $new_format, $get_alignment) );
# Function  : Main subroutine for open_sso_files. This calls either machine
#              readable or unreadable form parsing subroutine
# Example   :
# Keywords  : read_sso_lines_in_array
# Options   : a c r r2 n
#             u= for upper E value limit
#             l= for lower E value limit
# Category  :
# Version   : 1.5
#----------------------------------------------------------------------------
sub read_sso_lines{
		my (@out_refs, $parseable, @SSO, $create_sso, $i, $j, $k, $attach_range_in_names);
		my ($upper_expect_limit, $lower_expect_limit)=(50,0); ##<<--- DEFAULT

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
		# Processing input and options, don't worry!
		#__________________________________________
		for($i=0; $i< @_; $i++){
			 if($_[$i]=~/u=(\S+)/){    $upper_expect_limit=$1 }
			 elsif(ref($_[$i]) eq 'ARRAY'){ @SSO=@{$_[$i]};   }
			 elsif($_[$i]=~/l=(\S+)/){ $lower_expect_limit=$1 }
			 elsif($_[$i]=~/^c$/){     $create_sso = 'c' }
			 elsif($_[$i]=~/^a$/){     $get_alignment='a'; }
			 elsif($_[$i]=~/^r$/){   $attach_range_in_names='r' }
			 elsif($_[$i]=~/^r2$/){   $attach_range_in_names2='r2' }
			 elsif($_[$i]=~/^n$/){   $new_format='n' }
		}
		print "\n# (INFO) \$attach_range_in_names2 is $attach_range_in_names2" if $attach_range_in_names2;

		#~~~~~~ Checking if sso is a parseable form or not~~~~~~~~~~~~~
		TEMP:for($k=0; $k < @SSO; $k++){
					if($SSO[$k] =~ /\>\>\>/  or $SSO[$k] =~ /^ *\; \S+\:/ ){
							$parseable++;  if($parseable >= 8){  last TEMP;     }
					}elsif($SSO[$k]=~/^  +\:+/){ $parseable--;
					}elsif($SSO[$k] =~ /^ +1\>\>\>(\S+)/){ $pvm_version_fasta_out=1; $parseable +=10; $original_target_seq=$1; last TEMP;
					}
		}
		if($parseable >= 8){ ## 8 is critically important as some do not have matche seq in FASTA, SSEARCH
		    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		    # Machine READABLE  MSSO style file input(SSEARCH, FASTA result)
				#_________________________________________________________________
				@out_refs=@{&read_machine_readable_sso_lines(\@SSO,
								"u=$upper_expect_limit",
								"l=$lower_expect_limit",
								$get_alignment, $create_sso,
								$new_format, $attach_range_in_names,
								$attach_range_in_names2)};
		}else{
		    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		    # Machine UNREADABLE  MSSO style file input(SSEARCH, FASTA result)
				#_________________________________________________________________
				@out_refs=@{&read_machine_unreadable_sso_lines(\@SSO,
								$get_alignment, $create_sso,
								"u=$upper_expect_limit",
								"l=$lower_expect_limit",
								$new_format, $attach_range_in_names,
								$attach_range_in_names2)};
		}
		return(@out_refs);
}



#________________________________________________________________________________
# Title     : read_machine_unreadable_sso_lines
# Usage     : @out_refs=@{&read_machine_unreadable_sso_lines(\@SSO, $get_alignment,
#                           $create_sso, $upper_expect_limit,$new_format, $lower_expect_limit,
#                           $attach_range_in_names, $attach_range_in_names2)};
# Function  :
# Example   : output will look=>
#  ZFH1_DROME 60 d1ad3a_ 446 d1ad3a_ 0.9 71 34 3-37 253-287
#  ZFH1_DROME 60 d1ahdp_ 68 d1ahdp_ 0.00018 100 56 2-58 3-59
#  ZFH1_DROME 60 d1crka2 282 d1crka2 8.4 58 50 5-55 73-123
#  ZFH1_DROME 60 d1dkza_ 215 d1dkza_ 4.9 59 40 1-41 112-152
#  ZFH1_DROME 60 d1ecra_ 305 d1ecra_ 3.2 63 47 9-56 201-248
#
# Keywords  : read_normal_sso_lines
# Options   : a c r r2 n
#             u= for upper E value limit
#             l= for lower E value limit
# Version   : 1.3
#--------------------------------------------------------------------------------
sub read_machine_unreadable_sso_lines{
	 my ($upper_expect_limit, $lower_expect_limit)=(50,0);
	 my (@SSO, @out_refs, $match_seq, $match_evalue, $alignment_found,
			 $match_zscore, $query_seq_len, $space, %match, $entry_found,
			 $match_gap_len, $query_seq_name, $i, $j, $sw_score, $match_evalue,
			 $sw_ident, $query_seg_start, $query_seg_end, $match_seg_start,
			 $match_seg_end, $query_gap_len, $match_gap_len, $overlap,
			 $gap_start, $start, $match_range);
	 for($i=0; $i< @_; $i++){
			 if($_[$i]=~/u=(\S+)/){    $upper_expect_limit=$1 }
			 elsif(ref($_[$i]) eq 'ARRAY'){ @SSO=@{$_[$i]};   }
			 elsif($_[$i]=~/l=(\S+)/){ $lower_expect_limit=$1 }
			 elsif($_[$i]=~/^c$/){     $create_sso = 'c' }
			 elsif($_[$i]=~/^a$/){     $get_alignment='a'; }
			 elsif($_[$i]=~/^r$/){   $attach_range_in_names='r' }
			 elsif($_[$i]=~/^r2$/){   $attach_range_in_names2='r2' }
			 elsif($_[$i]=~/^n$/){   $new_format='n' }
	 }

	 print "\n# (i)read_machine_unreadable_sso_lines : You have put non-parseable format of xxxx.sso\n";
	 print "#      Did you set \'M\' option in do_sequence_search? \n";

	 for($j=4; $j< @SSO; $j++){
			 if($SSO[$j]=~/^ *\S+\: +(\d+) +\w+ *$/){ ## matching 'hbox.fasta: 60 aa'
						$query_seq_len=$1;
						print "\n (INFO) target seq len is  $query_seq_len \n";

			 }elsif($query_seq_len and $SSO[$j]=~/^ \>(\w[\w\-\.\/\\]+)/){ ##  matching  >MJ0497
						$query_seq_name=$1;
						$j+=4; ## jumping to skip the stat bars
						print "\n# (i)read_machine_unreadable_sso_lines : Found Query seq=> $query_seq_name ";
						next;
			 }

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # Matching the Match sequences
			 #_________________________________________________
			 if($query_seq_name and $SSO[$j]=~/^ {0,4}\>\> *(\S+) +.+\((\d+) aa\) *$/){ # # matching >>MG032 ATP-d (addA) Bacillus subtilis  (666 aa)
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
						# This is the assignment to OUT hash
						#________________________________________________
						if($alignment_found > 0){ ## If I have already read >>xxxx
								$match{$match_seq}=sprintf("%-5s %-8s %-6s %-4s %-5s %-30s %-4s %-5s %s\n",
									 $sw_score, $match_evalue, $sw_ident, $query_seg_start, $query_seg_end, $query_seq_name,
									 $match_seg_start, $match_seg_end, $match_seq);
						}
						$match_seq=$1;
						$entry_found=1;    $alignment_found=0;
						$query_gap_len=$match_gap_len=$match_seg_start=$match_seg_end=0;
						$query_seg_start=$query_seg_end=$overlap=0;
						undef($space);
						print "\n# (INFO) read_machine_unreadable_sso_lines : Found MATCHed seq $match_seq\n" if $verbose;
			 }elsif($entry_found and $SSO[$j]=~/ *Z\-score: *(\S+) *expect\( *\) +(\S+)/){ ## getting Evalue
						$match_zscore=$1;   # just in case needed
						$match_evalue=$2;
						if($upper_expect_limit < $match_evalue or $lower_expect_limit > $match_evalue){
								$match_seq=$alignment_found=$entry_found=$query_gap_len='';
						}
			 }elsif($entry_found and $SSO[$j]=~/Smith\-Waterman +score\: +(\d+)\; *(\S+) *\% *identity *in *(\d+) *aa overlap/i){
						$sw_score=$1;
						$sw_ident=$2;
						$overlap=$3;
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # Measuring the gap before position info "^         50        60$"
			 #_______________________________________________________________________
			 }elsif( $entry_found and !$alignment_found  and $SSO[$j]=~/^( +)(\d+) +\d+/  ){
						$start=$2;                                ## $start is the digit
						$gap_start=length($1)+length($start)-1;
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# $alignment_found is set HERE!
						#_____________________________________
						$alignment_found=1;
						print "\n# $query_seq_name $match_seq \$gap_start is  $gap_start, \$start: $start" if $verbose;
			 }elsif($alignment_found==1 and $SSO[$j]=~/^( +)[\.\:]/ ){ ### matching    .: .: : ::     :.:..: :.. .. ..
						$space=length($1);
						$query_seg_start=$space-$gap_start+$start;
						$query_seg_end=$query_seg_start+$overlap;
						$query_range="$query_seg_start-$query_seg_end";
			 }elsif($space and $alignment_found==1 and  $SSO[$j]=~/^( +)(\d+)/ ){ ##  !! $alignment_found == 1 !!
						$alignment_found++; ## <<--- $alignment_found++;  should increment!
						$match_gap_start=length($1)+length($2)-1;
						$match_start=$2;
						$match_seg_start=$space-$match_gap_start+$match_start;
						$match_seg_end=$match_seg_start+$overlap;
						$match_range ="$match_seg_start-$match_seg_end";
						#$match{$match_seq}.="$query_range $match_range ";
						#print "\n $query_seq_name $match_seq $match_evalue $overlap $query_range $match_range";
			 }
		}# end of for $j
		if( ($create_sso=~/c/) && (@file < 1) ){
			 open (SSO2, ">$query_seq_name\.sso");
			 print SSO2 @SSO, "\n";
			 print "\n# (INFO) $query_seq_name\.sso  is created";
			 close SSO2;
		}
		push(@out_refs, \%match);
		return(\@out_refs);
}# end of for $i




#________________________________________________________________________________
# Title     : make_seq_alignment_length_even
# Usage     : @out=@{&make_seq_alignment_length_even(\%hash1, \%hash2)};
#             @out=@{&make_seq_alignment_length_even(\%hash1)};
# Function  : creates hashes with values of equal lengths.
# Example   :
#    seq3     ---lasdkfjklsdjfkldjklfj----
#    seq4     dfasdfasdfadsfsadfsaas
#
#  will result in
#    seq3     ---lasdkfjklsdjfkldjklfj----
#    seq4     dfasdfasdfadsfsadfsaas------
#
# Keywords  : make_alignment_length_even, equalise_seq_alignments
# Options   :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub make_seq_alignment_length_even{
		my (@hash, $i, $leng_diff, @hash_out);
		for($i=0; $i< @_; $i++){
			 if(ref($_[$i]) eq 'HASH') {
							 push(@hash, $_[$i]);
			 }
		}
		for($i=0; $i< @hash; $i++){
			 my %hash1=%{$hash[$i]};
			 my ($seq1, $seq2)= keys %hash1;
			 $length_seq1=length($hash1{$seq1});
			 $length_seq2=length($hash1{$seq2});
			 $leng_diff=abs($length_seq1-$length_seq2);

			 if($length_seq1 > $length_seq2){
						$hash1{$seq2} .="-"x$leng_diff;
			 }else{
						$hash1{$seq1} .="-"x$leng_diff;
			 }
			 push(@hash_out, \%hash1);
		}
		if(@hash_out ==1){
			 return($hash_out[0]);
		}else{
			 return(\@hash_out);
		}
}

#________________________________________________________________________________
# Title     : tempname
# Usage     : $tmp=&tempname;
# Function  : Returns a unique temporary filename.
#             Reasonably robust but not completely immune to race conditions
#             with other processes simultaneously requesting a tempname.
# Example   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.0
#--------------------------------------------------------------------------------
sub tempname{
		foreach $suffix (0..99) {
			 if (! (-e "tmpxx$suffix")) {
		open(TMP,">tmpxx$suffix"); # Stamp it to reserve it.
		close(TMP);
		return "tmpxx$suffix";
			 }
		}
}

#_______________________________________________________________________________
# Title     : fasta_kt1_search
# Usage     : &fasta_kt1_search($query_database, $target_database, $fasta_version_to_use
# Function  : to search one database against the other using fasta
#                ktup=1 (default is simply "fasta"). The results are stored in sub dirs
#                which are from the 2 first chars of the query sequence.
# Example   : &fasta_kt1_search ($qdb_main, $tdb_main, $fastaver_main);
# Keywords  : fasta_search, fasta_database_search
# Options   :
# Author    : Sarah A. Teichmann
# Date      : 19th September 1997
# Category  :
# Version   : 1.1
#-------------------------------------------------------------------------------
sub fasta_kt1_search{
		my ($qdb, $tdb, @qdbcont, $fastaver, $gene, $seq,
				@genes, %genes, $genes, $out, $tmp, $sw_score,
				$e_val, @tmpcontent, $i, $dir, @dir);
		$qdb=$_[0];
		open (QDB, "$qdb");
		@qdbcont=<QDB>;
		close QDB;
		$tdb=$_[1];
		open(TDB, "$tdb");
		close TDB;
		if ($_[2]){ $fastaver=$_[2]; }
		else{$fastaver="fasta";}
		for ($i=0; $i<@qdbcont; $i++) {
	my $qdbcont=$qdbcont[$i];
	if ($qdbcont=~/^\>(\S+)/) {
	   $gene=$1;
	   push (@genes, $gene);
	}
	if ($qdbcont=~/^(\w+)/) {
	   $seq=$1;
	   $genes{"$gene"}.="$seq";
				}else {next;}
		}
		for ($i=0; $i<@genes; $i++) {
					$genes=$genes[$i];
					@dir=split(//, $genes);
					@dir=splice(@dir, 0, 2);
					$dir=join('', @dir);
					mkdir ($dir,  0777) unless -d $dir;  ## Jong changed
					$out="$dir"."/"."$genes".".sso";
					if (-s $out){next;}  ## -s is better than -e
					$tmp=&tempname;
					open (TMP, ">$tmp");
					print TMP ">$genes\n", $genes{"$genes"}, "\n";
					close TMP;
					$sw_score=0;
					$e_val=10;
					@tmpcontent=`$fastaver -E 0.1 -H -m 10 $tmp $tdb 1`;
					open (OUT, ">$out");
					print OUT "@tmpcontent\n";
					close OUT;
					unlink ("$tmp");
					next;
		}
}


#________________________________________________________________________________
# Title     : mspa_single_link_hash
# Usage     : %hash=%{&mspa_single_link_hash(\@mspa_files, E-value);
# Function  : To make a hash with all the genes in the mspa files as the keys,
#             which are linked at or below the E-value threshhold,
#             with the values denoting the cluster number
# Example   :
# Keywords  : single_linkage, mspa_single_linkage, mspa_single_linkage_hash
#              make_mspa_single_link_hash
# Options   :
# Author    : Sarah A. Teichmann with thanks to Alex Bateman,
#               sat@mrc-lmb.cam.ac.uk, jong@salt2.med.harvard.edu
# Version   : 1.7
#--------------------------------------------------------------------------------
sub mspa_single_link_hash{
		my (@mspa_files, $i, $j, $k, $e_val, $gene_1, $gene_2,
				@mspcont, $gene_1, $gene_2, $E_cut, %hash, $array);

		$E_cut=0.001; ## Default Eval cut

		if( @_==2 and ref($_[0]) eq 'ARRAY'){
				@mspa_files=@{$_[0]};
				$E_cut=${$_[1]} || $_[1];
		}else{
				print "Subroutine mspa_single_link_hash takes one input array and the E-value as its arguments!!" && die;
		}
		#print "\n# (i) mspa_single_link_hash : \$E_cut is $E_cut \nwith @mspa_files\n";
		print "\n# (i) mspa_single_link_hash : \$E_cut is $E_cut \nwith @mspa_files\n" if $verbose;

		for ($i=0; $i<@mspa_files; $i++){
				if ($mspa_files[$i]=~/\S+\.msp$/){
						open(MSP, "$mspa_files[$i]");
						@mspcont=<MSP>;
						close(MSP);
				}elsif ($mspa_files[$i]=~/\S+\.msp\.gz$/){
						@mspcont=`gunzip -c $mspa_files[$i]`;
						#print "\n @mspcont \n"; die;
				}

				$array++;
				for ($j=0; $j<@mspcont; $j++){
						if ($mspcont[$j]=~/^\s*\S+\s+(\S+)\s+\S+\s+\d+\s+\d+\s+(\S+)\s+\d+\s+\d+\s+(\S+)/){
								$e_val=$1;
								unless($e_val<=$E_cut){next;}
								$gene_1=$2;
								$gene_2=$3;
								#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
								# Removing REGION information as Sarah's can not handle regions
								#_______________________________________________________________
								if($gene_1=~/^(\S+)_\d+\-\d+/){ $gene_1=$1 }
								if($gene_2=~/^(\S+)_\d+\-\d+/){ $gene_2=$1 }

								if ($gene_1 eq $gene_2){next;}
								if ( ! $hash{"$gene_1"} and $gene_1){
										$hash{"$gene_1"}="$array";
										push (@{"$array"}, $gene_1);
								}
								if (! $hash{"$gene_2"} and $gene_2){
										$hash{"$gene_2"}="$array";
										push (@{"$array"}, $gene_2);
								}
								if ($hash{"$gene_1"}==$hash{"$gene_2"}){next;}
								if ( $hash{"$gene_1"} gt  $hash{"$gene_2"}){
										push (@{"$hash{$gene_2}"}, @{"$hash{$gene_1}"});
										for ($k=0; $k<@{"$hash{$gene_2}"}; $k++){
												 $hash{${"$hash{$gene_2}"}[$k]}=$hash{"$gene_2"};
												 next;
										}
										next;
								}
								if ( $hash{"$gene_2"} gt  $hash{"$gene_1"}){
										push (@{"$hash{$gene_1}"}, @{"$hash{$gene_2}"});
										for ($k=0; $k<@{"$hash{$gene_1}"}; $k++){
												 $hash{${"$hash{$gene_1}"}[$k]}=$hash{"$gene_1"};
												 next;
										}
										next;
								}
								next;
						}else{ next; }
				}
				next;
		}
		return (\%hash);
} ## mspa_single_link_hash




#________________________________________________________________________________
# Title     : print_clusfile_from_hash
# Usage     : &print_clusfile_from_hash(\%hash)
# Function  : To print out a file in cluster file format from an input hash containing the genes as keys and the cluster number as values.
# Example   :
# Keywords  : print_single_linkage_cluster, print_cluster_file
# Options   :
# Author    : Sarah A. Teichmann
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub print_clusfile_from_hash {
		my ($i, $j, $k, $gene, @subclus, %hash, $single_linkage_cluster);
		$single_linkage_cluster="single_linkage.sclu";
		open(SING, ">$single_linkage_cluster") or die "\n# $0: print_clusfile_from_hash: failed to open $single_linkage_cluster\n";
		if( @_==1 and ref($_[0]) eq 'HASH'){%hash=%{$_[0]};}

		my @clusters=values(%hash);

		@clusters=@{&remove_dup_in_array(\@clusters)};
		my @genes=keys(%hash);
		for ($i=0; $i<@genes; $i++){
				my $clus=$hash{"$genes[$i]"};
				push(@{"$clus"},$genes[$i]);
				next;
		}

		my (%sizes);
		for ($i=0; $i<@clusters; $i++){
				my $cluster=$clusters[$i];
				@{"$cluster"}=@{&remove_dup_in_array(\@{"$cluster"})};
				my $size=@{"$cluster"};
				$sizes{"$size"}.="$cluster\n";
				next;
		}


		my @clus_sizes=keys(%sizes);
		@clus_sizes=sort {$a<=>$b} (@clus_sizes);

		for ($i=0; $i<@clus_sizes; $i++){
				my $clus_size=$clus_sizes[$i];
				unless ($clus_size>1){next;}
				print SING "Cluster size $clus_size\n";
				my @subclus=split(/\n/,$sizes{"$clus_size"});
				for ($j=0; $j<@subclus; $j++){
						my $clus=$subclus[$j];
						print SING "Cluster $clus\n";
						for ($k=0; $k<@{"$clus"}; $k++){
								$gene=${"$clus"}[$k];
								print SING " 1 1 $gene\n";
								next
								}
						next;
			 }
			 next;
		}
		close SING;
		return(\$single_linkage_cluster);
}

#________________________________________________________________________________
# Title     : make_clustering_summary
# Usage     : &make_summ($sorted_cluster_file)
# Function  : to make a summary file of a sorted cluster file
# Example   :
# Keywords  : summary, make_cluster_summary, subclustering summary
# Options   :
# Author    : Sarah A. Teichmann
# Date      : 19th September 1997
# Category  :
# Version   : 1.5
#--------------------------------------------------------------------------------
sub make_clustering_summary{
		my ($good_cluster_file, $summary_file, @filecontent, $i, $filecontent,
				$cluster_size, @cluster_sizes, $cluster_number, $number_of_clusters,
				 $summary_file, @filecontent, %hash, @keys, @temp_clu, $make_separate_summary);
		$good_cluster_file=${$_[0]} || $_[0];

		$make_separate_summary=0;
		for($i=0; $i< @_; $i++){
				if($_[$i]=~/u *$/){  $make_separate_summary='u';
														 splice(@_, $i, 1)
				}
		}

		$summary_file="$good_cluster_file".".summary";

		open(CLU_FILE, "$good_cluster_file");
		while(<CLU_FILE>){
					push(@temp_clu, $_);  ## copying the content to ;
					if( /^ *Cluster +size +(\d+)/i){
							$cluster_size=$1;
					}elsif (/^ *Cluster +[number]* *(\d+)/) {
							$hash{$cluster_size} ++;
					}
		}
		close(CLU_FILE);

		open(CLU_FILE, ">$good_cluster_file"); # now overwrting it.

		if($make_separate_summary){
				open (SUMM, ">$summary_file");
				print SUMM "Cluster size    No. of clusters\n";
		}

		print CLU_FILE "Cluster size    No. of clusters\n";
		@keys=sort {$a<=>$b} keys %hash;
		for ($i=0; $i<@keys; $i++){
				print SUMM "     $keys[$i]               $hash{$keys[$i]}\n" if $make_separate_summary;
				print CLU_FILE "     $keys[$i]               $hash{$keys[$i]}\n";
		}
		close (SUMM) if $make_separate_summary;
		print CLU_FILE "\n# This file is created by $0 with make_clustering_summary sub, Details below\n\n";
		for(@temp_clu){  print CLU_FILE $_ }
		close (CLU_FILE);
		return(\$summary_file);
}

#_______________________________________________________________________________
# Title     : create_accounts_for_folders
# Usage     : @processed_files=&create_accounts_for_folders("d=$input_dir");
#                     $input_dir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
# Function  : open dir and process all files in the dir if you wish,
#             and then go in any other sub
#             if any file(dir) is linked, it skips that file.
# Example   : as in my 'indexing.pl' for perl file indexer.
# Warning   : Seems to work fine., !! Change the name of this sub to shorter one
#                                  !! for your own purpose.
# Keywords  : open_dir_and_go_in_and_do_something, open_subdir_and_gon_in_and_do_something
#             open_directory_and
#             go in there do something, get into subdir and do something.
#             go_in_subdir_and_do_something, recursive execution
#
#             ** Check out some subs derived from this:
#              concatenate_seq_files_in_subdir_to_db
#              opendir_and_go_in_and_make_pdb_db
# Options   :
#    $input_dir= by d=
# Returns   :
# Argument  : gets a ref. of a scaler (dir name) and returns nothing(void).
# Category  :
# Version   : 1.0
#---------------------------------------------------------------------------
sub create_accounts_for_folders{
    my ($each_file, $file, $new_fasta_name, %pdb_seq, @included_files,
        $min_seq_leng_accepted, @read_files, $original_dir);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Input argument processing and reading in all the files
    #______________________________________________________________
    if(ref($_[0]) eq 'SCALAR'){
        ${$_[0]}=~/d=(\S+)/; $original_dir=$1;
    }elsif($_[0]=~/d=(\S+)/){ $original_dir=$1; }
		@read_files=@{&read_any_dir_simple(\$original_dir)};
		sub read_any_dir_simple { my($in_dir); $in_dir=${$_[0]} || $_[0]; opendir(DIR1,"$in_dir");
		    my(@read_files) = readdir(DIR1);closedir(DIR1);	splice(@read_files, 0, 2);  return(\@read_files);
	}

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # removing /etd/passwd.lock and /etd/shadow.lock
    #___________________________________________________________
    if(-s "/etd/passwd.lock"){ unlink("/etc/passwd.lock") }
    if(-s "/etd/shadow.lock"){ unlink("/etc/shadow.lock") }

	chomp($pwd=`pwd`);
	foreach $file(@read_files){
         $each_file="$original_dir/$file";

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If the File read is DIR => Recurse
         #________________________________________________________
         if( -d "$each_file" ){  ## If it is a directory.
              $filename=${&extract_file_name($each_file)};
              $passwd="$filename\_2000";
              $group ='Biomatic';
              $home_dir="$each_file";
              if($filename=~/^[ABCDEFGHIJKLMNOPQRSTUVWXYZ][\-\.\w]*/){
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # check .bashrc and index.html. Only dirs with index.html will have accounts
                  #_____________________________________________________________________________
                  if(!-e "$home_dir\/.bashrc" and -s "$home_dir\/index.html"){
                     print "\nRoot:$original_dir, Creating an account with: -n $filename -g Biomatic -s /bin/bash -d $home_dir -p $passwd \n";
                     system("adduser -n $filename -g $group -s /bin/bash -d $home_dir -p $passwd");
                  }
              }
              $num=@included_files=(@included_files, &create_accounts_for_folders("d=$each_file") );   # RECURSION occurrs here!!

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If the File read is FILE => PROCESS!
         #________________________________________________________
         }elsif (-f $each_file){     #<<------ This is where things match
              next;
         }elsif (-l $each_file){
              print "\n\n$each_file is linked, skipping. \n";
              next;
         }else{  print "\n# (i) ODD?? "; next;  }
	}
	return(@included_files);
}





#______________________________________________________________________________
# Title     : create_sorted_cluster
# Usage     : &create_sorted_cluster
# Function  : to make a "sorted_cluster_file" from the .clu files in a directory
# Example   :
# Keywords  : make_cluster_file, sort_clu_files
# Options   :
# Author    : Sarah A. Teichmann, modified by Jong
# Date      : 19th September 1997
# Category  :
# Version   : 1.8
#--------------------------------------------------------------------------------
sub create_sorted_cluster{
		my ($i, $q, $p, $n, $j, $clufile, @filecontent, $new_gene, $cluster_size,
				@clufiles, @cluster_sizes_new_unsorted, @cluster_sizes_new,
				$newclus_number, %hash);

		@clufiles=@{$_[0]};
		if(@clufiles < 1 ){
				@clufiles=@{&read_file_names_only('.','.clu')};
				print "\n# $0, create_sorted_cluster: \@_ is empty, reading PWD to get xxx.clu files\n";
				if(@clufiles < 1){
					 print "\n# $0, create_sorted_cluster: I couldn\'t find any clu files, dying\n";
					 die;
				}
		}
		if($_[1]){  $good_cluster_file=${$_[1]}; }

		print "\n# (1) create_sorted_cluster: found \@clufiles are
								@clufiles\n";

		for ($i=0; $i < @clufiles; $i++) {
				 open (CLU_FILE, "<$clufiles[$i]") or
						die "\n# $0: create_sorted_cluster: error opening $clufiles[$i]";

				 my $cluster_size;
				 while(<CLU_FILE>){
						 if( /^ *Cluster +size +(\d+)/i){
								 $cluster_size=$1;
								 $hash{$cluster_size} .=$_;
						 }elsif (/^ *Cluster +[number]* *\d+/i) {
								 $hash{$cluster_size} .=$_;
						 }elsif (/^ *\d+ +\d+ +\S+/) {
								 $hash{$cluster_size} .=$_;
						 }
				}
	 }
	 close(CLU_FILE);
	 @sorted_by_size=sort { $a<=>$b } keys %hash;
	 $good_cluster_file2="sorted_cluster_file\.gclu";

	 open(GOODCLUS, ">$good_cluster_file") or die "\n# $0 create_sorted_cluster: I can not open $good_cluster_file\n";
	 open(GOODCLUS2, ">$good_cluster_file2") or die "\n# $0 create_sorted_cluster: I can not open $good_cluster_file\n";
	 for($i=0; $i< @sorted_by_size; $i++){
			 print GOODCLUS $hash{$sorted_by_size[$i]};
			 print GOODCLUS2 $hash{$sorted_by_size[$i]};
	 }
	 close(GOODCLUS);
	 close(GOODCLUS2);
	 return(\$good_cluster_file);
}





#______________________________________________________________________________
# Title     : interm_lib_search
# Usage     : &interm_lib_search(\@file, $over_write, $mspa_directly_opt, $create_sso, $single_big_msp);
#             &interm_lib_search(\%seq,  $over_write, $mspa_directly_opt, $create_sso, $single_big_msp);
# Function  : self_to_self input database search with reverse query as an option
# Example   : &interm_lib_search(\@file, $over_write, $mspa_directly_opt, $create_sso, $single_big_msp);
# Warning   :
# Keywords  : do_interm_lib_search, self_self_sequence_search, self_self_seq_search,
#             self_to_self_search, self_to_rev_self_search, self_to_reversed_self_search,
# Options   :
#             Query_seqs=  for enquiry sequences eg)  "Query_seqs=$ref_of_hash"
#             DB=   for target DB  "DB=$DB_used"
#             File= to get file base(root) name.  "File=$file[0]"
#             m  for MSP format directly from FASTA or Ssearch result than through sso_to_mspa to save mem
#             s  for the big single output (mspa file output I mean)
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             r  for reverse the query sequence
#             b  for doing in batch. Reads all the seqs in memory at one time
#             m10 for machine readable form
#             k= for k-tuple value. default is 1 (ori. FASTA prog. default is 2)
#             u= for $upper_expect_limit
#             l= for $lower_expect_limit
#             a= for choosing either fasta or ssearch algorithm
#             d  for $make_gz_in_sub_dir_opt, putting resultant sso files in gz format and in single char subdir
#             D  for $make_mspa_in_sub_dir_opt, convert sso to mspa and put in sub dir like /D/, /S/
#             n  for new format (msp2 format)
#       FILE_AGE for defining the age of file in days to be overwritten.
#
# Category  :
# Version   : 1.9
#-------------------------------------------------------------------------------
sub interm_lib_search{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my (%fasta_seqs, $new_format, $over_write, $upper_expect_limit, $lower_expect_limit,
	    $Score_thresh, $margin, $single_big_msp, $sequence_DB, $create_sso,
	    $mspa_directly_opt, $machine_readable, $make_gz_in_sub_dir_opt,
	    $do_in_batch, $make_mspa_in_sub_dir_opt, $new_format, $machine_readable,
				$age_in_days_of_out_file, $scramble_order, %seq_from_hash );
	my $algorithm='fasta';
	$mspa_directly_opt='m';
	$age_in_days_of_out_file=10000000000;
	#$single_big_mspa ='s';
	#$create_sso='c';
	$upper_expect_limit=2;
	my $k_tuple=1;

	if($vars{'a'}=~/\S+/){ $algorithm          = $vars{'a'}            };
	if($vars{'u'}=~/\d+/){ $upper_expect_limit = $vars{'u'}            };
	if($vars{'l'}=~/\d+/){ $lower_expect_limit = $vars{'l'}            };
	if($vars{'k'}=~/\d+/){ $k_tuple            = $vars{'k'}            };
	if($vars{'t'}=~/\d+/){ $Score_thresh       = $vars{'t'}            };
	if($vars{'m'}=~/\d+/){ $margin             = $vars{'m'}            };
	if($vars{'r'}=~/\S+/){ $add_range          = 'r'                   };
	if($vars{'s'}=~/\S+/){ $single_big_mspa     = 's'                   };
		if($vars{'DB'}=~/\S+/){ $sequence_DB       = $vars{'DB'}           };
	if($vars{'File'}=~/\S+/){ $input_file_name = $vars{'File'}         };
		if($vars{'FILE_AGE'}=~/\S+/){ $age_in_days_of_out_file= $vars{'FILE_AGE'};  };
	if($vars{'Query_seqs'}=~/\S+/){ %seq_input = %{$vars{'Query_seqs'}}};
	if($vars{'u'}         =~/\S+/){ $E_val     = $vars{'u'}            };
	if($char_opt=~/r/){    $add_range          = 'r' }
	if($char_opt=~/o/){    $over_write         = 'o'; print "\n# OVERWRITE option is set !!! \n\n"; }
	if($char_opt=~/c/){    $create_sso         = 'c' }
	if($char_opt=~/s/){    $single_big_mspa     = 's'; print "\n# Single file opt is set\n"; }
	if($char_opt=~/m/){    $mspa_directly_opt   = 'm' }
	if($char_opt=~/M/){    $machine_readable   = 'M' }
	if($char_opt=~/d/){$make_gz_in_sub_dir_opt = 'd' } # for simple search and storing in gz file (sso file will be zipped
	if($char_opt=~/D/){$make_mspa_in_sub_dir_opt= 'D' } # for simple search and storing mspa file
	if($char_opt=~/b/){    $do_in_batch        = 'b' } # for reading in all the
		if($char_opt=~/n/){    $new_format         = 'n' }
		if($char_opt=~/sc/){   $scramble_order     = 'sc' }
													   # seqs in memory
	if(-s "/gn0/jong/DB/PDB/PDB_Inter_lib/pdb95d_owl_interm_lib.fasta"){
			 $input_db_file = "/gn0/jong/DB/PDB/PDB_Inter_lib/pdb95d_owl_interm_lib.fasta";
	   print "\n# $0 is taking INTERM LIB from : $input_db_file\n";
	}elsif(-s $ENV{'INTERM_LIB'}){
	   $input_db_file = $ENV{'INTERM_LIB'};
	   print "\n# $0 is taking INTERM LIB from : \$ENV\{\'INTERM_LIB\'\}\n\n";
	}else{
	   print "\n# $0 could not find INTERM lib file\n"; die;
	}
	if(@hash > 0){
		for($i=0; $i< @hash; $i++){
			%seq_from_hash=(%seq_from_hash, %{$hash[$i]});
		}
		my @file_created=@{&do_sequence_search(\%fasta_seqs,
			           "FILE_AGE=$age_in_days_of_out_file",
			   "DB=$input_db_file",
			   "File=$file[$i]",
			   $single_big_msp,
			   $over_write,
			   "u=$upper_expect_limit",
			   "l=$lower_expect_limit",
			   "k=$k_tuple",
			   $add_range,
			   $create_sso,
			   "t=$Score_thresh",
			   "m=$margin",
			   "a=$algorithm",
			   $mspa_directly_opt,
			   $machine_readable,
			   $new_format )};
		  print "\n# File created: @file_created \n";
		}

	 	if($do_in_batch or $scramble_order and @file > 0){
	   for($i=0; $i< @file; $i++){
					%fasta_seqs=%{&open_fasta_files(\$file[$i])};
		  if($char_opt=~/r/){ ## reverse the query seqs.
			  %fasta_seqs=%{&reverse_sequences(\%fasta_seqs)};
		  }
		  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		  #  Main sequence search
		  #___________________________________________________
		  my @file_created=@{&do_sequence_search(\%fasta_seqs,
				       "FILE_AGE=$age_in_days_of_out_file",
																			 "DB=$input_db_file",
																			 "File=$file[$i]",
																			 $single_big_msp,
																			 $over_write,
																			 "u=$upper_expect_limit",
																			 "l=$lower_expect_limit",
																			 "k=$k_tuple",
																			 $add_range,
																			 $create_sso,
																			 "t=$Score_thresh",
																			 "m=$margin",
																			 "a=$algorithm",
																			 $mspa_directly_opt,
																			 $machine_readable,
																			 $new_format )};
		  print "\n# File created: @file_created \n";
	   }
	 }elsif(@file > 0){ ## reads in the big database file continously
	   my $make_gz_in_sub_dir_opt='d';
	   my ($ori_seq_name, $first_char, $seq_file_mspa_name,
	       $seq, $seq_name, $first_char);
	 	   for($i=0; $i< @file; $i++){
		   open(FASTA, "$file[$i]");
		   while(<FASTA>){
			  if( /\> *((\w)\S+)/ ){
				  $ori_seq_name=$1;
				  if($seq=~/\S/ and $seq_name=~/\S/){
																							my ($overwrite_by_age, $existing_mspa_file);
																							$seq_file_name="$seq_name\.fasta";
																							$seq_file_mspa_name="$seq_name\.msp";
																							$seq_file_mspa_gz_name="$seq_name\.msp\.gz";
																							$first_char= substr("\U$seq_name", 0, 1);
																							if(-s "$first_char\/$seq_file_mspa_name"){  $existing_mspa_file="$first_char\/$seq_file_mspa_name"; }
																							elsif(-s "$first_char\/$seq_file_mspa_gz_name"){  $existing_mspa_file="$first_char\/$seq_file_mspa_gz_name"; }

																							if(  (localtime(time- (stat($existing_mspa_file))[9]))[3] > $age_in_days_of_out_file ) {
																																		 $overwrite_by_age='o';
																																		 print "\n# interm_lib_search: $seq_file_mspa_name is older than $age_in_days_of_out_file days, ovrwrting\n";
																							}

																							if( !$over_write  and (-s "$first_char\/$seq_file_mspa_name" or -s "$first_char\/$seq_file_mspa_gz_name")
																																		 and !$overwrite_by_age ){
						 print "\n# interm_lib_search: $first_char\/$seq_file_mspa_name already exists or newer than $age_in_days_of_out_file \n";
						 $seq='';
					 }else{
						 &do_sequence_search({"$seq_name", "$seq"},
						                      "DB=$input_db_file" ,
																							"FILE_AGE=$age_in_days_of_out_file",
						                      "File=$seq_file_name",
																							$single_msp, $over_write,
																							"u=$upper_expect_limit",
																							"$make_gz_in_sub_dir_opt",
																							"l=$lower_expect_limit",
																							"k=$k_tuple",
																							$make_mspa_in_sub_dir_opt );
						 $seq='';
					 }
			      }
				  $seq_name=$ori_seq_name;
				  $first_char="\U$2"; # for storing output
			  }elsif(eof){
			      $seq.=$_;
				  if($seq=~/\S/ and $seq_name=~/\S/){
										 my ($overwrite_by_age, $existing_mspa_file);
										 $seq_file_name="$seq_name\.fasta";
					 $seq_file_mspa_name="$seq_name\.msp";
										 $seq_file_mspa_gz_name="$seq_name\.msp\.gz";
										 $first_char= substr("\U$seq_name", 0, 1);
										 if(-s "$first_char\/$seq_file_mspa_name"){  $existing_mspa_file="$first_char\/$seq_file_mspa_name"; }
										 elsif(-s "$first_char\/$seq_file_mspa_gz_name"){  $existing_mspa_file="$first_char\/$seq_file_mspa_gz_name"; }

										 if(  (localtime(time- (stat($existing_mspa_file))[9]))[3] > $age_in_days_of_out_file ) {
													$overwrite_by_age='o';
													print "\n# interm_lib_search : $seq_file_mspa_name is older than $age_in_days_of_out_file days, ovrwrting\n";
										 }

					 if( !$over_write  and (-s "$first_char\/$seq_file_mspa_name" or -s "$first_char\/$seq_file_mspa_gz_name")
					     and !$overwrite_by_age ){
						 print "\n# $first_char\/$seq_file_mspa_name already exists. (interm_lib_search) \n";
					 }else{
						 &do_sequence_search({"$seq_name", "$seq"},
						                      "DB=$input_db_file" ,
																							"FILE_AGE=$age_in_days_of_out_file",
																							"File=$seq_file_name",
							                  $single_msp, $over_write,
							                  "u=$upper_expect_limit",
							                  "$make_gz_in_sub_dir_opt",
							                  "l=$lower_expect_limit",
							                  "k=$k_tuple",
							                  $make_mspa_in_sub_dir_opt );
						 $seq='';
					 }
			      }
			  }elsif(/^(\w+)$/){
				  $seq.=$1;
			  }
		   }
		   close FASTA;
	   }
	 }
}


#______________________________________________________________________
# Title     : geanfammer
# Usage     : &geanfammer(\@your_genome_or_db_to_analyse_file,
#                          $verbose);
#
# Function  : Creates a domain level clustering file from a given
#              FASTA format sequence DB. It has been used for complete
#              genome sequence analysis. Can use PSI-blat, fasta, ssearch
#
#              ------------ USAGE INFORMATION -------------------
#             The parameters you put are important for the meaningful
#               protein family maker.
#             The most important one is the E and e options (Mostly,
#               they can have same value).
#             Large E is for setting the threshold for the single
#               linkage clustering.
#             This means, any sequence hit BELOW the threshold
#               (which is good ) will be linked.
#             For example, if Seq1 matched with Seq2 with E value
#              of FASTA search:
#              0.001, and you set the threshold 0.1, then YOU
#              ordered the geanfammer to regard them a family.
#
#             The second small e option is for the dividing a complex
#              and wrong cluster into correct more correct
#              duplication modules. This is necessary as a
#              lot of multidomain proteins can be clustered together
#              WRONGLY by single linkage.
#             At this stage, the e value is irrelevant to E value
#              and you can set a higher or lower one. Or you can set
#              the same as E.
#
#             Rough guide from our experience for E and e values:
#              We know that with 1000 sequence database, 0.01
#              produces around 1% error in grouping sequences
#              according to the evalue.
#              With 180,000, 0.081 gave us less than 1% error.
#             Evalue of FASTA and SSEARCH is DEPENDENT on DB size,
#              so you need to play a little bit to know the best
#              E value for your database or genome.
#             The best approach is :
#               1) You run geanfammer.pl with any of your target DB
#                  with certain E value you like
#               2) Check sequence families which are clustered
#                  in the final resultant file xxxx.gclu and decide
#                  if the E value is low or high. Lower evalues will
#                  make sure you do not make wrong clusters while
#                  high evalue will include more probable sequence
#                  family members.
#               3) Put all the xxxx.mspa files in subdirectory(s)
#                  created by geanfammer and run divclus.pl (which
#                  is accompanied in the package) with different
#                  Evalues. Divclus will not run any search algorithm
#                  etc, so it can be done fairly quickly.
#
# Example   :geanfammer.pl E_gnme.fasta             # simplest form
#            geanfammer.pl E_gnme.fasta a=ssearch   # use SSEARCH
#            geanfammer.pl E_gnme.fasta o           # for overwriting
#                                                   when you want a
#                                                   fresh run ovr old
#            geanfammer.pl E_gnme.fasta c         # For keeping
#                                                 SSO files
#                                                 (fasta output)
#            geanfammer.pl E_gnme.fasta k=2       # changing default
#                                                 k tuple for
#                                                 FASTA to 2
#            geanfammer.pl E_gnme.fasta E=0.01     # set the E value
#                                                 for initial single
#                                                 linkage clustering
#            geanfammer.pl E_gnme.fasta e=0.01    # set the E value
#                                                for domain level linkage
#       -->  geanfammer.pl E_gnme.fasta e=0.01 E=0.01 # set the 2 E values
#                                                    separately (no need
#                                                    to do this)
#
# Keywords  : genome_analysis_and_protein_family_maker,
#             genome_ana_protein_fam_maker
# Options   :
#             o  for overwrite existing xxxx.fasta files for search
#             c  for create SSO file (sequence search out file)
#             d  for very simple run and saving the result in
#                    xxxx.gz format in sub dir starting with one char
#             N
#             s
#             m
#             v
#             z
#             D
#             y  for dynamic factor
#             L  for Lean output(removes all the intermediate
#                                     outputs to save space)
#             u  for making separate summary file (redundant now)
#
#             DB=
#             File=
#             k= for k-tuple value. default is 1 (ori. FASTA prog.
#                                                   default is 2)
#             a= for choosing either fasta or ssearch algorithm
#             E= for Evalue cutoff for single linkage clustering
#                    $E_cut_main
#             e= for Evalue cutoff for divide_clusters subroutine.
#             u=
#             l=
#             d=
#             T= for $length_thresh (minimal domain size thresh)
#
#   !! Do not remove the following lines down to # Author line.
#                This program parses them
#
#  $factor=                 by f=       ## overlapping factor
#  $Lean_output=L           by L -L
#  $dynamic_factor=y        by y  Y -y -Y
#  $over_write=o            by o -o
#  $create_sso_file=c       by c -c
#  $k_tuple=                by k=
#  $upper_expect_limit=     by u=
#  $lower_expect_limit=     by l=
#  $algorithm=              by a=
#  $No_processing=N         by N -N
#  $single_msp=s            by s -s
#  $sequence_DB=            by DB=
#  $query_File=             by File=
#  $machine_readable=M      by M -M
#  $make_subdir_out=D       by D
#  $make_subdir_gzipped=d   by d -d
#  $direct_MSP_conversion=m by m -m
#  $verbose=v               by v -v
#  $sub_dir_size=           by d=
#  $Evalue_thresh=          by E=
#  $optimize=z              by z -z
#  $make_separate_summary=u by u -u
#  $length_thresh=          by T=
#  $take_last_iter_psi_bla  by l
#  $PSI_BLAST_iter_limit=   by j=
#
# Author    : Sarah A Teichmann, Jong Park, sat@mrc-lmb.cam.ac.uk,
#                                      jong@salt2.med.harvard.edu
# Version   : 3.2
#--------------------------------------------------------------------------------
sub geanfammer{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my ($algorithm, $upper_expect_limit, $k_tuple, $sub_dir_size, $factor,
            @mspa_files_main, $mspa_directly_opt, %hash_main, $single_linkage_file,
            @written_mspa_files, $num_of_seq_in_fa_file, $take_last_iter_psi_bla,
            $Evalue_thresh, %fasta_seqs, $final_summary_file,
            @sub_clustering_clu_files, $base, $final_gclu_output, $Lean_output,
            $dynamic_factor, $length_thresh, $make_mspa_in_sub_dir_opt );

    $algorithm         ='fasta'; # default algorithm set(you can change of course by using a= opt
    $upper_expect_limit= 10;     # default
    $k_tuple=1;                  # FASTA default (not applicable for other algorithms)
    $sub_dir_size=2;             # default
    $mspa_directly_opt='m';
    $Evalue_thresh=0.01; # default E value
    $length_thresh=30;            # default
    $PSI_BLAST_iter_limit=5;
    $take_last_iter_psi_bla='l';

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Dealing with options
    #_________________________________________
    if($char_opt=~/m/){    $mspa_directly_opt='m';   }
    if($char_opt=~/b/){    $do_in_batch        = 'b' } # for reading in all the
    if($char_opt=~/v/){    $verbose='v';             } # for showing debugging information
    if($char_opt=~/i/){    $indup='i';               }
    if($char_opt=~/R/){    $add_range          = 'r' }
    if($char_opt=~/y/){    $dynamic_factor     = 'y' }
    if($char_opt=~/z/){    $optimize           = 'z' }
    if($char_opt=~/o/){    $over_write         = 'o' }
    if($char_opt=~/c/){    $create_sso         = 'c' }
    if($char_opt=~/s/){    $single_big_mspa     = 's'; print "\n# Single file opt is set\n"; }
    if($char_opt=~/M/){    $machine_readable   = 'M' }
    if($char_opt=~/d/){$make_gz_in_sub_dir_opt = 'd' } # for simple search and storing in gz file (sso file will be zipped
    if($char_opt=~/D/){$make_mspa_in_sub_dir_opt= 'D' } # for simple search and storing mspa file
    if($char_opt=~/n/){    $new_format         = 'n' }
    if($char_opt=~/x/){    $answer_for_search  = 'x' }
    if($char_opt=~/r/){    $reverse_sequence   = 'r'  }
    if($char_opt=~/L/){    $Lean_output        = 'L'  }
    if($char_opt=~/l/){    $take_last_iter_psi_bla = 'l'; print "\n     \"l\" option was used for last Blast iteration parsing\n";  }
    if($vars{'f'}=~/\S+/){       $factor= $vars{'f'}; }
    if($vars{'a'}=~/(\S+)/){   $algorithm          = $1            }
    if($vars{'l'}=~/(\S+)/){   $lower_expect_limit = $1            }
    if($vars{'u'}=~/(\S+)/){   $upper_expect_limit = $1            }
    if($vars{'k'}=~/(\S+)/){   $k_tuple            = $1            }
    if($vars{'t'}=~/(\S+)/){   $Score_thresh       = $1            }
    if($vars{'d'}=~/(\S+)/){   $sub_dir_size       = $1            }
    if($vars{'s'}=~/(\S+)/){   $single_big_mspa     = $1            }
    if($vars{'DB'}=~/(\S+)/){  $sequence_DB        = $1; push(@file,$sequence_DB);   }
    if($vars{'File'}=~/(\S+)/){$query_File         = $1; push(@file,$query_File);  }
    if($vars{'Query_seqs'}=~/(\S+)/){            %seq_input = %{$1}            }
    if($vars{'E'}=~/\S+/){   $Evalue_thresh      = $vars{'E'};                   }
    if($vars{'T'}=~/\S+/){   $length_thresh      = $vars{'T'};                   }

    if(@file==2 and (!$query_File and !$sequence_DB) ){
        ($query_File, $sequence_DB)=@{&sort_files_by_size(\@file)};
    }elsif(@file==1){ $query_File=$file[0]; $sequence_DB=$file[0]; }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Only the Query file is taken
    #________________________________________________
    @file=($query_File);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # creating xxx.msso.gz or pbla files in subdirs
    #____________________________________________
    for($i=0; $i< @file; $i++){
        if(-s $file[$i]){   $input_db_or_genome=$file[$i] }
        if(-s $query_File){ $input_db_or_genome=$query_File }

        print "\n# (i) geanfammer : \$query_File: $query_File, \$sequence_DB: $sequence_DB, Evalue for single link:$Evalue_thresh\n";
        print "# (i) geanfammer : Min. Domain size is $length_thresh\n";
        print "# (i) geanfammer : Factor is $factor\n";
        print "# (i) geanfammer : \$Evalue_cut_divclus is $Evalue_cut_divclus\n";
        $base=${&get_base_names($query_File)};
        $final_gclu_output="$base\.gclu";
        %fasta_seqs=%{&open_fasta_files(\$query_File)};
        $num_of_seq_in_fa_file=keys %fasta_seqs;

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # When you want to reverse your protein sequence for whatever crazy reason
        #____________________________________________________________________________
        if($reverse_sequence){ ## reverse the query seqs.
            %fasta_seqs=%{&reverse_sequences(\%fasta_seqs)};
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Ask if she wants to search the db first, as it is the first time
        #_____________________________________________________________________
        unless($answer_for_search and !$over_write){
            print "\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
            print "\n# (3) You should have working FASTA (or SSEARCH) in the path";
            print "\n#     If you are doing the very first search now, Say, \"y\"es.     ";
            print "\n#_______________________________________________________________";
            print "\n# Shall I do seq. search using $file[$i]?", "\n  (y/n)\n\n \t-->";
            $answer_for_search=getc;
        }

        if($answer_for_search=~/y/i){
            $over_write='o';

            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            #  By default, the search level E value is always higher by 2 !!!
            #__________________________________________________________________________
            $Evalue_thresh_AT_SEARCH=$Evalue_thresh+2; ## adding 2 to the given E value

            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            #  Searching the db self to self using default algorithm of FASTA ktup=1
            #__________________________________________________________________________
            $num_of_seq_in_fa_file=@{&do_sequence_search(
                                $Lean_output,
                                "a=$algorithm",
                                \$file[$i],
                                $over_write,
                                $mspa_directly_opt,
                                "u=$upper_expect_limit",
                                $do_in_batch,
                                $create_sso,
                                $reverse_query,
                                $single_big_msp,
                                $machine_readable,
                                "DB=$sequence_DB",
                                "File=$query_File",
                                $make_mspa_in_sub_dir_opt,
                                $make_gz_in_sub_dir_opt,
                                "d=$sub_dir_size",
                                $new_format,
                                $add_range,
                                "E=$Evalue_thresh_AT_SEARCH",
                                $take_last_iter_psi_bla
                            ) };
        }else{
            print "\n# (i) $0; You chose NO search. I will cluster and divide now\n";
            print "# (i) The min domain size var \$length_thresh is $length_thresh\n";
            $over_write='o';
            sleep(1);
        }

        @mspa_files_main=@{&get_all_mspa_files};

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # When users didn't define E value and no STATIC Eval is set,
        #    estimate according to the db size
        #______________________________________________________________________
        if( !$Evalue_thresh  or $dynamic_factor){
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # following is a very rough guide for a reasonable E value thresh for different DB size
                #______________________________________________________________________________________________
                if(@mspa_files_main > 280,000){     $Evalue_thresh=0.2;
                }elsif(@mspa_files_main > 180000){  $Evalue_thresh=0.1;
                }elsif(@mspa_files_main > 50000){   $Evalue_thresh=0.08;
                }elsif(@mspa_files_main > 10000){   $Evalue_thresh=0.07;
                }elsif(@mspa_files_main > 1000){    $Evalue_thresh=0.05;
                }elsif(@mspa_files_main > 500){     $Evalue_thresh=0.03;
                }elsif(@mspa_files_main > 100){     $Evalue_thresh=0.02;
                }elsif(@mspa_files_main > 50){      $Evalue_thresh=0.01;
                }elsif(@mspa_files_main > 20 ){     $Evalue_thresh=0.001;
                }
        }


        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Making single linkage cluster file xxxxxxxx.sclu
        #___________________________________________________________________________________________
        #print "\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`#\n";
        #print "# BEfore running Sinlge linkage sub                    #\n";
        #print "# Evalue single for clus & Divclus  : $Evalue_thresh   #\n";
        #print "#______________________________________________________#\n";
        %hash_main=%{&mspa_single_link_hash(\@mspa_files_main, $Evalue_thresh)};


        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Single LINKAGE file,
        #___________________________________________________________________________________________
        $single_linkage_file=${&print_clusfile_from_hash(\%hash_main)};

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Make MSP files from the SCLU file
        #________________________________________________________________________
        if(-s $single_linkage_file){
            #print "\n# (i) Good! \$single_linkage_file $single_linkage_file is made\n";
            @written_mspa_files=@{&convert_clu_to_msp(\$single_linkage_file, $Lean_output)};
            print "\n\n==========================\n @written_mspa_files\n\n\n";
        }else{
            print "\n# (E) BAD! \$single_linkage_file $single_linkage_file is NOT here\n";
            die;
        }

        $over_write='o';
        $average_region='A';
        $range='r';
        $merge='m';
        $sat_file=0;

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # >>>>>> !! The very core of geanfammer. DIVCLUS
        #___________________________________________________________________________
        @sub_clustering_clu_files=@{&divide_clusters(
                        $Lean_output,
                        \@written_mspa_files,
                        "s=$score",
                        "f=$factor", ## this is a very impo. parameter in the behaviour of divclus, Sarah!
                        "T=$length_thresh",
                        "E=$Evalue_thresh", ## this is a very impo. parameter in the behaviour of divclus, Sarah!
                        $dynamic_factor,
                        $verbose,
                        $range,
                        $merge,
                        $sat_file,
                        $dindom,
                        $indup,
                        $over_write,
                        $optimize,
                        $short_region,
                        $large_region,
                        $average_region
                     )};

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  This is the final result now.
        #_______________________________________________________________

        #print "\n\n# create_sorted_cluster: Final gclu file name is $final_gclu_output\n  with @sub_clustering_clu_files\n" if $verbose;
        $good_cluster_file=${&create_sorted_cluster(\@sub_clustering_clu_files, \$final_gclu_output)};
        print "\n\n\n#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
        print "\n# ! Finished create_sorted_cluster(geanfammer), result is \"$good_cluster_file\"";
        print "\n#_________________________________________________________________\n\n\n";

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        #  make_clustering_summary  became redundant after peer review
        #_______________________________________________________________
        $final_summary_file=${&make_clustering_summary(\$final_gclu_output, $make_separate_summary)};

        push(@files_created, $final_summary_file);

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Make the whole output Lean
        #_______________________________________
        if($Lean_output){
                for($k=0; $k < @sub_clustering_clu_files; $k++){
                        $base_name=${&get_base_names($sub_clustering_clu_files[$k])};
                        $sub_clustering_mspa_file="$base_name\.msp";
                        unlink($sub_clustering_clu_files[$k], $sub_clustering_mspa_file);
                }
        }
    }# end of for loop for @file
    return(\@files_created);
}


#________________________________________________________________________________
# Title     : PDB_ISL_server
# Usage     : &PDB_ISL_server(\%seq, "e=$E_val", "k=$ktuple", "a=$algorithm", "t=$leng_thresh",
#                         "$which_score", $show_raw_result, $segged_PDB_ISL );
# Function  : This does PDB_ISL and makes HTML file to return to HTTPD server
# Example   :
# Keywords  : intermdediate_sequence_search_server
# Options   :
#  $algorithm=    by a=
#  $leng_thresh=  by t=
#  $E_val=        by e=
#  $DB_type=      by y=
#
# Author    : Sarah Teichmann and Jong Park, jong@salt2.med.harvard.edu
# Version   : 2.3
#--------------------------------------------------------------------------------
sub PDB_ISL_server{
		my (@mspa_hashes_from_temp, $i, $j, $algorithm, $E_val, $fasta_file, $k_tuple, @seq,
				$add_range, $lower_expect_limit, $upper_expect_limit, %temp, $leng_thresh, $DB_type,
				$which_score, @temp, $seq_id, $show_raw_result, $segged_PDB_ISL, $iter_opt, $step_e_opt);
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# All the defaults
		#________________________________________
		$add_range='r';
		@seq=%{$_[0]}; ### $seq_name, and $sequence
		$algorithm='fasta';
		$E_val=$upper_expect_limit=1;
		$lower_expect_limit=0;
		$fasta_file="./Query/$seq[0]\.spfa";
		$k_tuple=1;
		$iter_opt=2; ## for PSI
		$step_e_opt=0.001;   ## for PSI

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  Input handling
		#____________________________________
		for($i=0; $i< @_; $i++){
			 if($_[$i]=~/e=(\S+)/){          $E_val=$upper_expect_limit=$1;
			 }elsif($_[$i]=~/k=(\d+)/){      $ktuple=$1;
			 }elsif($_[$i]=~/a=(\w+)/){      $algorithm=$1;
			 }elsif($_[$i]=~/t=(\w+)/){      $leng_thresh=$1;
			 }elsif($_[$i]=~/z$/){           $which_score='z';
			 }elsif($_[$i]=~/s/){            $show_raw_result='s';
			 }elsif($_[$i]=~/l=(\S+)/){      $seq_lib    =$1
			 }elsif($_[$i]=~/i=(\S+)/){      $iter_opt   =$1
			 }elsif($_[$i]=~/h=(\S+)/){      $step_e_opt =$1
			 }elsif($_[$i]=~/y=(\S+)/){      $DB_type =$1
			 }
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# Choose and find PDB_ISLLib and others. INTERM_LIB.mpfa is the default name
		#____________________________________________________________________________
		if($seq_lib=~/PDB_ISL/i){
			 if($DB_type=~/Normal/i){					$sequence_DB="./DB/PDB_ISL.mpfa";
					unless(-s $sequence_DB){ print "<br>You wanted PDB_ISL with Normal DB_type, but $sequence_DB doesnt exist<br>"; exit; }
			 }elsif($DB_type=~/Segged/i){			$sequence_DB="./DB/PDB_ISL_SEG.mpfa";
					unless(-s $sequence_DB){ print "<br>You wanted PDB_ISL with Segged DB_type, but $sequence_DB doesnt exist<br>"; exit; }
			 }else{    print "<br> Error, DB_type is not set, something is wrong, -> jong\@salt2.med.harvard.edu<br>";			    exit;
			 }
		}elsif($seq_lib=~/(\S+)/){
			 if(-s "./DB/$seq_lib"){      $sequence_DB="./DB/$seq_lib";
			 }elsif(-s $seq_lib){         $sequence_DB="$seq_lib"; print "<br> Please move $seq_lib to ./DB/ subdir<br>"; }
		}else{
			 print "<br> Error!, Can not determine the sequence DB type <br> report bug to jong\@salt2.med.harvard.edu<br>";
			 exit;
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Showing the seq ,size, DB used etc
		#___________________________________
		$seq_name="$seq[0]";
		$seq_leng=length($seq[1]);
		if($leng_thresh > $seq_leng){ $leng_thresh=($seq_leng-5); }
		print "<b><FONT COLOR=\"#008001\"><FONT SIZE=+3>PDB_ISL </FONT>Result against </FONT>$seq_lib</b>";
		print "<br>$seq_name sequence (<FONT COLOR=\"#005CB5\">$seq_leng residue</font>) was: <br>";
		$sequence2=$sequence;
		for($c=0; $c <= length($sequence2); $c+=50){
				 $seq=substr($sequence2, $c, 50);
				 if($RV_seq){  print "<FONT COLOR=\"#FF4E10\">$seq</FONT><br>";  $E_val=$E_val*33;
				 }else{        print "<FONT COLOR=\"#6162CE\">$seq</FONT><br>";  }
		}

		if($seq_lib=~/PDB_ISL?L/i or $seq_lib=~/PDB_ISL/i){  ## if the search was against any kind of PDB_ISL lib
				if($algorithm=~/fasta/i or $algorithm=~/ssearch/i){
						print "<FONT COLOR=\"#018000\">Algorithm</font>= <b>$algorithm</b>, ";
						print "<FONT COLOR=\"#008000\">UpperEvalue</font>= <b>$E_val XX</b>, <FONT COLOR=\"#008000\">Ktuple</font>= <b>$ktuple</b>, ";
						print "<FONT COLOR=\"#008000\">LengThresh</font>=<b>$leng_thresh, </b>";
						print "with <FONT COLOR=\"#0000FF\">-m 10</font> opt<FONT COLOR=\"#00FF00\">...<FONT SIZE=+1>....., WAIT! </font></font><br>";
						print "."x130;
				}elsif($algorithm=~/blast/i or $algorithm=~/psi/i){
						$PSI_E_val=$E_val/10;
						print "<FONT COLOR=\"#008000\">Algorithm</font>= <b>$algorithm</b>, ";
						print "<FONT COLOR=\"#008000\">PSI UpperEvalue</font>= <b>$PSI_E_val </b>";
						print "<FONT COLOR=\"#008000\"> LengThresh</font>=<b>$leng_thresh, StepEval(h)= $step_e_opt, Iteration(j)= $iter_opt</b>";
						print "....., WAIT!<br>";
						print "."x100;
				}
		}else{
				print "<FONT COLOR=\"#DC143C\">NON PDB_ISL lib search. Using ./DB/$seq_lib</font>,";
				print "<FONT COLOR=\"#00FF09\">...<FONT SIZE=+1>.., WAIT! </font></font><br>";
		}
		open(FASTA, ">$fasta_file") || print "<hr><B><FONT COLOR=\"#FF3F50\">
		      # Failed to open $fasta_file
		      <br>!!!! Ask Jong to Check File Permission, email</font><FONT COLOR=\"#FF5E50\"> jong\@salt2.med.harvard.edu  !!!! <hr></Font></B>";

		print FASTA "\>$seq[0]\n$seq[1]\n";
		close FASTA;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Running search program
		#_________________________________
		if($algorithm=~/fasta/i){
				 if(-s "./Bin/fasta"){
							@temp=`./Bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/usr/local/bin/fasta"){
							@temp=`/usr/local/bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/usr/bin/fasta"){
							@temp=`/usr/bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/Bio/Bin/fasta"){
							@temp=`/Bio/Bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }else{ die "<br> $0 can not access $algorithm program in ./Bin/ directory. Error, contact jong\@salt2.med.harvard.edu<br>";  }
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # Parsing the result of FASTA like search
				 #__________________________________________________________
				 @mspa_hashes_from_temp = @{&read_machine_readable_sso_lines_PDB_ISL(\@temp, $add_range,
									"u=$upper_expect_limit", "l=$lower_expect_limit", "$which_score", "t=$leng_thresh")};
		}elsif($algorithm=~/ssearch/){
				 if(-s "./Bin/ssearch"){
							@temp=`./Bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB`;
				 }elsif(-s "/usr/local/bin/ssearch"){
									@temp=`/usr/local/bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB`;
				 }elsif(-s "/usr/bin/ssearch"){
									@temp=`/usr/bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB`;
				 }elsif(-s "/Bio/Bin/ssearch"){
									@temp=`/Bio/Bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB`;
				 }else{ die "<br> $0 can not access $algorithm program in ./Bin/ directory. Error, contact jong\@salt2.med.harvard.edu<br>";  }
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # Parsing the result of FASTA like search
				 #__________________________________________________________
				 @mspa_hashes_from_temp = @{&read_machine_readable_sso_lines_PDB_ISL(\@temp, $add_range,
									"u=$upper_expect_limit", "l=$lower_expect_limit", "$which_score", "t=$leng_thresh")};
		}elsif($algorithm=~/blast/i or $algorithm=~/psi/i){
        	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # WARN!  Here I am adjusting PSI-Blast E value
			 #__________________________________________________
		     $E_val=$E_val/10;
                 @mspa_hashes_from_temp=@{&do_psi_blast_search_PDB_ISL( "d=$sequence_DB", "i=$fasta_file",
						           "E=$E_val", "e=$step_e_opt", "o=$over_write", "j=$iter_opt")};
		}


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# NOW, We have MSPA format hashes as input
		#______________________________________________________________
		if(@mspa_hashes_from_temp < 1){
			 print "<br><FONT COLOR=\"#DC143C\"><FONT SIZE=+3>! NO hits, Go back to a New PDB_ISL search";
			 print "<A href=\"PDB_ISL_server.html\">PDB_ISL server</A></font></font>";
			 exit;
		}
		if($which_score=~/z/){ $score_col='<FONT COLOR="#0000FF">Z-scor</font>' }else{ $score_col='SWscor' }
		for($i=0; $i< @mspa_hashes_from_temp; $i++){
		     my(%temp, @values, $occur_iter_num, $query_align, $match_align);
			 %temp=%{$mspa_hashes_from_temp[$i]};
             $SCOP_address='http://scop.mrc-lmb.cam.ac.uk/scop';
			 @values=@{&sort_by_column([values %temp], 2)};
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # one of the headlines
			 #__________________________________________________________
			 print "<pre>";
			 printf("%-s \t%-s \t%-s\t%-s\t%-s\t%-s\t%-s\t%-s\t%s\n", $score_col,
							"<A href=Paper/expectation_value.html>E-val</A>",
							'SeqID', 'From', 'To',
							'Query', 'From', 'To', 'InterSeq & linked superfam    Seq Alignment', "<br>");

			 for($j=0; $j< @values; $j++){
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 #  Matching output MSPA lines
                 #___________________________________________
                 if($values[$j]=~/^(\S+)\s+(\S+)\s+(\S+)\s+(\d+\s+\d+\s+\S+\s)\s*(\d+\s+\d+\s+\S+_)([dec\d](\w{3,4})[\.\w]{2,3})_(\d+)\.(\d+)\.(\d+)\s*(\d*)\s*([\-\.\w]+)\<=\>([\-\.\w]+)/){
                     ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name, $class, $fold, $superfam, $occur_iter_num, $query_align, $match_align)
                       =($1, $2, $3, "$4 $5", $6, $7, $8, $9, $10, $11, $12, $13);

                      $rest=~/(\d+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\S+)\_\d+\-\d+_/;
                      $query=$3; $match=$6; $query_start=$1; $query_stop=$2; $match_start=$4; $match_stop=$5;
                      $sorted_name="$3\_$1\-$2\_$6\_$4\-$5";
                      $alignment="$query_align\_$match_align";

                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                      #    $sorted_name=join(' ', sort("$query\_$query_range_start\-$query_range_stop",
                      #                      "$matched\_$match_string_start\-$match_string_stop"));
                      #_______________________________________________________________________________________
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
                      #______________________________________________________________________________________
                      if(length($class) ==1){      $first_num="00$class";
                      }elsif(length($class) ==2){  $first_num="0$class";
                      }else{                       $first_num="$class"; }
                      if(length($fold) ==1){       $sec_num="00$fold";
                      }elsif(length($fold) ==2){   $sec_num="0$fold";
                      }else{                       $sec_num="$fold"; }
                      if(length($superfam) ==1){      $third_num="00$superfam";
                      }elsif(length($superfam) ==2){  $third_num="0$superfam";
                      }else{                          $third_num="$superfam"; }
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      #  printing each line of output with coloring
                      #_______________________________________________

                      if($sw > 125){ print "<b>$sw</b>\t"; }else{ print "$sw\t"; }
                      if($evalue < 0.05 or $evalue=~/e\-/){
                                          print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>\t";
                      }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>\t";  }
                      if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\"> $seq_id </FONT>\t</b>$query_start\t$query_stop\t$query";
                      }else{              print "<FONT COLOR=\"#800000\"> $seq_id </FONT>\t$query_start\t$query_stop\t$query"; }
                      print "\t$match_start\t$match_stop\t$match\t";
                      print "<a href=\"$SCOP_address\/search.cgi?ver=1.48;sid=$d_name,\">\t$pdb_name</A>";
                      print "<b><FONT COLOR=\"#DC143C\">_</FONT></b>";
                      print "<A href=\"$SCOP_address\/data/scop.1.$first_num.$sec_num.$third_num.000.000.html\">$class.$fold.$superfam";
                      print "</A> ";
                      print "<A href=Bin\/show_alignment_for_ISL_server.cgi?sorted_name=$sorted_name+alignment=$alignment>  Align<\/A><br>";

                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # This is FASTA style output, I am just lazy
                 #__________________________________________________________________
                 }elsif($values[$j]=~/^ *(\S+\s+)(\S+\s+)(\S+\s+)(\d+\s+\d+\s+\S+\s+\d+\s+\d+\s+\S+)([de](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)$/){
                      ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name, $class, $fold, $superfam)
                          =($1, $2, $3, $4, $5, $6, $7, $8, $9);
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
                      #______________________________________________________________________________________
                      if(length($class) ==1){      $first_num="00$class";
                      }elsif(length($class) ==2){  $first_num="0$class";
                      }else{                       $first_num="$class"; }
                      if(length($fold) ==1){       $sec_num="00$fold";
                      }elsif(length($fold) ==2){   $sec_num="0$fold";
                      }else{                       $sec_num="$fold"; }
                      if(length($superfam) ==1){      $third_num="00$superfam";
                      }elsif(length($superfam) ==2){  $third_num="0$superfam";
                      }else{                          $third_num="$superfam"; }
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      #  printing each line of output with coloring
                      #_______________________________________________

                      if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
                      if($evalue < 0.05 or $evalue=~/e\-/){
                              print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>\t";
                      }else{ print "<FONT COLOR=\"#FF1463\">$evalue</FONT>\t";  }
                      if($seq_id > 0.4){
                              print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest\t";
                      }else{ print "<FONT COLOR=\"#800000\">$seq_id</FONT>\t$rest"; }
                      print "<a href=\"$SCOP_address\/search.cgi?ver=1.35;sid=$d_name,\">$pdb_name</A>";
                      print "<b><FONT COLOR=\"#DC143C\">_</FONT></b>";
                      print "<A href=\"$SCOP_address\/data/scop.1.$first_num.$sec_num.$third_num.000.000.html\">$class.$fold.$superfam";
                      print "</A><br>";
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # 65.5 2e-12  1  1 34   Q5440___1-34    2 35  d1enh___1.3.1.1.2
                 #___________________________________________________________________________________________________
                 }elsif($values[$j]=~/^ *(\S+\s+)(\S+\s+)(\S+\s+)(\d+\s+\d+\s+\S+\s+\d+\s+\d+\s+)([dce](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)/){
                      ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name, $class, $fold, $superfam)=($1, $2, $3, $4, $5, $6, $7, $8, $9);
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
                      #______________________________________________________________________________________
                      if(length($class) ==1){      $first_num="00$class";
                      }elsif(length($class) ==2){  $first_num="0$class";
                      }else{                       $first_num="$class"; }
                      if(length($fold) ==1){       $sec_num="00$fold";
                      }elsif(length($fold) ==2){   $sec_num="0$fold";
                      }else{                       $sec_num="$fold"; }
                      if(length($superfam) ==1){      $third_num="00$superfam";
                      }elsif(length($superfam) ==2){  $third_num="0$superfam";
                      }else{                          $third_num="$superfam"; }
                      if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
                      if($evalue < 0.05 or $evalue=~/e\-/){
                                              print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>\t";
                      }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
                      if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest\t";
                      }else{              print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
                      print "<a href=\"$SCOP_address/search.cgi?ver=1.38;sid=$d_name,\">$pdb_name</A>";
                      print "<b><FONT COLOR=\"#DC143C\">_</FONT></b>";
                      print "<A href=\"$SCOP_address/data/scop.1.$first_num.$sec_num.$third_num.000.000.html\">$class.$fold.$superfam";
                      print "</A><br>";
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # 65.5 2e-12  1  1 34   Q5440___1-34    2 35  d1enh___2-35           1
                 #___________________________________________________________________________________________________
                 }elsif($values[$j]=~/^(\S+\s+)(\S+\s+)(\S+\s+)(\d+\s+\d+\s+\S+\s+\d+\s+\d+\s+)([dce](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)/){
                      ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name)=($1, $2, $3, $4, $5, $6);
                      if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
                      if($evalue < 0.05 or $evalue=~/e\-/){
                           print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>";
                      }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
                      if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest";
                      }else{              print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
                      print "<a href=\"$SCOP_address/search.cgi?ver=1.38;sid=$d_name,\">$pdb_name</A><br>";
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # The following is for making output for pdb100d.mpfa DB search results(simple format)
                 #__________________________________________________________________________________
                 }elsif($values[$j]=~/^\s*(\S+\s+)(\S+\s+)(\S+\s+)(\d+\s+\d+\s+\S+\s+\d+\s+\d+\s+)([dce](\w{4})\w{2}).+/){
                     ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name)=($1, $2, $3, $4, $5, $6);
                     if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
                     if($evalue < 0.05 or $evalue=~/e\-/){
                                             print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>";
                     }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
                     if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest";
                     }else{              print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
                     print "<a href=\"$SCOP_address/search.cgi?ver=1.38;sid=$d_name,\">$pdb_name</A><br>";
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Die and ask for bug report !!!!!!!!!!
                 #______________________________________________
                 }else{
                     print "<br>\$values\[\$j\] : $values[$j] <br>\n";
                     print "In: PDB_ISL_server: ERROR not right pattern matching for MSPA format <br>\n";
                     print "<br>Report this to jong\@ebi.ac.uk, sat\@mrc-lmb.cam.ac.uk, jgough\@mrc-lmb.cam.ac.uk<br>";
                 }
			 }
			 print "<\/pre>";

		}
		if($show_raw_result){
				print "Following is Raw search output<br><pre>@temp</pre><br>";
		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Epilogue
		#___________________________________
		print "<hr><FONT COLOR=\"#DC143C\"><FONT SIZE=+2><< Go back to a NEW ";
		print "<A href=\"PDB_ISL_server.html\">PDB_ISL server</A></font></font>";
		print "</html>\n";


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Making log
		#__________________________________
		$visitor= $ENV{'HTTP_REFERER'};
		$rhost =  $ENV{'REMOTE_HOST'};
		$ruser =  $ENV{'REMOTE_USER'};
		$server = $ENV{'SERVER_SOFTWARE'};
		$q_string=$ENV{'QUERY_STRING'};
		$rident  =$ENV{'REMOTE_IDENT'};
		$page_acc=$ENV{'DOCUMENT_NAME'};

		@date=@{&get_date};
		if(-s "PDB_ISL_server_access.log" > 10000000){
		   print "<HR>The PDB_ISL_server_access.log in ./Log dir is over 10MB, reduce it or warn the sysadmin<br>";
		}
		open (PDB_ISL_server_access, ">>./Log/PDB_ISL_server_access.log");
		print PDB_ISL_server_access "@date $seq_name, REMOTE_HOST: $rhost, REMOTE_USER:$ruser, REMOTE_IDENT:$rident, SERVER_SOFTWARE: $server\n";
		close PDB_ISL_server_access;
}



#________________________________________________________________________________
# Title     : ISS_server
# Usage     : &ISS_server(\%seq, "e=$E_val", "k=$ktuple", "a=$algorithm", "t=$leng_thresh",
#                         "$which_score", $show_raw_result, $segged_ISSL );
# Function  : This does ISS and makes HTML file to return to HTTPD server
# Example   :
# Keywords  : intermdediate_sequence_search_server
# Options   :
#  $algorithm=    by a=
#  $leng_thresh=  by t=
#  $E_val=        by e=
#  $DB_type=      by y=
#
# Author    : Sarah Teichmann and Jong Park, jong@biosophy.org
# Version   : 1.8
#--------------------------------------------------------------------------------
sub ISS_server{
		my (@mspa_hashes_from_temp, $i, $j, $algorithm, $E_val, $fasta_file, $k_tuple, @seq,
				$add_range, $lower_expect_limit, $upper_expect_limit, %temp, $leng_thresh, $DB_type,
				$which_score, @temp, $seq_id, $show_raw_result, $segged_ISSL, $iter_opt, $step_e_opt);
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# All the defaults
		#________________________________________
		$add_range='r';
		@seq=%{$_[0]}; ### $seq_name, and $sequence
		$algorithm='fasta';
		$E_val=$upper_expect_limit=1;
		$lower_expect_limit=0;
		$fasta_file="./Query/$seq[0]\.spfa";
		$k_tuple=1;
		$iter_opt=2; ## for PSI
		$step_e_opt=0.001;   ## for PSI

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		#  Input handling
		#____________________________________
		for($i=0; $i< @_; $i++){
			 if($_[$i]=~/e=(\S+)/){          $E_val=$upper_expect_limit=$1;
			 }elsif($_[$i]=~/k=(\d+)/){      $ktuple=$1;
			 }elsif($_[$i]=~/a=(\w+)/){      $algorithm=$1;
			 }elsif($_[$i]=~/t=(\w+)/){      $leng_thresh=$1;
			 }elsif($_[$i]=~/z$/){           $which_score='z';
			 }elsif($_[$i]=~/s/){            $show_raw_result='s';
			 }elsif($_[$i]=~/l=(\S+)/){      $seq_lib    =$1
			 }elsif($_[$i]=~/i=(\S+)/){      $iter_opt   =$1
			 }elsif($_[$i]=~/h=(\S+)/){      $step_e_opt =$1
			 }elsif($_[$i]=~/y=(\S+)/){      $DB_type =$1
			 }
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# Choose and find ISSLib and others. INTERM_LIB.mpfa is the default name
		#____________________________________________________________________________
		if($seq_lib=~/PDB_ISL/i){
			 if($DB_type=~/Normal/i){					$sequence_DB="./DB/PDB_ISL.mpfa";
					unless(-s $sequence_DB){ print "<br>You wanted PDB_ISL with Normal DB_type, but $sequence_DB doesnt exist<br>"; die; }
			 }elsif($DB_type=~/Segged/i){			$sequence_DB="./DB/PDB_ISL_SEG.mpfa";
					unless(-s $sequence_DB){ print "<br>You wanted PDB_ISL with Segged DB_type, but $sequence_DB doesnt exist<br>"; die; }
			 }else{    print "<br> Error, DB_type is not set, something is wrong, -> jong\@salt2.med.harvard.edu<br>";			    die;
			 }
		}elsif($seq_lib=~/(\S+)/){
			 if(-s "./DB/$seq_lib"){      $sequence_DB="./DB/$seq_lib";
			 }elsif(-s $seq_lib){         $sequence_DB="$seq_lib"; print "<br> Please move $seq_lib to ./DB/ subdir<br>"; }
		}else{
			 print "<br> Error!, Can not determine the sequence DB type <br> report bug to jong\@salt2.med.harvard.edu<br>";
			 die;
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Showing the seq ,size, DB used etc
		#___________________________________
		$seq_name="$seq[0]";
		$seq_leng=length($seq[1]);
		if($leng_thresh > $seq_leng){ $leng_thresh=($seq_leng-5); }
		print "<b><FONT COLOR=\"#008001\"><FONT SIZE=+3>ISS </FONT>Result against </FONT>$seq_lib</b>";
		print "<br>$seq_name sequence (<FONT COLOR=\"#005CB5\">$seq_leng residue</font>) was: <br>";
		$sequence2=$sequence;
		for($c=0; $c <= length($sequence2); $c+=50){
				 $seq=substr($sequence2, $c, 50);
				 print "<FONT COLOR=\"#FF4E10\">$seq</FONT><br>";
		}

		if($seq_lib=~/ISS?L/i or $seq_lib=~/PDB_ISL/i){  ## if the search was against any kind of ISS lib
				if($algorithm=~/fasta/i or $algorithm=~/ssearch/i){
						print "<FONT COLOR=\"#018000\">Algorithm</font>= <b>$algorithm</b>, ";
						print "<FONT COLOR=\"#008000\">UpperEvalue</font>= <b>$E_val XX</b>, <FONT COLOR=\"#008000\">Ktuple</font>= <b>$ktuple</b>, ";
						print "<FONT COLOR=\"#008000\">LengThresh</font>=<b>$leng_thresh, </b>";
						print "with <FONT COLOR=\"#0000FF\">-m 10</font> opt<FONT COLOR=\"#00FF00\">...<FONT SIZE=+1>....., WAIT! </font></font><br>";
						print "."x130;
				}elsif($algorithm=~/blast/i or $algorithm=~/psi/i){
						$PSI_E_val=$E_val/10;
						print "<FONT COLOR=\"#008000\">Algorithm</font>= <b>$algorithm</b>, ";
						print "<FONT COLOR=\"#008000\">PSI UpperEvalue</font>= <b>$PSI_E_val </b>";
						print "<FONT COLOR=\"#008000\"> LengThresh</font>=<b>$leng_thresh, StepEval(h)= $step_e_opt, Iteration(j)= $iter_opt</b>";
						print "....., WAIT!<br>";
						print "."x100;
				}
		}else{
				print "<FONT COLOR=\"#DC143C\">NON ISS lib search. Using ./DB/$seq_lib</font>,";
				print "<FONT COLOR=\"#00FF09\">...<FONT SIZE=+1>.., WAIT! </font></font><br>";
		}
		open(FASTA, ">$fasta_file") || print "<hr><B><FONT COLOR=\"#FF3F50\">
		      # Failed to open $fasta_file
		      <br>!!!! Ask Jong to Check File Permission, email</font><FONT COLOR=\"#FF5E50\"> jong\@salt2.med.harvard.edu  !!!! <hr></Font></B>";

		print FASTA "\>$seq[0]\n$seq[1]\n";
		close FASTA;

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Running search program
		#_________________________________
		if($algorithm=~/fasta/i){
				 if(-s "./Bin/fasta"){
							@temp=`./Bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/usr/local/bin/fasta"){
							@temp=`/usr/local/bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/usr/bin/fasta"){
							@temp=`/usr/bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/Bio/Bin/fasta"){
							@temp=`/Bio/Bin/fasta -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }else{ die "<br> $0 can not access $algorithm program in ./Bin/ directory. Error, contact jong\@salt2.med.harvard.edu<br>";  }
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # Parsing the result of FASTA like search
				 #__________________________________________________________
				 @mspa_hashes_from_temp = @{&read_machine_readable_sso_lines_ISS(\@temp, $add_range,
									"u=$upper_expect_limit", "l=$lower_expect_limit", "$which_score", "t=$leng_thresh")};
		}elsif($algorithm=~/ssearch/){
				 if(-s "./Bin/ssearch"){
							@temp=`./Bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/usr/local/bin/ssearch"){
									@temp=`/usr/local/bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/usr/bin/ssearch"){
									@temp=`/usr/bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }elsif(-s "/Bio/Bin/ssearch"){
									@temp=`/Bio/Bin/ssearch -m 10 -H -E $E_val $fasta_file $sequence_DB $k_tuple`;
				 }else{ die "<br> $0 can not access $algorithm program in ./Bin/ directory. Error, contact jong\@salt2.med.harvard.edu<br>";  }
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # Parsing the result of FASTA like search
				 #__________________________________________________________
				 @mspa_hashes_from_temp = @{&read_machine_readable_sso_lines_ISS(\@temp, $add_range,
									"u=$upper_expect_limit", "l=$lower_expect_limit", "$which_score", "t=$leng_thresh")};
		}elsif($algorithm=~/blast/i or $algorithm=~/psi/i){
				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # WARN!  Here I am adjusting PSI-Blast E value
				 #__________________________________________________
		     $E_val=$E_val/10;
				 @mspa_hashes_from_temp=@{&do_psi_blast_search_ISS( "d=$sequence_DB", "i=$fasta_file",
						           "E=$E_val", "e=$step_e_opt", "o=$over_write", "j=$iter_opt")};
		}


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# NOW, We have MSP format hashes as input
		#______________________________________________________________
		if(@mspa_hashes_from_temp < 1){
			 print "<br><FONT COLOR=\"#DC143C\"><FONT SIZE=+3>! NO hits, Go back to a New ISS search";
			 print "<A href=\"ISS_server.html\">ISS server</A></font></font>";
			 die;
		}
		if($which_score=~/z/){ $score_col='<FONT COLOR="#0000FF">Z-scor</font>' }else{ $score_col='SWscor' }
		for($i=0; $i< @mspa_hashes_from_temp; $i++){
			 my %temp=%{$mspa_hashes_from_temp[$i]};
			 my @values=@{&sort_by_column([values %temp], 2)};
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # one of the headlines
			 #__________________________________________________________
			 print "<pre>";
			 printf("%-6s %-8s %-5s %-4s  %-5s %-12s %-5s %-5s %s\n", $score_col,
							"<A href=\"http://www.mrc-lmb.cam.ac.uk/genomes/jong/expectation_value.html\">E-value </A>",
							'SeqID', 'From', 'To',
							'Query', 'From', 'To', 'InterSeq and SCOP superfamily', "<br>");

			 for($j=0; $j< @values; $j++){
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 #  Matching output MSP lines
					 #___________________________________________
					 if(  $values[$j]=~/^ *(\S.{3,6}) *(\S.{4,8}) *(\S.{3,6}) *(\d+ +\d+ +\S+ ) +(\d+ +\d+ +\S+)([dec](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)/){
							 ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name, $class, $fold, $superfam)=($1, $2, $3, "$4 $5", $6, $7, $8, $9, $10);
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
							 #______________________________________________________________________________________
							 if(length($class) ==1){      $first_num="00$class";
							 }elsif(length($class) ==2){  $first_num="0$class";
							 }else{                       $first_num="$class"; }
							 if(length($fold) ==1){       $sec_num="00$fold";
							 }elsif(length($fold) ==2){   $sec_num="0$fold";
							 }else{                       $sec_num="$fold"; }
							 if(length($superfam) ==1){      $third_num="00$superfam";
							 }elsif(length($superfam) ==2){  $third_num="0$superfam";
							 }else{                          $third_num="$superfam"; }
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 #  printing each line of output with coloring
							 #_______________________________________________

							 if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
							 if($evalue < 0.05 or $evalue=~/e\-/){
									                 print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>";
							 }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
							 if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest";
							 }else{              print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
							 print "<a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/search.cgi?ver=1.38;sid=$d_name,\">$pdb_name</A>";
							 print "<b><FONT COLOR=\"#DC143C\">_</FONT></b>";
							 print "<A href=\"http://scop.mrc-lmb.cam.ac.uk/scop/data/scop.1.$first_num.$sec_num.$third_num.000.000.html\">$class.$fold.$superfam";
							 print "</A><br>";
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # This is FASTA style output, I am just lazy
					 #__________________________________________________________________
					 }elsif($values[$j]=~/^ *(\S+ +)(\S+ +)(\S+ +)(\d+ +\d+ +\S+ +\d+ +\d+ +\S+)([de](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)$/){
							 ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name, $class, $fold, $superfam)=($1, $2, $3, $4, $5, $6, $7, $8, $9);
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
							 #______________________________________________________________________________________
							 if(length($class) ==1){      $first_num="00$class";
							 }elsif(length($class) ==2){  $first_num="0$class";
							 }else{                       $first_num="$class"; }
							 if(length($fold) ==1){       $sec_num="00$fold";
							 }elsif(length($fold) ==2){   $sec_num="0$fold";
							 }else{                       $sec_num="$fold"; }
							 if(length($superfam) ==1){      $third_num="00$superfam";
							 }elsif(length($superfam) ==2){  $third_num="0$superfam";
							 }else{                          $third_num="$superfam"; }
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 #  printing each line of output with coloring
							 #_______________________________________________

							 if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
							 if($evalue < 0.05 or $evalue=~/e\-/){
									 print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>";
							 }else{ print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
							 if($seq_id > 0.4){
									 print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest";
							 }else{ print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
							 print "<a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/search.cgi?ver=1.35;sid=$d_name,\">$pdb_name</A>";
							 print "<b><FONT COLOR=\"#DC143C\">_</FONT></b>";
							 print "<A href=\"http://scop.mrc-lmb.cam.ac.uk/scop/data/scop.1.$first_num.$sec_num.$third_num.000.000.html\">$class.$fold.$superfam";
							 print "</A><br>";
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # 65.5 2e-12  1  1 34   Q5440___1-34    2 35  d1enh___1.3.1.1.2
					 #___________________________________________________________________________________________________
					 }elsif($values[$j]=~/^ *(\S+ +)(\S+ +)(\S+ +)(\d+ +\d+ +\S+ +\d+ +\d+ +)([dce](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)/){
							 ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name, $class, $fold, $superfam)=($1, $2, $3, $4, $5, $6, $7, $8, $9);
							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # To create: http://scop.mrc-lmb.cam.ac.uk:80/scop/data/scop.1.000.000.000.000.html
							 #______________________________________________________________________________________
							 if(length($class) ==1){      $first_num="00$class";
							 }elsif(length($class) ==2){  $first_num="0$class";
							 }else{                       $first_num="$class"; }
							 if(length($fold) ==1){       $sec_num="00$fold";
							 }elsif(length($fold) ==2){   $sec_num="0$fold";
							 }else{                       $sec_num="$fold"; }
							 if(length($superfam) ==1){      $third_num="00$superfam";
							 }elsif(length($superfam) ==2){  $third_num="0$superfam";
							 }else{                          $third_num="$superfam"; }
							 if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
							 if($evalue < 0.05 or $evalue=~/e\-/){
									                 print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>";
							 }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
							 if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest";
							 }else{              print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
							 print "<a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/search.cgi?ver=1.38;sid=$d_name,\">$pdb_name</A>";
							 print "<b><FONT COLOR=\"#DC143C\">_</FONT></b>";
							 print "<A href=\"http://scop.mrc-lmb.cam.ac.uk/scop/data/scop.1.$first_num.$sec_num.$third_num.000.000.html\">$class.$fold.$superfam";
							 print "</A><br>";
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # 65.5 2e-12  1  1 34   Q5440___1-34    2 35  d1enh___2-35           1
					 #___________________________________________________________________________________________________
					 }elsif($values[$j]=~/^ *(\S+ +)(\S+ +)(\S+ +)(\d+ +\d+ +\S+ +\d+ +\d+ +)([dce](\w{4})\w{2})\_(\d+)\.(\d+)\.(\d+)/){
							 ($sw, $evalue, $seq_id, $rest, $d_name, $pdb_name)=($1, $2, $3, $4, $5, $6);
							 if($sw > 125){ print "<b>$sw</b>"; }else{ print "$sw"; }
							 if($evalue < 0.05 or $evalue=~/e\-/){
									                 print "<b><FONT COLOR=\"#FE2211\">$evalue</FONT></b>";
							 }else{              print "<FONT COLOR=\"#FF1463\">$evalue</FONT>";  }
							 if($seq_id > 0.4){  print "<b><FONT COLOR=\"#800000\">$seq_id</FONT></b>$rest";
							 }else{              print "<FONT COLOR=\"#800000\">$seq_id</FONT>$rest"; }
							 print "<a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/search.cgi?ver=1.38;sid=$d_name,\">$pdb_name</A><br>";
					 }else{
					     print "ERROR not right pattern matching for MSP format"; die;
					 }
			 }
			 print "<\/pre>";

		}
		if($show_raw_result){
				print "Following is Raw search output<br><pre>@temp</pre><br>";
		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Epilogue
		#___________________________________
		print "<hr><FONT COLOR=\"#DC143C\"><FONT SIZE=+2><< Go back to a NEW ";
		print "<A href=\"ISS_server.html\">ISS server</A></font></font>";
		print "</html>\n";


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Making log
		#__________________________________
		$visitor= $ENV{'HTTP_REFERER'};
		$rhost =  $ENV{'REMOTE_HOST'};
		$ruser =  $ENV{'REMOTE_USER'};
		$server = $ENV{'SERVER_SOFTWARE'};
		$q_string=$ENV{'QUERY_STRING'};
		$rident  =$ENV{'REMOTE_IDENT'};
		$page_acc=$ENV{'DOCUMENT_NAME'};

		@date=@{&get_date};
		if(-s "ISS_server_access.log" > 10000000){
		   print "<HR>The ISS_server_access.log in ./Log dir is over 10MB, reduce it or warn the sysadmin<br>";
		}
		open (ISS_server_access, ">>./Log/ISS_server_access.log");
		print ISS_server_access "@date $seq_name, REMOTE_HOST: $rhost, REMOTE_USER:$ruser, REMOTE_IDENT:$rident, SERVER_SOFTWARE: $server\n";
		close ISS_server_access;
}




#________________________________________________________________________________
# Title     : read_machine_readable_sso_lines_ISS
# Usage     : @out_refs=@{&read_machine_readable_sso_lines(\@SSO, $get_alignment,
#                           $create_sso, $upper_expect_limit,$new_format, $lower_expect_limit,
#                           $attach_range_in_names, $attach_range_in_names2)};
# Function  :
# Example   :
# Keywords  : read_m10_sso_lines read_msso_lines
# Options   : a c r r2 u= t= z
# Version   : 1.4
#--------------------------------------------------------------------------------
sub read_machine_readable_sso_lines_ISS{
	 my ($upper_expect_limit, $lower_expect_limit)=(50,0);
	 my (%match, @out_refs, $target_found, $target_sq_stop, $target_sq_statrt, $match_found,
			$match_seq, $match_found2, $i, $j,$match_found3, $overlap, $sw_score,$which_score,
			$match_sq_stop, $match_seq2, $sw_ident, $name_range, $target_seq,
			$al_display_start, $match_seq_count, $leng_thresh);
	 $leng_thresh=30;
	 $upper_expect_limit=1;

	 for($i=0; $i< @_; $i++){
			 if(ref($_[$i]) eq 'ARRAY'){ @SSO=@{$_[$i]};   }
			 elsif($_[$i]=~/^u=(\S+)$/){ $upper_expect_limit=$1 }
			 elsif($_[$i]=~/^t=(\S+)$/){ $leng_thresh=$1 }
			 elsif($_[$i]=~/^l=(\S+)$/){ $lower_expect_limit=$1 }
			 elsif($_[$i]=~/^c *$/){     $create_sso = 'c'; print "\n# read_machine_readable_sso_lines: \$create_sso is set"; }
			 elsif($_[$i]=~/^a *$/){     $get_alignment='a'; }
			 elsif($_[$i]=~/^r *$/){     $attach_range_in_names='r' }
			 elsif($_[$i]=~/^r2 *$/){    $attach_range_in_names2='r2' }
			 elsif($_[$i]=~/^z *$/){     $which_score='z' }
	 }

	 for($j=0; $j< @SSO; $j++){
	    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    # Matching   >>>sadf_.fasta, 32 aa vs PSI-ISS_nr_interm_lib_Jan99.mnfa library
	    #_____________________________________________________________________________
		  if($SSO[$j]=~/\>\>\> *(\S+)\,? +(\d+)/){  ## >>>  line
		     $target_found=1;  $target_seq_leng=$2;  ## Ignoring the $1, as file name can be different from rea seq names
	    	 $j+=8;
	    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    # Matching   >>nr_APA1_MOUSE_20-195_d1nfn___1.24.1
	    #_____________________________________________________________________________
	    }elsif( $target_found==1 and $SSO[$j]=~/\>\>(\w[\w\-\.]+)([\.prot\,\:]*) */ ){ ##
				 $match_found=1;   $match_seq="$1";
			   $match_seq_count++;
			   $al_display_start=0;
			   if(length($2)>0){  print "\n# read_machine_readable_sso_lines: Seq name has this special char \"$2\". I ignore it"; }
			   next;
			}elsif($match_found and $SSO[$j]=~/^ *\; +\w+_z\-score *\: +(\S+)/){  $z_score =$1;
	    }elsif($match_found and $SSO[$j]=~/^ *\; +\w+_expect\:? +(\S+)/){
			   #~~~~~~~~~~~~~~~~~~~~~~~
			   # Filtering by E val
			   #_______________________
			   if( $1 > $upper_expect_limit or $1 < $lower_expect_limit ){    $match_found=0; next;
				 }else{ $expect =$1; }
			}elsif($match_found and $SSO[$j]=~/^ *\; +sw_score *\: +(\S+)/i){  $sw_score =$1;
	    }elsif($match_found and $SSO[$j]=~/^\; +sw_ident\: +(\S+)/){  $sw_ident =$1;
			}elsif($match_found and $SSO[$j]=~/^ *\; +sw_overlap\: +(\S+)/){  $overlap=$1;
				 if($overlap < $leng_thresh){ $match_found=0; next; }
	    }elsif($match_found and $SSO[$j]=~/^ *\>(\w[\w\-\.]+)([\.prot\,\:]*) *\d*/){
				 $match_seq2="$1";
			   $match_found2=1;	 $match_found=0;
			   if( length($2)>0 ){  print "\n# read_machine_readable_sso_lines: Seq name has this special char \"$2\". I ignore it"; }
			   $target_seq=$match_seq2;
	    }elsif($match_found2 and $SSO[$j]=~/\; +sq_len\: +(\S+)/){
		     $target_sq_len=$1;
	    }elsif($match_found2 and $SSO[$j]=~/\; +al_start\: +(\S+)/){
		     $target_sq_start=$1;
	    }elsif($match_found2 and $SSO[$j]=~/\; +al_stop\: +(\S+)/){
		     $target_sq_stop=$1;
	    }elsif($SSO[$j]=~/\; +al_display_start/ and $al_display_start < 1){
				 $al_display_start ++;
	    #------------------------------------------------------------
	    }elsif($match_found2 and $SSO[$j]=~/\>(\w[\w\-\.]+)([\.prot\,\:]*) *[\d+]*/){
				 $match_found3=1; $match_found2=0;
				 if(length($2)>0){  print "\n# open_sso_files: Seq name has this special char \"$2\". I ignore it"; }
	    }elsif($match_found3 and $SSO[$j]=~/\; +sq_len\: +(\S+)/){
		     $match_sq_len=$1;
	    }elsif($match_found3 and $SSO[$j]=~/\; +al_start\: +(\d+)/){
				 $match_sq_start=$1;
	    }elsif($match_found3 and $SSO[$j]=~/\; +al_stop\: +(\d+)/){
				 $match_sq_stop=$1;
	    }elsif($match_found3 and $SSO[$j]=~/\; +al_display_start/){
			   $match_found3=0;          $al_display_start++;
			   if($expect=~/^$/){ $expect='0.0'; }
			   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			   # adding the offset for names with ranges
			   #__________________________________________________
			   if($target_seq=~/^\S+_(\d+)\-(\d+)/){ $target_sq_start +=$1-1; $target_sq_stop +=$1-1;  }
						 if($which_score=~/z/){ $sw_score=$z_score;  }
						 $match{$match_seq}=sprintf("%-6s %-8s %-6s %-4s %-5s %s %-4s %-5s %s\n",
						 $sw_score, $expect, $sw_ident, $target_sq_start, $target_sq_stop, $target_seq,
						 $match_sq_start, $match_sq_stop, $match_seq);
	    }elsif($get_alignment and $al_display_start==1 and $SSO[$j]=~/^([\w\-]+) *$/){
		     ${"match_alignment\_$match_seq_count"}{$match_seq2} .= $1;
	    }elsif($get_alignment and $al_display_start==2 and $SSO[$j]=~/^([\w\-]+) *$/){
		     ${"match_alignment\_$match_seq_count"}{"$match_seq"} .= $1;
	    }elsif($get_alignment and $SSO[$j]=~/^ *\;al_cons\:/){
		     $al_display_start=0;
		     my %temp=%{"match_alignment\_$match_seq_count"};
		     push(@out_refs, \%temp );
		     %{"match_alignment\_$match_seq_count"}=();
	    }
	 } ## <-- for($j=0; $j< @SSO; $j++)

	 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	 # If create sso option is set, it creates SSO files(array input case)
	 #________________________________________________________________________
	 if( $create_sso and !$get_alignment){
	    open (SSO2, ">$target_seq\.msso");
	    print SSO2 @SSO, "\n";
	    print "\n# read_machine_readable_sso_lines : $target_seq\.msso file  is created by \"c\" opt ";
	    close SSO2
	 }
	 #print "<BR>",%match, "<BR>";
	 unless($get_alignment){
	   push(@out_refs, \%match);
	 }
	 return(\@out_refs);
}



#____________________________________________________________
# Title    : read_any_dir_for_dir
# Function : read any dir and REMOVES the '.' and '..' entries. And
#            then put in array.
# Usage    : @file_list = @{&read_any_dir(\$absolute_path_dir_name, ....)};
# Argument : takes one or more scaler references.
# Returns  : one ref. of array.
# Keywords : read_any_dir_for_dir_command
# Warning  : This does not report '.', '..', '#xxxx', ',xxxx', etc. only legitimate
# Warning  : file and dir names are reported.
# Version  : 1.2
#----------------------------------------------------------------------
sub read_any_dir_for_dir{

		my ($i,%big_files, $in_dir, $size_sum, @final_files, @in,
				@target_file_names, $in_dir, $k, @possible_dirs, @read_files, @stat);
		@in=@_;
		for($k=0; $k < @in; $k++){
			 if   ( ($in[$k] eq '.') || !(defined($in[$k]))){    $in_dir='.';  splice(@in, $k, 1); $k-- }
			 elsif(!(ref($in[$k]))){   $in_dir=$in[$k];     }
			 elsif(ref($in[$k]) eq 'SCALAR'){
					 $in_dir =${$in[$k]};
					 splice(@in, $k, 1); $k--;next;   }
			 elsif(ref($in[$k]) eq 'ARRAY'){
					@target_file_names= @{$in[$k]}; splice(@in, $k, 1); $k--;  }

			 if($in_dir!~/^\.$/ and $in_dir =~ /^([\w\-\.]+)$/){  $in_dir="\.\/$in_dir";   # if it is a short dir name
					 unless(-d $in_dir){ $in_dir=${&dir_search_special(\$in_dir, \@target_file_names)} }
			 }
			 print "\n# $0: read_any_dir_for_dir: \$in_dir is  $in_dir\n";
		}
			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
			 # This is to search the input dir names in your whole dirs
			 #____________________________________________________________
			 sub dir_search_special{
														 my($in_dir)=${$in[0]};
														 my(@ENV_dir, @probable_dir_list, @dirs,@possible_dirs, $final_dir);
														 if($in_dir =~ /\/([\w\.\-]+)$/){   $in_dir = $1; }
														 @probable_dir_list=('ALIGN', 'PDB', 'PATH', 'HOME', 'JPO', 'PIRDIR', 'PDBSST','PDBENT',
																																																																		 'BLASTDB', 'PIRDIR', 'SWDIR');
														 for (@probable_dir_list){ @dirs=split(':', $ENV{$_});
														 for (@dirs){ if (/$in_dir$/){ $final_dir = $_; } } }
														 if(@possible_dirs <1){  # goes up one level and tries to find dir.
																						 my($pwd)=`pwd`;
																						 chomp($pwd);
																						 my(@temp)=split('/', $pwd);
																						 pop(@temp);
																						 my($up_pwd)=join('/', @temp);
																						 $in_dir="$up_pwd\/$in_dir";
																						 $final_dir=$in_dir if (-d $in_dir);
														 }
														 return(\$final_dir);
			 }#~~~~~~~ End of sub ~~~~~~~~~~~

		 @read_files = @{&read_file_names_only(\$in_dir, \@target_file_names)};
		 for($i=0; $i < @read_files; $i ++){
					@stat=stat($read_files[$i]);
					$size_sum+=$stat[7];
					if($stat[7] > 1000000){ $big_files{$stat[7]} = $read_files[$i]; }
					if( ($read_files[$i]=~/^[\W]+$/)||($read_files[$i] =~ /\s+/)){
							splice( @read_files, $i, 1 ); $i--  }
					if( ($read_files[$i]=~/\.\.+/)||($read_files[$i] =~ /\#+/)||($read_files[$i]=~/\,+/)){
							splice( @read_files, $i, 1 ); $i-- }
					if(-d "$in_dir\/$read_files[$i]" ){ push(@read_dirs, $read_files[$i]); next}
		 }
		 push(@final_files, @read_files);
		 return(\@final_files, \%big_files,  \$size_sum, \@read_dirs);
}

#______________________________________________________________________________
# Title     : generate_URI_content_line
# Usage     : $URI_content_line=${&generate_URI_content_line(\%URI_param_keys_and_values)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@salt2.med.harvard.edu,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub generate_URI_content_line{
        my($i, $URI_content_line, %URI_param_keys_and_values, @keys);
		%URI_param_keys_and_values=%{$_[0]};

		@keys=keys %URI_param_keys_and_values;
		for($i=0; $i< @keys; $i++){
			 $URI_content_line .="$keys[$i]=$URI_param_keys_and_values{$keys[$i]}\&";
		}
		return(\$URI_content_line);
}


#________________________________________________________________________
# Title     : generate_random_DNA_sequence
# Usage     : $DNA = ${&generate_random_DNA_sequence(1, 400)};
# Function  : gets one or more numbers for seq length and makes random sequences
#             It can handle proportional random sequenes according to the
#             nucleic acid occurance matrix.
# Example   : $out=${&generate_random_DNA_sequence(@ARGV)};  While @ARGV can be '1 200 -p'
# Warning   :
# Keywords  : scramble_sequence, make_scrambled_sequence, shuffle_sequence
#             random_sequence, generate_random_DNA_sequence, generate_random_DNA_seq
#             create_random_sequene create_random_aa_sequence, pick_random_sequence
#             generate_randomly_picked_sequence, get_random_sequence,
# Options   : 'p' for proportional random sequence option
#             'f' for fastsa format output (returns one ref. of HASH)
# Returns   : one or more scalar references according to the input numbers.
# Argument  : 1 200 [-p] [@array_of_array_refs]
#             1 = num of seq, 200=leng of seq, -p =option, @arr.. = option
#             You can optionally give nucleic acid matrices
# Category  :
# Version   : 1.6
#--------------------------------------------------------------------
sub generate_random_DNA_sequence{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my($seq_length, $residue, %fasta, @out_seq_ref, @base_freq);
	if(@num_opt==1){
		$num_of_seq=1;
		$seq_length=$num_opt[0];
	}elsif(@num_opt ==2){
		$num_of_seq=$num_opt[0];
		$seq_length=$num_opt[1];
	}
	srand(time());
	if($char_opt=~/p/i){ ####### PROPORTIONAL random #####
	  my ($rand_DNA_seq, $sum, $random);
	  if(@array>0){  # when matrices are given in @hash
         @array1=@{$array[0]};
         if($array1[0]=~/\d+/){
            @base_freq  =@array1;
            @DNA=@{$array[1]};
         }else{
            @DNA=@array1;
            @base_freq  =@{$array[1]};
         }
	  }else{
         @base_freq = (.25, .25, .25, .25, .25);
         @DNA=("A",  "T",  "G",  "C");
	  }
	  for($j=0; $j<$num_of_seq; $j++){
		  my ($rand_DNA_seq, $random, $sum);
		  for($i=1; $i <= $seq_length; $i++){
			 $random=rand;
			 $sum =0;
			 for($x=0; $x< 20; $x++){
				$sum+=$base_freq[$x];
				if( $sum >= $random){
					if($char_opt=~/f/i){
                        $fasta{"rand${j}"} .=$DNA[$x]; last;
					}else{
                        $rand_DNA_seq .= $DNA[$x];
						last;
					}
				}
			 }
			 if($random > $sum){ $rand_DNA_seq .= $DNA[19]; }
			 if( (!($i%60)) && ($char_opt=~/f/i) ){ $fasta{"rand${j}"} .= "\n" }
			 elsif( !($i%60) ){ $rand_DNA_seq .= "\n" }
		  }
		  if($char_opt=~/f/i){ push(@fasta_out_ref, \%fasta) }
		  else{ push(@out_seq_ref, \$rand_DNA_seq) }
	  }
	}else{
	  for($j=0; $j<$num_of_seq; $j++){
		 my ($rand_DNA_seq, $residue);
		 for $i (1..$seq_length) {
			$residue = pack("c", rand(128));
			redo unless $residue =~ /[ACTG]/i;
			if($char_opt=~/f/i){
				$fasta{"rand${j}"} .=$residue;
			}else{
				$rand_DNA_seq .= $residue;
			}
			if( (!($i%60)) && ($char_opt=~/f/i) ){ $fasta{"rand${j}"} .= "\n" }
			elsif( !($i%60) ){ $rand_DNA_seq .= "\n" }
		 }
		 $rand_DNA_seq=~tr/atgc/ATGC/;
		 $fasta{"rand${j}"}=~tr/atgc/ATGC/;
		 if($char_opt=~/f/i){ push(@fasta_out_ref, \%fasta) }
		 else{ push(@out_seq_ref, \$rand_DNA_seq) }
	  }
	}
	if($debug==1){ print "\n",%fasta, "\n" }
	if($char_opt=~/f/i){ return(@fasta_out_ref) }
	elsif(@out_seq_ref == 1){ return($out_seq_ref[0]); }
	elsif(@out_seq_ref > 1){ return(@out_seq_ref); }
}



#________________________________________________________________________________
# Title     : produce_random_numbers
# Usage     : @rand_nums=@{&produce_random_numbers($how_many, $range)};
# Function  :
# Example   : @rand_nums=@{&produce_random_numbers($how_many, $range)};
#              while $how_many->10, $range->9  =>> will produce '151287192'
# Keywords  : generate_random_numbers, make_random_numbers, create_random_numbers
#             random_numbers, get_random_numbers
# Options   :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub produce_random_numbers{
    my (%hash, $how_many, $i, $range);
    unless(@_ > 1){
         print "\n# $0: produce_random_numbers needs 2 args. 1st for howmany, 2nd for range\n";
         die;
    }
    $how_many=${$_[0]} || $_[0];
    $range   =${$_[1]} || $_[1];
    for($i=0; $i<$how_many; $i++){
         $hash{$i}=int(rand($range))+1; ## if your range is 10, it will make numbers 1-10
    }
    if((keys %hash) == 1){
       return \(values %hash);
    }else{
       return([values %hash]);
    }
}

#________________________________________________________________________________
# Title     : read_seq_matrix_files
# Usage     : %matrix=%{&read_seq_matrix_files(\@file)};
# Function  : Makes similarrity matrix hash(reflexive, so it has AT as well as TA)
#             %matrix looks like this:  $matrix{X}{Y}= 4
# Example   :
# Keywords  : get_2D_aa_matrix, read_seq_matrix
# Options   :
#     $reflexive_combi=r by r -r
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub read_seq_matrix_files{
	#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my($residue_num, @matrix, @residue, $first_residue, $residue_num,
			 @matrix_val, $second_residue, $paired_residues, %matrix, $reflexive_combi);

		if($char_opt=~/r/){ $reflexive_combi='r' } ## decide if the pairs are to be reflexive

		for($i=0; $i< @file; $i++){
				open(MATRIX_FILE, "$file[$i]");
				@matrix=<MATRIX_FILE>;
				close(MATRIX_FILE);

				for($j=0; $j < @matrix; $j++){

					 if($matrix[$j]=~/^ *#/){ next }

					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # matching '   A  R  N  D  C  Q  E  G  H  I ..' line
					 #___________________________________________________
					 if(@residue=$matrix[$j]=~/ ([\*\w])/g){
							 $residue_num=@residue;
							 #print "\n@residue $residue_num\n";
							 $j++;

							 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							 # matching ' A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -'
							 #          ' R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -'
							 #___________________________________________________
							 for($k=0; $k<@residue; $k++){
									$first_residue=$residue[$k];
									print $matrix[$j] if $verbose;
									if(@matrix_val=$matrix[$j]=~/ +([\-\d]+)/g){
											#print "\n-> @matrix_val @residue\n";
											for($l=$k; $l< @matrix_val; $l++){
												 $second_residue=$residue[$l];
												 #print "$second_residue $first_residue $l\n";
												 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
												 #  Taking only non-reflexive ones
												 #________________________________________________
												 if($reflexive_combi){
														 $paired_residues=join('', $first_residue, $second_residue);
												 }else{
														 @sorted = sort($first_residue, $second_residue);
														 $paired_residues=join('', @sorted);
												 }
												 $matrix{$paired_residues}=$matrix_val[$l]  unless $matrix{$paired_residues};
												 $out_matrix{$first_residue}{$second_residue}=$matrix_val[$l];
											}
											$j++;
									}
							 }
					 }

				}
		}
		if($string_pair_hash_out==1){  ## out looks : $matrix{'XY'}    =4
				return(\%matrix);
		}else{                         ## out looks : $matrix{'X'}{'Y'}=4
				return(\%out_matrix);
		}
}


#______________________________________________________________________________
# Title     : attach_suffix_in_file_name
# Usage     : $input_file_suffix=${&attach_suffix_in_file_name(\$file_name, 'rv', [e])};
# Function  :
# Example   :
# Keywords  :
# Options   :
#   $attach_extension=e by e  # for attaching file extension in the output
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub attach_suffix_in_file_name{
    my($input_file_name, $suffix, $pos1, $file_only, $pos, $base, $base_suffix,
       $ext, $attach_extension);
    $input_file_name=${$_[0]} || $_[0];
    $suffix=${$_[1]} || $_[1];
    $attach_extension=${$_[2]} || $_[2];

    $pos1=rindex($input_file_name, "/");
    $file_only=substr($input_file_name, ($pos1+1));
    if($file_only=~/(\S+\.\S+)\.gz$/){
         $pos = rindex($1, ".");
         $base= substr($1, 0, $pos);
    }elsif($file_only=~/^[^\.]+$/){ ## when file does not have '.' in its name
         $base= $file_only;
    }else{
         $pos = rindex($file_only, ".");
         $base= substr($file_only, 0, $pos);
         $ext = substr($file_only, ($pos+1));
    }
    if($attach_extension){
       $base_suffix="$base\_$suffix\.$ext";
    }else{
       $base_suffix="$base\_$suffix";
    }
    return(\$base_suffix);
}

#________________________________________________________________________________
# Title     : attach_scop_classification_to_pdbd_seq
# Usage     : &attach_classification_to_pdb_seq(\%hash_classification,
#                              \%correcting_pairs, \@files, $over_write);
# Function  :
# Example   :
# Keywords  : attach_scop_classificaion_to_pdb_seq, add_scop_classification_to_pdb_seq
#             attach_classification_to_pdbd_seq
# Options   :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub attach_scop_classification_to_pdbd_seq_for_strass_file{
    my (%out_with_class, %hash_classification, %correcting_pairs, @files, $i,
            $query_range, $match_range, $msp);
    %hash_classification=%{$_[0]};
    %correcting_pairs   =%{$_[1]};
    if(ref($_[2]) eq 'ARRAY'){
       @files=@{$_[2]};
    }else{ die "\n attach_classification_to_pdb_seq needs a ref. of an array \n";  }
    my $over_write=$_[3];
    print "\n Parsing @files \n";

	for($i=0; $i< @files; $i++){
			my (%out_with_class, $query_range, $match_range, $class_attached, $msp);
			$msp=$files[$i];
            print "\n Processing $msp\n";
            open(MSP, "<$msp") || die;
			while(<MSP>){
					 $match_range='';
					 $class_attached='';
					 $query_range='';
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # This is handling newer MSP files
					 #  d2hts___1-85_1.4.3.8.2         270    8.7e-14  Nomolog S25478_36-113                64     1.7      d1gp1a__129-153_3.27.1.3.1
					 #  d1irk___20-224_5.1.1.2.1       281    5.6e-10  Nomolog CRPK1_475-670                62     2.9      d1lfb___40-69_1.4.1.1.3
					 #  d2act___22-200_4.3.1.1.1       216    0.0014   Nomolog A57480_238-452               68     3.1      d1flp___25-115_1.1.1.1.2
					 #______________________________________________________________
					 if(/^ *(\S+)(_\d+\-\d+)\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)(_\d+\-\d+)/){
							 if($hash_super{$1} eq $hash_super{$8}){
									 printf("%-30s %-6s %-8s Homolog %-28s %-6s %-8s %-30s\n",
													 "$1"."$2"."\_$hash_classification{$1}",
													 $3, $4, $5, $6, $7,
													 "$8"."$9"."\_$hash_classification{$8}");
							 }else{
									 printf("%-30s %-6s %-8s Nomolog %-28s %-6s %-8s %-30s\n",
													 "$1"."$2"."\_$hash_classification{$1}",
													 $3, $4, $5, $6, $7,
													 "$8"."$9"."\_$hash_classification{$8}");
							 }
                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     # for STRASS file (psi_pdbisl_merge_assign.strass in ~/Proj/Bio/Bit/MIPS_vs_SISF
                     #    It was originally produced by Sarah in UCL
                     #  YAL019W-1131 588-734 d1a1va1-136 6-136 6e-18
                     #  YAL019W-1131 560-855 d2bct__-516 142-445 7.5e-32
                     #  YAL020C-333 4-300 d1a12a_-401 68-357 3e-45
                     #  YAL021C-837 342-527 d1dfji_-456 1-186 0
                     #______________________________________________________________________________________
                     }elsif(/^\s*(\S+\-\d+\s+\d+\-\d+\s+)(\S+)(\-\d+\s+\d+\-\d+.*)/){
                           $PDBD_name=$1;
                           print "$1\t$2$3\t$hash_classification{$2}\n";
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
					 # This is handling true MSP files
					 # 380    1e-105  1     1     356   d1pmd_4                1     356   d1pmd_4                                9
					 # 176    1e-43   0.11  45    352   d1pmd_4                6     256   d4blma_                                9
					 # 174    4e-43   0.12  37    342   d1pmd_4                3     254   d1btl__                                9
					 #__________________________________________________________________________
					 }elsif(/^ *((\d+) +(\S+) +(\S+) +(\d+) +(\d+)) +(\S+) +((\d+) +(\d+)) +(\S+) *(\S*)/){
							 print "\n# handling TRUE MSP files ======= << $0\n";
							 $front_part=$1;
							 $rear_part=$8;
							 $query_seq=$7;
							 $match_seq=$11;
							 $iteration_num=$12;
							 if($query_seq=~/(\S+)\_\d+\.\d+\.\d+/){
									 $query_seq=$1;
									 $class_attached=1;
							 }
							 if($match_seq=~/(\S+)\_\d+\.\d+\.\d+/){
									 $match_seq=$1;
									 $class_attached=1;
							 }
							 if($query_seq=~/(\S+)\_(\d+\-\d+)$/){
									 $query_seq=$1;
									 $query_range=$2;
							 }
							 if($match_seq=~/(\S+)\_(\d+\-\d+)$/){
									 $match_seq=$1;
									 $match_range=$2;
									 print "\n# \$match_seq $match_seq has range of  $match_range << $0";
							 }
							 print "\n# \$query_seq $query_seq \$match_seq $match_seq";

							 if(!$over_write and $class_attached){
									 $out_with_class{$msp}.=$_;
									 print "\n# Seq names ALREADY have classification << $0\n";
									 next;
							 }
							 if( ($over_write or !$class_attached)
									 and ($hash_classification{$query_seq} or $hash_classification{$match_seq} )){
									 print "\n# \$over_write is set or \$class_attached is true << $0\n";
									 if($query_range){
											 $classi_query="\_$hash_classification{$query_seq}";
									 }else{ $classi_query='';
									 }
									 if($match_range){
											 $classi_match="\_$hash_classification{$match_seq}";
									 }else{ $classi_match='';
									 }

									 if($verbose){
											 printf("%-34s %-25s %-27s %-28s %-3s\n",
													 $front_part, "$query_seq"."$classi_query"."$query_range",
													 $rear_part, "$match_seq"."$match_range"."$classi_match", $iteration_num);
									 }
									 $out_with_class{$msp}.=sprintf("%-34s %-25s %-27s %-28s %-3s\n",
													 $front_part, "$query_seq"."$classi_query"."$query_range",
													 $rear_part, "$match_seq"."$match_range"."$classi_match", $iteration_num);
							 }else{
									 $out_with_class{$msp}.=$_;
									 print "\n ERROR, the input pdbxx.fasta file does not have class infor for $6 $8\n";
							 }
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# This is for paired ranking file
						#
						#  d1nsca_ d3nn9__ Homolog 0
						#  d1ovaa_ e2ach.1a1 Homolog 0
						#  d1dppa_ d2olba_ Homolog 0
						#  d1brla_ d1brlb_ Homolog 0
						#_________________________________________
						}elsif(/^ *(\S+) +(\S+) +\S+molog\s+(\S+)/){
								$sorted_pair=join(' ',  sort($1, $2));

								if($hash_super{$1} eq $hash_super{$2}){
										printf("%-12s %-12s Homolog %-22s %-12s %-12s\n",
													 $1, $2, $3,
													 "$hash_classification{$1}",
													 "$hash_classification{$2}");
								}elsif( $correcting_pairs{$sorted_pair}){
										printf("%-12s %-12s Homolog %-22s %-12s %-12s\n",
													 $1, $2, $3,
													 "$hash_classification{$1}",
													 "$hash_classification{$1}");  ## I am putting the same classi as in SCOP they were different !!
								}else{
										printf("%-12s %-12s Nomolog %-22s %-12s %-12s\n",
													 $1, $2, $3,
													 "$hash_classification{$1}",
													 "$hash_classification{$2}");
								}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# This is for paired ranking file
						#
						#  d1nsca_ d3nn9__ Homolog 0
						#  d1ovaa_ e2ach.1a1 Homolog 0
						#  d1dppa_ d2olba_ Homolog 0
						#  d1brla_ d1brlb_ Homolog 0
						#_________________________________________
						}elsif(/^ *\> *(\S+) */){
								if($hash_super{$1}){
                                        printf("\>%-12s %-15s\n", $1, "$hash_classification{$1}" );
								}
						}else{
								print
						}

				}## end of each file While loop
				close(MSP);
		}
}



#______________________________________________________________________________
# Title     : attach_scop_classification_in_fasta_db_file
# Usage     :
# Function  :
# Example   : $0 pdb100d_1_41.mpfa pdb90d_1_41.mpfa  > pdb90d_1_41.mpfa2
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub attach_scop_classification_in_fasta_db_file{
    my($classification_source_file, $classification_target_file, $i);
    $classification_source_file=$_[0];
    $classification_target_file=$_[1];
    open(SCOP_CLASS_FILE, $classification_source_file ) || die "\n CAn not open $classification_source_file\n";
    while(<SCOP_CLASS_FILE>){
       if(/\>(\S+)\s+((\d+\.\d+\.\d+)\.\d+\.\d+.*)/){
           $hash_classification{$1}=$2;
           $hash_super{$1}=$3;
       }
    }
    close(SCOP_CLASS_FILE);
    open(TARGET_PDBD_FILE, "$classification_target_file") || die "\n Cannt open $classification_target_file\n";
    while(<TARGET_PDBD_FILE>){
       if(/\>(\S+)\s*/){
          print "\>$1 $hash_classification{$1}\n";
       }else{
          print;
       }
    }

}



#________________________________________________________________________________
# Title     : attach_classification_to_pdb_seq
# Usage     : &attach_classification_to_pdb_seq(\%hash_classification, \%correcting_pairs, \@files, $over_write);
# Function  :
# Example   :
# Keywords  : attach_scop_classificaion_to_pdb_seq, add_scop_classification_to_pdb_seq
#             attach_classification_to_pdbd_seq
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub attach_classification_to_pdb_seq{
		my (%out_with_class, %hash_classification, %correcting_pairs, @files, $i,
				$query_range, $match_range);
		%hash_classification=%{$_[0]};
		%correcting_pairs   =%{$_[1]};
		@files=@{$_[2]};
		my $over_write=$_[3];

		for($i=0; $i< @files; $i++){
				my (%out_with_class, $query_range, $match_range, $class_attached, $msp);
				$msp=$files[$i];

				open(MSP, $msp);
				while(<MSP>){
					 $match_range='';
					 $class_attached='';
					 $query_range='';
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					 # This is handling newer MSP files
					 #  d2hts___1-85_1.4.3.8.2         270    8.7e-14  Nomolog S25478_36-113                64     1.7      d1gp1a__129-153_3.27.1.3.1
					 #  d1irk___20-224_5.1.1.2.1       281    5.6e-10  Nomolog CRPK1_475-670                62     2.9      d1lfb___40-69_1.4.1.1.3
					 #  d2act___22-200_4.3.1.1.1       216    0.0014   Nomolog A57480_238-452               68     3.1      d1flp___25-115_1.1.1.1.2
					 #______________________________________________________________
					 if(/^ *(\S+)(_\d+\-\d+) +(\S+) +(\S+) +(\S+) +(\S+) +(\S+) +(\S+)(_\d+\-\d+)/){
							 if($hash_super{$1} eq $hash_super{$8}){
									 printf("%-30s %-6s %-8s Homolog %-28s %-6s %-8s %-30s\n",
													 "$1"."$2"."\_$hash_classification{$1}",
													 $3, $4, $5, $6, $7,
													 "$8"."$9"."\_$hash_classification{$8}");
							 }else{
									 printf("%-30s %-6s %-8s Nomolog %-28s %-6s %-8s %-30s\n",
													 "$1"."$2"."\_$hash_classification{$1}",
													 $3, $4, $5, $6, $7,
													 "$8"."$9"."\_$hash_classification{$8}");
							 }
					 }
					 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
					 # This is handling true MSP files
					 # 380    1e-105  1     1     356   d1pmd_4                1     356   d1pmd_4                                9
					 # 176    1e-43   0.11  45    352   d1pmd_4                6     256   d4blma_                                9
					 # 174    4e-43   0.12  37    342   d1pmd_4                3     254   d1btl__                                9
					 #__________________________________________________________________________
					 elsif(/^ *((\S+) +(\S+) +(\S+) +(\d+) +(\d+)) +(\S+) +((\d+) +(\d+)) +(\S+) *(\S*)/){
							 print "\n# handling TRUE MSP files ======= << $0\n";
							 $front_part=$1;
							 $rear_part=$8;
							 $query_seq=$7;
							 $match_seq=$11;
							 $iteration_num=$12;
							 if($query_seq=~/(\S+)\_\d+\.\d+\.\d+/){
									 $query_seq=$1;
									 $class_attached=1;
							 }
							 if($match_seq=~/(\S+)\_\d+\.\d+\.\d+/){
									 $match_seq=$1;
									 $class_attached=1;
							 }
							 if($query_seq=~/(\S+)\_(\d+\-\d+)$/){
									 $query_seq=$1;
									 $query_range=$2;
							 }
							 if($match_seq=~/(\S+)\_(\d+\-\d+)$/){
									 $match_seq=$1;
									 $match_range=$2;
									 print "\n# \$match_seq $match_seq has range of  $match_range << $0";
							 }
							 print "\n# \$query_seq $query_seq \$match_seq $match_seq";

							 if(!$over_write and $class_attached){
									 $out_with_class{$msp}.=$_;
									 print "\n# Seq names ALREADY have classification << $0\n";
									 next;
							 }
							 if( ($over_write or !$class_attached)
									 and ($hash_classification{$query_seq} or $hash_classification{$match_seq} )){
									 print "\n# \$over_write is set or \$class_attached is true << $0\n";
									 if($query_range){
											 $classi_query="\_$hash_classification{$query_seq}";
									 }else{ $classi_query='';
									 }
									 if($match_range){
											 $classi_match="\_$hash_classification{$match_seq}";
									 }else{ $classi_match='';
									 }

									 if($verbose){
											 printf("%-34s %-25s %-27s %-28s %-3s\n",
													 $front_part, "$query_seq"."$classi_query"."$query_range",
													 $rear_part, "$match_seq"."$match_range"."$classi_match", $iteration_num);
									 }
									 $out_with_class{$msp}.=sprintf("%-34s %-25s %-27s %-28s %-3s\n",
													 $front_part, "$query_seq"."$classi_query"."$query_range",
													 $rear_part, "$match_seq"."$match_range"."$classi_match", $iteration_num);
							 }else{
									 $out_with_class{$msp}.=$_;
									 print "\n ERROR, the input pdbxx.fasta file does not have class infor for $6 $8\n";
							 }
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# This is for paired ranking file
						#
						#  d1nsca_ d3nn9__ Homolog 0
						#  d1ovaa_ e2ach.1a1 Homolog 0
						#  d1dppa_ d2olba_ Homolog 0
						#  d1brla_ d1brlb_ Homolog 0
						#_________________________________________
						elsif(/^ *(\S+) +(\S+) +\S+ +(\S+)/){
								$sorted_pair=join(' ',  sort($1, $2));

								if($hash_super{$1} eq $hash_super{$2}){
										printf("%-12s %-12s Homolog %-22s %-12s %-12s\n",
													 $1, $2, $3,
													 "$hash_classification{$1}",
													 "$hash_classification{$2}");
								}elsif( $correcting_pairs{$sorted_pair}){
										printf("%-12s %-12s Homolog %-22s %-12s %-12s\n",
													 $1, $2, $3,
													 "$hash_classification{$1}",
													 "$hash_classification{$1}");  ## I am putting the same classi as in SCOP they were different !!
								}else{
										printf("%-12s %-12s Nomolog %-22s %-12s %-12s\n",
													 $1, $2, $3,
													 "$hash_classification{$1}",
													 "$hash_classification{$2}");
								}
						}
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# This is for paired ranking file
						#
						#  d1nsca_ d3nn9__ Homolog 0
						#  d1ovaa_ e2ach.1a1 Homolog 0
						#  d1dppa_ d2olba_ Homolog 0
						#  d1brla_ d1brlb_ Homolog 0
						#_________________________________________
						elsif(/^ *\> *(\S+) */){
								if($hash_super{$1}){
										printf("\>%-12s %-15s\n", $1, "$hash_classification{$1}" );
								}
						}else{
								print
						}

				}## end of each file While loop
				close(MSP);
				open(MSP_NEW, ">$msp"); #  overwrites $mspa !!
				print MSP_NEW $out_with_class{$msp};
				print $out_with_class{$msp};
				close (MSP_NEW);
		}
}


#________________________________________________________________________________
# Title     : put_slash_before_special_chars
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub put_slash_before_special_chars{
		my ($i);
		my $string=${$_[0]};
		my @string=split(//, $string);
		for($i=0; $i< @string; $i++){
			 if($string[$i]=~/\W/){
					$string[$i]="\\$string[$i]";
			 }
		}
		$string = join("", @string);
		return(\$string);
}

#________________________________________________________________________________
# Title     : split_file_by_string
# Usage     :
# Function  :
# Example   :
# Keywords  : split_file_by_string  divide_file_by_string
# Options   :
# Category  :
# Version   : 1.1
#--------------------------------------------------------------------------------
sub split_file_by_string{
		my ($count, $out_file, $i);
		my @files=@{$_[0]};
		my $string=${$_[1]};
		$string=${&put_slash_before_special_chars(\$string)};
		unless($string){
			 print "\n# $0 needs a delimiting string \n";
			 die;
		}else{
			 print "\n# $0: string delimiter was \"$string\" \n";
		}

		for($i=0; $i< @files; $i++){
			 open(F, $files[$i]);
			 my $count=1;
			 my $out_file="splited\_".$files[$i]."\_$count\.txt";
			 open(SPLIT, ">$out_file");
			 while(<F>){
					unless(/$string/){
						 print SPLIT $_;
					}else{
						 push(@splited_files_out, $out_file);
						 close SPLIT;
						 $count++;
						 $out_file="splited\_$files[$i]\_$count\.txt";
						 open(SPLIT, ">$out_file");
					}
			 }
			 close(F);
			 close(SPLIT);
		}
		print "\n# $0: @splited_files_out were created \n";
}

#________________________________________________________________________________
# Title     : check_input_file_extension
# Usage     : @file=@{&check_input_file_extension('msp', \@file)};
#             or @file=@{&check_input_file_extension('msp,nhco', \@file)};
#                for multiple extension allowance
# Function  :
# Example   : @file=@{&check_input_file_extension('msp', \@file)};
# Keywords  :
# Options   :
# Category  :
# Version   : 1.2
#--------------------------------------------------------------------------------
sub check_input_file_extension{
		my(@file, @extentions, $extension_not_matched, $i, $file_ext_wanted);
		$file_ext_wanted=$_[0];
		@extentions=split(/[\, ]+/, $file_ext_wanted);
		@file=@{$_[1]};
		for(@extentions){
				$file_ext_wanted=$_;
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				print "\n# (2) checking file extension \n";
				#___________________________________________________
				if($file[0] =~/\.$file_ext_wanted/){
						 $extension_not_matched=1;
				}
		}
		unless($extension_not_matched){
				 print "\n# write_nhco_files : normally accepts xxxx.$file_ext_wanted files. Put y+return to continue";
				 print "\n# write_nhco_files : You can type \'c\' for changing the file extension to parf \n\n>>>";
				 $answer_char=getc;
				 if($answer_char=~/^y/i){
						 $answer_char='';
				 }elsif($answer_char=~/^c/i){
						 $answer_char='';
						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						 print "\n# (3) write_nhco_files: chaning all the file input extension to 'parf'";
						 #_______________________________________________________________________________
						 for($i=0; $i< @file; $i++){
								 $base=${&get_base_names($file[$i])};
								 $file[$i]="$base\.$file_ext_wanted";
						 }
				 }else{
						 $answer_char='';
						 print "\n\n\n# check_input_file_extension: You rudely put rubbish, I am dying. $0\n\n\n";
						 print chr(7);
						 die;
				 }
		}
		return(\@file);
}




#________________________________________________________________________________
# Title     : geanfammer_main
# Usage     : &geanfammer_main;
# Function  : The main sub of geanfammer
# Example   :
# Keywords  : main_geanfammer, geanfammer
# Options   :
# Version   : 2.4
#--------------------------------------------------------------------------------
sub geanfammer_main{
    ### !!! As parse_arguments is in this, DO not 'my' any variable here
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # All the defaults, Evalues are determined in geanfammer sub
    #__________________________________________________________________
    $|=1;
    unless($algorithm){
        $algorithm='fasta'; # default search algorithm setting(will be overridden
    }                         # by 'a=xxx' prompt argument
    $sub_dir_size=2; # this is the subdirectory name char size
    $machine_readable='M';  # this is to invoke FASTA's m=10 option
    $make_mspa_in_sub_dir_opt='m';
    $make_subdir_gzipped='d';
    $make_subdir_out=$make_mspa_in_sub_dir_opt='D';
    $Evalue_thresh=0.01;
    $length_thresh=30;  # default
    $take_last_iter_PSI_BLA='l';  ## this is to take the last iter only(default)
    $PSI_BLA_iter_limit=5;            # let's set it low
    $PSI_BLA_step_eval=0.001;  # default
    $make_MSP_files='q';

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # preprocessing the inputs,  parse_arguments reads in the options in the headerbox
    #__________________________________________________________________________________
    @your_genome_or_db_to_analyse_file=@{&parse_arguments(1)};

    print "\n\n# (2) geanfammer_main (with $algorithm): \@your_genome_or_db_to_analyse_file are(is) @your_genome_or_db_to_analyse_file\n";
    print "\n# (2.1) geanfammer_main (with $algorithm): \$sequence_DB: $sequence_DB \$query_File: $query_File\n";
    print "\n => @your_genome_or_db_to_analyse_file with $algorithm. Min domain size is \"$length_thresh\"
    \$make_subdir_out is $make_subdir_out\n\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Just checking error!
    #_____________________________________________________
    if(@your_genome_or_db_to_analyse_file < 1
         and (!$sequence_DB and !$query_File) ){
        print "\n# (E) geanfammer_main: ERROR!\n";
        print "\n# Dear $ENV{'USER'}, $0: failed to find input file!\n
                    Did you put FASTA format DB file as input?\n
                    Or I guess your INPUT file DOES NOT exist in PWD.\n\n";
        print " As like:  $0 MG.fasta \n\n\n";
        print chr(7);
        die;
    }else{ print "# (i) $0 is running geanfammer sub\n"; }


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # This is to handle 'geanfammer.pl temp.fasta DB=temp_DB.fasta' situation
    #____________________________________________________________________
    if(@your_genome_or_db_to_analyse_file==1 and -s $sequence_DB){
         $query_File=$your_genome_or_db_to_analyse_file[0];
    }elsif(@your_genome_or_db_to_analyse_file==1 and -s $query_File){
         $sequence_DB=$your_genome_or_db_to_analyse_file[0];
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Checking if they have 'fasta' or 'ssearch' in the path
    #__________________________________________________________________________________
    if($algorithm=~/\/([^\/]+) *$/){
        print "\n# Checking \$algorithm ($algorithm) name\n";
        $algorithm_name=$1;
        if(-s $algorithm){
            print "\n# (i) $0 will use \"$algorithm\"\n";
        }else{
            $result_of_which_run=`which $algorithm_name`;
            if($result_of_which_run=~/^ *(\/\S+\/)[fastassearch]+\d* *$/){ ## after Lily Fu's suggestion
                print "\n# $0: Your $algorithm_name is in $1, good, I am running it\n";
            }else{
                print "\n# (E) \$algorithm value $algorithm is not found\n";
                print "\n# (E) $0 ran \'which\' Linux command and the result is:\n";
                print "  $result_of_which_run, You may have fasta3 instead of fasta\n";
                print "\n# Please check your path for $algorithm\n\n"; print chr(7);
                die;
            }
        }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Running the actual big sub 'geanfammer'
    #_____________________________________________
    @final_clu_files=@{&geanfammer(\@your_genome_or_db_to_analyse_file,
                "DB=$sequence_DB",
                "File=$query_File",
                "f=$factor",
                "a=$algorithm",
                "T=$length_thresh",
                 $verbose,
                 "d=$sub_dir_size",
                 $over_write,
                 $dynamic_factor,
                 $create_sso_file,
                 $reverse_sequence,
                 $machine_readable,
                 $make_mspa_in_sub_dir_opt,
                 $make_subdir_out,
                 $make_MSP_files,
                 "E=$Evalue_thresh",
                 $make_subdir_gzipped,
                 $Lean_output,
                 $take_last_iter_PSI_BLA,
                 "j=$PSI_BLA_iter_limit",
                 "e=$PSI_BLA_step_eval"
             )};
    print "\n# $0 : the final output \'@final_clu_files\' is created " if $make_separate_summary;
    print "\n#__________________________________________________________________\n\n" if $verbose;
    return(\@final_clu_files);
}






#______________________________________________________________________________
# Title     : encrypt_passwd
# Usage     :
# Function  :
# Example   : $crypted = ${&encrypted_passwd( $plaintext, $salt )};
# Keywords  :
# Options   :
# Author    : --Mark Henderson, modified by Jong
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub encrypt_passwd {
	 my($user,$pass)=@_;
	 my($nsalt,$week,$now,$pert1,$pert2);
	 my(@salt_set)=('a'..'z','A'..'Z','0'..'9','.','/');
	 $now=time;
	 ($pert1,$pert2) = unpack("C2",$user);
	 $week = $now / (60*60*24*7) + $pert1 + $pert2;
	 $nsalt = $salt_set[$week % 64] . $salt_set[$now %64];
	 $crypted= crypt($pass,$nsalt);
	 return(\$crypted);
}

#______________________________________________________________________________
# Title     : detect_file_format_type
# Usage     : $file_type=${&detect_file_format_type($file[$i])};
# Function  :
# Example   : $crypted = ${&encrypted_passwd( $plaintext, $salt )};
# Keywords  :
# Options   :
# Author    : jong
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub detect_file_format_type{
		my($file_format_type, $possible_fasta_format, $possible_pred_format1,
			 $possible_pred_format2, $possible_prdl_format, $possible_fsso_format1,
			 $possible_ssso_format1, $possible_hmmls_format1);
		my $unknown_file=$_[0];

		%list_of_file_format_type=qw(aln clustalw
																 msf msf
																 fa fasta
																 hmmls HMM_search
																 hmmfs HMM_search
																 );
		if($unknown_file=~/^\S+\.(\S+)$/){
				print "\n# (INFO) Detecting file format type. There seems to be extension name of $1\n";
				if($list_of_file_format_type{$1}){
						$file_format_type=$1;
				}else{
						print "\n# (INFO) The possible extension is not listed in \%list_of_file_format_type\n";
				}
		}else{
				if(-b $_){
						print "\n# (INFO) $unknown_file seems to be a binary file\n";
				}else{
						print "\n# (INFO) I am opening the file to see what it is!\n";
						open (UNKNOWN_ALIGNMENT_FILE, "$unknown_file");
						while(<UNKNOWN_ALIGNMENT_FILE>){
								if(/CLUSTAL W *\(\d+\.\d+\) *multiple sequence alignment/i){
										 $file_format_type='aln';
								}elsif(/^ *MSF *\: *\d+ *Type\: *\S+ *Check\: *\d+/i){
										 $file_format_type='msf';
								}elsif(/^\> *\S{1,60} */){
										 $possible_fasta_format=1;
										 $possible_pred_format1=1;
								}elsif($possible_fasta_format and /^[ACDEFGHIKLMNPQRSTVWXY\*]+ *$/i){
										 $file_format_type='fasta'; ## fasta file format
										 $possible_fasta_format=0;
								}elsif($possible_pred_format1 and /^ *\d+ *[ACDEFGHIKLMNPQRSTVWXY]+ *\d+ *$/i){
										 $possible_pred_format2=1;
								}elsif($possible_pred_format2 and /^ *[EHC_]+ *$/){
										 $file_format_type='pred'; # predator simple output format (no -l option used)
										 $possible_pred_format1='';
								}elsif(/^ *NAME *\S+ *$/){
										 $possible_prdl_format=1;
								}elsif($possible_prdl_format and /^ *HEADER *\|\- *Residue *\-\| *Rred/i){
										 $file_format_type='prdl'; ## predator long output format with -l option
								}elsif(/^ *FASTA *searches *a *protein/){
										 $possible_fsso_format1=1;
								}elsif($possible_fsso_format1 and /^\>\>\S+ +\( *\d+ *aa *\)/){
										 $file_format_type='fsso';
								}elsif(/^ *SSEARCH *searches *a *protein/){
										 $possible_ssso_format1=1;
								}elsif($possible_ssso_format1 and /^\>\>\S+ +\( *\d+ *aa *\)/){
										 $file_format_type='ssso';
								}elsif(/^ *hmmls *\- *search +long/){
										 $possible_hmmls_format1=1;
								}elsif($possible_hmmls_format1 and /^ *\- +\- +\- +\-/){
											$file_format_type='hmmls';
								}
						}
				}
		}
		return(\$file_format_type);
}

#______________________________________________________________________________
# Title     : get_first_seq_in_alignment
# Usage     : $seq_name=${&get_first_seq_in_alignment($file)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub get_first_seq_in_alignment{
		my $input_seq_align_file=$_[0];
		my ($first_seq_appeared, $clustalw_file_detected);
		open(SEQ_ALIGN_FILE, "$input_seq_align_file");
		while(<SEQ_ALIGN_FILE>){
				if(/^CLUSTAL *W/){
						 $clustalw_file_detected=1;
				}elsif($clustalw_file_detected and /^ {0,6}(\S+)\s+[_\-ACDEFGHIKLMNPQRSTVWXY]+ *$/i){ ## matching 'CER07B5_6       SPFPAEFINVKKLFICEFCFFYARSDEIM'
						 $first_seq_appeared=$1;
						 last;
				}elsif(/NAME +(\S+)/){
						 $first_seq_appeared=$1;
						 last;
				}elsif(/^\> *(\S+)/){
						 $first_seq_appeared=$1;
						 last;
				}elsif(/^ {1,3}Name: +(\S+)/i){ # matching ' Name: AF015956_1        Len: ...'
						 $first_seq_appeared=$1;
						 last;
				}elsif(/^(\S+) +\S{10} +\S/){ ## matching  'AF015956_1             MATANSIIVL DDDDED-'
						 $first_seq_appeared=$1;
						 last;
				}
		}
		close(SEQ_ALIGN_FILE);
		return(\$first_seq_appeared);
}


#______________________________________________________________________________
# Title     : find_program_in_path
# Usage     :
# Function  :
# Example   :
# Keywords  : which, whence
# Options   :
# Author    : Jong, jong@biosophy.org
# Category  :
# Version   : 1.3
#------------------------------------------------------------------------------
sub find_program_in_path{
		my(@found_prog_and_path, $file, $verbose);

		if(@_==0){
			 #print "\n# (ERROR) $0 requires at least one program in path to detect\n\n";
			 print chr(7);
			 die;
		}
		foreach $file (@_) {
			 if($file=~/^v/i and !-s $file){
					$verbose='v'; next;
			 }
			 for $dir (split(/:/,$ENV{'PATH'})) {
					if(-f ($path="$dir/$file") && -f _){
						 $size= -s "$path";
						 $path=~s/\/\//\//g;  ## removing /bin//gzip like entry
						 push(@found_prog_and_path, sprintf("%-30s %12s byte", $path, $size) );
					}
			 }
		}
		@found_prog_and_path=@{&remove_dup_in_array(\@found_prog_and_path)};

		return(\@found_prog_and_path);
}

#______________________________________________________________________________
# Title     : do_psi_blast_search_PDB_ISL
# Usage     : &do_psi_blast_search(\@files, "d=$source_DB_file",
#                     "i=$input_seq_file",
#                     $over_write,
#                     $make_mspa_in_sub_dir_opt);
# Function  :
# Example   :
# Keywords  :
# Options   :
#    $source_DB_file=           by d= s=
#    $input_seq_file=           by i=
#    $Eval_limit=               by E=
#    $iter_opt=          by j=
#    $step_e_opt=              by h= e=
#    $over_write=o              by o
#    $make_mspa_in_sub_dir_opt=D by D
#    $Lean_output=L             by L -L
#    $put_NO_gaps=G             by G
#    $alignment_opt=            by m=
#    $make_MSP_files=M          by M
# Author    :
# Version   : 2.3
#------------------------------------------------------------------------------
sub do_psi_blast_search_PDB_ISL{
		my($i, @final_mspa_out, $iter_opt, $alignment_opt,  $source_DB_file,
			 $input_seq_file, $over_write, @in,
			 $step_e_opt, $Eval_limit, %seq_input, $base, @seq_names, $final_out_pbla_file,
			 $make_mspa_in_sub_dir_opt, $sub_dir_size, $answer_for_self_self,
			 $defined_all_ok, $ENV_BLASTDB_var, $Lean_output, $put_NO_gaps,
			 $open_gap_penalty, $extension_gap_penalty, $make_MSP_files);

		my $blast_env_var='BLASTDB';
		$USER_HOME_DIR=$ENV{'HOME'};
		if(! -s ".ncbirc"){ 		   open(NCBIRC, ">.ncbirc");
		   print "[NCBI]\n";		   print "         Data=./NCBI_Data\n";		   close(NCBIRC);
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Default parameters for blastpgp
		#_____________________________________________
		$Eval_limit=100;
		$alignment_opt=0; # default is 0, This is for -m option (0-6). 6 is used for Jason's output
		$iter_opt=3;
		$step_e_opt=0.001;
		$extension_gap_penalty=1;
		$open_gap_penalty=10;
		$gap_trigger_val=22.0; # default
		$Accumulate_matches='A';

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  # getting options
		#________________________________________________________
		@in=@_;
		for($i=0; $i< @in; $i++){
			  if($in[$i]=~/d=(\S+)/){ $source_DB_file =$1 };
				if($in[$i]=~/i=(\S+)/){ $input_seq_file =$1 };
				if($in[$i]=~/E=(\S+)/){ $Eval_limit     =$1 };
				if($in[$i]=~/e=(\S+)/){ $step_e_opt    =$1 };
				if($in[$i]=~/j=(\S+)/){ $iter_opt=$1 };
		}

		if(! $source_DB_file or ! $input_seq_file){
				 print "\n# (Warn) You did not set d= and i= options for DB and Inquiry, I set automatically\n";
				 $source_DB_file=${&get_largest_file(@file)};
				 $input_seq_file=${&get_smallest_file(@file)};

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
				 # If one of the files is missing, ask if it is for self self search and
				 #  make query=target, else die
				 #_______________________________________________________________________
				 $defined_all_ok=&check_if_defined($source_DB_file, $input_seq_file);
				 unless($defined_all_ok){
						 print "\n# (Q) $source_DB_file $input_seq_file Did you want to do self self search? ->(y/n) ";
						 $answer_for_self_self=<STDIN>;
						 if($answer_for_self_self =~/y/i){
								 if($input_file_name){  $sequence_DB=$input_file_name }
								 else{ $input_file_name=$sequence_DB };
								 close(STDIN);
						 }else{
								 print "\n# (E) You seemed made a mistake, O.K., I will kill myself!\n\n";
								 print chr(7);  die;
						 }
				 }
				 print "\n# (i) \$source_DB_file is $source_DB_file, \$input_seq_file is $input_seq_file\n";
		 }

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 # Check if formatdb has to be been run
		 #_______________________________________________________________
		 $blast_db_phr_file="$source_DB_file\.phr";
		 $blast_db_pin_file="$source_DB_file\.pin";
		 $blast_db_psq_file="$source_DB_file\.psq";
		 if( -s $blast_db_phr_file and -s $source_DB_file and -s $source_DB_file ){
		 }else{
				 print "<hr> NO $blast_db_phr_file or $blast_db_pin_file or $blast_db_psq_file  file, dying<hr>";
				 print "You can make the missing file(s) by \"formatdb\" in ./Bin directory <br>";
				 die;
		 }

		$base=${&get_base_names(\$source_DB_file)};
		$seq_name=${&get_base_names(\$input_seq_file)};

		my(%mspa_format_from_bla, $first_char);
		my $temp_file_name=$input_seq_file;
		my $out_pbla_file="./Results/$seq_name\.pbla";
		my $out_mspa_file="./Results/$seq_name\.msp";

		if(-s "./Bin/blastpgp"){
				system("./Bin/blastpgp -d $source_DB_file -i $temp_file_name -j $iter_opt -e $Eval_limit -h $step_e_opt -b 2500 -v 1000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $out_pbla_file ");
		}elsif(-s "/usr/local/bin/blastpgp"){
				system("/usr/local/bin/blastpgp -d $source_DB_file -i $temp_file_name -j $iter_opt -e $Eval_limit -h $step_e_opt -b 2500 -v 1000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $out_pbla_file ");
		}elsif(-s "/local/bin/blastpgp"){
				system("/local/bin/blastpgp  -d $source_DB_file -i $temp_file_name -j $iter_opt -e $Eval_limit -h $step_e_opt  -b 2500 -v 1000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $out_pbla_file");
		}else{
		    print "<br> Can not run blastpgp, something is wrong, check ./Bin directory  etc<br>";
		    die;
		}
		$Lean_output='L';
		%mspa_format_from_bla=%{&convert_bla_to_msp($out_pbla_file, $Lean_output, $Accumulate_matches)};
		push(@final_mspa_out, \%mspa_format_from_bla);
		unlink($out_pbla_file);
		@seq_name=keys %mspa_format_from_bla;
		open(MSP, ">$out_mspa_file");
		for($i=0; $i< @seq_name; $i++){
		   print MSP "$mspa_format_from_bla{$seq_name[$i]}";
		}
		close(MSP);
		system("gzip $out_mspa_file &");
		return(\@final_mspa_out);
} # do_psi_blast_search_PDB_ISL




#______________________________________________________________________________
# Title     : do_psi_blast_search_ISS
# Usage     : &do_psi_blast_search(\@files, "d=$source_DB_file",
#                     "i=$input_seq_file",
#                     $over_write,
#                     $make_mspa_in_sub_dir_opt);
# Function  :
# Example   :
# Keywords  :
# Options   :
#    $source_DB_file=           by d= s=
#    $input_seq_file=           by i=
#    $Eval_limit=               by E=
#    $iter_opt=          by j=
#    $step_e_opt=              by h= e=
#    $over_write=o              by o
#    $make_mspa_in_sub_dir_opt=D by D
#    $Lean_output=L             by L -L
#    $put_NO_gaps=G             by G
#    $alignment_opt=            by m=
#    $make_MSP_files=M          by M
# Author    :
# Version   : 2.3
#------------------------------------------------------------------------------
sub do_psi_blast_search_ISS{
		my($i, @final_mspa_out, $iter_opt, $alignment_opt,  $source_DB_file,
			 $input_seq_file, $over_write, @in,
			 $step_e_opt, $Eval_limit, %seq_input, $base, @seq_names, $final_out_pbla_file,
			 $make_mspa_in_sub_dir_opt, $sub_dir_size, $answer_for_self_self,
			 $defined_all_ok, $ENV_BLASTDB_var, $Lean_output, $put_NO_gaps,
			 $open_gap_penalty, $extension_gap_penalty, $make_MSP_files);

		my $blast_env_var='BLASTDB';
		$USER_HOME_DIR=$ENV{'HOME'};
		if(! -s ".ncbirc"){ 		   open(NCBIRC, ">.ncbirc");
		   print "[NCBI]\n";		   print "         Data=./NCBI_Data\n";		   close(NCBIRC);
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Default parameters for blastpgp
		#_____________________________________________
		$Eval_limit=100;
		$alignment_opt=0; # default is 0, This is for -m option (0-6). 6 is used for Jason's output
		$iter_opt=3;
		$step_e_opt=0.001;
		$extension_gap_penalty=1;
		$open_gap_penalty=10;
		$gap_trigger_val=22.0; # default
		$Accumulate_matches='A';

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	  # getting options
		#________________________________________________________
		@in=@_;
		for($i=0; $i< @in; $i++){
			  if($in[$i]=~/d=(\S+)/){ $source_DB_file =$1 };
				if($in[$i]=~/i=(\S+)/){ $input_seq_file =$1 };
				if($in[$i]=~/E=(\S+)/){ $Eval_limit     =$1 };
				if($in[$i]=~/e=(\S+)/){ $step_e_opt    =$1 };
				if($in[$i]=~/j=(\S+)/){ $iter_opt=$1 };
		}

		if(! $source_DB_file or ! $input_seq_file){
				 print "\n# (Warn) You did not set d= and i= options for DB and Inquiry, I set automatically\n";
				 $source_DB_file=${&get_largest_file(@file)};
				 $input_seq_file=${&get_smallest_file(@file)};

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
				 # If one of the files is missing, ask if it is for self self search and
				 #  make query=target, else die
				 #_______________________________________________________________________
				 $defined_all_ok=&check_if_defined($source_DB_file, $input_seq_file);
				 unless($defined_all_ok){
						 print "\n# (Q) $source_DB_file $input_seq_file Did you want to do self self search? ->(y/n) ";
						 $answer_for_self_self=<STDIN>;
						 if($answer_for_self_self =~/y/i){
								 if($input_file_name){  $sequence_DB=$input_file_name }
								 else{ $input_file_name=$sequence_DB };
								 close(STDIN);
						 }else{
								 print "\n# (E) You seemed made a mistake, O.K., I will kill myself!\n\n";
								 print chr(7);  die;
						 }
				 }
				 print "\n# (i) \$source_DB_file is $source_DB_file, \$input_seq_file is $input_seq_file\n";
		 }

		 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 # Check if formatdb has to be been run
		 #_______________________________________________________________
		 $blast_db_phr_file="$source_DB_file\.phr";
		 $blast_db_pin_file="$source_DB_file\.pin";
		 $blast_db_psq_file="$source_DB_file\.psq";
		 if( -s $blast_db_phr_file and -s $source_DB_file and -s $source_DB_file ){
		 }else{
				 print "<hr> NO $blast_db_phr_file or $blast_db_pin_file or $blast_db_psq_file  file, dying<hr>";
				 print "You can make the missing file(s) by \"formatdb\" in ./Bin directory <br>";
				 die;
		 }

		$base=${&get_base_names(\$source_DB_file)};
		$seq_name=${&get_base_names(\$input_seq_file)};

		my(%mspa_format_from_bla, $first_char);
		my $temp_file_name=$input_seq_file;
		my $out_pbla_file="./Results/$seq_name\.pbla";
		my $out_mspa_file="./Results/$seq_name\.msp";

		if(-s "./Bin/blastpgp"){
				system("./Bin/blastpgp -d $source_DB_file -i $temp_file_name -j $iter_opt -e $Eval_limit -h $step_e_opt -b 15000 -v 15000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $out_pbla_file ");
		}elsif(-s "/usr/local/bin/blastpgp"){
				system("/usr/local/bin/blastpgp -d $source_DB_file -i $temp_file_name -j $iter_opt -e $Eval_limit -h $step_e_opt -b 15000 -v 15000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $out_pbla_file ");
		}elsif(-s "/local/bin/blastpgp"){
				system("/local/bin/blastpgp  -d $source_DB_file -i $temp_file_name -j $iter_opt -e $Eval_limit -h $step_e_opt  -b 15000 -v 15000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $out_pbla_file");
		}else{
		    print "<br> Can not run blastpgp, something is wrong, check ./Bin directory  etc<br>";
		    die;
		}
		$Lean_output='L';
		%mspa_format_from_bla=%{&convert_bla_to_msp($out_pbla_file, $Lean_output, $Accumulate_matches)};
		push(@final_mspa_out, \%mspa_format_from_bla);
		unlink($out_pbla_file);
		@seq_name=keys %mspa_format_from_bla;
		open(MSP, ">$out_mspa_file");
		for($i=0; $i< @seq_name; $i++){
		   print MSP "$mspa_format_from_bla{$seq_name[$i]}";
		}
		close(MSP);
		system("gzip $out_mspa_file &");
		return(\@final_mspa_out);
} # do_psi_blast_search_ISS


#________________________________________________________________________________
# Title     : do_net_psi_blast_search
# Usage     : &do_net_psi_blast_search(\%NetBioVariables);
# Function  :
# Example   :
#             %NetBioVariables=('USER',     'JONG',
#									'SEQUENCE', 'ASDFASDFASDFASDFASASDF',
#									'SEQ_NAME', 'TEST1');
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Version   : 1.0
#--------------------------------------------------------------------------------
sub do_net_psi_blast_search{

		my($PROGRAM, $DATALIB, $gappedAlignmentOption, $INPUT_TYPE, $SEQUENCE,
			 $EXPECT, $FILTER, $DESCRIPTIONS, $ALIGNMENTS, $graphicalOverviewOption,
			 $GENETICS_CODE, $OTHER_ADVANCED, $i, $j, %NetBioVariables,
			 @Search_result, $E_THRESH, $local_hostname, $target_server_IP,
			 $step_number);
		my $blastServerURL = $blastServerURLdefault   ='www.ncbi.nlm.nih.gov/cgi-bin/BLAST/nph-newblast';
		my $psi_blastServer_URL=$blastServerURLdefault='www.ncbi.nlm.nih.gov/cgi-bin/BLAST/nph-psi_blast';


		$local_hostname='cyrah.med.harvard.edu';
		$target_server_IP='www.ncbi.nlm.nih.gov';

		%NetBioVariables=%{$_[0]};
		$algorithm='PSI_BLAST';
		$step_number=1;
		$step_limit =2;

		$user_dir_name=$NetBioVariables{USER};
		$seq_dir_name="$NetBioVariables{USER}\/$NetBioVariables{SEQ_NAME}";
		mkdir($user_dir_name, 0777) unless -d $user_dir_name;
		mkdir($seq_dir_name, 0777)  unless -d $seq_dir_name;
		$result_file_name="$seq_dir_name\/$NetBioVariables{SEQ_NAME}\.html";

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# I write the seq. fasta file at ~/Proj/Bio/NetBioServ/Jong/, while Jong is the user name
		#______________________________________________________________________________________________________
		open(FASTA_SEQ_FILE, ">$seq_dir_name\.spfa") || die "\n Can not open $seq_dir_name\.spfa \n";
		print FASTA_SEQ_FILE "\>$NetBioVariables{\"SEQ_NAME\"}\n$NetBioVariables{\"SEQUENCE\"}";
		close(FASTA_SEQ_FILE);

		%parameter_keys_and_values=(
				'PROGRAM'=>'blastp', ## even PSI-blast uses 'blastp' not 'blastpgp' !!
				'DATALIB'=>'nr',
				'E_THRESH'=>0.0001,   # for PSI blast
				'STEP_NUMBER'=>$step_number,     # for PSI blast
				'INPUT_TYPE'=>"sequence in fasta format",
				'GAPPED_ALIGNMENT'=>'is_set',
				'SEQUENCE'=>"$NetBioVariables{SEQUENCE}",
				'EXPECT'=>1,
				'FILTER'=>'default',
				'DESCRIPTIONS'=>100,
				'ALIGNMENTS'=>100,
				'OVERVIEW'=>'is_set',
				'GENETICS_CODE'=>1,
				'OTHER_ADVANCED'=>'',
				'HTML'=>'',
				'MAXLENGTH'=>10,
				'local_hostname'=>'cyrah.med.harvard.edu',
				'target_server_IP'=>'www.ncbi.nlm.nih.gov',
				'file_handle'=>'SOCKET_FOR_POST',
				'port'=>80,
				'resultTypeOption'=>''); ## $resultTypeOption'="HTML=is_set";

		$URI_content=${&generate_URI_content_line(\%parameter_keys_and_values)};
		$URI_length=length($URI_content);

		ITERATION_POINT:

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# Opening the NET connection
		#_____________________________________________________
		$SOCKET_FILEHANDLE=${&open_socket("H=$local_hostname", "S=$target_server_IP", "FH=$file_handle", "P=$port")};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Build the HTTP POST object.  Actual Writing part
		#___________________________________________________________
		if($algorithm eq 'PSI_BLAST'){
		    if($step_number > 1){
						$blast_path='/cgi-bin/BLAST/nph-psi_blast/'."step${step_number}";
						$parameter_keys_and_values{'NEXT_I'}="\"Run PSI-Blast iteration $step_number\"";
		    }else{
						$blast_path='/cgi-bin/BLAST/nph-psi_blast/';
		    }
		}else{   $blast_path='/cgi-bin/BLAST/nph-newblast'; }

		&write_to_www_socket_filehandle($SOCKET_FILEHANDLE, $blast_path, $URI_length, $URI_content);

		$response = <$SOCKET_FILEHANDLE>;
		print "\n The response from the server:=> $response\n";

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# I write the search result file at ~/Proj/Bio/NetBioServ/Jong/128U_DROME_Jong, while Jong is the user name
		#______________________________________________________________________________________________________
		open(RESULT, ">$result_file_name") || die "\n Can not open $result_file_name\n\n";

		@Search_result = (<$SOCKET_FILEHANDLE>); ## <-- this works, but not <"$SOCKET_FILEHANDLE">

		for($i=0; $i< @Search_result; $i++){

			 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 # Adding  http:\/\/$target_server_IP to /htbin-post/Entrez/query?f etc
			 #____________________________________________________________________________
			 $Search_result[$i]=~s/ACTION=\"\/cgi-bin/ACTION=\"http:\/\/$target_server_IP\/cgi-bin/g;
			 $Search_result[$i]=~s/href=\"\/htbin-post\//href=\"http:\/\/$target_server_IP\/htbin-post\//g;
			 $Search_result[$i]=~s/\<IMG SRC=\"\S+.gif\" [^\>]+\>//ig;  ## removing Image links <IMG SRC="/BLAST/psi_blast.gif" BORDER=0 ISMAP></A>
			 print $Search_result[$i];
			 print RESULT $Search_result[$i];
			 if($Search_result[$i]=~/\<INPUT TYPE=\"hidden\" NAME= \"(\S)\" VALUE="(\S+)"\>/){
					 $param_keys_and_values{$1}=$2;
			 }
		}
		$URI_content=${&generate_URI_content_line(\%parameter_keys_and_values)};
		$URI_length=length($URI_content);
		close(RESULT);
		if($step_number >= $step_limit){ goto EXIT;
		}else{
			 $step_number++;
			 $parameter_keys_and_values{'STEP_NUMBER'}=$step_number;
			 &show_hash(\%parameter_keys_and_values);
			 goto ITERATION_POINT;
		}

		EXIT:

}


#______________________________________________________________________________
# Title     : do_psi_blast_search
# Usage     : &do_psi_blast_search(\@files, "d=$source_DB_file",
#                     "i=$input_seq_file",
#                     $over_write,
#                     $make_mspa_in_sub_dir_opt);
# Function  :
# Example   :
# Keywords  :
# Options   :
#    $source_DB_file=           by d= s=
#    $input_seq_file=           by i=
#    $Eval_limit=               by E=
#    $PSI_BLA_iter_limit=          by j=
#    $PSI_BLA_step_eval=              by h= e=
#    $over_write=o              by o
#    $make_mspa_in_sub_dir_opt=D by D
#    $Lean_output=L             by L -L
#    $put_NO_gaps=G             by G
#    $alignment_opt=            by m=
#    $make_MSP_files=M          by M
#    $take_last_iter_PSI_BLA    by l
# Author    :
# Version   : 2.6
#------------------------------------------------------------------------------
sub do_psi_blast_search{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    $|=1;
    my(@final_mspa_out, $PSI_BLA_iter_limit, $alignment_opt,  $source_DB_file,
         $input_seq_file, $over_write,
         $PSI_BLA_step_eval, $Eval_limit, %seq_input, $base, @seq_names, $final_out_pbla_file,
         $make_mspa_in_sub_dir_opt, $sub_dir_size, $answer_for_self_self,
         $defined_all_ok, $ENV_BLASTDB_var, $Lean_output, $put_NO_gaps,
         $open_gap_penalty, $extension_gap_penalty, $make_MSP_files,
         $take_last_iter_PSI_BLA, $Accumulate_matches);

    my $blast_env_var='BLASTDB';
    $USER_HOME_DIR=$ENV{'HOME'};
    if(! -s ".ncbirc"){ &cp("$USER_HOME_DIR\/.ncbirc", ".ncbirc"); } ## Copying the problematic .ncbirc file

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Default parameters for blastpgp
    #_____________________________________________
    $PSI_BLA_ACCUMU_hits_eval_thresh=0.00001; ## for PSI blast
    $Accumulate_matches='';
    $Eval_limit=10;
    $alignment_opt=0;    # default is 0, This is for -m option (0-6). 6 is used for Jason's output
    $PSI_BLA_iter_limit=5;  # 7 is the default! arbitrary
    $PSI_BLA_step_eval=0.001;
    $sub_dir_size  =2;  # the default char number taken from seq name to make sub dirs
    $extension_gap_penalty=1;
    $open_gap_penalty=10;
    $gap_trigger_val=22.0; # default
    $make_mspa_in_sub_dir_opt='D';

    if($ENV{'BLASTDB'}=~/^ *$/){
         print "\n# (i) Your ENV variable setting  \"BLASTDB\" is not set\n";
         print "\n# (i) BLASTDB is for the directory for various blast DBs\n";
         print "\n# (i) You can set it by \"export BLASTDB=/your/dir/for/db\" in bash shell\n";
         print "\n# (i) or \"set BLASTDB /your/dir/for/db\" in cshell or in .bashrc or .cshrc file\n";
         print "\n# (i) Do you want to set the directory path right NOW?(y/n)\n";
         $answer_for_blastenv=getc;
         if($answer_for_blastenv=~/^y/i){
                 &ask_for_ENV_vars($blast_env_var);
                 print "\n# (Warn) You need to source your .bashrc or .cshrc file to activate the ENV var\n";
         }elsif($answer_for_blastenv=~/^n/i){
                 print "\n# (i) I hope it is O.K., to run Blast without BLASTDB env var\n";
         }else{  print "\n# (ERROR) You pressed none of y or n, I am exiting \n";
                 die;
         }
    }elsif($ENV{'BLASTDB'}=~/\S/){
         print "\n# (i) $blast_env_var is set to ", $ENV{'BLASTDB'}, "\n";
         $ENV_BLASTDB_var=$ENV{'BLASTDB'};
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # getting options
    #________________________________________________________
    if($vars{'d'}){    $source_DB_file =$vars{'d'} };
    if(-s $vars{'i'}){ $input_seq_file =$vars{'i'} };
    if($vars{'E'}){    $Eval_limit     =$vars{'E'} };
    if($vars{'j'}){    $PSI_BLA_iter_limit=$vars{'j'} };
    if($vars{'e'}=~/(\S+)/ or $vars{'h'}=~/(\S+)/){ $PSI_BLA_step_eval=$1 };
    if($vars{'m'}=~/(\S+)/){ $alignment_opt=$1 };
    if($char_opt=~/o/){ $over_write='o' }
    if($char_opt=~/l/){ $take_last_iter_PSI_BLA= 'l'  } ## this is relevant to convert_bla_to_msp
    if($char_opt=~/D/){$make_mspa_in_sub_dir_opt= 'D' } ## You'd better set this as default
    if($char_opt=~/L/){    $Lean_output        = 'L' }
    if($char_opt=~/q/){    $make_MSP_files     = 'q' }
    if($char_opt=~/G/){    $put_NO_gaps        = 'G';
        $open_gap_penalty=12; $extension_gap_penalty=1;
        $blast_g_option='F';
        $Eval_limit=3000;
        $PSI_BLA_iter_limit=3;
        $PSI_BLA_step_eval=30;
        $gap_trigger_val=22.0; # default is 22.0 , -N option
    }


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Assign DB file and query FASTA file (if not given)
    #_________________________________________________________
    if(! $source_DB_file and ! $input_seq_file){
        print "\n# (Warn) You did not set d= and i= options for DB and Inquiry, I set automatically\n";
        $source_DB_file=${&get_largest_file(@file)};
        $input_seq_file=${&get_smallest_file(@file)};

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~```
        # If one of the files is missing, ask if it is for self self search and
        #  make query=target, else die
        #_______________________________________________________________________
        $defined_all_ok=&check_if_defined($source_DB_file, $input_seq_file);
        unless($defined_all_ok){
                print "\n# (Q) $source_DB_file $input_seq_file Did you want to do self self search? ->(y/n) ";
                $answer_for_self_self=<STDIN>;
                if($answer_for_self_self =~/y/i){
                        if($input_file_name){  $sequence_DB=$input_file_name }
                        else{ $input_file_name=$sequence_DB };
                        close(STDIN);
                }else{
                        print "\n# (E) You seemed made a mistake, O.K., I will kill myself!\n\n";
                        print chr(7);  die;
                }
        }
        print "\n# (i) \$source_DB_file is $source_DB_file, \$input_seq_file is $input_seq_file\n";
    }else{
        print "\n# (i) I have \$input_seq_file : $input_seq_file, \$source_DB_file : $source_DB_file\n";
        print "\n# (i) $0 uses \"gzip\" program, just warning :-) \n";
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Check if formatdb has to be been run. If not, Let's run it!
    #_______________________________________________________________
    $blast_db_phr_file="$source_DB_file\.phr";
    $blast_db_pin_file="$source_DB_file\.pin";
    $blast_db_psq_file="$source_DB_file\.psq";
    unless(-s $blast_db_phr_file and -s $blast_db_pin_file and -s $blast_db_psq_file ){
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
        # Checking in the ENV BLASTDB for xxxx.phr, xxx.pin, xxxx.psq
        #_____________________________________________________
        unless( -s "$ENV_BLASTDB_var\/$blast_db_phr_file" and
                -s "$ENV_BLASTDB_var\/$blast_db_pin_file" and
                -s "$ENV_BLASTDB_var\/$blast_db_psq_file"){
           if(&find_program_in_path("formatdb")){
                   system("formatdb -t $source_DB_file -i $source_DB_file");
           }else{
                print "\n# (E) I am trying to run formatdb to make blastdb, but can not find it\n";
                print "\n# (E) Without running formatdb over seq DB, you can not run psi-blast\n";
                die;
           }
        }else{
               print "\n# (i) do_psi_blast_search: I found ENV BLASTDB ($ENV_BLASTDB_var) set";
        }
    }

     $base=${&get_base_names(\$source_DB_file)};

     %seq_input=%{&open_fasta_files(\$input_seq_file)};

     @seq_names= keys %seq_input;
     @seq_names= @{&scramble_array(\@seq_names)};

     print "\n# (i) Number of sequences to search is: ", scalar(@seq_names), " \n";

    for($i=0; $i< @seq_names; $i++){
         my(%mspa_format_from_bla, $first_char, $seq_name, $temp_file_name, $out_pbla_file,
            $out_mspa_file, $gzipped_pbla);
         $seq_name=$seq_names[$i];
         print "\n# (i) $seq_name is being processed, please wait";
         $temp_file_name="$seq_name\.fasta";
         $out_pbla_file="$seq_name\.pbla";
         $out_mspa_file="$seq_name\.msp";
         $gzipped_pbla="$out_pbla_file\.gz";
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If D option is set
         #____________________________________________
         if($make_mspa_in_sub_dir_opt){
             $first_char= substr("\U$seq_name", 0, $sub_dir_size);
             unless(-d $first_char){
                 mkdir ("$first_char", 0777);
                 print "\n# (i) do_psi_blast_search: You set \'d\' or \'D\' opt\n";
                 print "# (i) making subDIRs ($first_char) with $seq_name $sequence_DB to store MSP files\n";
             }
         }
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # Let's make each fasta file for each seq to be used in searching
         #_____________________________________________________________________
         %single_seq=($seq_name, $seq_input{$seq_name});
         &write_fasta(\%single_seq, $temp_file_name ); ## e for writing each file

         if( !(-s $out_pbla_file) or $over_write){
             if($make_mspa_in_sub_dir_opt){  $final_out_pbla_file="$first_char/$out_pbla_file";
             }else{                         $final_out_pbla_file="$out_pbla_file";   }
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # This is the actual running part for Blastpgp
             #________________________________________________________________
             print "\n#  (i) Running Blast with j=$PSI_BLA_iter_limit, h=$PSI_BLA_step_eval";
             if(-s "./Bin/blastpgp"){
                 system("/Bin/blastpgp -d $source_DB_file -i $temp_file_name -j $PSI_BLA_iter_limit -e $Eval_limit -h $PSI_BLA_step_eval -b 15000 -v 15000 -o $final_out_pbla_file");
             }elsif(&find_program_in_path("blastpgp")){
                 print "\n#  (i) Running blastpgp in PATH: -h $PSI_BLA_step_eval -j $PSI_BLA_iter_limit -g $blast_g_option -N $gap_trigger_val -G $open_gap_penalty -m $alignment_opt -E $extension_gap_penalty \n";
                 if($put_NO_gaps){
                     print "\n# (i) Putting NO gaps !!!!!";
                     system("blastpgp -d $source_DB_file -i $temp_file_name -j $PSI_BLA_iter_limit -e $Eval_limit -h $PSI_BLA_step_eval -b 15000 -v 15000 -G $open_gap_penalty -N $gap_trigger_val -m $alignment_opt -o $final_out_pbla_file ");
                 }else{
                     system("blastpgp -d $source_DB_file -i $temp_file_name -j $PSI_BLA_iter_limit -e $Eval_limit -h $PSI_BLA_step_eval -b 15000 -v 15000 -N $gap_trigger_val -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $final_out_pbla_file ");
                 }
             }elsif(-s "/usr/local/bin/blastpgp"){
                 system("/usr/local/bin/blastpgp -d $source_DB_file -i $temp_file_name -j $PSI_BLA_iter_limit -e $Eval_limit -h $PSI_BLA_step_eval -g $blast_g_option -b 15000 -v 15000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $final_out_pbla_file ");
             }elsif(-s "/local/bin/blastpgp"){
                 system("/local/bin/blastpgp  -d $source_DB_file -i $temp_file_name -j $PSI_BLA_iter_limit -e $Eval_limit -h $PSI_BLA_step_eval -g $blast_g_option -b 15000 -v 15000 -G $open_gap_penalty -E $extension_gap_penalty -m $alignment_opt -o $final_out_pbla_file");
             }else{
                 print "\n# Error, do_psi_blast_search in $0 can not find \"blastpgp\" (psi-blast) in PATH, dying\n\a\n"; die;
             }

             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
             # Going into SUB directory if 'D' is set and Writing MSP
             #________________________________________________________
             if($make_mspa_in_sub_dir_opt){  chdir("$first_char");    }
             #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
             # Converting PBLA to MSP file format, for each run (for geanfammer each conversion is O.K.
             #___________________________________________________________________________________________________
             if($make_MSP_files){
                 print "#  (i) Writing MSP file with $seq_name $out_pbla_file, $Lean_output, $take_last_iter_PSI_BLA\n";
                 %mspa_format_from_bla=%{&convert_bla_to_msp(\$out_pbla_file,
                                                            $Lean_output,
                                                            $take_last_iter_PSI_BLA,
                                                            "i=$PSI_BLA_iter_limit",
                                                            "SEQ_NAME=$seq_name",
                                                            "e=$PSI_BLA_ACCUMU_hits_eval_thresh",
                                                            "E=$Eval_limit",
                                                            $report_only_the_best,
                                                            $Accumulate_matches,
                                                            $verbose
                                                            )};
                 &write_mspa_files(\%mspa_format_from_bla, $out_mspa_file);
                 push(@final_mspa_out, $out_mspa_file);
             }
             &compress_files_by_gzip($out_pbla_file) unless $Lean_output;
             if($make_mspa_in_sub_dir_opt){  chdir('..');  }
         }else{
             print "\n# (Warn) It seems $out_pbla_file or $gzipped_pbla is already present, skipping psi run\n";
         }
         unlink($temp_file_name) if $cleanup_dir;
    }
    return(\@final_mspa_out);
} # do_psi_blast_search





#______________________________________________________________________________
# Title     : merge_superfam_fasta_files_for_ISL
# Usage     : &merge_superfam_fasta_files_for_ISL;
# Function  :
# Example   :
# Keywords  : compile_superfam_fasta_files_for_ISL
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub merge_superfam_fasta_files_for_ISL{
		my($j, $i, @files);
		@files=@{&read_file_names_only('.', 'fasta')};
		print "\n# (INFO) Making compiled_interm_lib.fasta, this takes several minutes\n";
		open(COMPILED, ">compiled_interm_lib.fasta");

		for($j=0; $j< @files; $j++){
			 unless($files[$j]=~/\d+\.\d+\.\d+\.fasta/){
					 next;
			 }
			 my $base=${&get_base_names($files[$j])};
			 my ($seq_name);
			 open(SUPER, "$files[$j]");
			 while(<SUPER>){
					 if(/\>(\S+)/){
							 $seq_name="\>$1_$base";
							 print COMPILED $seq_name, "\n";
					 }elsif(/^(\w+)$/){
							 print COMPILED $1, "\n";
					 }
			 }
			 close SUPER;
		}
		print "\n# (INFO) merge_superfam_fasta_files_for_ISL: compiled_interm_lib.fasta has been created. \n";
		return( \"compiled_interm_lib.fasta");
}

#______________________________________________________________________________
# Title     : get_total_memory_size_in_linux
# Usage     : $mem=${&get_total_memory_size_in_linux};
# Function  :
# Example   : The /proc/meminfo file looks like this:>>>>
#           total:    used:    free:  shared: buffers:  cached:
#   Mem:  395735040 233975808 161759232 65953792 111476736 41345024
#   Swap:  7319552   147456  7172096
#   MemTotal:    386460 kB
#   MemFree:     157968 kB
#   MemShared:    64408 kB
#   Buffers:     108864 kB
#   Cached:       40376 kB
#   SwapTotal:     7148 kB
#   SwapFree:      7004 kB
#
# Keywords  : get_memory_size_in_linux, get_mem_size, check_memory_size
#             get_system_memory_size
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub get_total_memory_size_in_linux{
    my($total_memory_size);
    open(MEMORY,"</proc/meminfo") || die "Something is very wrong, can't get memory size\n";
    while (<MEMORY>){
         if(/MemTotal:\s+(\S+)\s+kB/i){
                $total_memory_size=$1;
         }
    }
    close(MEM);
    return(\$total_memory_size);
}

#______________________________________________________________________________
# Title     : check_file_exists_in_path
# Usage     : $exist=&check_file_exists_in_path("hmmbuild");
# Function  : checks if file exists in UNIX path
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  : File
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_file_exists_in_path{
		my($i, @path_dirs, $the_query_program_exists, $query_program);
		$query_program=$_[0];
		@path_dirs=split(/\:/, $ENV{'PATH'});
		for($i=0; $i<@path_dirs; $i++){
				if(-s "$path_dirs[$i]\/$query_program"){
						$the_query_program_exists=1;
						last;
				}
		}
		return($the_query_program_exists);
}

#______________________________________________________________________________
# Title     : compress_files_by_gzip
# Usage     : &compress_files_by_gzip('file_name_to_be_compressed');
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.3
#------------------------------------------------------------------------------
sub compress_files_by_gzip{
		my($file, $input_file_name, @final_output_file_names, $out_file_gz_name);
		for $file(@_){
			 if(ref($file) eq 'SCALAR'){
					 $file=${$file};
			 }
			 $out_file_gz_name="$file\.gz";
			 if(-s $out_file_gz_name){
					 unlink ($out_file_gz_name); # remove existing $out_file_gz_name
			 }
			 if(@{&find_program_in_path('gzip')} > 0){
					 system("gzip $file"); ## gzipping it
			 }else{
					 print "\n# (ERROR) gzip is not found here. Please put gzip compressing program in exe path\n";
					 print "\n# (INFO) No compression will be made by gzip \n\n";
			 }
			 push( @final_output_file_names, $out_file_gz_name) if -s $out_file_gz_name;
			 if(@final_output_file_names < 1){ print "\n# (ERROR) No gz files were written, Error??\n"; }
		}
		if(@final_output_file_names> 1){ return(\@final_output_file_names);
		}else{  return(\$final_output_file_names[0]);   }
}

#______________________________________________________________________________
# Title     : check_if_palindrome
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_if_palindrome{
		my $string=${$_[0]} || $_[0];
		$str_leng=length($string);
		$str_2 = $string ^ reverse($string); # ^ bitwise operator checks identity in the identical position
		$occur= $str_2 =~ tr/\000/:/;
		#print $occur, " $string\n" if $occur > 3;
		if($occur/$str_leng >= 0.999999999){
			 return($string);
		}else{
			 return('');
		}
}


#______________________________________________________________________________
# Title     : check_if_it_is_for_Tk
# Usage     :
# Function  : check input arguments to see if the whole program is in Tk env.
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_if_it_is_for_Tk{
		my (@hash_arg_input, @arg_input, $j, $i, $use_Tk);
		for($i=0; $i< @_; $i++){
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (1) When it is passed as REF.
				#____________________________________
				if(ref($_[$i]) eq 'HASH'){
						@hash_arg_input=%{$_[$i]};
						for($j=0; $j<@hash_arg_input; $j++){
								if($hash_arg_input[$j]=~/(TkValue|label2|Configure|scrollbar|checkbutton|frame|Palette)/){
										$use_Tk='Tk';
								}
						}
				}elsif(ref($_[$i]) eq 'SCALAR'){
						$arg_input=${$_[$i]};
						if($arg_input=~/^Tk$/i){
								$use_Tk='Tk';
						}
				}elsif(ref($_[$i]) eq 'ARRAY'){
						@arg_input=@{$_[$i]};
						for($j=0; $j< @arg_input; $j++){
								if($arg_input[$j]=~/^Tk$/i){
										$use_Tk='Tk';
								}
						}
				}
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (2) When it is not passed as REF.
				#____________________________________
				elsif(!ref($_[$i])){
						if($_[$i]=~/^Tk$/i){
								 $use_Tk='Tk';
						}
				}
		}
		return(\$use_Tk);
}

#______________________________________________________________________________
# Title     : check_if_sec_str_form_hash
# Usage     : $check_sec_str_form_hash=${&check_if_sec_str_form_hash(\%sec)};
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_if_sec_str_form_hash{
		my ($check_sec_str_form_hash);
		my %hash_to_be_checked=%{$_[0]};
		if($hash_to_be_checked{0}->[0]=~/^\S$/){
			 $check_sec_str_form_hash=1;
		}
		return(\$check_sec_str_form_hash);
}

#______________________________________________________________________________
# Title     : check_if_defined
# Usage     : $defined=&check_if_defined($var, $file);
# Function  : checks if all the args are defined
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_if_defined{
		my($i, $input_arg_count);
		for($i=0; $i< @_; $i++){
			 $input_arg_count++;
			 if(-s $_[$i]){
					print "\n# (INFO) check_if_defined: $input_arg_count does not exist as a file in PWD\n";
			 }elsif(! $_[$i]){
					print "\n# (INFO) check_if_defined: $input_arg_count is not defined\n";
					return(0);
			 }
		}
		return(1);
}

#______________________________________________________________________________
# Title     : check_if_files_exist
# Usage     : $defined=&complain_if_not_defined($var, $file);
# Function  : checks if all the args are defined
# Example   :
# Keywords  : check_if_exists, check_if_file_exist
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub check_if_files_exist{
		my($i, $input_arg_count, $input_file);
		for($i=0; $i< @_; $i++){
			 $input_arg_count++;
			 $input_file=$_[$i] or ${$_[$i]};
			 if(-s $input_file){
					print "\n# (i) check_if_files_exist: $input_arg_count exists as a file in PWD\n";
					return($input_file);
			 }elsif(! $input_file){
					print "\n# (i) check_if_files_exist: $input_file is not defined\n";
					return(0);
			 }
		}
		return(1);
}

#______________________________________________________________________________
# Title     : check_if_multiple_sequence_file
# Usage     :
# Function  : checks if all the args are defined
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub check_if_multiple_sequence_file{
		my $input_seq_file=$_[0] or ${$_[0]};
		my ($seq_name_counter,$final_output_digit );
		unless(&check_if_files_exist($input_seq_file)){ print "\n Dying ";die }
		$file_size=(-s $input_seq_file);
		open(INPUT_SEQ_FILE, "$input_seq_file") or die "\n Can't open $input_seq_file";
		while(<INPUT_SEQ_FILE>){
			 if(/^ *\>\S+/){
					$seq_name_counter++;
			 }
			 if($seq_name_counter > 1 and $file_size > 1000000){
					$final_output_digit=2;
					return(\$final_output_digit);
			 }else{
					$final_output_digit=$seq_name_counter;
			 }
		}
		close(INPUT_SEQ_FILE);
		return(\$final_output_digit);
}


#______________________________________________________________________________
# Title     : die_if_file_not_present
# Usage     : &die_if_file_not_present($var, $file);
# Function  : checks if all the args are present
# Example   :
# Keywords  : die_unless_present, die_unless_file_present
# Options   :
# Author    : jong@biosophy.org
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub die_if_file_not_present{
		my($i, $input_arg_count);
		for($i=0; $i< @_; $i++){
			 $input_arg_count++;
			 unless(-s $_[$i]){
					 print "\n# (i)die_if_file_not_present: ${input_arg_count}th exist as a file in PWD\n";
			 }
		}
}




#_____________________________________________________________________________
# Title     : ask_for_ENV_vars
# Usage     : &ask_for_ENV_vars('BLAST_DIR');
# Function  : asks for env var and write the env var to appropriate shell
#             UNIX only RC file
# Example   :
# Keywords  : write_ENV_vars, write_env_vars
# Options   :
# Author    : jong@biosophy.org, On commercial use issue, Email me.
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub ask_for_ENV_vars{
		 #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		 my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		 my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		 my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		 my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		 my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		 if($debug==1){print "\n\t\@hash=\"@hash\"
		 \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		 \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		 #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		 my(@target_files, $answer_for_ENV_setting, $shell_rc_file, $shell_type,
				$home_dir);
		 $shell_type=${&get_unix_shell_name};

		 if($ENV{'HOME'}=~/\S/){
				print "\n# (INFO) Good, your OS/shell have set HOME env var\n";
				$home_dir=$ENV{'HOME'};
				if($home_dir=~/\/$/){ chop($home_dir) }
				$shell_rc_file="$home_dir\/\.$shell_type"."rc";
		 }else{
				print "\n# (ERROR) Bad, your OS/shell did not set HOME env var, I am dying\n";
				die;
		 }
		 for($i=0; $i< @raw_string; $i++){
				if($ENV{"$raw_string[$i]"}=~/^ */){
						print "\n# Please put the path or whatever for the ENV setting for $raw_string[$i]\n\>";
						$answer_for_ENV_setting=<STDIN>; close(STDIN);
						if(-d $answer_for_ENV_setting){
								print "\n# (INFO) You typed a directory name! I hope this is what you wanted\n";
						}elsif(-f $answer_for_ENV_setting){
								print "\n# (INFO) You put file name. I hope this is what you wanted\n";
						}else{
								print "\n# (INFO) You put something that is not dir nor file, O.K?\n";
						}
						if($shell_type=~/csh/){
								 $insertion_line_rc ="set $raw_string[$i] $answer_for_ENV_setting\n";
						}elsif($shell_type=~/bash/){
								 $insertion_line_rc ="export $raw_string[$i]\=$answer_for_ENV_setting\n";
						}
						&insert_lines_anywhere(\$shell_rc_file, $insertion_line_rc);
						&reset_shell_environment;
						print "\n# (INFO) Please source your .cshrc or .bashrc file\n";
						system("export $raw_string[$i]\=$answer_for_ENV_setting");
						push(@env_setting, $raw_string[$i]);
				}elsif($ENV{"$raw_string[$i]"}=~/\S/){
						print "\n# (INFO) $raw_string is already defined in ENV\n";
						print "\n# Do you want to overwrite the ENV setting with new one\n";
						$answer_for_overwrite=<STDIN>; close(STDIN);
						if($answer_for_overwrite=~/^ *y */i){
								print "\n# Please put the path or whatever for the ENV setting for $raw_string\n";
								$answer_for_ENV_setting=getc;
								if(-d $answer_for_ENV_setting){
										print "\n# (INFO) You typed a directory name! I hope this is what you wanted\n";
								}elsif(-f $answer_for_ENV_setting){
										print "\n# (INFO) You put file name. I hope this is what you wanted\n";
								}else{
										print "\n# (INFO) You put something that is not dir nor file, O.K?\n";
								}
								if($shell_type=~/csh/){
										 $insertion_line_rc ="set $raw_string[$i] $answer_for_ENV_setting\n";
								}elsif($shell_type=~/bash/){
										 $insertion_line_rc ="export $raw_string[$i]\=$answer_for_ENV_setting\n";
								}
								&insert_lines_anywhere(\$shell_rc_file, $insertion_line_rc);
								push(@env_setting, $raw_string[$i]);
								print "\n# (INFO) Please source your .cshrc or .bashrc file\n";
								&reset_shell_environment;
								system("export $raw_string[$i]\=$answer_for_ENV_setting");
						}else{
								next;
						}
				}
		 }
		 return(\@env_setting);
}

#______________________________________________________________________________
# Title     : reset_shell_environment
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org, On commercial use issue, Email me.
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub reset_shell_environment{
		my($shell_env);
		if($ENV{'SHELL'}=~/\/(\w+)$/ or $ENV{'SHELL'}=~/(\w+)$/){
				$shell_env=$1
		}else{
				print "\n# (ERROR) SHELL env setting is not on, I can not give you SHELL type\n";
				die;
		}
		if($shell_env=~/csh/){
				print "\n# (INFO) Sourcing CSH shell, .cshrc and .login files\n";
				system("source ~/.cshrc");
				system("source ~/.login");
		}elsif($shell_env=~/bash/){
				print "\n# (INFO) Sourcing BASH shell, .bashrc and .profile files\n";
				system("source ~/.profile");
				system("source ~/.bashrc");
		}else{  print "\n# (ERROR) Something is wrong \n"; print (chr(7)); }
}




#________________________________________________________________________________
# Title     : get_all_mspa_files
# Usage     : @msp_files=@{&get_all_msp_files};
# Function  : puts the names of all msp or msp.gz files in the directory and its subdirectories into an array
# Example   :
# Keywords  : read_msp_files, make_msp_file_array, get_all_msp_files_in_dir
# Date      : 19th September 1997
# Options   :
# Author    : Sarah A. Teichmann, jong@salt2.med.harvard.edu
# Version   : 1.5
#--------------------------------------------------------------------------------
sub get_all_mspa_files {
	 my (@MSPA_files_main_final);
	 my @MSPA_files_main=@{&read_file_names_only('.msp','.msp.gz')};
	 for(@MSPA_files_main){
			if($_=~/cluster\.msp/){ next ## xxxx_cluster.msp is the processed file
			}else{ push(@MSPA_files_main_final, $_) }
	 }
	 my @dirs=@{&read_dir_names_only('n', '.')};
	 my ($i, $j, @msp_files, $file_in_dir, $dir_file);
	 for ($i=0; $i<@dirs; $i++){
			 my $dir=$dirs[$i];
			 unless( -d $dir){
					next;
			 }
			 if( -d $dir){  chdir($dir);  }

			 @msp_files=@{&read_file_names_only('.','.msp','.msp.gz')};
			 for ($j=0; $j<@msp_files; $j++){
					if($msp_files[$j]=~/cluster\.msp/){ next } ## skipping already existing  20-1_cluster.msp like files
					$file_in_dir=$msp_files[$j];
					$dir_file="$dir"."/"."$file_in_dir";
					push(@msp_files_dirs, $dir_file);
					next;
			 }
			 chdir('..');
			 next;
	 }

	 @msp_files=sort (@MSPA_files_main_final, @msp_files_dirs);
	 return (\@msp_files);
}





#______________________________________________________________________________
# Title     : find_low_complexity_region
# Usage     :
# Function  :
# Example   :
# Keywords  : get_low_complexity_region, calc_low_complexity_region
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.1
#------------------------------------------------------------------------------
sub find_low_complexity_region{
	 	#"""""""""""""""""< handle_arguments{ head Ver 3.9 >"""""""""""""""""""
	my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
	my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
	my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
	my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
	my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
	if($debug==1){print "\n\t\@hash=\"@hash\"
	\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
	\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
	#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
	my $win_size=$win_size_ori=10;
	my $threshold=0.3;
	my $extend=1;
	my ($extension, $extended);
	if($char_opt=~/n$/i){ $extend=0; } ## when NO extension option is given
	for($i=0; $i < @hash; $i++){       ## extension option is to lengthen the
	   my %hash=%{$hash[$i]};          ## low complexity region
	   my @keys=keys %hash;
	   for($j=0; $j< @keys; $j++){
		  my $seq=$hash{$keys[$j]};
		  my @seq=split(//, $seq);
		  my $max_pos=@seq-$win_size;
		  for($k=0; $k < $max_pos; $k++){
		     my $end=$k+$win_size;
			 my @move=@seq[$k..$end];
			 my $complexity=${&get_sequence_complexity(\@move, 10)};
			 if($win_size==@seq){
				printf "\n%-10s %-4d %-${win_size}s", $keys[$j],$k, join('',@move);
			    last;
			 }
			 if($complexity <= $threshold){
				if($extend==1){
			        #""""" When complexity starts to increase, jump!
					#if((defined($old_complexity))&&($old_complexity < ($complexity - 0.15)) ){
	                #   print "\n \$old_complexity is $old_complexity \$complexity is $complexity \n";
					#   #printf "\n%-4d %-${win_size}s", $k, join('',@move);
				    #   @{$low_seg{$k}}=join('',@move);
					#   $k+=$win_size;
					#   $win_size=$win_size_ori;
				    #   $extended=0;
				    #   $extension=0;
					#   next;
					#}
					print "\n$k \$complexity is $complexity";
					$win_size++;
					$extension++;
					$k--;
					$extended=1;
					$old_complexity=$complexity;
					next;
				}elsif($extend !=1){

					printf "\n%-10s %-4d %-${win_size}s", $keys[$j], $k, join('',@move);
					@{$low_seg{$k}}=join('',@move);
				}
			 }elsif(($complexity > $threshold)&&($extended==1)){
			    print "\n    $k HIGHER \$complexity is $complexity";
				printf "\n%-10s %-4d %-${win_size}s", $keys[$j], $k, join('',@move);
				@{$low_seg{$k}}=join('',@move);
				$k+=$win_size;
				$win_size=$win_size_ori;
				$extended=0;
				$extension=0;
			 }#else{
			#	printf "\n%-10s %-4d %-${win_size}s", $keys[$j], $k, join('',@move);
			# }
		  }
		  print "\n";
	   }
	}
	return(\%low_seq);
}



#______________________________________________________________________________
# Title     : predict_sec_str_of_protein_by_FB_method
# Usage     :
# Function  :
# Example   :
#    &predict_sec_str_of_protein_by_FB_method(@files,
#                                      "$put_reliability_line_in_PRED",
#                                      "$give_weight_with_good_match",
#                                      "w=$weight_factor",
#                                      "$reverse_order_of_one_hash",
#                                      "$graphical_rep_of_str",
#                                      "$each_seq_prediction",
#                                      "$use_PHD_prediction_ALSO",
#                                      "$use_PHD_prediction_ONLY",
#                                      "$overwrite_previous_prediction",
#                                      "$Use_known_PDB_structure");
# Keywords  :
# Options   :
#   $put_reliability_line_in_PRED=l        by l -l
#   $give_weight_with_good_match=w by w # this is to give preference to well
#   $weight_factor= by w=
#   $reverse_order_of_one_hash=r   by r
#   $graphical_rep_of_str=g by g -g
#   $each_seq_prediction=e by e  ## take each seq use Predator and combine,
#                                   default is to use multiple seq predator
#   $use_PHD_prediction_ALSO=p by p   ## use PHD neural net prediction.
#   $use_PHD_prediction_ONLY=P by P
#   $overwrite_previous_prediction=o by o
#   $Use_known_PDB_structure=u by u
#   $produce_seq_oder_info=O by O  # used by open_msf_files
#   $opt_write_c3ss_file=C by C
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.3
#------------------------------------------------------------------------------
sub predict_sec_str_of_protein_by_FB_method{
		#"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
		my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
		my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
		my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
		my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
		my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
		if($debug==1){print "\n\t\@hash=\"@hash\"
		\@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
		\@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
		#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
		my ($put_reliability_line_in_PRED, $give_weight_with_good_match,
				$weight_factor, $reverse_order_of_one_hash, $graphical_rep_of_str,
				$each_seq_prediction, $use_PHD_prediction_ALSO, $use_PHD_prediction_ONLY,
				$overwrite_previous_prediction, %sec1, %sec1_rv, %seq_from_msf,
				%seq_from_msf_rv, $msf_file_reversed, @seq_names,$base_name,
				%gapped_av_for_back_pred, $ext, $input_seq_file, $final_output_pred_name,
				$very_final_output_pred_name, $very_final_output_prdl_name,
				%seq_from_msf_gapped, %seq_from_msf, %seq_from_msf_rv,
				$msf_file_reversed, @seq_names, %gapped_av_for_back_pred,
				%sec1, %av_of_forw_backw_pred, @accumulated, %gapped_av_for_back_pred,
				$Use_known_PDB_structure, $phd_file_name, $phd_file_name_rv,
				%sec2, %sec2_rv, %gross_av_for_back_pred, $produce_seq_oder_info,
				@seq_from_msf_gapped, $seq_order, $opt_write_c3ss_file);

		$reverse_order_of_one_hash='r';
		$put_reliability_line_in_PRED='l';     ##<--- this option is for write_pred_files
		$Use_known_PDB_structure='u';
		$produce_seq_oder_info='O';

		if($char_opt=~/o/){ $overwrite_previous_prediction='o' }
		if($char_opt=~/l/){ $put_reliability_line_in_PRED='l' }
		if($char_opt=~/w/){ $give_weight_with_good_match='w' }
		if($char_opt=~/r/){ $reverse_order_of_one_hash='r' }
		if($char_opt=~/g/){ $graphical_rep_of_str='g' }
		if($char_opt=~/e/){ $each_seq_prediction='e' }
		if($char_opt=~/u/){ $Use_known_PDB_structure='u' }
		if($char_opt=~/p/){ $use_PHD_prediction_ALSO='p' }
		if($char_opt=~/P/){ $use_PHD_prediction_ONLY='P' }
		if($char_opt=~/C/){ $opt_write_c3ss_file='C' }
		if($vars{'w'}){     $weight_factor=$vars{'w'} }

		$base_name=${&get_base_names($file[0])};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Following several lines are dodgy
		#_________________________________________
		if($use_PHD_prediction_ONLY){ $base_name=$base_name."\_PHD";
		}elsif($use_PHD_prediction_ALSO){  $base_name=$base_name."\_PPD";   # both PHD, Predator
		}else{                        $base_name=$base_name."\_PRD"; } # Predator only

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# If input is multiple alignment
		#____________________________________
		if($file[0]=~/(msf|aln)$/ ){
				 $ext=$1;
				 print "\n# (1) You have put $ext file. Good. I will run predator or use PHD result\n";
				 $input_seq_file=$file[0];
				 $final_output_pred_name="$base_name\_fb\.pred";
				 $very_final_output_pred_name="$base_name\_fb\.pred";
				 $very_final_output_prdl_name="$base_name\_fb\.prdl";

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # we'll need MSF MSFrv for Predator, so let's make it rev
				 #_________________________________________________________
				 unless( $use_PHD_prediction_ONLY){
						 @seq_from_msf_gapped =&open_msf_files(\$input_seq_file, $produce_seq_oder_info); ## no gap char like '.'
						 if(@seq_from_msf_gapped< 1){ print "\n# (E) open_msf_files sub failed "; exit }
						 %seq_from_msf_gapped=%{$seq_from_msf_gapped[0]};
						 if(ref($seq_from_msf_gapped[1]) eq 'ARRAY'){
								 @seq_order=@{$seq_from_msf_gapped[1]};
								 $seq_order=join(' ', @seq_order);
						 }elsif(ref($seq_from_msf_gapped[1]) eq 'SCALAR'){
								 $seq_order=${$seq_from_msf_gapped[1]};
						 }
						 &write_msf(\%seq_from_msf_gapped, \$input_seq_file, "o=$seq_order");

						 %seq_from_msf =%{&open_msf_files($input_seq_file, 'n')}; ## no gap char like '.'
						 %seq_from_msf_rv=%{&open_msf_files($input_seq_file, 'r')}; ## r is for reverse
						 $msf_file_reversed="$base_name\_rv\.msf";

						 &write_reverse_seq_files($input_seq_file); # writing reversed seq. MSF file

						 @seq_names=keys %seq_from_msf;
				 }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # If PHD file with the given File name, let's assign them
				 #_____________________________________________________________
				 if(-s "$base_name\.phd"){ $phd_file_name="$base_name\.phd" }
				 if(-s "$base_name\_rv\.phd"){ $phd_file_name_rv="$base_name\_rv\.phd" }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
				 # (1) This splits seqs and predict each seq's sec str
				 #________________________________________________________________
				 if($each_seq_prediction){
							print "\n# (2) Seq names are: @seq_names\n\n";

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# Write down each seq fasta
							#___________________________________________
							&write_fasta_seq_by_seq(\%seq_from_msf, 'R'); # R is for writing rv seq as well as forward seq

							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# go through and run predator for each fasta seq
							#__________________________________________________
							for($i=0; $i< @seq_names; $i++){
								 $each_fasta_seq="$seq_names[$i]\.fasta";
								 $each_fasta_seq_rv="$seq_names[$i]\_rv\.fasta";
								 $output_pred_file_name="$seq_names[$i]\.prdl";
								 $output_pred_file_name_rv="$seq_names[$i]\_rv\.prdl";
								 $final_output_pred_name="$seq_names[$i]\_fb\.pred";

								 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								 # If phd file with same is found, let's use it, too
								 #____________________________________________________
								 unless(-s $phd_file_name){
										 $phd_file_name="$seq_names[$i]\.phd";
								 }
								 unless(-s $phd_file_name_rv){
										 $phd_file_name_rv="$seq_names[$i]\_rv\.phd";
								 }

								 if(!-s $output_pred_file_name or $overwrite_previous_prediction){
										print "\n# (3) predator requires PRE_DIR ENV  to be set. Running predator... $input_seq_file (1)\n";
										system("predator -l -a -u $each_fasta_seq -f${output_pred_file_name}"); ## -u is for not using PDB 7 residue fragment when found
								 }
								 if(!-s $output_pred_file_name_rv or $overwrite_previous_prediction){
										print "\n# (4) predator requires PRE_DIR ENV  to be set. Running predator... $output_file_name_rv(2)\n";
										system("predator -l -a -u $each_fasta_seq_rv -f${output_pred_file_name_rv}");
								 }

                                 %sec1    =%{&open_predator_files($output_pred_file_name)};
                                 %sec1_rv =%{&open_predator_files($output_pred_file_name_rv )};

								 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								 # The core Averaging part
								 #___________________________________________
								 %av_of_forw_backw_pred=%{&get_averaged_prediction(\%sec1, \%sec1_rv,
																					"w=$weight_factor",
																					$give_weight_with_good_match,
																					"$reverse_order_of_one_hash")};
								 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								 # Aligning sequences to the original gaps
								 #___________________________________________
								 %gapped_seq=($seq_names[$i], $seq_from_msf_gapped{$seq_names[$i]});
								 %gapped_av_for_back_pred=%{&insert_gaps_in_seq_hash(\%av_of_forw_backw_pred, \%gapped_seq)};

								 push(@accumulated, \%gapped_av_for_back_pred);

								 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
								 # Writing PRED file
								 #___________________________________________
								 &write_pred_files(\%gapped_av_for_back_pred, $final_output_pred_name,
																		$graphical_rep_of_str, "$put_reliability_line_in_PRED");
							}
							#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
							# (3) Handling additional PHD prediction results
							#_____________________________________________________

							if( ($use_PHD_prediction_ALSO or $use_PHD_prediction_ONLY) and
								 -s $phd_file_name and -s $phd_file_name_rv and !%gapped_seq_phd){

								 print "\n# (5) I found $phd_file_name and $phd_file_name_rv\n"; sleep(1);
								 %sec1_phd   =%{&open_phd_files($phd_file_name)};
								 %sec1_phd_rv=%{&open_phd_files($phd_file_name_rv)};
								 %av_of_forw_backw_pred_phd=%{&get_averaged_prediction(\%sec1_phd, \%sec1_phd_rv,
												 "w=$weight_factor",
												 $give_weight_with_good_match,
												 "$reverse_order_of_one_hash")};

								 if($each_seq_prediction){
										%gapped_seq_phd=($seq_names[$i], $seq_from_msf_gapped{$seq_names[$i]});
										%gapped_av_for_back_pred_phd=%{&insert_gaps_in_seq_hash(\%av_of_forw_backw_pred_phd, \%gapped_seq)};
								 }
								 unshift(@accumulated, \%av_of_forw_backw_pred_phd);
							}else{ print "\n# (W) Handling PHD result is not going to work\n"; }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # Not breaking MULtiple align seqs
				 #_______________________________________
				 }else{
							unless($use_PHD_prediction_ONLY){ # <<-------- DEFAULT
									 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
									 # (2) This predicts multiple seqs' sec str. The default!!!
									 #________________________________________________________________
									 $output_pred_file_name= "$base_name\.prdl"; ## this var will have diff value from the above ones
									 $output_pred_file_name_rv="$base_name\_rv\.prdl";

									 print "\n# (6) Running Predator for MULtiple seq MSF files($files[0]) for  $output_pred_file_name\n";
									 if( ! -s $output_pred_file_name or $overwrite_previous_prediction){
											print "\n# (i) predator requires PRE_DIR ENV  to be set. Running predator... $files[0] (1)\n";
											if($Use_known_PDB_structure){
													 system("predator -l  -u $files[0] -f${output_pred_file_name}"); ## -u is for not using PDB 7 residue fragment when found
											}else{
													 system("predator -l $files[0] -f${output_pred_file_name}"); ## -u is for not using PDB 7 residue fragment when found
											}
									 }
									 if( ! -s $output_pred_file_name_rv or $overwrite_previous_prediction){ ## -r of predator is for preserving original alignment
											print "\n# (7) $base_name: predator requires PRE_DIR ENV  to be set. Running predator... $msf_file_reversed (2)\n";
											if($Use_known_PDB_structure){
													 system("predator -l  -u $msf_file_reversed -f${output_pred_file_name_rv}");
											}else{
													 system("predator -l  $msf_file_reversed -f${output_pred_file_name_rv}");
											}
									 }
									 %sec1       =%{&open_predator_files($output_pred_file_name)};
									 %sec1_rv    =%{&open_predator_files($output_pred_file_name_rv )};

									 %av_of_forw_backw_pred=%{&get_averaged_prediction(\%sec1, \%sec1_rv,
															"w=$weight_factor",
															$give_weight_with_good_match,
															"$reverse_order_of_one_hash")};
									 &write_pred_files(\%av_of_forw_backw_pred, $final_output_pred_name,
														$graphical_rep_of_str, "$put_reliability_line_in_PRED");
									 &write_c3ss_files(\%av_of_forw_backw_pred, \$base_name);
									 push(@accumulated, \%av_of_forw_backw_pred);

						 }elsif($use_PHD_prediction_ONLY){
									print "\n# (8) \$use_PHD_prediction_ONLY is set\n";
									%sec2=%{&open_phd_files($phd_file_name)};
									%sec2_rv=%{&open_phd_files($phd_file_name_rv)};
									%av_of_forw_backw_pred_phd=%{&get_averaged_prediction(\%sec2, \%sec2_rv,
														 "w=$weight_factor",
														 $give_weight_with_good_match,
														 "$reverse_order_of_one_hash")};
									@accumulated=(\%av_of_forw_backw_pred_phd);
						 }
				}

				print "\n# (9) Going into final averaging";

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# (4) Final averaging of PHD and PRD predictions
				#________________________________________________
				if(@accumulated > 1){
						%gross_av_for_back_pred=%{&get_averaged_prediction(@accumulated,
											 "w=$weight_factor",
											 $give_weight_with_good_match,
											 "$reverse_order_of_one_hash")};
						&write_pred_files(\%gross_av_for_back_pred, $very_final_output_pred_name,
										 $graphical_rep_of_str, "$put_reliability_line_in_PRED");
						&write_prdl_files(\%gross_av_for_back_pred, $very_final_output_prdl_name);
						&write_c3ss_files(\%gross_av_for_back_pred, \$base_name);
						print "\n# (10) $very_final_output_pred_name and $base_name\.c3ss are made \n\n";
				}else{
						 print "\n# (11) \$final_output_pred_name is made with $base_name\.c3ss\n\n";
						 $put_reliability_line_in_PRED='l';
						 &write_prdl_files($accumulated[0], $final_output_prdl_name);
						 &write_pred_files($accumulated[0], $final_output_pred_name,
															 $graphical_rep_of_str, $put_reliability_line_in_PRED);

						 &write_c3ss_files($accumulated[0], \$base_name);
						 print "\n# $base_name.c3ss, $final_output_prdl_name and $final_output_pred_name are created by $0\n\n";
				}

		}
		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# If input is simpler FASTA sequences. If multiple,(mpfa), it separates them
		#__________________________________________________________________________
		elsif($files[0]=~/\S\.[mps]+fa[sta]?/){ # xxxx.spfa means Single Protein Fasta file
				 local(%seq, %seq_rv);
				 @accumulated=();
				 print "\n# (i) You have put FASTA file. Good. I will run predator";
				 $input_seq_file=$file[0];
				 $base_name=${&get_base_names($input_seq_file)};
				 $output_fasta_file_name_rv="$base_name\_rv\.spfa";
				 $final_output_pred_name   ="$base_name\_fb\.pred";
				 $final_output_prdl_name   ="$base_name\_fb\.prdl";
				 $output_pred_file_name    ="$base_name\.prdl";       # prdl stands for predator long out file
				 $output_pred_file_name_rv ="$base_name\_rv\.prdl";
				 $output_phd_file_name     ="$base_name\.phd";       # prdl stands for predator long out file
				 $output_phd_file_name_rv  ="$base_name\_rv\.phd";
				 $very_final_output_pred_name="$base_name\_fb\.pred";
				 $very_final_output_prdl_name="$base_name\_fb\.prdl";

				 print "\n# (i) Forward seq: $output_pred_file_name, Rev seq: $output_pred_file_name_rv";

				 $reverse_order_of_one_hash='r';

				 if($use_PHD_prediction_ONLY){
						 print "\n# (i) \$use_PHD_prediction_ONLY is NOT set\n";
						 %sec2=%{&open_phd_files($output_phd_file_name)};
						 %sec2_rv=%{&open_phd_files($output_phd_file_name_rv)};
						 %av_of_forw_backw_pred_phd=%{&get_averaged_prediction(\%sec2, \%sec2_rv,
												"w=$weight_factor",
												$give_weight_with_good_match,
												"$reverse_order_of_one_hash")};
						 @accumulated=(\%av_of_forw_backw_pred_phd);

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # Following is the DEFAULT condition
				 #__________________________________________________
				 }elsif(!$use_PHD_prediction_ONLY){
						 print "\n# (i) \$use_PHD_prediction_ONLY is NOT set";
						 %seq=%{&open_fasta_files($input_seq_file)};

						 unless(-s $output_fasta_file_name_rv){
								 %seq_rv=%{&reverse_sequences(\%seq)};
								 &write_fasta(\%seq_rv, $output_fasta_file_name_rv);
						 }

						 if( ! -s $output_pred_file_name or $overwrite_previous_prediction){
								print "\n# (i) predator requires PRE_DIR ENV  to be set. Running 1st predator(1)";
								if($Use_known_PDB_structure){
										 system("predator -l  -u $input_seq_file -f${output_pred_file_name}"); ## -u is for not using PDB 7 residue fragment when found
								}else{
										 system("predator -l $input_seq_file -f${output_pred_file_name}"); ## -u is for not using PDB 7 residue fragment when found
								}
						 }else{
								print "\n# (i) $output_pred_file_name already Exists. Not running predator\n";
						 }
						 if( ! -s $output_pred_file_name_rv or $overwrite_previous_prediction){ ## -r of predator is for preserving original alignment
								print "\n# (i) predator requires PRE_DIR ENV  to be set. Running 2nd predator(2)";
								if($Use_known_PDB_structure){
										 system("predator -l  -u $output_fasta_file_name_rv -f${output_pred_file_name_rv}"); ## -u is for not using PDB 7 residue fragment when found
								}else{
										 system("predator -l $output_fasta_file_name_rv -f${output_pred_file_name_rv}"); ## -u is for not using PDB 7 residue fragment when found
								}
						 }else{
								print "# (i) $output_pred_file_name_rv already Exists. Not running predator\n";
						 }

						 %av_of_forw_backw_pred=%{&combine_forward_backward_sec_str_prediction(\$output_pred_file_name,
																																									\$output_pred_file_name_rv)};
						 @accumulated=( \%av_of_forw_backw_pred);
				 }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # If you want PHD prediction to be  added additionally
				 #_________________________________________________________
				 if($use_PHD_prediction_ALSO){
						 print "\n# (i) \$use_PHD_prediction_ALSO is set\n";
						 %sec2=%{&open_phd_files($output_phd_file_name)};
						 %sec2_rv=%{&open_phd_files($output_phd_file_name_rv)};
						 %av_of_forw_backw_pred_phd=%{&get_averaged_prediction(\%sec2, \%sec2_rv,
												"w=$weight_factor",
												$give_weight_with_good_match,
												"$reverse_order_of_one_hash")};
						 push(@accumulated, \%av_of_forw_backw_pred_phd);
				 }

				 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 # (4) Final averaging of the For and Backward prediction
				 #_________________________________________________________
				 if(@accumulated > 1){
						 print "\n# (i) Processing 2 hashes from \@accumulated\n";
						 $reverse_order_of_one_hash='';
						 %gross_av_for_back_pred=%{&get_averaged_prediction(@accumulated,
												"w=$weight_factor",
												$give_weight_with_good_match,
												"$reverse_order_of_one_hash")};
						 $put_reliability_line_in_PRED='l';
						 &write_pred_files(\%gross_av_for_back_pred, $very_final_output_pred_name,
											$graphical_rep_of_str, "$put_reliability_line_in_PRED");
						 &write_prdl_files(\%gross_av_for_back_pred, $very_final_output_prdl_name);
						 if($opt_write_c3ss_file){
								 &write_c3ss_files(\%gross_av_for_back_pred, \$base_name);
						 }
						 print "\n# (i) $very_final_output_pred_name and $base_name\.c3ss are made \n\n";
				 }else{
						 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						 # (4.1) This is when ONE for- ONE backward sequence were used to make only 1 out hash
						 #____________________________________________________________________________________
						 if( -s $final_output_prdl_name < 60 or $overwrite_previous_prediction){
								&write_prdl_files($accumulated[0], $final_output_prdl_name);
						 }
						 if( -s $final_output_pred_name < 60 or $overwrite_previous_prediction){
								$put_reliability_line_in_PRED='l';
								&write_pred_files($accumulated[0], $final_output_pred_name, $graphical_rep_of_str);
						 }
						 $base_name="$base_name\_P";
						 if($opt_write_c3ss_file){
								&write_c3ss_files($accumulated[0], \$base_name);
						 }
						 print "\n# $base_name.c3ss, $final_output_prdl_name and $final_output_pred_name are created by $0\n\n";
				 }
		}
}

#___________________________________________________________________
# Title     : assess_sec_str_prediction
# Usage     : assess_sec_str_prediction stx_fb.prdl stx.prdl [stx.stride, stx.dssp]
# Function  :
# Example   : assess_sec_str_pred.pl bpip.pre bpip.phd $DSSP/1bll.dssp 1bllE_bpip.msf
#
#           H        Alpha helix
#           G        3-10 helix
#           I        PI-helix
#           E        Extended conformation
#           B or b   Isolated bridge
#           T        Turn
#           C        Coil (none of the above)
#
# Class     : Perl::Utility::Arg_handling
# Keywords  :
# Options   : #  for debugging.
#             _  for debugging.
#   $use_universal_seq_hash_format=u by u -u
#   $convert_diff_pred_to_COIL_opt=C by C
#   $verbose=v by v
#   $consider_top_X_percent_only= by T=  # if T value is less than 100, it is activated
#
# Reference : http://cyrah.med.harvard.edu/perl_for_bio.html
# Returns   : Ref of
# Version   : 1.8
#---------------------------------------------------------------
sub assess_sec_str_prediction{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my ($convert_diff_pred_to_COIL_opt,
        %SEC_STR_ASSIGN, @success_rates, $num_of_residues,
        $i, $str_assignment, $prediction_1, $prediction_2,
        $score_for_prediction1, $score_for_prediction2,
        $sucess_rate_for_pred_1, $sucess_rate_for_pred_2,
        $mismatch_score_for_prediction2, $mismatch_score_for_prediction1,
        $match_score_for_prediction2, $match_score_for_prediction1,
        $num_of_residues1, $num_of_residues2, $match_reliability1,
        $match_reliability2, @reliability1, @reliability2,
        %mismatch_stats, $num_of_same_pred_for_both_methods,
        $num_of_diff_pred_for_both_methods, $top_X_perc_exclusion1,$top_X_perc_exclusion2,
        $matched_prediction_count, $error_rate_for_pred_1,
        $error_rate_for_pred_2, $diff_H_corr_E_wrong, $diff_H_corr_C_wrong,
        $diff_E_corr_H_wrong, $diff_E_corr_C_wrong, $diff_C_corr_H_wrong,
        $diff_C_corr_E_wrong, $diff_H_wrong_E_corr, $diff_H_wrong_C_corr,
        $diff_E_wrong_H_corr, $diff_E_wrong_C_corr, $diff_C_wrong_H_corr,
        $diff_C_wrong_E_corr, $diff_H_wrong_E_wrong, $diff_H_wrong_C_wrong,
        $diff_E_wrong_H_wrong,$diff_E_wrong_C_wrong, $diff_C_wrong_H_wrong,
        $diff_C_wrong_E_wrong, $same_H_corr_H_corr, $same_E_corr_E_corr,
        $same_C_corr_C_corr,  $same_H_wrong_H_wrong, $same_E_wrong_E_wrong,
        $same_C_wrong_C_wrong, $total_sec_str_assign_count,
        $hits_for_pred1_only, $hits_for_pred2_only,
        $hits_of_same_pred_for_both_methods, $protein_name,
        $C_errors_for_pred1_only,        $E_errors_for_pred1_only,
        $H_errors_for_pred1_only,        $C_errors_for_pred2_only,
        $E_errors_for_pred2_only,        $H_errors_for_pred2_only,
        $partial_res_above_T_thresh_for_pred1, $partial_res_above_T_thresh_for_pred2
        );

    $consider_top_X_percent_only=100; # the default
    $num_of_same_pred_for_both_methods=1;
    if($char_opt=~/C/){ $convert_diff_pred_to_COIL_opt='C' };
    if($vars{'T'}=~/(\S+)/){ $consider_top_X_percent_only=$1 };

    my %SEC_STR_ASSIGN =%{$_[0]};
    my %str_prediction1=%{$_[1]};
    my %str_prediction2=%{$_[2]};

    $protein_name=$SEC_STR_ASSIGN{'name'};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # $matched_prediction_count is matched pred. res. between forw and backward seq
    #________________________________________________________________________________
    $matched_prediction_count   =$str_prediction2{'matched_prediction_count'};
    $num_of_diff_pred_for_both_methods=$str_prediction2{'mismatched_prediction_count'};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # %mismatch_stats has 'H_E_mismatch', 'H_C_mismatch' etc keys
    #______________________________________________________________
    %mismatch_stats=%{$str_prediction2{'mismatch_stats'}};

    $num_of_residues =@positions=   @{$SEC_STR_ASSIGN{'sec_str_array'}};

    print "\n", @positions;

    $consider_top_X_percent_only=100; # the default

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Filtering out according to the TOP percentage given thresh
    #____________________________________________________________
    if($consider_top_X_percent_only < 100){ # NOTE that $str_prediction2{'top_X_perc_sec_str'} has been reversed in open_predator_files
       $num_of_residues=$num_of_residues1=@prediction1= split(//, $str_prediction1{'top_X_perc_sec_str'});
       $num_of_residues2=@prediction2= split(//, $str_prediction2{'top_X_perc_sec_str'});
       if($num_of_residues1 < 1 or $num_of_residues2 < 1){ die "\n# (E) \$num_of_residues1 is too small dying \n"; }
       print  "\n", @prediction1, "\n", @prediction2, "\n";
    }else{
       $num_of_residues1=@prediction1= @{$str_prediction1{'sec_str_array'}};
       $num_of_residues2=@prediction2= @{$str_prediction2{'sec_str_array'}};
       @reliability1= @{$str_prediction1{'prediction_reliability'}};
       @reliability2= @{$str_prediction2{'prediction_reliability'}};
       print  "\n", @prediction1, "\n", @prediction2;
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # NOW, I have in @prediction1 and @prediction2
    # Pred 1: cccccccceeeecccceeeecccccccceeecccceeeeeeecccchhhhhhhhcccchhhhhhh
    # Pred 2: ccchhhhhhcccccccceeeeeeccccceeecccccccccccccccccchhhhhcccccccccee
    #______________________________________________________________________________

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # running through the whole length of the sequence. First and last 2 residues are chopped off
    #______________________________________________________________________________________
    for($i=0; $i< $num_of_residues; $i++){
       $str_assignment=$positions[$i];

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # converting IiGgBbTt to CcCcCcCc from  FRISHMAN@MIPS.BIOCHEM.MPG.DE
       #_______________________________________________________________________
       $str_assignment=~tr/IiGgBbTt/CcCcCcCc/;  # changing B to H and T to C <-- This is a simplification

       $prediction_1  =$prediction1[$i];     $prediction_2  =$prediction2[$i];
       $reliability1  =$reliability1[$i];    $reliability2  =$reliability2[$i];

       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # count according to the sec. str type, NOT critical
       #_______________________________________________________
       if($str_assignment=~/H/i){     $mismatch_stats{'H_sec_str_assigned_count'}++
       }elsif($str_assignment=~/E/i){ $mismatch_stats{'E_sec_str_assigned_count'}++
       }elsif($str_assignment=~/C/i){ $mismatch_stats{'C_sec_str_assigned_count'}++ }


       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # (1) If either of the prediction was dropped by low reliability set by T option
       #____________________________________________________________________________
       if($prediction_1 eq '-' or $prediction_2 eq '-'){
          if($prediction_1 eq '-' and $prediction_2 ne '-' ){
              $top_X_perc_exclusion1++;       ## this is to handle top X perc only calc
              $partial_res_above_T_thresh_for_pred2++;
              if($prediction_2=~/$str_assignment/i){ $hits_for_pred2_only++; }
          }elsif($prediction_2 eq '-' and $prediction_1 ne '-' ){
              $top_X_perc_exclusion2++;
              $partial_res_above_T_thresh_for_pred1++;
              if($prediction_1=~/$str_assignment/i){ $hits_for_pred1_only++;  };
          }else{
              next;
          }
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # (2) If both are above T option thresh
       #___________________________________________________
       }else{
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # When prediction 1 matched prediction 2 (fb method)
          #_____________________________________________________
          if($prediction_1 =~/$prediction_2/i ){
              $num_of_same_pred_for_both_methods ++;

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # If the idential predict. is CORRECT
              #_______________________________________________
              if($prediction_1 =~/$str_assignment/i){
                 $hits_of_same_pred_for_both_methods++;
                 $reliability_of_hits_for_pred1_only +=$reliability1;
                 $reliability_of_hits_for_pred2_only +=$reliability2;
                 if(    $prediction_1=~/H/i ){  $same_H_corr_H_corr++;
                 }elsif($prediction_1=~/E/i ){  $same_E_corr_E_corr++;
                 }elsif($prediction_1=~/C/i ){  $same_C_corr_C_corr++;
                 }
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # If the identical predict. is WRONG
              #_______________________________________________
              }elsif($prediction_1 !~/$str_assignment/i){
                 $errors_of_same_pred_for_both_methods++;
                 $reliability_of_errors_for_pred1_only +=$reliability1;
                 $reliability_of_errors_for_pred2_only +=$reliability2;
                 if(    $prediction_1=~/H/i ){  $same_H_wrong_H_wrong++;
                 }elsif($prediction_1=~/E/i ){  $same_E_wrong_E_wrong++;
                 }elsif($prediction_1=~/C/i ){  $same_C_wrong_C_wrong++;
                 }
              }
          #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          # When prediction 1 DO NOT match prediction 2 (fb method)
          #___________________________________________________________
          }elsif($prediction_1 !~ /$prediction_2/i){
              $num_of_diff_pred_for_both_methods ++;

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # This is to accommodate Jason's idea. C option
              #________________________________________
              if($convert_diff_pred_to_COIL_opt){
                  if( $str_assignment=~/C/i){
                      $hits_of_same_pred_for_both_methods++;
                      $num_of_same_pred_for_both_methods++;
                  }elsif($convert_diff_pred_to_COIL_opt){
                      $errors_of_same_pred_for_both_methods++;
                      $num_of_same_pred_for_both_methods++;
                  }
              }

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Pred1-> CORRECT, Pred2-> Wrong
              #________________________________________
              if($prediction_1 =~/$str_assignment/i and $prediction_2 !~/$str_assignment/i){
                 $hits_for_pred1_only   ++;
                 $errors_for_pred2_only ++;
                 if($str_assignment=~/C/i){      $C_errors_for_pred2_only++;
                 }elsif($str_assignment=~/E/i){  $E_errors_for_pred2_only++;
                 }elsif($str_assignment=~/H/i){  $H_errors_for_pred2_only++; }

                 $reliability_of_hits_for_pred1_only +=$reliability1;
                 $reliability_of_errors_for_pred2_only +=$reliability2;
                 if(    $prediction_1=~/H/i and $prediction_2=~/E/i){  $diff_H_corr_E_wrong++;
                 }elsif($prediction_1=~/H/i and $prediction_2=~/C/i){  $diff_H_corr_C_wrong++;
                 }elsif($prediction_1=~/E/i and $prediction_2=~/H/i){  $diff_E_corr_H_wrong++;
                 }elsif($prediction_1=~/E/i and $prediction_2=~/C/i){  $diff_E_corr_C_wrong++;
                 }elsif($prediction_1=~/C/i and $prediction_2=~/H/i){  $diff_C_corr_H_wrong++;
                 }elsif($prediction_1=~/C/i and $prediction_2=~/E/i){  $diff_C_corr_E_wrong++;
                 }

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Pred1-> WRONG, Pred2-> CORRECT
              #________________________________________
              }elsif($prediction_1 !~/$str_assignment/i and $prediction_2 =~/$str_assignment/i){
                 $hits_for_pred2_only   ++;
                 $errors_for_pred1_only ++;
                 if($str_assignment=~/C/i){      $C_errors_for_pred1_only++;
                 }elsif($str_assignment=~/E/i){  $E_errors_for_pred1_only++;
                 }elsif($str_assignment=~/H/i){  $H_errors_for_pred1_only++; }

                 $reliability_of_hits_for_pred2_only +=$reliability2;
                 $reliability_of_errors_for_pred1_only +=$reliability1;
                 if(    $prediction_1=~/H/i and $prediction_2=~/E/i){  $diff_H_wrong_E_corr++;
                 }elsif($prediction_1=~/H/i and $prediction_2=~/C/i){  $diff_H_wrong_C_corr++;
                 }elsif($prediction_1=~/E/i and $prediction_2=~/H/i){  $diff_E_wrong_H_corr++;
                 }elsif($prediction_1=~/E/i and $prediction_2=~/C/i){  $diff_E_wrong_C_corr++;
                 }elsif($prediction_1=~/C/i and $prediction_2=~/H/i){  $diff_C_wrong_H_corr++;
                 }elsif($prediction_1=~/C/i and $prediction_2=~/E/i){  $diff_C_wrong_E_corr++;
                 }

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Pred1-> WRONG, Pred2-> WRONG
              #________________________________________
              }elsif($prediction_1 !~/$str_assignment/i and $prediction_2 !~/$str_assignment/i){
                 $errors_for_pred1_only ++;
                 $errors_for_pred2_only ++;
                 if($str_assignment=~/C/i){      $C_errors_for_pred1_only++; $C_errors_for_pred2_only++;
                 }elsif($str_assignment=~/E/i){  $E_errors_for_pred1_only++; $E_errors_for_pred2_only++;
                 }elsif($str_assignment=~/H/i){  $H_errors_for_pred1_only++; $H_errors_for_pred2_only++;}

                 $reliability_of_errors_for_pred1_only +=$reliability1;
                 $reliability_of_errors_for_pred2_only +=$reliability2;
                 if(    $prediction_1=~/H/i and $prediction_2=~/E/i){  $diff_H_wrong_E_wrong++;
                 }elsif($prediction_1=~/H/i and $prediction_2=~/C/i){  $diff_H_wrong_C_wrong++;
                 }elsif($prediction_1=~/E/i and $prediction_2=~/H/i){  $diff_E_wrong_H_wrong++;
                 }elsif($prediction_1=~/E/i and $prediction_2=~/C/i){  $diff_E_wrong_C_wrong++;
                 }elsif($prediction_1=~/C/i and $prediction_2=~/H/i){  $diff_C_wrong_H_wrong++;
                 }elsif($prediction_1=~/C/i and $prediction_2=~/E/i){  $diff_C_wrong_E_wrong++;
                 }
              }
          }
       }
    }

    $residues_both_above_T_thresh = $num_of_same_pred_for_both_methods + $num_of_diff_pred_for_both_methods;
    $total_res_above_T_thresh_for_pred1 = $residues_both_above_T_thresh + $partial_res_above_T_thresh_for_pred1;
    $total_res_above_T_thresh_for_pred2 = $residues_both_above_T_thresh + $partial_res_above_T_thresh_for_pred2;

    $success_rate_above_T_thresh_pred1 = ($hits_of_same_pred_for_both_methods + $hits_for_pred1_only) / $total_res_above_T_thresh_for_pred1;
    $success_rate_above_T_thresh_pred2 = ($hits_of_same_pred_for_both_methods + $hits_for_pred2_only) / $total_res_above_T_thresh_for_pred2;

    print "\n# \$success_rate_above_T_thresh_pred1 : $success_rate_above_T_thresh_pred1";
    print "\n# \$success_rate_above_T_thresh_pred2 : $success_rate_above_T_thresh_pred2";

    $hits_for_pred1=$hits_for_pred1_only + $hits_of_same_pred_for_both_methods;
    $hits_for_pred2=$hits_for_pred2_only + $hits_of_same_pred_for_both_methods;
    $reliability_for_pred1_total =$reliability_of_hits_for_pred1_only
                                  + $reliability_of_hits_for_same_pred;
    $reliability_for_pred2_total =$reliability_of_hits_for_pred2_only
                                  + $reliability_of_hits_for_same_pred;

    $errors_of_pred1_total= $errors_for_pred1_only + $errors_of_same_pred_for_both_methods;
    $errors_of_pred2_total= $errors_for_pred2_only + $errors_of_same_pred_for_both_methods;

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # These are for final variables to be returned
    #_______________________________________________________________________
    $success_rate_for_pred_1     =$hits_for_pred1/($num_of_residues1-$top_X_perc_exclusion1);
    $success_rate_for_pred_2     =$hits_for_pred2/($num_of_residues2-$top_X_perc_exclusion2);
    $success_rate_for_same_pred  =$hits_of_same_pred_for_both_methods/$num_of_same_pred_for_both_methods;

    print "\n# \$success_rate_for_pred_1 $success_rate_for_pred_1, $hits_for_pred1 /$num_of_residues1 - $top_X_perc_exclusion1";
    print "\n# \$success_rate_for_pred_2 $success_rate_for_pred_2, $hits_for_pred2 /$num_of_residues2 - $top_X_perc_exclusion2";
    print "\n# \$success_rate_for_same_pred $success_rate_for_same_pred,  $hits_of_same_pred_for_both_methods/ $num_of_same_pred_for_both_methods";

    $reliability_rate_for_pred_1 =$reliability_for_pred1_total/($num_of_residues1 - 4);
    $reliability_rate_for_pred_2 =$match_reliability2/($num_of_residues2 - 4);

    $error_rate_for_pred_1= -$errors_of_pred1_total/($num_of_residues1 - 4);
    $error_rate_for_pred_2= -$errors_of_pred2_total/($num_of_residues2 - 4);

    $matched_pred_rate   = $num_of_same_pred_for_both_methods/($num_of_residues - 4);
    $mismatched_pred_rate= $num_of_diff_pred_for_both_methods/($num_of_residues - 4);

    $mismatch_stats{'diff_H_corr_E_wrong'}=$diff_H_corr_E_wrong;
    $mismatch_stats{'diff_H_corr_C_wrong'}=$diff_H_corr_E_wrong;
    $mismatch_stats{'diff_E_corr_H_wrong'}=$diff_E_corr_H_wrong;
    $mismatch_stats{'diff_E_corr_C_wrong'}=$diff_E_corr_C_wrong;
    $mismatch_stats{'diff_C_corr_H_wrong'}=$diff_C_corr_H_wrong;
    $mismatch_stats{'diff_C_corr_E_wrong'}=$diff_C_corr_E_wrong;

    $mismatch_stats{'diff_H_wrong_E_corr'}=$diff_H_wrong_E_corr;
    $mismatch_stats{'diff_H_wrong_E_corr'}=$diff_H_wrong_E_corr;
    $mismatch_stats{'diff_E_wrong_H_corr'}=$diff_E_wrong_H_corr;
    $mismatch_stats{'diff_E_wrong_C_corr'}=$diff_E_wrong_C_corr;
    $mismatch_stats{'diff_C_wrong_H_corr'}=$diff_C_wrong_H_corr;
    $mismatch_stats{'diff_C_wrong_E_corr'}=$diff_C_wrong_E_corr;

    $mismatch_stats{'diff_H_wrong_E_wrong'}=$diff_H_wrong_E_wrong;
    $mismatch_stats{'diff_H_wrong_C_wrong'}=$diff_H_wrong_C_wrong;
    $mismatch_stats{'diff_E_wrong_H_wrong'}=$diff_E_wrong_H_wrong;
    $mismatch_stats{'diff_E_wrong_C_wrong'}=$diff_E_wrong_C_wrong;
    $mismatch_stats{'diff_C_wrong_H_wrong'}=$diff_C_wrong_H_wrong;
    $mismatch_stats{'diff_C_wrong_E_wrong'}=$diff_C_wrong_E_wrong;

    $mismatch_stats{'same_H_corr_H_corr'}=$same_H_corr_H_corr;
    $mismatch_stats{'same_E_corr_E_corr'}=$same_E_corr_E_corr;
    $mismatch_stats{'same_C_corr_C_corr'}=$same_C_corr_C_corr;

    $mismatch_stats{'same_H_wrong_H_wrong'}=$same_H_wrong_H_wrong;
    $mismatch_stats{'same_E_wrong_E_wrong'}=$same_E_wrong_E_wrong;
    $mismatch_stats{'same_C_wrong_C_wrong'}=$same_C_wrong_C_wrong;


    $mismatch_stats{'num_of_diff_pred_for_both_methods'}=$num_of_diff_pred_for_both_methods;

    $mismatch_stats_ref={%mismatch_stats};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # The very final retunred. %mismatch_stats is from previous sub
    #_______________________________________________________________
    @success_rates=($protein_name,
                    $num_of_residues,
                    $hits_for_pred1, $hits_for_pred2,
                    $success_rate_for_pred_1, $success_rate_for_pred_2,
                    $error_rate_for_pred_1,  $error_rate_for_pred_2,
                    $reliability_rate_for_pred_1, $reliability_rate_for_pred_2,
                    $num_of_same_pred_for_both_methods, $num_of_diff_pred_for_both_methods,
                    $hits_of_same_pred_for_both_methods, $errors_of_same_pred_for_both_methods,
                    $success_rate_for_same_pred,
                    $matched_pred_rate, $mismatched_pred_rate,
                    $C_errors_for_pred1_only,
                    $E_errors_for_pred1_only,
                    $H_errors_for_pred1_only,
                    $C_errors_for_pred2_only,
                    $E_errors_for_pred2_only,
                    $H_errors_for_pred2_only,
                    $mismatch_stats_ref,
                    $top_X_perc_exclusion1,
                    $top_X_perc_exclusion2);
    if($verbose){
       print "\# \$hits_of_same_pred_for_both_methods: $hits_of_same_pred_for_both_methods\n";
       print "\# \$num_of_same_pred_for_both_methods : $num_of_same_pred_for_both_methods, TOTAL res: $num_of_residues\n";
    }
    return(\@success_rates);
}



#________________________________________________________________________________
# Title     : NetBioServer
# Usage     : &NetBioServer(\%NetBioVariables);
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org
# Version   : 1.1
#--------------------------------------------------------------------------------
sub NetBioServer{

		my($PROGRAM, $DATALIB, $gappedAlignmentOption, $INPUT_TYPE, $SEQUENCE,
			 $EXPECT, $FILTER, $DESCRIPTIONS, $ALIGNMENTS, $graphicalOverviewOption,
			 $GENETICS_CODE, $OTHER_ADVANCED, $i, $j, %NetBioVariables,
			 @Search_result, $E_THRESH, $local_hostname, $target_server_IP,
			 $step_number, %blast_output_in_MSP);
		my $blastServerURL = $blastServerURLdefault   ='www.ncbi.nlm.nih.gov/cgi-bin/BLAST/nph-newblast';
		my $psi_blastServer_URL=$blastServerURLdefault='www.ncbi.nlm.nih.gov/cgi-bin/BLAST/nph-psi_blast';



		$local_hostname='cyrah.med.harvard.edu';
		$target_server_IP='www.ncbi.nlm.nih.gov';

		%NetBioVariables=%{$_[0]};
		$algorithm='PSI_BLAST';
		$step_number=1;
		$step_limit =2;

		$user_dir_name=$NetBioVariables{USER};
		$seq_dir_name="$NetBioVariables{USER}\/$NetBioVariables{SEQ_NAME}";
		mkdir($user_dir_name, 0777) unless -d $user_dir_name;
		mkdir($seq_dir_name, 0777)  unless -d $seq_dir_name;
		$result_file_name="$seq_dir_name\/$NetBioVariables{SEQ_NAME}\.html";
		$result_MSP_file_name="$seq_dir_name\/$NetBioVariables{SEQ_NAME}\.msp";  # <----------- MSP file format writing

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# I write the seq. fasta file at ~/Proj/Bio/NetBioServ/Jong/, while Jong is the user name
		#______________________________________________________________________________________________________
		open(FASTA_SEQ_FILE, ">$seq_dir_name\.spfa") || die "\n Can not open $seq_dir_name\.spfa \n";
		print FASTA_SEQ_FILE "\>$NetBioVariables{\"SEQ_NAME\"}\n$NetBioVariables{\"SEQUENCE\"}";
		close(FASTA_SEQ_FILE);

		%parameter_keys_and_values=(
				'PROGRAM'=>'blastp', ## even PSI-blast uses 'blastp' not 'blastpgp' !!
				'DATALIB'=>'nr',
				'E_THRESH'=>0.0001,   # for PSI blast
				'STEP_NUMBER'=>$step_number,     # for PSI blast
				'INPUT_TYPE'=>"sequence in fasta format",
				'SEQ_NAME'=>"$NetBioVariables{SEQ_NAME}",  ## I am not sure about this value(total guess)
				'QUERY'=>"$NetBioVariables{SEQ_NAME}",     ## I am not sure about this value(total guess)
				'GAPPED_ALIGNMENT'=>'is_set',
				'SEQUENCE'=>"$NetBioVariables{SEQUENCE}",
				'EXPECT'=>1,
				'FILTER'=>'default',
				'DESCRIPTIONS'=>100,
				'ALIGNMENTS'=>100,
				'OVERVIEW'=>'is_set',
				'GENETICS_CODE'=>1,
				'OTHER_ADVANCED'=>'',
				'HTML'=>'',
				'MAXLENGTH'=>10,
				'local_hostname'=>'cyrah.med.harvard.edu',
				'target_server_IP'=>'www.ncbi.nlm.nih.gov',
				'file_handle'=>'SOCKET_FOR_POST',
				'port'=>80,
				'resultTypeOption'=>''); ## $resultTypeOption'="HTML=is_set";

		ITERATION_POINT:

		$URI_content=${&generate_URI_content_line(\%parameter_keys_and_values)};
		$URI_length=length($URI_content);

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
		# Opening the NET connection
		#_____________________________________________________
		$SOCKET_FILEHANDLE=${&open_socket("H=$local_hostname", "S=$target_server_IP", "FH=$file_handle", "P=$port")};

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Build the HTTP POST object.  Actual Writing part
		#___________________________________________________________
		if($algorithm eq 'PSI_BLAST'){
		    if($step_number > 1){
						$blast_path='/cgi-bin/BLAST/nph-psi_blast/'."step${step_number}";
						$parameter_keys_and_values{'NEXT_I'}="\"Run PSI-Blast iteration $step_number\"";
		    }else{
						$blast_path='/cgi-bin/BLAST/nph-psi_blast/';
		    }
		}else{   $blast_path='/cgi-bin/BLAST/nph-newblast'; }

		&write_to_www_socket_filehandle($SOCKET_FILEHANDLE, $blast_path, $URI_length, $URI_content);

		$response = <$SOCKET_FILEHANDLE>;
		print "\n The response from the server:=> $response  From Step: $step_number\n";


		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Putting the result of server came through the socket to a big ARRAY: @Search_result
		#____________________________________________________________________________________________
		@Search_result = (<$SOCKET_FILEHANDLE>); ## <-- this works, but not <"$SOCKET_FILEHANDLE">

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Retrieve Keys and values for next search etc (near to the end of the result from server)
		#________________________________________________________________________________________________________
		for($i=(@Search_result-150); $i< @Search_result; $i++){
				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# matching: <INPUT TYPE="hidden" NAME= "file_handle" VALUE="SOCKET_FOR_POST">
				#__________________________________________________________________________________________
				if($Search_result[$i]=~/\<INPUT .+NAME *= *\"(\S+)\" +VALUE *= *\"?(\S+)\"? *\>/i){
						$param_keys_and_values{$1}=$2;
						print "\n $1 ";
				}
		}

		#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		# Check the step number and finishes if the step was equal to $step_limit
		#________________________________________________________________________________
		if($step_number >= $step_limit){

				#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				# I write the search result file at ~/Proj/Bio/NetBioServ/Jong/128U_DROME_Jong, while Jong is the user name
				#______________________________________________________________________________________________________
				open(RESULT, ">$result_file_name") || die "\n Can not open $result_file_name\n\n";
				for($i=0; $i< @Search_result; $i++){
						#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						# Adding  http:\/\/$target_server_IP to /htbin-post/Entrez/query?f etc
						#____________________________________________________________________________
						$Search_result[$i]=~s/ACTION=\"\/cgi-bin/ACTION=\"http:\/\/$target_server_IP\/cgi-bin/g;
						$Search_result[$i]=~s/href=\"\/htbin-post\//href=\"http:\/\/$target_server_IP\/htbin-post\//g;
						$Search_result[$i]=~s/\<IMG SRC=\"\S+.gif\" [^\>]+\>//ig;  ## removing Image links <IMG SRC="/BLAST/psi_blast.gif" BORDER=0 ISMAP></A>
						print $Search_result[$i];
						print RESULT $Search_result[$i];
				}
				close(RESULT);
				%blast_output_in_MSP=%{&convert_bla_to_msp(\$result_file_name, "SEQ_NAME=$SEQ_NAME")};
				&write_mspa_files(\%blast_output_in_MSP, $result_MSP_file_name);
		    goto EXIT;
		}else{
				$step_number++;
				$parameter_keys_and_values{'STEP_NUMBER'}=$step_number;
				#&show_hash(\%parameter_keys_and_values);
				goto ITERATION_POINT;
		}

		EXIT:

}



#___________________________________________________________________
# Title     : analyse_fb_sec_str_prediction
# Usage     : &analyse_fb_sec_str_prediction;
# Function  : compares 2 xxx.prdl (sec. str) files.
#             Usually to compare forw- and backward seq predictions
# Example   : analyse_fb_sec_str_prediction.pl bpip.pre bpip.phd $DSSP/1bll.dssp 1bllE_bpip.msf
# Class     : Perl::Utility::Arg_handling
# Keywords  : analyse_sec_str_prediction_performance
#             analyse_sec_str_pred_performance
# Options   :  -h  for help info.
#    $use_universal_seq_hash_format=u by u -u
#    $reverse_residue_order=r by r
#    $consider_top_X_percent_only= by T=  # if T value is less than 100, it is activated
#    $verbose=v by v
#
# Reference : http://cyrah.med.harvard.edu/perl_for_bio.html
# Returns   : Ref of
# Version   : 1.7
#---------------------------------------------------------------
sub analyse_fb_sec_str_prediction{
    #"""""""""""""""""< handle_arguments{ head Ver 4.1 >"""""""""""""""""""
    my(@A)=&handle_arguments(@_);my($num_opt)=${$A[7]};my($char_opt)=${$A[8]};
    my(@hash)=@{$A[0]};my(@file)=@{$A[4]};my(@dir)=@{$A[3]};my(@array)=@{$A[1]};
    my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};
    my(@raw_string)=@{$A[9]};my(%vars)=%{$A[10]};my(@range)=@{$A[11]};
    my($i,$j,$c,$d,$e,$f,$g,$h,$k,$l,$m,$n,$o,$p,$q,$r,$s,$t,$u,$v,$w,$x,$y,$z);
    if($debug==1){print "\n\t\@hash=\"@hash\"
    \@raw_string=\"@raw_string\"\n\t\@array=\"@array\"\n\t\@num_opt=\"@num_opt\"
    \@char_opt=\"@char_opt\"\n\t\@file=\"@file\"\n\t\@string=\"@string\"\n" }
    #""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    my (%predator1, %predator2, $predator_sec, %mismatch_stats, $use_universal_seq_hash_format,
         $in, $pdb_file_count, $worst_success_rate_for_pred_1, %PDBG_file,
         $worst_success_rate_for_same_pred, $worst_success_rate_for_pred_2,
         @in_files, $PDB_ATOM_FILE_DIR, %SEC_STR_ASSIGN, @success_rates,
         $consider_top_X_percent_only, $top_X_perc_exclusion);

    $worst_success_rate_for_pred_1=$worst_success_rate_for_pred_2=$worst_success_rate_for_same_pred=10;
    $consider_top_X_percent_only=100; ## to make the comparison equal with COMMON only region
    $use_universal_seq_hash_format='u';  # <--- this is the latest seq hash format of Jong
    $reverse_residue_order='r'; ## As I use _fv.prdl files

    if($vars{'T'}=~/(\S+)/){ $consider_top_X_percent_only=$1; }
    if($char_opt=~/u/){ $use_universal_seq_hash_format='u' }
    if($char_opt=~/r/){ $reverse_residue_order='r' }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # opening various data files for ploting
    #___________________________________________________________
    if(-s success_rate_dist.txt){  &cp('success_rate_dist.txt', 'success_rate_dist.txt.bak');  }
    open(DISTRIBUTION_SUC_RATE, ">success_rate_dist\_T\_$consider_top_X_percent_only.txt");
    open(SCOP_CLASS_STAT, ">scop_class_stat\_T\_$consider_top_X_percent_only.txt");

    if(-s "/Bio/DB/PDB/PDB100/pdb100d.pdbg"){
        $PDBG_FILE='/Bio/DB/PDB/PDB100/pdb100d.pdbg';
    }elsif(-s '/Bio/DB/PDB/PDB100/pdbd100.pdbg'){
        $PDBG_FILE='/Bio/DB/PDB/PDB100/pdbd100.pdbg';
    }
    %PDB100_PDBG=%{&open_pdbg_files($PDBG_FILE, 'p', 'C')}; ## PDB old style out without CHain
    $PDB_ATOM_FILE_DIR='/Bio/DB/PDB/Atom';

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Actual parsing of the PRDL files (predator Long out file)
    #____________________________________________________________________
    for $in (@file){
        my ($chain_number, $PDB_base, $PDB_backbone, $forward_prediction, $backward_prediction, $FB_prediction, $STRIDE_file,
            $STRIDE_file_whole_chain, @files);

        if($in=~/\S\S\S+_[fbrv]+\.prdl/){ next ;  # <----- this xxxx_fb.prdl is handled by assess_sec...pl prog
        }elsif($in=~/^(\d(\S\S)\S+?)\.prdl/){
            $PDB_base=$1;
            $PDB_backbone=$2; # this is to handle  /DB/PDB/Atom/ab  like directory names
            $forward_prediction ="$PDB_base\.prdl";
            $backward_prediction="$PDB_base\_rv.prdl";
            $STRIDE_base="$PDB_base\.stride";
            $STRIDE_file_whole_chain="$PDB_ATOM_FILE_DIR/$PDB_backbone/$PDB_base\.stride";
            if(-s $STRIDE_file_whole_chain and !-s $STRIDE_base){
                $STRIDE_file=$STRIDE_file_whole_chain;
                system("cp $STRIDE_file ."); ##<--- this isn't really required
            }elsif(-s $STRIDE_base){   #<---- if the file is in PWD
                $STRIDE_file=$STRIDE_base;
                print "\n STRIDE files are found in PWD, NOT in $PDB_ATOM_FILE_DIR/$PDB_backbone/\n";
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # Following is to handle when stride file is 1xxx.stride while my prdl file is 1xxxA.prdl
            #__________________________________________________________________________________________
            }elsif(!-s $STRIDE_file_whole_chain and !-s $STRIDE_base){
                $chain_number = chop($PDB_base);
                $STRIDE_file="/Bio/DB/PDB/Atom/$PDB_backbone/$PDB_base\.stride";
                $STRIDE_base="$PDB_base\.stride";
                unless(-s $STRIDE_file){  next; print "\n# (W) Can\'t still find $STRIDE_file !!\n\n", chr(7);
                }else{  system("cp $STRIDE_file .");   }
            }
        }else{  next; print "# (W) The given PRDL file(\$in): $in  can not be used ! Skipping";   }

        if(!-s $STRIDE_file or !-s $forward_prediction or !-s $backward_prediction){
            print chr(7), "\n File missing ($STRIDE_file, $forward_prediction, $backward_prediction): Skipps $PDB_base ";
            next;
        }else{
            @final_in_files=($forward_prediction, $backward_prediction, $STRIDE_file); $pdb_file_count++;
        }
        print "\n (i) Final Input files are @final_in_files\n" if $verbose;

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # The final data set from the following openning is  @final_hashes, %Aln, %DSSP
        #_________________________________________________________________________________
        %predator1= %{&open_predator_files(\$forward_prediction, $use_universal_seq_hash_format,
                      "T=$consider_top_X_percent_only")};
        %predator2= %{&open_predator_files(\$backward_prediction, $use_universal_seq_hash_format,
                      "T=$consider_top_X_percent_only", $reverse_residue_order)};
        %SEC_STR_ASSIGN = %{&open_stride_files(\$STRIDE_file, "C=$chain_number", $use_universal_seq_hash_format)};

        @success_rates=@{&assess_sec_str_prediction(\%SEC_STR_ASSIGN, \%predator1, \%predator2,
                                                    "T=$consider_top_X_percent_only")};
        ($protein_name,
        $num_of_residues,
        $hits_for_pred1, $hits_for_pred2,
        $success_rate_for_pred_1, $success_rate_for_pred_2,
        $error_rate_for_pred_1,  $error_rate_for_pred_2,
        $reliability_rate_for_pred_1, $reliability_rate_for_pred_2,
        $num_of_same_pred_for_both_methods, $num_of_diff_pred_for_both_methods,
        $hits_of_same_pred_for_both_methods, $errors_of_same_pred_for_both_methods,
        $success_rate_for_same_pred,
        $matched_pred_rate, $mismatched_pred_rate, # rate of same and diff prediction rate
        $C_errors_for_pred1_only,
        $E_errors_for_pred1_only,
        $H_errors_for_pred1_only,
        $C_errors_for_pred2_only,
        $E_errors_for_pred2_only,
        $H_errors_for_pred2_only,
        $mismatch_stats_ref,
        $top_X_perc_exclusion1,
        $top_X_perc_exclusion2 )= @success_rates;

        if($num_of_diff_pred_for_both_methods == 0){ $num_of_diff_pred_for_both_methods=1 }
        ## H_E_mismatch is defined in get_averaged_.. sub in predict_ssop.pl

        %mismatch_stats=%{$mismatch_stats_ref};

        #$total_success1+=$success_rate_for_pred_1;
        #$total_success2+=$success_rate_for_pred_2;
        #$total_failure1+=$failure_rate_for_pred_1;
        #$total_failure2+=$failure_rate_for_pred_2;
        #$total_reliability1+=$match_reliability1;
        #$total_reliability2+=$match_reliability2;
        $total_matched_pred_rate    += $matched_pred_rate;
        $total_mismatched_pred_rate += $mismatched_pred_rate;

        $total_sec_str_assign_count      += $num_of_residues;
        $total_sec_str_assign_count1     += ($num_of_residues - $top_X_perc_exclusion1); ## I used to subtract 4 to remove the edges
        $total_sec_str_assign_count2     += ($num_of_residues - $top_X_perc_exclusion2); ## I used to subtract 4 to remove the edges
        $total_hits_for_pred1 +=$hits_for_pred1;
        $total_hits_for_pred2 +=$hits_for_pred2;
        $hits_for_pred1_rate =$total_hits_for_pred1/$total_sec_str_assign_count1;
        $hits_for_pred2_rate =$total_hits_for_pred2/$total_sec_str_assign_count2;

        $H_sec_str_assigned_count_total +=$mismatch_stats{'H_sec_str_assigned_count'};
        $E_sec_str_assigned_count_total +=$mismatch_stats{'E_sec_str_assigned_count'};
        $C_sec_str_assigned_count_total +=$mismatch_stats{'C_sec_str_assigned_count'};
        $H_sec_str_assigned_count_total_rate =$H_sec_str_assigned_count_total/$total_sec_str_assign_count;
        $E_sec_str_assigned_count_total_rate =$E_sec_str_assigned_count_total/$total_sec_str_assign_count;
        $C_sec_str_assigned_count_total_rate =$C_sec_str_assigned_count_total/$total_sec_str_assign_count;


        $total_H_E_mismatch_rate += $mismatch_stats{'H_E_mismatch'}/$num_of_diff_pred_for_both_methods ;
        $total_H_C_mismatch_rate += $mismatch_stats{'H_C_mismatch'}/$num_of_diff_pred_for_both_methods ;
        $total_E_H_mismatch_rate += $mismatch_stats{'E_H_mismatch'}/$num_of_diff_pred_for_both_methods ;
        $total_E_C_mismatch_rate += $mismatch_stats{'E_C_mismatch'}/$num_of_diff_pred_for_both_methods ;
        $total_C_H_mismatch_rate += $mismatch_stats{'C_H_mismatch'}/$num_of_diff_pred_for_both_methods ;
        $total_C_E_mismatch_rate += $mismatch_stats{'C_E_mismatch'}/$num_of_diff_pred_for_both_methods ;

        $total_matching_pred     +=$num_of_same_pred_for_both_methods;
        $total_non_matching_pred +=$num_of_diff_pred_for_both_methods;
        #$total_matching_pred_rate     =$total_matching_pred    /$total_sec_str_assign_count;
        #$total_non_matching_pred_rate =$total_non_matching_pred/$total_sec_str_assign_count;

        $total_hits_of_same_pred_for_both_methods += $hits_of_same_pred_for_both_methods;

        $total_hits_of_same_pred_for_both_methods_rate= $total_hits_of_same_pred_for_both_methods/$total_matching_pred;
        #$total_hits_of_same_pred_for_both_methods_rate= $total_hits_of_same_pred_for_both_methods/$total_sec_str_assign_count;

        $total_C_errors_for_pred1_only+= $C_errors_for_pred1_only;
        $total_E_errors_for_pred1_only+= $E_errors_for_pred1_only;
        $total_H_errors_for_pred1_only+= $H_errors_for_pred1_only;
        $total_C_errors_for_pred2_only+= $C_errors_for_pred2_only;
        $total_E_errors_for_pred2_only+= $E_errors_for_pred2_only;
        $total_H_errors_for_pred2_only+= $H_errors_for_pred2_only;

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Finding the best prediction protein names
        #____________________________________________________________________
        if($best_success_rate_for_pred_1 < $success_rate_for_pred_1){
            $best_success_rate_for_pred_1=$success_rate_for_pred_1;
            $best_success_rate_pred1_name=$protein_name;        $best_hit_num_of_residues1=$num_of_residues;
        }
        if($best_success_rate_for_pred_2 < $success_rate_for_pred_2){
            $best_success_rate_for_pred_2=$success_rate_for_pred_2;
            $best_success_rate_pred2_name=$protein_name;        $best_hit_num_of_residues2=$num_of_residues;
        }
        if($best_success_rate_for_same_pred < $success_rate_for_same_pred){
            $best_success_rate_for_same_pred=$success_rate_for_same_pred;
            $best_success_rate_for_same_name=$protein_name;     $best_hit_num_of_residues3=$num_of_residues;
        }
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Finding the Worst prediction protein names
        #____________________________________________________________________

        if($worst_success_rate_for_pred_1 > $success_rate_for_pred_1){
            $worst_success_rate_for_pred_1=$success_rate_for_pred_1;
            $worst_success_rate_pred1_name=$protein_name;        $worst_hit_num_of_residues1=$num_of_residues;
        }
        if($worst_success_rate_for_pred_2 > $success_rate_for_pred_2){
            $worst_success_rate_for_pred_2=$success_rate_for_pred_2;
            $worst_success_rate_pred2_name=$protein_name;        $worst_hit_num_of_residues2=$num_of_residues;
        }
        if($worst_success_rate_for_same_pred > $success_rate_for_same_pred){
            $worst_success_rate_for_same_pred=$success_rate_for_same_pred;
            $worst_success_rate_for_same_name=$protein_name;     $worst_hit_num_of_residues3=$num_of_residues;
        }


        if($verbose){
            print "\nPDB40C: $pdb_file_count ------------------------------------------------------------\n";
            print "Accumulated H, E, C : $H_sec_str_assigned_count_total, $E_sec_str_assigned_count_total, $C_sec_str_assigned_count_total\n";
            print "Total_H, E, C rate: $H_sec_str_assigned_count_total_rate, $E_sec_str_assigned_count_total_rate, $C_sec_str_assigned_count_total_rate \n";
            print "Hits for pred1: $hits_for_pred1  Hits for pred2: $hits_for_pred2. \n";
            print "Total accumulated residue assgined:  $total_sec_str_assign_count\n";
            print "Hits for pred1_total: $total_hits_for_pred1 $hits_for_pred1_rate, Hits for pred2_total: $total_hits_for_pred2 $hits_for_pred2_rate\n";
            print "Total same sec. str pred.: $total_matching_pred ($total_matching_pred_rate) Non-matching: $total_non_matching_pred ($total_non_matching_pred_rate)\n";

            print "Sucesss rate1 : $total_success1, Sucesss rate2 :$total_success2 \n";
            print "Sucesss rate for same pred : $total_hits_of_same_pred_for_both_methods_rate \n";
            print "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
            print "Bests: $best_success_rate_pred1_name ($best_hit_num_of_residues1): P1 = $best_success_rate_for_pred_1\n";
            print "Bests: $best_success_rate_pred2_name ($best_hit_num_of_residues2): P2 = $best_success_rate_for_pred_2\n";
            print "Bests: $best_success_rate_for_same_name ($best_hit_num_of_residues3): common= $best_success_rate_for_same_pred \n";
            print "Worst: $worst_success_rate_pred1_name ($worst_hit_num_of_residues1): P1 = $worst_success_rate_for_pred_1\n";
            print "Worst: $worst_success_rate_pred2_name ($worst_hit_num_of_residues2): P2 = $worst_success_rate_for_pred_2\n";
            print "Worst: $worst_success_rate_for_same_name ($worst_hit_num_of_residues3): common= $worst_success_rate_for_same_pred \n";
            print "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n";
            print "$total_failure1 $total_failure2 \n";
            print "\$total_reliability1 $total_reliability1, \$total_reliability2 $total_reliability2\n";
            print "# Following is NOT error rate but forw- backward matching rate\n";
            print "  \$total_matched_pred_rate $total_matched_pred_rate, \$total_mismatched_pred_rate $total_mismatched_pred_rate\n";
            print "  \$total_H_E_mismatch_rate F&B: $total_H_E_mismatch_rate\n";
            print "  \$total_H_C_mismatch_rate F&B: $total_H_C_mismatch_rate\n";
            print "  \$total_E_H_mismatch_rate F&B: $total_E_H_mismatch_rate\n";
            print "  \$total_E_C_mismatch_rate F&B: $total_E_C_mismatch_rate\n";
            print "  \$total_C_H_mismatch_rate F&B: $total_C_H_mismatch_rate\n";
            print "  \$total_C_E_mismatch_rate F&B: $total_C_E_mismatch_rate\n";
            @mis_match_pred_keys=sort keys %mismatch_stats;
            for($i=0; $i < @mis_match_pred_keys; $i++){
               if($mis_match_pred_keys[$i]=~/^diff_|^same_/){
                   print "    $mis_match_pred_keys[$i]     : $mismatch_stats{$mis_match_pred_keys[$i]}\n";
                   $total_stats{$mis_match_pred_keys[$i]}+=$mismatch_stats{$mis_match_pred_keys[$i]};
                   #print "     Total $mis_match_pred_keys[$i] :  $total_stats{$mis_match_pred_keys[$i]}\n";
               }
            }
            print "\n";
        }else{
        }

        $protein_name="\L$protein_name"."\U$chain_number";
        if($PDB100_PDBG{$protein_name}){  $protein_scop_class=$PDB100_PDBG{$protein_name};
           if($protein_scop_class=~/^(\d+)\./){ $protein_scop_class=$1 };
           print SCOP_CLASS_STAT "$protein_scop_class $success_rate_for_pred_1 $success_rate_for_pred_2 $success_rate_for_same_pred\n";
        }else{
           print &__YELLOW__, "No $protein_name in \%PDB100_PDBG\n", &__RESET__;
        }

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # printing files
        #______________________________________________________
        print DISTRIBUTION_SUC_RATE "$num_of_residues $success_rate_for_pred_1 $success_rate_for_pred_2 $success_rate_for_same_pred\n";

    }

    @total_diff_same_stat=keys %total_stats;  ## use: $total_matching_pred, $total_non_matching_pred
    for($i=0; $i< @total_diff_same_stat; $i++){
        if($total_diff_same_stat[$i]=~/diff_/){
           $rate=$total_stats{$total_diff_same_stat[$i]}/$total_non_matching_pred;
           print "# Total $total_diff_same_stat[$i]: $total_stats{$total_diff_same_stat[$i]}, $rate\n";
        }else{
           $rate=$total_stats{$total_diff_same_stat[$i]}/$total_matching_pred;
           print "# Total $total_diff_same_stat[$i]: $total_stats{$total_diff_same_stat[$i]}, $rate\n";
        }
    }

    print "\$total_C_errors_for_pred1_only: $total_C_errors_for_pred1_only \/$C_sec_str_assigned_count_total\n";
    print "\$total_E_errors_for_pred1_only: $total_E_errors_for_pred1_only \/$E_sec_str_assigned_count_total\n";
    print "\$total_H_errors_for_pred1_only: $total_H_errors_for_pred1_only \/$H_sec_str_assigned_count_total\n";
    print "\$total_C_errors_for_pred2_only: $total_C_errors_for_pred2_only \/$C_sec_str_assigned_count_total\n";
    print "\$total_E_errors_for_pred2_only: $total_E_errors_for_pred2_only \/$E_sec_str_assigned_count_total\n";
    print "\$total_H_errors_for_pred2_only: $total_H_errors_for_pred2_only \/$H_sec_str_assigned_count_total\n";

    open (RES_SUMMARY, ">sec_str_anlysis_sum\_T\_$consider_top_X_percent_only.txt");
    print RES_SUMMARY "# RES: SAME Pred ratio: $total_matched_pred_rate, DIFF Pred Ratio: $total_mismatched_pred_rate\n";
    print RES_SUMMARY "# RES: \$total_sec_str_assign_count for forward seq: $total_sec_str_assign_count\n";
    print RES_SUMMARY "# RES: Total H, E, C ratio: $H_sec_str_assigned_count_total_rate, $E_sec_str_assigned_count_total_rate, $C_sec_str_assigned_count_total_rate \n";
    print RES_SUMMARY "# RES: Hits for pred1_total: $total_hits_for_pred1 $hits_for_pred1_rate, Hits for pred2_total: $total_hits_for_pred2 $hits_for_pred2_rate\n";
    print RES_SUMMARY "# RES: Total same pred: $total_matching_pred ($total_matching_pred_rate)
              Non-matching: $total_non_matching_pred ($total_non_matching_pred_rate)\n";
    print RES_SUMMARY "# RES: \$total_hits_of_same_pred_for_both_methods_rate: $total_hits_of_same_pred_for_both_methods_rate ($total_hits_of_same_pred_for_both_methods \/$total_matching_pred)\n";
    print "# RES: SAME suc rate: $total_hits_of_same_pred_for_both_methods_rate ($total_hits_of_same_pred_for_both_methods \/$total_matching_pred)\n";
    print "# RES: Hits for pred1_total: $total_hits_for_pred1 $hits_for_pred1_rate, Hits for pred2_total: $total_hits_for_pred2 $hits_for_pred2_rate\n";

    close(DISTRIBUTION_SUC_RATE);
    close(SCOP_CLASS_STAT);
    close(RES_SUMMARY);
    print "# (i) Files created: success_rate_dist.txt scop_class_stat.txt sec_str_anlysis_sum.txt\n\n";

}


#______________________________________________________________________________
# Title     : make_revcomp_sequences
# Usage     : @out=@{&make_revcomp_sequences(\@input_string_or_seq)};
# Function  :
# Example   :
# Keywords  : make_revcomp_string, make_revcomp_string_array
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub make_revcomp_sequences{
		my(@revcomp_patterns, @patterns, $pattern, $i);
		@patterns=@{$_[0]};
		for($i=0; $i< @patterns; $i++){
			 $pattern=$patterns[$i];
		   $pattern =~ tr/\[\]acgtrymkswhbvdnACGTRYMKSWHBVDN/\]\[tgcayrkmswdvbhnTGCAYRKMSWDVBHN/;
			 $pattern = reverse $pattern; # reversing it to make complimentary to the original
			 push(@revcomp_patterns, $pattern);
		}
		return(\@revcomp_patterns);
}



#______________________________________________________________________________
# Title     : match_number_of_seq_ranges
# Usage     :
# Function  : With a given 2 sets of ranges, it forces the
#             longer ranges to smaller one.
# Example   :
#     Input Example>>
#      1preA : 191 222           268 297   403 449
#      h1_dd6: 190 206 210 225   271 300   406 421 424 451
#
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub match_number_of_seq_ranges{
    my(@ranges1, @ranges2, @short_ranges, @long_ranges, @compacted_ranges,
       $i, $j, $closest_start_point_index, $closest_stop_point_index, $j_increment);
    @ranges1=@{$_[0]};
    @ranges2=@{$_[1]};
    if(@ranges1 > @ranges2){
       @short_ranges=@ranges2;
       @long_ranges=@ranges1;
    }elsif(@ranges1 < @ranges2){
       @short_ranges=@ranges1;
       @long_ranges=@ranges2;
    }else{
       print "\n Warning: The 2 range inputs have the same element size. \n";
       print "\n   This might be a problem for  match_the_number_of_seq_ranges\n";
       return(\@ranges1);
    }
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # If the short range is only one pair (like 147, 297). It is obvious!
    #___________________________________________________________________
    if(@short_ranges == 2){
        @compacted_ranges=($long_ranges[0], $long_ranges[$#long_ranges]);
    }else{

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        # On short_ranges number, I try to match the best long ranges start and stop points
        #_________________________________________________________________________________________
        for($i=1; $i< @short_ranges; $i+=2){
           my($stop_point_difference, $shortest_stop_diff, $shortest_start_diff,
              $short_arr_range_size, $template_range_start,
              $target_range_start, $target_range_stop, $start_point_difference,
              $stop_point_difference );

           $shortest_stop_diff = $shortest_start_diff=10000000000;

           $short_arr_range_size  = ($short_ranges[$i] - $short_ranges[$i-1]); ## this is necessary

           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           # Handling stopping point
           #___________________________________________________________
           for($j=$i+$j_increment; $j< @long_ranges; $j+=2){
              $target_range_stop = ($long_ranges[$j] - $long_ranges[$i+$j_increment-1]);
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # Comparing the stop point difference
              #__________________________________________
              $stop_point_difference= abs($target_range_stop-$short_arr_range_size);
              if( $stop_point_difference  < $shortest_stop_diff){
                  $shortest_stop_diff       = $stop_point_difference;
                  $closest_stop_point_index = $j;
                  #print "\n     \$closest_stop_point_index \"$j\"  $target_range_stop $long_ranges[$j] - $long_ranges[$i-1]";
              }else{
                  #print "\n     \"$j\", Skipping \$target_range_stop: $target_range_stop";
              }
           }

           $j_increment = $closest_stop_point_index-$i;
           $compacted_ranges[$i-1]=$long_ranges[$closest_start_point_index];
           $compacted_ranges[$i]  =$long_ranges[$closest_stop_point_index];
           #print "\n>> $i $closest_start_point_index - $closest_stop_point_index \t$long_ranges[$closest_start_point_index] $long_ranges[$closest_stop_point_index]";

           $closest_start_point_index = $closest_stop_point_index + 1;


        }
    }
    return(\@compacted_ranges);

}




#______________________________________________________________________________
# Title     : retrieve_pdb_chain_IDs_from_file_names
# Usage     :
# Function  :
# Example   :
# Keywords  : get_pdb_chain_ID, extract_pdb_chain_ID, get_chain_number,
#             get_chain_ID
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub retrieve_pdb_chain_IDs_from_file_names{
    my(@input_files, $i,%chain_ID);
    @input_files=@{$_[0]};
    for($i=0; $i< @input_files; $i++){
       if($input_files[$i]=~/^\d\w\w\w(\w)\./){
          $chain_ID{$1}=$1;
       }
    }
    if(keys %chain_ID > 1){
       return([sort keys %chain_ID]);
    }elsif( (keys %chain_ID) == 1){
       return(\(keys %chain_ID));
    }else{
       print "\n No chain id found";
       return(0);
    }
}


#______________________________________________________________________________
# Title     : __YELLOW__
# Usage     : &__YELLOW__
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :  print &__RED__, "This should be RED\n";
# Keywords  : __yellow__, __YELL__, yellow_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __YELLOW__{
		return("\e[33m");
}

#______________________________________________________________________________
# Title     : __RED__
# Usage     : print &__RED__, "This should be RED\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __RED__{
		return("\e[31m");
}


#______________________________________________________________________________
# Title     : __BLUE__
# Usage     : print &__BLUE__, "This should be BLUE\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __BLUE__{
		return("\e[34m");
}

#______________________________________________________________________________
# Title     : __GREEN__
# Usage     : print &__GREEN__, "This should be GREEN\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __GREEN__{
		return("\e[32m");
}

#______________________________________________________________________________
# Title     : __BLACK__
# Usage     : print &__BLACK__, "This should be BLACK\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __BLACK__{
		return("\e[30m");
}

#______________________________________________________________________________
# Title     : __MAGENTA__
# Usage     : print &__MAGENTA__, "This should be MAGENTA\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __MAGENTA__{
		return("\e[35m");
}


#______________________________________________________________________________
# Title     : __CYAN__
# Usage     : print &__CYAN__, "This should be CYAN\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __CYAN__{
		return("\e[36m");
}

#______________________________________________________________________________
# Title     : __WHITE__
# Usage     : print &__WHITE__, "This should be WHITE\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __WHITE__{
	return("\e[37m");
}

#______________________________________________________________________________
# Title     : __RESET__
# Usage     : print &__RESET__, "This should be RESET\n";
# Function  : changes the color of following text, to reset, use, &__RESET__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __RESET__{
	return("\e[0m");
}

#______________________________________________________________________________
# Title     : __BOLD__
# Usage     : print &__BOLD__, "This should be BOLD\n";
# Function  : changes the color of following text, to reset, use, &__BOLD__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __BOLD__{
	return("\e[1m");
}

#______________________________________________________________________________
# Title     : __REVERSE__
# Usage     : print &__REVERSE__, "This should be REVERSE\n";
# Function  : changes the color of following text, to reset, use, &__REVERSE__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __REVERSE__{
		return("\e[7m");
}

#______________________________________________________________________________
# Title     : __UNDERLINE__
# Usage     : print &__UNDERLINE__, "This should be UNDERLINE\n";
# Function  : changes the color of following text, to reset, use, &__UNDERLINE__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __UNDERLINE__{
		return("\e[4m");
}

#______________________________________________________________________________
# Title     : __UNDERLINE__
# Usage     : print &__UNDERLINE__, "This should be UNDERLINE\n";
# Function  : changes the color of following text, to reset, use, &__UNDERLINE__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __UNDERLINE__{
		return("\e[4m");
}

#______________________________________________________________________________
# Title     : __BLINK__
# Usage     : print &__BLINK__, "This should be BLINK\n";
# Function  : changes the color of following text, to reset, use, &__BLINK__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __BLINK__{
		return("\e[5m");
}

#______________________________________________________________________________
# Title     : __ON_BLACK__
# Usage     : print &__ON_BLACK__, "This should be ON_BLACK\n";
# Function  : changes the color of following text, to reset, use, &__ON_BLACK__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_BLACK__{
		return("\e[40m");
}

#______________________________________________________________________________
# Title     : __ON_RED__
# Usage     : print &__ON_RED__, "This should be ON_RED\n";
# Function  : changes the color of following text, to reset, use, &__ON_RED__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_RED__{
		return("\e[41m");
}

#______________________________________________________________________________
# Title     : __ON_GREEN__
# Usage     : print &__ON_GREEN__, "This should be ON_GREEN\n";
# Function  : changes the color of following text, to reset, use, &__ON_GREEN__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_GREEN__{
		return("\e[42m");
}

#______________________________________________________________________________
# Title     : __ON_YELLOW__
# Usage     : print &__ON_YELLOW__, "This should be ON_YELLOW\n";
# Function  : changes the color of following text, to reset, use, &__ON_YELLOW__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_YELLOW__{
		return("\e[43m");
}

#______________________________________________________________________________
# Title     : __ON_BLUE__
# Usage     : print &__ON_BLUE__, "This should be ON_BLUE\n";
# Function  : changes the color of following text, to reset, use, &__ON_BLUE__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_BLUE__{
		return("\e[44m");
}

#______________________________________________________________________________
# Title     : __ON_CYAN__
# Usage     : print &__ON_CYAN__, "This should be ON_CYAN\n";
# Function  : changes the color of following text, to reset, use, &__ON_CYAN__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_CYAN__{
		return("\e[46m");
}

#______________________________________________________________________________
# Title     : __ON_MAGENTA__
# Usage     : print &__ON_MAGENTA__, "This should be ON_MAGENTA\n";
# Function  : changes the color of following text, to reset, use, &__ON_MAGENTA__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_MAGENTA__{
		return("\e[45m");
}

#______________________________________________________________________________
# Title     : __ON_WHITE__
# Usage     : print &__ON_WHITE__, "This should be ON_WHITE\n";
# Function  : changes the color of following text, to reset, use, &__ON_WHITE__
# Example   :
# Keywords  : __red__, red_text,
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Version   : 1.0
#------------------------------------------------------------------------------
sub __ON_WHITE__{
		return("\e[47m");
}

#______________________________________________________________________________
# Title     : datesort
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub datesort {
	local(%rep,%rank,%hom,%daterank,%founder,%count,%class,%ix,%compnd,%nres,%dssp);
	# get rank from date.rdb
	open(IN,"$RDBDIR/sorttbl Date < $DATERDB |");
	$i=0; while(<IN>) { $i++; ($short)=/^(\w{4})/; $rank{$short}=$i; }
	close(IN);
	# get homologs from FSSP_PAIR_TABLE (former TABLE2)
	open(IN,"<$FSSP_PAIR_TABLE"); while(<IN>) { last if(/^PDBid Repre/); }
	while(<IN>) {
		($cd,$rep)=/^(\w{4})\S*\s+(\w{4})/;
		$hom{$rep}.="$cd ";
	}
	close(IN);
	# get class from DOMTABLE1
	open(IN,'<DOMTABLE1');
	while(<IN>) {
		($class,$ix,$rep,$compnd,$nres,$dssp)=/^\s*(\d+)(\.\d+\.\d+\.\d+\.)\S*\s+(\S+)\s+(.*)\s+(\d+)\s*([HE]*)\s*$/;
		# print "class=$class rep=$rep from $_";
		$class{$rep}=$class; $ix{$rep}=$ix; $compnd{$rep}=$compnd; $nres{$rep}=$nres; $dssp{$rep}=$dssp;
	}
	close(IN);
	# get founder,date of each rep
	foreach (keys(%class)) {
		($cd1)=/^(\w+)/; ($short)=/^(\w{4})/;
		$class=$class{$_}; $count{$class}++;
		(@homologs)=split(/\s+/,$hom{$short});
		$oldest=9999; $founder='';
		foreach $cd (@homologs) {
			if($rank{$cd}<$oldest) {
				$oldest=$rank{$cd};
				$founder=$cd;
			}
		}
		$daterank{$short}=$oldest;
		$founder{$short}=substr($founder,$[,4);
		if(!defined($rank{$class}) || ($daterank{$short} < $rank{$class})) {
			$rank{$class}=$daterank{$short};
			$founder{$class}=$founder{$short};
		}
		# print "$short -> daterank $daterank{$short} from $oldest; class $class -> $rank{$class}\n";
		# print "founder of $_ ($hom{$short}) -> $short -> $founder{$short}; $class -> $founder{$class}\n";
	}
	# renumber classes sorted by size by date
	foreach(keys(%count)) {
		$count{$_}+=(1-$daterank{$founder{$_}}/100000);
	}
	$i=0;
	foreach (sort {$count{$b}<=>$count{$a}} keys(%count)) {
		$i++; $newclass{$_}=$i;
		print "newclass $_ $count{$_} -> $i\n";
	}
	# write FSSP_TREE_TABLE.rdb
	open(OUT,'>tmp.rdb');
	foreach $rep (keys(%class)) {
		$_=$rep; ($short)=/^(\w{4})/;
		(@x)=split(/\./,$ix{$rep});
		$x=join(' ',$newclass{$class{$rep}},@x);
		print OUT "$x\t$founder{$class{$rep}}\t$founder{$short}\t$newclass{$class{$rep}}$ix{$rep}\t$rep\t$compnd{$rep}\t$nres{$rep}\t$dssp{$rep}\n";
	}
	close(OUT);
	# sort table by class
	open(IN,'sort -n +0 +1 +2 +3 tmp.rdb|');
	open(OUT,'>FSSP_TREE_TABLE.rdb');
	print OUT "# Perl-RDB\nClassfounder\tFounder\tClass\tDomain\tCompound\tnres\tdssp\n";
	print OUT "4s\t4s\t16s\t6s\t40s\t3d\t10s\n";
	while(<IN>) {
		chop;
		next if(!/[a-z]/);
		($x,@x)=split(/\t/);
		print OUT join("\t",@x),"\n";
	}
	close(IN); close(OUT);
}


#________________________________________________________________________________
# Title     : ProteoSeq
# Usage     : &ProteoSeq(\%ProteoSeqVariables);
# Function  :
# Example   :
# Keywords  : NetBioServer, ProSeq, GenoSeq
# Options   :
# Author    : jong@salt2.med.harvard.edu
# Version   : 1.5
#--------------------------------------------------------------------------------
sub ProteoSeq{

    my($PROGRAM, $DATALIB, $gappedAlignmentOption, $INPUT_TYPE, $SEQUENCE,
         $EXPECT, $FILTER, $DESCRIPTIONS, $ALIGNMENTS, $graphicalOverviewOption,
         $GENETICS_CODE, $OTHER_ADVANCED, $i, $j, %URI_param_keys_and_values,
         @Search_result, $E_THRESH, $local_hostname, $target_server_IP, $SEARCH_INTERVAL,
         $step_number, %blast_output_in_MSP, $SEQ_NAME, %ProteoSeqVariables,
         $interval_directory, $SERVER_PORT, $HTTP_HOST, $step_num_LIMIT,
         $evalue_thresh, %param_keys_and_values, $result_ROOT_URL_name_base,
         $HTTP_REFERER_base, @NO_new_HIT_case_result_URL_summary,
         $URL_for_result_HTML_file, $URL_for_result_MSP_file, $iteration_count);
    my $blastServerURL = $blastServerURLdefault   ='www.ncbi.nlm.nih.gov/cgi-bin/BLAST/nph-newblast';
    my $psi_blastServer_URL=$blastServerURLdefault='www.ncbi.nlm.nih.gov/cgi-bin/BLAST/nph-psi_blast';


    $evalue_thresh=0.0005; ## for parsing BLAST result
    $Percent_similarity=80; # for comparing the new seq_regions with old seq_regions
    $local_hostname    =${&get_hostname}; # 'cyrah.med.harvard.edu';
    $target_server_IP  ='www.ncbi.nlm.nih.gov';
    %ProteoSeqVariables  =%{$_[0]};
    $SERVER_PORT =$ENV{SERVER_PORT};
    $HTTP_HOST   =$ENV{HTTP_HOST};
    $HTTP_REFERER=$ENV{HTTP_REFERER};
    $REQUEST_URI =$ENV{REQUEST_URI};

    # HTTP_REFERER http://cyrah.ebi.ac.uk:1111/Proj/Bio/ProteoSeq/ProteoSeq.html
    if($HTTP_REFERER=~/^ *(\S+)\/[^\/]+ *$/){
        $HTTP_REFERER_base=$1;
    }else{
        die "failed to pattern match $HTTP_REFERER   $HTTP_REFERER_base\n";
    }

    open(SERVER_INFORMATION_file, ">SERVER_INFORMATION_file.txt");
    # REQUEST_URI /Proj/Bio/NetBioServ/NetBioServer.cgi
    # HTTP_REFERER http://cyrah.ebi.ac.uk:1111/Proj/Bio/NetBioServ/NetBioServer.html
    print SERVER_INFORMATION_file "HTTP_HOST $HTTP_HOST\nHTTP_REFERER $HTTP_REFERER\nREQUEST_URI $REQUEST_URI\nSERVER_PORT $SERVER_PORT";
    close(SERVER_INFORMATION_file);

    $SEQ_NAME       =$ProteoSeqVariables{SEQ_NAME};
    $SEARCH_INTERVAL=$ProteoSeqVariables{SEARCH_INTERVAL};
    $algorithm      ='PSI_BLAST';
    $step_number    =1;
    $step_num_LIMIT =2;
    $iteration_count=1;

    $web_user_dir_name=$ProteoSeqVariables{USER}; ## This is usually 'nobody'
    $USER_NAME_dir    ="$web_user_dir_name\/$ProteoSeqVariables{USER_NAME}"; ## This is usually email address 'sat@bio.com'
    if($SEARCH_INTERVAL=~/DAY/i){ $interval_directory      ="$USER_NAME_dir\/Daily";
    }elsif($SEARCH_INTERVAL=~/WEEK/i){  $interval_directory="$USER_NAME_dir\/Weekly";
    }elsif($SEARCH_INTERVAL=~/MONTH/i){ $interval_directory="$USER_NAME_dir\/Monthly"; }
    $seq_dir_name     ="$interval_directory\/$ProteoSeqVariables{SEQ_NAME}";      ## This is

    if(!$web_user_dir_name or !$seq_dir_name){ print "\n \$web_user_dir_name or \$seq_dir_name are empty, dying<br>"; exit }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Making User and Sequence directory
    #___________________________________________________________________________
    print "\n<hr>>>> Making $web_user_dir_name, <br> $USER_NAME_dir <br> $interval_directory and $seq_dir_name\n<br>";
    mkdir($web_user_dir_name, 0777)  unless -d $web_user_dir_name;
    mkdir($USER_NAME_dir, 0777) unless -d $USER_NAME_dir;
    mkdir($interval_directory, 0777) unless -d $seq_dir_name;
    mkdir($seq_dir_name , 0777) unless -d $seq_dir_name;
    $result_file_name_base="$seq_dir_name\/$ProteoSeqVariables{SEQ_NAME}";
    $result_HTML_file_name="$result_file_name_base\.html";
    $result_MSP_file_name ="$result_file_name_base\.msp";  # <----------- MSP file format writing
    $result_ROOT_URL_name_base="$HTTP_REFERER_base\/$result_file_name_base"; ## http:/xxxx/Proj/Bio/ProteoSeq/nobody/...
    $URL_for_result_HTML_file="$result_ROOT_URL_name_base\.html";
    $URL_for_result_MSP_file="$result_ROOT_URL_name_base\.msp";

    %URI_param_keys_and_values=(
				'PROGRAM'=>'blastp', ## even PSI-blast uses 'blastp' not 'blastpgp' !!
                'DATALIB'=>'nr',
                'E_THRESH'=>$evalue_thresh,   # for PSI blast
				'STEP_NUMBER'=>$step_number,     # for PSI blast
				'INPUT_TYPE'=>"sequence in fasta format",
                'SEQ_NAME'=>"$SEQ_NAME",  ## I am not sure about this value(total guess)
                'USER_NAME'=>"$ProteoSeqVariables{USER_NAME}",  ## I am not sure about this value(total guess)
				'QUERY'=>"$ProteoSeqVariables{SEQ_NAME}",     ## I am not sure about this value(total guess)
				'GAPPED_ALIGNMENT'=>'is_set',
                'SEQUENCE'=>"$ProteoSeqVariables{SEQUENCE}",
				'EXPECT'=>1,
				'FILTER'=>'default',
				'DESCRIPTIONS'=>100,
				'ALIGNMENTS'=>100,
				'OVERVIEW'=>'is_set',
				'GENETICS_CODE'=>1,
				'OTHER_ADVANCED'=>'',
				'HTML'=>'',
				'MAXLENGTH'=>10,
				'local_hostname'=>'cyrah.ebi.ac.uk',
				'target_server_IP'=>'www.ncbi.nlm.nih.gov',
				'file_handle'=>'SOCKET_FOR_POST',
				'port'=>80,
				'resultTypeOption'=>''); ## $resultTypeOption'="HTML=is_set";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # I write the seq. fasta file at ~/Proj/Bio/NetBioServ/Jong/, while Jong is the user name
    #______________________________________________________________________________________________________
    open(FASTA_SEQ_FILE, ">$seq_dir_name\/$SEQ_NAME\.spfa") || die "\n Can not open $seq_dir_name\.spfa \n";
    print FASTA_SEQ_FILE "\>$ProteoSeqVariables{\"SEQ_NAME\"}\n$ProteoSeqVariables{\"SEQUENCE\"}";
    close(FASTA_SEQ_FILE);

    open(RESULT, ">$result_HTML_file_name") || die "\n Can not open $result_HTML_file_name\n\n";
    print RESULT "\n<html><br><B><FONT color=\"red\"> USER NAME:  $USER_NAME_email <br>";
    print RESULT "Here is the FINAL result of ProteoSeq for your\n<br>Query=$SEQ_NAME
                  for periodic search: $time_interval<\/FONT><\/B><br>";

    $seq_leng=length($ProteoSeqVariables{'SEQUENCE'});
    if($ProteoSeqVariables{'SEQ_LENG_LIMIT'} > $seq_leng){
        print "<br><br>ERROR: Your sequence length is shorter than the minimum sequence length SEQ_LENG_LIMIT<br>\n\n";
        die;
    }

   ITERATION_POINT:
    $URI_content=${&generate_URI_content_line(\%URI_param_keys_and_values)};
    $URI_length=length($URI_content);

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
    # Opening the NET connection
    #_____________________________________________________
    $SOCKET_FILEHANDLE=${&open_socket("H=$local_hostname", "S=$target_server_IP", "FH=$file_handle", "P=$port")};

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Build the HTTP POST object.  Actual Writing part
    #___________________________________________________________
    if($algorithm eq 'PSI_BLAST'){
        if($step_number > 1){
            $blast_path='/cgi-bin/BLAST/nph-psi_blast/'."step${step_number}";
            $URI_param_keys_and_values{'NEXT_I'}="\"Run PSI-Blast iteration $step_number\"";
        }else{
            $blast_path='/cgi-bin/BLAST/nph-psi_blast/';
        }
    }else{   $blast_path='/cgi-bin/BLAST/nph-newblast'; }

    &write_to_www_socket_filehandle($SOCKET_FILEHANDLE, $blast_path, $URI_length, $URI_content);

    $initial_response = <$SOCKET_FILEHANDLE>;
    #print "\n The response from the server:=> $initial_response  From Step: $step_number\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Putting the result of server came through the socket to a big ARRAY: @Search_result
    #____________________________________________________________________________________________
    @Search_result = (<$SOCKET_FILEHANDLE>); ## <-- this works, but not <"$SOCKET_FILEHANDLE">

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Retrieve Keys and values for next search etc (near to the end of the result from server)
    #________________________________________________________________________________________________________
    for($i=(@Search_result-100); $i< @Search_result; $i++){
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # matching: <INPUT TYPE="hidden" NAME= "file_handle" VALUE="SOCKET_FOR_POST">
         #__________________________________________________________________________________________
         if($Search_result[$i]=~/\<INPUT .+NAME *= *\"(\S+)\" +VALUE *= *\"?([^\>]+)\"? *\>\<?/i){
              $param_keys_and_values{$1}=$2;
              #print "Matching output:  $1 $2\n";
         }elsif($Search_result[$i]=~/\<H2\>.+\<\/H2\>/i){ ## removing the line "<H2> Commencing search, please wait for results.</H2>
              $Search_result[$i]=~s/\<H2\>.+\<\/H2\>//i;
         }elsif($Search_result[$i]=~/BGCOLOR/i){
              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              # changing background color according to the iteration
              #____________________________________________________________________________________________
              $Search_result[$i]=~s/BGCOLOR=\"#FFFFFF/BGCOLOR=\"#\F$iteration_count\FFDC/;
         }
    }

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
    # (!) Here, I add PSI_MATRIX to the query web URI socket so that PSI-blast use it for next iteration
    #_________________________________________________________________________________________________________
    $URI_param_keys_and_values{'PSI_MATRIX'}=$param_keys_and_values{PSI_MATRIX};

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # Check the step number and finishes if the step was equal to $step_limit
     #________________________________________________________________________________
     if($iteration_count < $step_num_LIMIT){
            #print "\n Iterating again as \$iteration_count $iteration_count < \$step_num_LIMIT $step_num_LIMIT\n\n";
            open(RESULT_FOR_EACH_ITERATION, ">$result_file_name_base\_$iteration_count\.html") || die;
            print RESULT_FOR_EACH_ITERATION "\n<html><br><FONT color=\"red\"> USER NAME:  $USER_NAME_email <br>";
            print RESULT_FOR_EACH_ITERATION "Here is the 1st result of ProteoSeq for your\n<br>Query=$SEQ_NAME
                                             for periodic search: $time_interval<\/FONT><br>";
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # I write the search result file at ~/Proj/Bio/NetBioServ/Jong/128U_DROME_Jong, while Jong is the user name
            #______________________________________________________________________________________________________
            for($i=0; $i< @Search_result; $i++){
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Adding  http:\/\/$target_server_IP to /htbin-post/Entrez/query?f etc
                 #____________________________________________________________________________
                 $Search_result[$i]=~s/ACTION=\"\/cgi-bin/ACTION=\"http:\/\/$target_server_IP\/cgi-bin/g;
                 $Search_result[$i]=~s/href=\"\/htbin-post\//href=\"http:\/\/$target_server_IP\/htbin-post\//g;
                 $Search_result[$i]=~s/\<IMG SRC=\"\S+.gif\" [^\>]+\>//ig;  ## removing Image links <IMG SRC="/BLAST/psi_blast.gif" BORDER=0 ISMAP></A>
                 #print $Search_result[$i];
                 print RESULT_FOR_EACH_ITERATION $Search_result[$i];
            }
            close(RESULT_FOR_EACH_ITERATION);

            $URL_for_result_HTML_file_previous_iteration="$result_ROOT_URL_name_base\_$iteration_count\.html";
            push(@NO_new_HIT_case_result_URL_summary,
                 ">$SEQ_NAME\tResult for $iteration_count iteration:\n$URL_for_result_HTML_file_previous_iteration\n");
            $iteration_count++;
            $URI_param_keys_and_values{STEP_NUMBER}=$iteration_count;
            goto ITERATION_POINT;

     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # When $iteration_count has reached the TARGET ITERATION
     #________________________________________________________________________
     }elsif($step_num_LIMIT >= $iteration_count){
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # I write the search result file at ~/Proj/Bio/NetBioServ/Jong/128U_DROME_Jong, while Jong is the user name
            #______________________________________________________________________________________________________
            for($i=0; $i< @Search_result; $i++){
                 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                 # Adding  http:\/\/$target_server_IP to /htbin-post/Entrez/query?f etc
                 #____________________________________________________________________________
                 $Search_result[$i]=~s/ACTION=\"\/cgi-bin/ACTION=\"http:\/\/$target_server_IP\/cgi-bin/g;
                 $Search_result[$i]=~s/href=\"\/htbin-post\//href=\"http:\/\/$target_server_IP\/htbin-post\//g;
                 $Search_result[$i]=~s/\<IMG SRC=\"\S+.gif\" [^\>]+\>//ig;  ## removing Image links <IMG SRC="/BLAST/psi_blast.gif" BORDER=0 ISMAP></A>
                 if($Search_result[$i]=~/\<H2\>.+\<\/H2\>/i){ ## removing the line "<H2> Commencing search, please wait for results.</H2>
                      $Search_result[$i]=~s/\<H2\>.+\<\/H2\>//i;
                 }elsif($Search_result[$i]=~/BGCOLOR/i){
                      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                      # changing background color according to the iteration
                      #____________________________________________________________________________________________
                      $Search_result[$i]=~s/BGCOLOR=\"#FFFFFF/BGCOLOR=\"#\F$iteration_count\FFCD/;
                 }
                 #print $Search_result[$i];
                 print RESULT $Search_result[$i];
            }
            close(RESULT);

            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # Reads the old MSP file contents to compare with new ones
            #__________________________________________________________________
            #print "\n\n Calling open_mspa_files with (old) $result_MSP_file_name \$iteration_count : $iteration_count \n";
            if(-s $result_MSP_file_name){
                %Old_MSP_data=%{&open_mspa_files(\$result_MSP_file_name)};
            }else{
                print "\n $0 : open_mspa_files did not detect $result_MSP_file_name. I guess this is the first time run\n\n";
            }
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            # converting the BLAST result to MSP file format
            #____________________________________________________________________
            print "\n<br>\n Calling convert_bla_HTML_to_mspa \n";
            $which_iteration=1;
            $accumulative_hits_eval_thresh=$evalue_thresh/100;
            $Accumulate_matches='A';
            %blast_output_in_MSP=%{&convert_bla_HTML_to_msp(\$result_HTML_file_name,
                                                  "SEQ_NAME=$SEQ_NAME",
                                                  $pdbd_seq_only,
                                                  "i=$which_iteration",
                                                  "e=$accumulative_hits_eval_thresh",
                                                  "E=$evalue_thresh",
                                                  $take_only_the_last_iteration,
                                                  $report_only_the_best,
                                                  $genome_seq_only,
                                                  $nrdb_seq_only,
                                                  $all_seq,
                                                  $Accumulate_matches,
                                                  $verbose )};
            #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
            # Check if the SEARCH was NEW or not. If not, COMPARE with the ole one
            #_________________________________________________________________________
            if(!%Old_MSP_data){
                #print "\n No old MSP result found, writing  $result_MSP_file_name with write_mspa_files\n\n";
                &write_mspa_files(\%blast_output_in_MSP, "o=$result_MSP_file_name");
                chmod (0777, $result_MSP_file_name);
                push(@NO_new_HIT_case_result_URL_summary,
                     ">$SEQ_NAME\tResult for $iteration_count iteration:\n$URL_for_result_HTML_file $URL_for_result_MSP_file\n");
            }else{
                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                # Comparing the results with the result of the previous run
                #_____________________________________________________________________
                $Percent_similarity=90;
                $num_of_new_match=@Comp_result=@{&compare_MSP_hash_data(\%Old_MSP_data,
                                                         \%blast_output_in_MSP,
                                                         "Percent_similarity=$Percent_similarity")};
                if($num_of_new_match > 0){
                    &write_mspa_files(\%blast_output_in_MSP, $result_MSP_file_name);
                    push(@NO_new_HIT_case_result_URL_summary,
                         "New Finding! \(^o^)/ Look at:\n>$SEQ_NAME\tResult for $iteration_count iter:\n$URL_for_result_HTML_file\n");
                    push(@NO_new_HIT_case_result_URL_summary,
                         "The summary MSP file is :\n$URL_for_result_MSP_file\n\n ====NEXT====\n\n");
                }else{  print "\n No new hit found \n";
                    push(@NO_new_HIT_case_result_URL_summary,
                         "NO New Finding!, Sorry.\n>$SEQ_NAME\tResult for $iteration_count iter:\n$URL_for_result_HTML_file\n");
                    push(@NO_new_HIT_case_result_URL_summary,
                         "The summary MSP file is :\n$URL_for_result_MSP_file\n\n ====NEXT====\n\n");
                }
            }
     }
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     # Processing the result and send email
     #______________________________________________________
     if($NO_new_HIT_case_result_URL_summary[0]=~/\/([^\/]+\@[^\/]+\.[^\/]+)\/(\S+) */){
        $USER_NAME_email=$1;
        $from='jong@ebi.ac.uk';
        $subject="Result of $2";

        $Result_Intro="
        Dear ProSeq user,\n
        Here is the result of $SEQ_SERVER_NAME which will automatically search for
        new sequences for you by using the PSI-Blast iterative algorithm
        at \"$step_num_LIMIT\" iteration level. Please contact for any bug report
        or suggestions to park\@proseq.med.harvard.edu, or flugel\@proseq.med.harvard.edu

        The resulting HTML files with iteration number is for each iteration.
        Without them is the final result which is the most useful\n
        Yours auomatically,\n
        ";
        &send_email($USER_NAME_email, $subject, $from,
                    $Result_Intro, @NO_new_HIT_case_result_URL_summary);
        #print "<hr>@NO_new_HIT_case_result_URL_summary<br>";
     }else{
        print "\n I could not pattern match \n$NO_new_HIT_case_result_URL_summary[0]\n";
     }
     print "<hr> $0 has finished. Check you mail ($USER_NAME_email) to see the result<br>";
}


#______________________________________________________________________________
# Title     : ProteoSeq_cron(<time_interval>, <ProteoSeq_dir>, <HTTP_referer_base>);
# Usage     :
# Function  :
# Example   :
#     @resulting_string=&ProteoSeq_cron(\$time_interval, \$ProSeq_dir,
#                                       \$HTTP_REFERER_base, \$step_num_LIMIT);
# Keywords  : ProSeq, GenoSeq
# Options   :
#  $time_interval= by t=
#  $ProSeq_dir= by d=
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.4
#------------------------------------------------------------------------------
sub ProteoSeq_cron{
    my($num, $file, @read_files, $time_interval, $ProSeq_dir, $target_server_IP,
       $algorithm, $iteration_count, $local_hostname, $step_num_LIMIT,
       $result_HTML_file_name, $result_MSP_file_name, %Old_MSP_data,
       $USER_NAME_email, $HTTP_HOST, $HTTP_REFERER, $REQUEST_URI, $initial_response,
       $SERVER_PORT, $URL_ROOT, @included_files,$SERVER_INFORMATION_file,
       $original_dir, $each_file, @NO_new_HIT_case_result_URL_summary,
       $from, $result_ROOT_URL_name_base, $result_file_name_base,
       $URL_for_result_HTML_file_previous_iteration, $HTTP_REFERER_base,
       %param_keys_and_values, $evalue_thresh, $Percent_similarity);

    $evalue_thresh=0.001; ## for parsing BLAST result
    $time_interval=${$_[0]} || $_[0];
    $ProSeq_dir=${$_[1]} || $_[1];
    $HTTP_REFERER_base=${$_[2]};
    $step_num_LIMIT=${$_[3]};

    $target_server_IP  ='www.ncbi.nlm.nih.gov';
    $algorithm='PSI_BLAST';
    $step_num_LIMIT=2 if $step_num_LIMIT < 1;
    $local_hostname    =${&get_hostname}; # 'cyrah.med.harvard.edu';

    if(-d ${$_[1]}){ $original_dir=${$_[1]};
        @read_files=@{&read_any_dir_simple(\$original_dir)};
		sub read_any_dir_simple { my($in_dir); $in_dir=${$_[0]} || $_[0]; opendir(DIR1,"$in_dir");
		    my(@read_files) = readdir(DIR1);closedir(DIR1);	splice(@read_files, 0, 2);  return(\@read_files); }
	}else{
	    print "\n Error, ${$_[1]} is not a directory\n\n"; die;
	}

    foreach $file(@read_files){
         $each_file="$original_dir/$file";

         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (1) If the File read is DIR => Recurse
         #________________________________________________________
         if( -d "$each_file" ){  ## If it is a directory.
              print ">DIR: $each_file \n";
              $num=@NO_new_HIT_case_result_URL_summary=(@NO_new_HIT_case_result_URL_summary,
                                                        &ProteoSeq_cron(\$time_interval,
                                                                        \$each_file,
                                                                        \$HTTP_REFERER_base,
                                                                        \$step_num_LIMIT) );   # RECURSION occurrs here!!
         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # (2) If the File read is FILE => /ProteoSeq/nobody/jong@ebi.ac.uk/Weekly/test/test.spfa
         #________________________________________________________________________________________
         }elsif (-f $each_file and $each_file=~/^ *(\S+\/(\S+\/(\S+)\/\S+\/\S+\/\S+))\.spfa$/){     #<<------ This is where things match
              my($SEQUENCE, $USER_NAME_email, $iteration_count, %URI_param_keys_and_values);
              print ">FILE: $each_file \$URL_ROOT: $HTTP_REFERER_base \n";
              $iteration_count=1;
              $result_file_name_base=$1;
              $output_HTML_file=$result_HTML_file_name="$result_file_name_base\.html";
              $result_MSP_file_name=$output_MSP_file="$result_file_name_base\.msp";
              $result_ROOT_URL_name_base="$HTTP_REFERER_base\/$2";
              $URL_for_result_HTML_file ="$result_ROOT_URL_name_base\.html";
              $URL_for_result_MSP_file  ="$result_ROOT_URL_name_base\.msp";
              $USER_NAME_email="$3";
              @dir=split(/\//, $each_file);
              $dir=$dir[($#dir-1)];  # $dir is the name of the subdirectory where you are in.
              print "\n Openning  $each_file with $USER_NAME_email $dir\n --> @read_files\n";

              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
              # Check if the Time interval is correct 'Weekly' 'Daily' etc. Otherwise, look for another sequenc file(FASTA)
              #________________________________________________________________________________________________________________
              if($time_interval=~/$dir[$#dir-2]/){
                  print "\n \$time_interval $time_interval:  $dir[$#dir-2] \n";
                  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                  # Open the query FASTA file and Resulting HTML file
                  #______________________________________________________
                  ($SEQ_NAME, $SEQUENCE)=%{&open_fasta_files($each_file)};
                  open(RESULT, ">$result_HTML_file_name") || die "\n Can not open $result_HTML_file_name\n\n";
                  print RESULT "\n<html><br><B><FONT color=\"red\"> USER NAME:  $USER_NAME_email <br>";
                  print RESULT "Here is the FINAL result of ProteoSeq for your\n<br>Query=$SEQ_NAME
                                for periodic search: $time_interval<\/FONT><\/B><br>";

                  %URI_param_keys_and_values=(
                    'PROGRAM'=>'blastp', ## even PSI-blast uses 'blastp' not 'blastpgp' !!
                    'DATALIB'=>'nr',
                    'E_THRESH'=>0.0001,   # for PSI blast
                    'STEP_NUMBER'=>$iteration_count,     # for PSI blast
                    'INPUT_TYPE'=>"sequence in fasta format",
                    'SEQ_NAME'=>"$SEQ_NAME",  ## I am not sure about this value(total guess)
                    'USER_NAME'=>"$USER_NAME_email",  ## I am not sure about this value(total guess)
                    'QUERY'=>"$SEQ_NAME",     ## I am not sure about this value(total guess)
                    'GAPPED_ALIGNMENT'=>'is_set',
                    'SEQUENCE'=>"$SEQUENCE",
                    'EXPECT'=>1,
                    'FILTER'=>'default',
                    'DESCRIPTIONS'=>100,
                    'ALIGNMENTS'=>100,
                    'OVERVIEW'=>'is_set',
                    'GENETICS_CODE'=>1,
                    'OTHER_ADVANCED'=>'',
                    'HTML'=>'',
                    'MAXLENGTH'=>10,
                    'local_hostname'=>'cyrah.ebi.ac.uk',
                    'target_server_IP'=>'www.ncbi.nlm.nih.gov',
                    'file_handle'=>'SOCKET_FOR_POST',
                    'port'=>80,
                    'resultTypeOption'=>''); ## $resultTypeOption'="HTML=is_set";


                  ITERATION_POINT:
                    $URI_content=${&generate_URI_content_line(\%URI_param_keys_and_values)};
                    $URI_length=length($URI_content);

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
                    # Opening the NET connection
                    #_____________________________________________________
                    #print "\n Calling  open_socket with $local_hostname, $target_server_IP, $port \n";
                    $SOCKET_FILEHANDLE=${&open_socket("H=$local_hostname", "S=$target_server_IP", "FH=$file_handle", "P=$port")};

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Build the HTTP POST object.  Actual Writing part
                    #___________________________________________________________
                    if($algorithm eq 'PSI_BLAST'){
                        if( $iteration_count > 1){
                             $blast_path='/cgi-bin/BLAST/nph-psi_blast/'."step${iteration_count}";
                             $URI_param_keys_and_values{'NEXT_I'}="\"Run PSI-Blast iteration $iteration_count\"";
                        }else{
                             $blast_path='/cgi-bin/BLAST/nph-psi_blast/';
                        }
                    }else{   $blast_path='/cgi-bin/BLAST/nph-newblast'; }

                    &write_to_www_socket_filehandle($SOCKET_FILEHANDLE, $blast_path, $URI_length, $URI_content);

                    $initial_response = <$SOCKET_FILEHANDLE>;
                    print "\n The response from the server:=> $initial_response  Target Step No.: $iteration_count\n";

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Putting the result of server came through the socket to a big ARRAY: @Search_result
                    #____________________________________________________________________________________________
                    @Search_result = (<$SOCKET_FILEHANDLE>); ## <-- this works, but not <"$SOCKET_FILEHANDLE">

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Retrieve Keys and values for next search etc (near to the end of the result from server)
                    #________________________________________________________________________________________________________
                    for($i=(@Search_result-150); $i< @Search_result; $i++){
                         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                         # matching: <INPUT TYPE="hidden" NAME= "file_handle" VALUE="SOCKET_FOR_POST">
                         #__________________________________________________________________________________________
                         if($Search_result[$i]=~/\<INPUT .+NAME *= *\"(\S+)\" +VALUE *= *\"?([^\>]+)\"? *\>\<?/i){
                              $param_keys_and_values{$1}=$2;
                              #print "Matching output:  $1 $2\n";
                         }elsif($Search_result[$i]=~/\<H2\>.+\<\/H2\>/i){ ## removing the line "<H2> Commencing search, please wait for results.</H2>
                              $Search_result[$i]=~s/\<H2\>.+\<\/H2\>//i;
                         }elsif($Search_result[$i]=~/BGCOLOR/i){
                              #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                              # changing background color according to the iteration
                              #____________________________________________________________________________________________
                              $Search_result[$i]=~s/BGCOLOR=\"#FFFFFF/BGCOLOR=\"#\F$iteration_count\FFDC/;
                         }
                    }
                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``
                    # (!) Here, I add PSI_MATRIX to the query web URI socket so that PSI-blast use it for next iteration
                    #_________________________________________________________________________________________________________
                    $URI_param_keys_and_values{'PSI_MATRIX'}=$param_keys_and_values{PSI_MATRIX};

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # Check the step number and finishes if the step was equal to $step_limit
                    #________________________________________________________________________________
                    if($iteration_count < $step_num_LIMIT){
                           print "\n Iterating again as \$iteration_count $iteration_count < \$step_num_LIMIT $step_num_LIMIT\n\n";
                           open(RESULT_FOR_EACH_ITERATION, ">$result_file_name_base\_$iteration_count\.html") || die;
                           print RESULT_FOR_EACH_ITERATION "\n<html><br><FONT color=\"red\"> USER NAME:  $USER_NAME_email <br>";
                           print RESULT_FOR_EACH_ITERATION "Here is the 1st result of ProteoSeq for your\n<br>Query=$SEQ_NAME
                                                            for periodic search: $time_interval<\/FONT><br>";
                           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                           # I write the search result file at ~/Proj/Bio/NetBioServ/Jong/128U_DROME_Jong, while Jong is the user name
                           #______________________________________________________________________________________________________
                           for($i=0; $i< @Search_result; $i++){
                                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                # Adding  http:\/\/$target_server_IP to /htbin-post/Entrez/query?f etc
                                #____________________________________________________________________________
                                $Search_result[$i]=~s/ACTION=\"\/cgi-bin/ACTION=\"http:\/\/$target_server_IP\/cgi-bin/g;
                                $Search_result[$i]=~s/href=\"\/htbin-post\//href=\"http:\/\/$target_server_IP\/htbin-post\//g;
                                $Search_result[$i]=~s/\<IMG SRC=\"\S+.gif\" [^\>]+\>//ig;  ## removing Image links <IMG SRC="/BLAST/psi_blast.gif" BORDER=0 ISMAP></A>
                                #print $Search_result[$i];
                                print RESULT_FOR_EACH_ITERATION $Search_result[$i];
                           }
                           close(RESULT_FOR_EACH_ITERATION);

                           $URL_for_result_HTML_file_previous_iteration="$result_ROOT_URL_name_base\_$iteration_count\.html";
                           push(@NO_new_HIT_case_result_URL_summary,
                                ">$SEQ_NAME\tResult for $iteration_count iteration:\n$URL_for_result_HTML_file_previous_iteration\n");
                           $iteration_count++;
                           $URI_param_keys_and_values{STEP_NUMBER}=$iteration_count;
                           goto ITERATION_POINT;

                    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    # When $iteration_count has reached the TARGET ITERATION
                    #________________________________________________________________________
                    }elsif($step_num_LIMIT >= $iteration_count){
                           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                           # I write the search result file at ~/Proj/Bio/NetBioServ/Jong/128U_DROME_Jong, while Jong is the user name
                           #______________________________________________________________________________________________________
                           for($i=0; $i< @Search_result; $i++){
                                #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                # Adding  http:\/\/$target_server_IP to /htbin-post/Entrez/query?f etc
                                #____________________________________________________________________________
                                $Search_result[$i]=~s/ACTION=\"\/cgi-bin/ACTION=\"http:\/\/$target_server_IP\/cgi-bin/g;
                                $Search_result[$i]=~s/href=\"\/htbin-post\//href=\"http:\/\/$target_server_IP\/htbin-post\//g;
                                $Search_result[$i]=~s/\<IMG SRC=\"\S+.gif\" [^\>]+\>//ig;  ## removing Image links <IMG SRC="/BLAST/psi_blast.gif" BORDER=0 ISMAP></A>
                                if($Search_result[$i]=~/\<H2\>.+\<\/H2\>/i){ ## removing the line "<H2> Commencing search, please wait for results.</H2>
                                     $Search_result[$i]=~s/\<H2\>.+\<\/H2\>//i;
                                }elsif($Search_result[$i]=~/BGCOLOR/i){
                                     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                     # changing background color according to the iteration
                                     #____________________________________________________________________________________________
                                     $Search_result[$i]=~s/BGCOLOR=\"#FFFFFF/BGCOLOR=\"#\F$iteration_count\FFCD/;
                                }
                                #print $Search_result[$i];
                                print RESULT $Search_result[$i];
                           }
                           close(RESULT);

                           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                           # Reads the old MSP file contents to compare with new ones
                           #__________________________________________________________________
                           print "\n\n Calling open_mspa_files with (old) $result_MSP_file_name \$iteration_count : $iteration_count \n";
                           if(-s $result_MSP_file_name){
                               %Old_MSP_data=%{&open_mspa_files(\$result_MSP_file_name)};
                           }else{
                               print "\n $0 : open_mspa_files did not detect $result_MSP_file_name. I guess this is the first time run\n\n";
                           }
                           #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                           # converting the BLAST result to MSP file format
                           #____________________________________________________________________
                           print "\n\n Calling convert_bla_HTML_to_mspa \n";
                           $which_iteration=1;
                           $accumulative_hits_eval_thresh=$evalue_thresh/100;
                           $Accumulate_matches='A';
                           %blast_output_in_MSP=%{&convert_bla_HTML_to_msp(\$result_HTML_file_name,
                                                                 "SEQ_NAME=$SEQ_NAME",
                                                                 $pdbd_seq_only,
                                                                 "i=$which_iteration",
                                                                 "e=$accumulative_hits_eval_thresh",
                                                                 "E=$evalue_thresh",
                                                                 $take_only_the_last_iteration,
                                                                 $report_only_the_best,
                                                                 $genome_seq_only,
                                                                 $nrdb_seq_only,
                                                                 $all_seq,
                                                                 $Accumulate_matches,
                                                                 $verbose )};

                           if(!%Old_MSP_data){
                               print "\n No old MSP result found, writing  $result_MSP_file_name with write_mspa_files\n\n";
                               &write_mspa_files(\%blast_output_in_MSP, "o=$result_MSP_file_name");
                               chmod (0777, $result_MSP_file_name);
                               push(@NO_new_HIT_case_result_URL_summary,
                                    ">$SEQ_NAME\tResult for $iteration_count iteration:\n$URL_for_result_HTML_file $URL_for_result_MSP_file\n");
                           }else{

                               #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                               # Comparing the results with the result of the previous run
                               #_____________________________________________________________________
                               $Percent_similarity=90;
                               $num_of_new_match=@Comp_result=@{&compare_MSP_hash_data(\%Old_MSP_data,
                                                                        \%blast_output_in_MSP,
                                                                        "Percent_similarity=$Percent_similarity")};
                               if($num_of_new_match > 0){
                                   &write_mspa_files(\%blast_output_in_MSP, $result_MSP_file_name);
                                   push(@NO_new_HIT_case_result_URL_summary,
                                        "New Finding! \(^o^)/ Look at:\n>$SEQ_NAME\tResult for $iteration_count iter:\n$URL_for_result_HTML_file_previous_iteration\n");
                               }else{  print "\n No new hit found \n";
                                   push(@NO_new_HIT_case_result_URL_summary,
                                        "NO New Finding!, Sorry.\n>$SEQ_NAME\tResult for $iteration_count iter:\n$URL_for_result_HTML_file_previous_iteration\n");
                               }
                           }
                           next;
                    }
                    next;
              }else{
                  print "\n Skipping as \$time_interval $time_interval does not match $dir[$#dir-2]\n\n";
                  next;
              }
         }elsif (-l $each_file){
              print "\n\n$each_file is linked, skipping. \n";
              next;
         }
	}
    return(@NO_new_HIT_case_result_URL_summary);
}

#______________________________________________________________________________
# Title     : get_correct_DDD_domain_region_from_alignment
# Usage     : @HOMOL_DDD_ranges=@{&get_correct_DDD_domain_region_from_alignment(
#                                        \$PDB_str_name,
#                                        \$FSSP_homolog_name,
#                                        \%FSSP_alignment_1to1_residue_map,
#                                        \$REP_DDD_range_start,
#                                        \$REP_DDD_range_stop)};
#
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub get_correct_DDD_domain_region_from_alignment{
    my($PDB_str_name, $FSSP_homolog_name, %FSSP_alignment_1to1_residue_map,
       $REP_DDD_range_start, $REP_DDD_range_stop, @HOMOL_DDD_ranges);
    $PDB_str_name=${$_[0]};
    $FSSP_homolog_name=${$_[1]};
    %FSSP_alignment_1to1_residue_map=%{$_[2]};
    $REP_DDD_range_start=${$_[3]};
    $REP_DDD_range_stop =${$_[4]};
    for($i=$REP_DDD_range_start; $i<=$REP_DDD_range_stop; $i++){
       if($HOMOL_DDD_range=$FSSP_alignment_1to1_residue_map{$PDB_str_name}{$FSSP_homolog_name}{$i}){
           push(@HOMOL_DDD_ranges,  $HOMOL_DDD_range);
       }
    }
    return(\@HOMOL_DDD_ranges);
}



#______________________________________________________________________________
# Title     : write_PDC_file
# Usage     :
# Function  :
# Example   :
# Keywords  : write_protein_domain_classification_file write_dali_classification_file
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub write_PDC_file{
    my(@PDC);
    @PDC=@{$_[0]};

    $PDC_file="Protein_Domain_Classification\_$r_average_cutoff.pdc";
    open(PDC, ">$PDC_file") || die "\n Can not open $PDC_file\n\n";
    print PDC "# This is PDC file made by $0\n";
    for($i=0; $i< @PDC; $i++){
       if($PDC[$i]=~/D.C.\d+\.\d+\.\d+/){
           print PDC "$PDC[$i]";
       }
    }
    print "\n $PDC_file has been written\n" if -s $PDC_file;
    close(PDC);
}






#______________________________________________________________________________
# Title     : sort_protein_domain_classification_entries
# Usage     :
# Function  :
# Example   :
# Keywords  : sort_dali_domain_classification sort_DALI
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub sort_protein_domain_classification_entries{
    my(@PDC)=@{$_[0]};
    @PDC= map {$_->[0]} sort { $a->[1] <=> $b->[1]  or
                               $a->[2] <=> $b->[2]  or
                               $a->[3] <=> $b->[3]   }
                               map { [$_,  ($_=~/D.C.(\d+)\.(\d+)\.(\d+)/)] } @PDC;
    return(\@PDC);
}


#______________________________________________________________________________
# Title     : insert_gaps_in_missing_positions
# Usage     : @out=@{&insert_gaps_in_missing_positions(\@input)};
# Function  :
# Example   :
# Keywords  : put_gaps_in_missing_positions, fill_gaps_in_array
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   : ref. of array
# Version   : 1.0
#------------------------------------------------------------------------------
sub insert_gaps_in_missing_positions{
    my(@input_numbers_in_array, $i, $absolute_pos);
    @input_numbers_in_array=@{$_[0]};
    for($i=0; $i < @input_numbers_in_array; $i++){
       $absolute_pos=$i+1;
       if($absolute_pos != $input_numbers_in_array[$i]){
          splice(@input_numbers_in_array, $i, 0, '.');
       }
    }
    return(\@input_numbers_in_array);
}


#______________________________________________________________________________
# Title     : open_herta_files
# Usage     :
# Function  : opening Andreas Heger's Herta search algorithm result file
# Example   : $herta_align_hash{$seq_1_name}{$posi} = -9.99
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.6
#------------------------------------------------------------------------------
sub open_herta_files{
    my($herta_file, $seq_1_name, $seq_2_name, %herta_align_hash,
       $seq_pos_1, $seq_pos_2, $align_score, $abs_position_count,
       @FASTA_ali_info);
    $herta_file=${$_[0]} || $_[0];
    $seq_1_name=1;
    $seq_2_name=2;

    open(HERTA_FILE, "$herta_file") || die "\n Can not open \$herta_file $herta_file\n";
    while(<HERTA_FILE>){
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # mathing :     9    1      0.43
       #__________________________________________________________________
       if(/^\s*(\d+)\s+(\d+)\s+(\S+)/){
          $abs_position_count++;
          $seq_pos_1=$1;
          $seq_pos_2=$2;
          $align_score=$3;
          $herta_align_hash{$seq_1_name}{$seq_pos_1}=$align_score;
          $herta_align_hash{$seq_2_name}{$seq_pos_2}=$align_score;
       #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       # Matching: Alignment: score=138.67 length=164 gaps=42
       #__________________________________________________________________
       }elsif(/Alignment: score=\s*(\S+)\s+length=(\d+)\s+gaps=(\d+)/){
          $herta_align_hash{'RAW_ALIGN_SCORE'}=$1;
          $herta_align_hash{'LENGTH'}=$2;
          $herta_align_hash{'GAPS'}=$3;
       }elsif(/\d+\,/){
          @FASTA_ali_info=$_=~/([\-\d]+)\,/g;
          $herta_align_hash{'ALIGNMENT'}=\@FASTA_ali_info;
       }
    }
    close(HERTA_FILE);
    return(\%herta_align_hash);
}




#______________________________________________________________________________
# Title     : insert_gaps_in_missing_positions_in_herta_hash
# Usage     :
# Function  :
# Example   :
# Keywords  : put_gaps_in_missing_positions_in_herta_hash
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.4
#------------------------------------------------------------------------------
sub insert_gaps_in_missing_positions_in_herta_hash{
    # $herta_align_hash{$seq_1_name}{$seq_pos_1}=$align_score;
    my(%herta_align_hash, $i, $j, $k, @seqnames, @residue_posi, $abs_res_posi,
       $gap_size_overall, $gap_size);
    if(ref($_[0]) eq 'HASH'){
       %herta_align_hash=%{$_[0]};
    }else{
       %herta_align_hash=@_;
    }
    @seqnames=(1,2);
    for($i=0; $i< @seqnames; $i++){
       my($gap_size_overall, $gap_size, $abs_res_posi, $gap_size);
       unless($seqnames[$i]=~/\d/){ next }
       @residue_posi=sort {$a<=>$b} keys %{$herta_align_hash{$seqnames[$i]}};
       #print "\n>$seqnames[$i]\t @residue_posi\n";
       for($j=0; $j < @residue_posi + $gap_size_overall; $j++){
          $abs_res_posi=$j+1+$gap_size_overall;
          #if($abs_res_posi != $residue_posi[$j] and $residue_posi[$j]){
          if($abs_res_posi != $residue_posi[$j]){
              #print "\n !! ABS: $abs_res_posi RES: $residue_posi[$j]\n";
              $gap_size = $residue_posi[$j]-$abs_res_posi;
              $gap_size_overall += $gap_size;
              for($k=0; $k< $gap_size; $k++){
                 print "\n   GAPsize $gap_size:  $abs_res_posi+$k => -9.99"; ## -9.99 means gaps
                 $herta_align_hash{$seqnames[$i]}{$abs_res_posi+$k}=-9.99;
              }
          }
       }
    }
    return(\%herta_align_hash);
}



#______________________________________________________________________________
# Title     : encode_residue_exchange_matrix
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub encode_residue_exchange_matrix{
    my(@scores, @codes, $count, $out_matrix_name, $algorithm,
       $openning_gap_penalty, $elongation_gap_penalty, $seq_1,
       $seq_2, $Matrix_name);

    $Matrix_name=${$_[0]} || $_[0];
    $out_matrix_name="AA_matrix.matx";

    if(!-s $out_matrix_name or $overwrite){
       open(MATRIX_TEXT, "$Matrix_name") || die "\n Can not open $Matrix_name in making AA_matrix.matx";
       open (OUT, ">$out_matrix_name") || die;
    }else{
       print "\n $out_matrix_name already exists, skipping this step \n";
       return(\$out_matrix_name);
    }
    while (<MATRIX_TEXT>) {
        my ($aa1, $aa2, $occ, $score)= /^(\S\S)\s+(\S\S)\s+(\S+)\s+(\S+)/;
        next unless ($aa1);
        push @scores, $score;

        $count ++;
        if ($count >= 400) {
           push (@codes, $aa1);
           print OUT pack ("d400", @scores);
           undef (@scores);
           $count = 0;
        }
    }
    close (OUT);
    close(MATRIX_TEXT);
    print "\n encode_residue_exchange_matrix has finished with $out_matrix_name\n";
    return(\$out_matrix_name);
}



#______________________________________________________________________________
# Title     : show_herta_hash
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub show_herta_hash{
    my(%herta, @keys, $i);
    %herta=%{$_[0]};
    @keys=keys %herta;
    for $keys(@keys){
       print "\n>$keys\n\n";
       if(ref($herta{$keys}) eq 'HASH'){
           @keys2=keys %{$herta{$keys}};
       }elsif(ref($herta{$keys}) eq 'ARRAY'){
           print "\n$keys @{$herta{$keys}}\n";
       }
       for($i=0; $i< @keys2; $i++){
         #print "$keys2[$i]\t $herta{$keys2[$i]}";
         if(ref($herta{$keys2[$i]}) eq 'HASH'){
            @keys3=sort {$a<=>$b} keys %{$herta{$keys2[$i]}};
            print "\n >> SEQNAME: $keys2[$i]  >>\nResidue  AlignScore\n";
            for $key3(@keys3){
               print "$key3\t ${$herta{$keys2[$i]}}{$key3}\n";
            }
            print "\n";
         }
       }
       print "\n";
    }

}



#______________________________________________________________________________
# Title     : remove_low_complexity_seq_regions
# Usage     :
# Function  :
# Example   :
# Keywords  : mask_low_complexity_seq_regions
#             seg_sequences, seq, dust
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub remove_low_complexity_seq_regions{
    my($input_seq, $repeat_residue_threshold);
    $repeat_residue_threshold=5;
    $input_seq=${$_[0]} || $_[0];
    $input_seq =~s/((.+?)\2{$repeat_residue_threshold,})/"x" x length($1)/eg;
    return(\$input_seq);
}

#______________________________________________________________________________
# Title     : mask_low_complexity_seq_regions
# Usage     :
# Function  :
# Example   :
# Keywords  : mask_low_complexity_seq_regions, remove_low_complexity_seq_regions
#             seg_sequences, seq, dust
# Options   :
# Author    : jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.0
#------------------------------------------------------------------------------
sub mask_low_complexity_seq_regions{
    my($input_seq, $repeat_residue_threshold);
    $repeat_residue_threshold=5;
    $input_seq=${$_[0]} || $_[0];
    $input_seq =~s/((.+?)\2{$repeat_residue_threshold,})/"x" x length($1)/eg;
    return(\$input_seq);
}

#______________________________________________________________________________
# Title     : encode_fasta_sequences
# Usage     : ($coded_seq1, $coded_seq1_rv,  $coded_seq2, $coded_seq2_rv)
#                       =@{&encode_fasta_sequences($query_seq_file, $DB_seq_file)};
#
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : heger@ebi.ac.uk jong@biosophy.org,
# Category  :
# Returns   :
# Version   : 1.4
#------------------------------------------------------------------------------
sub encode_fasta_sequences{
    my(@codearray, $seq_1, $seq_2, $i, %codehash, $seq, @seq,
       $coded_seq,  $base, @coded_seq, $coded_seq_rv, @seq_rv,
       $coded_seq_rv, $code_rv, $packed_codes_rv );
    ($seq_1, $seq_2)=(@_);

    #print "\n\t(1) encode_fasta_sequences : Input FASTA sequences are: $seq_1, $seq_2\n";
    @codearray =qw(AA AC AD AE AF AG AH AI AK AL AM AN AP AQ AR AS AT AV AW AY
                   CA CC CD CE CF CG CH CI CK CL CM CN CP CQ CR CS CT CV CW CY
                   DA DC DD DE DF DG DH DI DK DL DM DN DP DQ DR DS DT DV DW DY
                   EA EC ED EE EF EG EH EI EK EL EM EN EP EQ ER ES ET EV EW EY
                   FA FC FD FE FF FG FH FI FK FL FM FN FP FQ FR FS FT FV FW FY
                   GA GC GD GE GF GG GH GI GK GL GM GN GP GQ GR GS GT GV GW GY
                   HA HC HD HE HF HG HH HI HK HL HM HN HP HQ HR HS HT HV HW HY
                   IA IC ID IE IF IG IH II IK IL IM IN IP IQ IR IS IT IV IW IY
                   KA KC KD KE KF KG KH KI KK KL KM KN KP KQ KR KS KT KV KW KY
                   LA LC LD LE LF LG LH LI LK LL LM LN LP LQ LR LS LT LV LW LY
                   MA MC MD ME MF MG MH MI MK ML MM MN MP MQ MR MS MT MV MW MY
                   NA NC ND NE NF NG NH NI NK NL NM NN NP NQ NR NS NT NV NW NY
                   PA PC PD PE PF PG PH PI PK PL PM PN PP PQ PR PS PT PV PW PY
                   QA QC QD QE QF QG QH QI QK QL QM QN QP QQ QR QS QT QV QW QY
                   RA RC RD RE RF RG RH RI RK RL RM RN RP RQ RR RS RT RV RW RY
                   SA SC SD SE SF SG SH SI SK SL SM SN SP SQ SR SS ST SV SW SY
                   TA TC TD TE TF TG TH TI TK TL TM TN TP TQ TR TS TT TV TW TY
                   VA VC VD VE VF VG VH VI VK VL VM VN VP VQ VR VS VT VV VW VY
                   WA WC WD WE WF WG WH WI WK WL WM WN WP WQ WR WS WT WV WW WY
                   YA YC YD YE YF YG YH YI YK YL YM YN YP YQ YR YS YT YV YW YY);

    foreach $i (0..$#codearray) { $codehash{$codearray[$i]} = $i; }

    for $seq_file($seq_1, $seq_2){
        my($seq, @seq, $i);
        $base=${&get_base_names($seq_file)};
        $coded_seq="$base\.cofa"; # COFA : coded Fasta

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        # making rev. seq. cofa file (this is for getting better score
        #___________________________________________________________________
        $coded_seq_rv="$base\_rv.cofa"; # COFA : coded Fasta

        if(-s $coded_seq){ push(@coded_seq, $coded_seq, $coded_seq_rv); next }

        open(CODED_SEQ,    ">$coded_seq") || die "\n Can not open $coded_seq ";
        open(CODED_SEQ_RV, ">$coded_seq_rv") || die "\n Can not open $coded_seq_rv";

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`
        # pipe in sequence in fasta format and print coded sequence on stdout
        #___________________________________________________________________________
        open(SEQ1, "<$seq_file") || die "\n Cannot open $seq_file \n";
        while (<SEQ1>) {
           next if (/^>/);
           chop;
           $seq .= $_;
        }

        $seq =~ s/[\W\s]//g;

        @seq = split (//,$seq);
        @seq_rv=reverse(@seq);

        foreach $i (0..$#seq - 1) {
           $code = $seq[$i] . $seq[$i+1];
           $packed_codes=pack ("i", $codehash{$code});
           print CODED_SEQ $packed_codes;
        }
        close(CODED_SEQ);

        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # Writing reverse coded seq
        #__________________________________________________
        foreach $i (0..$#seq_rv - 1) {
           $code_rv = $seq_rv[$i] . $seq_rv[$i+1];
           $packed_codes_rv=pack ("i", $codehash{$code_rv});
           print CODED_SEQ_RV $packed_codes_rv;
        }
        close(CODED_SEQ_RV);
        push(@coded_seq, $coded_seq, $coded_seq_rv);
    }
    #print "\t(2) encode_fasta_sequences : finished with @coded_seq\n";
    return(\@coded_seq);
}




#______________________________________________________________________________
# Title     : grep_string_in_PDB_file
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.1
#------------------------------------------------------------------------------
sub grep_string_in_PDB_file {
    my($x);
        ($string,$hit)=@_;
        print "<H2>Searching for $string in Protein Index</H2>";
        @list=`grep -i \'$string\' $TABLE2`;       # quote string for .AND.
        #print "grep_string_in_PDB_file: grep -i \'$string\' $TABLE2";
        $x=$#list+1;
        #print ",  $x matches were found. <br><br> Is your DALI_SERVER_HOME variable correct ??\n";
        $hit+=$x;
        if($x>0) {
                print "<PRE>\n$heading";
                foreach ($[..$#list) {
                        $x=$list[$_];
                        # append PDBbrowser crosslink after compound name
                        chop($_=$x); $x=$_;
                        ($beg,$cdx,$rest)=/^(\S+\s+)(\S+)(\s.*)$/;
                        if($cdx=~/\-/) {
                                if(length($cdx)>4) { $cd1=substr($cdx,$[,4).substr($cdx,$[+5,1); } else { $cd1=$cdx; }
                        } else { $cd1=$cdx; }
                        print "$beg<A HREF=$qz3"."filename=$FSSPDIR/$cd1\.fssp>$cdx</A>$rest\n";
                }
        }
        print "</PRE>\n";
}


#______________________________________________________________________________
# Title     : fetch_cd2list
# Usage     :
# Function  :
# Example   :
# Keywords  :
# Options   :
# Author    : holm@ebi.ac.uk,
# Category  :
# Returns   :
# Version   : 1.2
#------------------------------------------------------------------------------
sub fetch_cd2list {
    local($cd1,$fsspfile,$stereo)=@_;
    open(IN,$fsspfile) || die "FATAL: bad file name $fsspfile\n";
    while(<IN>) { last if (/^##/); }
    print "<FORM METHOD=\"GET\" ACTION=\"$qz3\">\n\n";
    print $query->h1("Select (check) structural neighbours to display");
    print "<INPUT TYPE=\"submit\" Value=\"3D superimposition\" Name=3D\>";
    print "<INPUT TYPE=\"submit\" Value=\"Multiple alignment (wide)\" Name=1D\>";
    print "<INPUT TYPE=\"submit\" Value=\"Multiple alignment (narrow)\" Name=1Dshort\>";
     print "<INPUT TYPE=\"submit\" Value=\"Multiple families (wide)\" Name=belvu\>";
     print "<INPUT TYPE=\"submit\" Value=\"Multiple families (narrow)\" Name=short\>";
    print "<INPUT TYPE=\"reset\" Value=\"Reset selection\">\n";
    # print "<A HREF=$qz3?mode=options&filename=$fsspfile>(Set display options)</A>";
    print "<INPUT TYPE=\"hidden\" NAME=\"filename\" Value=$fsspfile>\n";
    print "<INPUT TYPE=\"hidden\" NAME=\"idecut\" Value=$idecut>\n";
    print "<INPUT TYPE=\"hidden\" NAME=\"stereo\" Value=$stereo>\n";
    $x=<IN>; print "<PRE><B>   ",substr($x,13,33),substr($x,70,50),"</B></PRE>\n";
    print "<PRE>\n";
    undef(@x);
    while(<IN>) {
         last if(/^\/\//);
         last if(/^## ALIGNMENTS/);
         last if(/^## FOOTER/);
         last if(!/\w/);
         chop;
         $long=substr($_,13,6); $cd2=$long; $cd2=~s/-//; $cd2=~s/ //g;
         ($x,$name)=/ 0\s+0\s+\d+[\sS]+(\d*)\s*[\sS]*(.*)$/;
         $domfssp2=$FSSPDIR.$cd2.'.fssp';


         #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         # If FSSP file exists we print this.
         #___________________________________________________
         if(-e $domfssp2) {
    print "<INPUT TYPE=\"checkbox\" $check Name='cd2list' Value=\"",$long,"\"> ",
"<A HREF=".$qz3."&filename=$domfssp2>$long</A>",substr($_,19,27),$x,' ',$name,"\n";

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # If FSSP file does not exist, we print homologues
    #___________________________________________________
         } else {
            #print "<INPUT TYPE=\"checkbox\" $check Name='cd2list' Value=\"",$long,"\"> ","$long",substr($_,19,27),$x,' ',$name,"\n";
         }
    }
    print "</PRE>\n";
    close(IN);
    print "</FORM>\n";
}


1;




